<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件质量与管理</title>
    <link href="/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <url>/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="软件质量与管理整理"><a href="#软件质量与管理整理" class="headerlink" title="软件质量与管理整理"></a>软件质量与管理整理</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><strong>软件危机</strong> 重要<ul><li><strong>软件的四大本质困难和挑战（本质属性，驱动力）</strong>：复杂性、不可见性、可变性、一致性</li><li>软件危机是指<strong>落后的软件生产方式</strong>无法满足迅速增长的<strong>计算机软件需求</strong>，从而导致软件开发与维护过程中出现一系列严重问题的现象。</li><li>软件工程是一门研究用<strong>工程化方法</strong>构建和维护有效的、实用的和高质量的软件的学科。</li><li>软件工程的两大视角：<strong>管理视角（复制成功）</strong>、技术视角（将问题解决的更好）</li></ul></li><li><strong>软件项目管理概念(重要)</strong><ul><li>管理的三大关键要素：目标、状态(接近目标还是远离目标)、纠偏</li><li><strong>软件项目管理</strong>是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</li></ul></li></ul><span id="more"></span><ul><li>软件过程<ul><li>软件过程(狭义)：软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</li><li>广义软件过程包括<strong>技术、人员以及狭义过程</strong></li></ul></li><li><strong>生命周期模型与软件过程</strong> 重要<ul><li>软件过程：是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合，这组实践之间往往有<br>一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标</li><li>生命周期模型：对软件过程的一种人为的划分。典型生命周期模型：<strong>瀑布模型</strong>、<strong>迭代式模型</strong>、增量模型、螺旋模型、原型法等等</li><li>区别：<ul><li>生命周期模型是对软件过程的一种人为划分</li><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分</li><li>生命周期模型往往不包括技术实践</li></ul></li></ul></li><li><strong>如何理解瀑布模型</strong> 重要<ul><li>瀑布模型不是单一模型，是一系列模型，覆盖最简单场景（过程元素少）到最复杂的场景（过程元素多）</li><li>软件项目应该结合实际情况选择合适过程元素的瀑布模型，基本原则是，项目面临困难和挑战越多，选择<br>的模型应该越复杂</li><li>软件项目团队往往低估项目的挑战，选择了过于简单的不使用的瀑布模型</li></ul></li><li>软件过程管理与软件项目管理<ul><li>软件过程管理的管理对象是软件过程</li><li>管理的<strong>目的</strong>是为了让软件过程在开发效率、质量等方面有着更好性能绩效</li><li><img src="image-20250515203452375.png" alt="image-20250515203452375" style="zoom: 67%;" /></li></ul></li><li>软件过程管理与软件过程改进<ul><li>两者意思接近</li><li>软件过程管理参考模型 CMM&#x2F;CMMI, SPICE等</li><li>软件过程改进参考元模型 <strong>PDCA，IDEAL</strong></li></ul></li><li>以下说法是否正确？为什么？<ol><li>软件过程管理是软件项目管理应该要实现的目标：软件过程管理和软件项目管理完全是两回事，因此并不是实现目标，<strong>错误</strong>的。</li><li>在公司导入敏捷过程是我们今年过程改进的主要目标：过程管理和过程改进是类似的，这个说法是合理的，<strong>正确</strong>的。</li><li>XP与CMM&#x2F;CMMI是对立的两种软件开发方法：CMM和CMMI并不是软件开发方法，而是软件过程管理和改进，CMM和CMMI是没有较大区别的，<strong>错误</strong>的。</li><li>CMM&#x2F;CMMI不适合当今互联网环境的项目管理需求：CMM&#x2F;CMMI是用来做过程管理和改进的，根本不是满足项目管理需求的手段，<strong>错误</strong>的。</li><li>PDCA和IDEAL不适合在敏捷环境中使用：PDCA，IDEAL是软件过程改进参考元模型，因此是适合在敏捷环境中使用的，<strong>错误</strong>的。</li><li>不同的软件开发过程应该使用不同的生命周期模型，反之亦如此：生命周期模型是由人类划分的，不一定，<strong>错误</strong>的。</li></ol></li></ul><h2 id="2-软件过程的历史演变和经典工作"><a href="#2-软件过程的历史演变和经典工作" class="headerlink" title="2. 软件过程的历史演变和经典工作"></a>2. 软件过程的历史演变和经典工作</h2><ul><li><strong>软件发展三大阶段</strong> 重要<ul><li>软硬件一体化阶段（50年代~70年代）：软件完全依附于硬件、软件作坊<ul><li>线性顺序过程，事实上是硬件开发流程</li><li>Measure twice, cut once</li><li>Code and fix</li></ul></li><li>软件成为独立的产品（70年代~90年代）<ul><li>结构化程序设计和瀑布模型</li><li>成熟度模型</li></ul></li><li>网络化和服务化（90年代中期迄今）<ul><li>迭代式开发</li><li>敏捷开发（XP、SCRUM、Kanban）</li><li>开源软件开发方法</li><li>DevOps</li></ul></li></ul></li><li>软件完全依附于硬件<ul><li>软件<strong>应用</strong>典型特征：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更</li><li>软件<strong>开发</strong>典型特征：硬件太贵、团队以硬件工程师和数学家为主</li><li>典型软件过程和实践：Measure twice, cut once（相同的软件工程实践：code review &amp; inspection）</li><li><img src="image-20250518202931736.png" alt="image-20250518202931736" style="zoom:50%;" /></li></ul></li><li>软件作坊<ul><li>软件<strong>应用</strong>典型特征：功能简单、规模小</li><li>软件<strong>开发</strong>典型特征：很多非专业领域的人员涌入、高级程序语言出现、质疑权威文化盛行</li><li>典型软件过程和实践：Code And Fix</li></ul></li></ul><h3 id="软件成为独立产品"><a href="#软件成为独立产品" class="headerlink" title="软件成为独立产品"></a>软件成为独立产品</h3><ul><li>软件<strong>应用</strong>典型特征：摆脱了硬件束缚（OS）、功能强大、规模和复杂度剧增、个人电脑出现使普通人成为软件用户、来自市场的压力</li><li>软件典型过程和实践：形式化方法、结构化设计+瀑布模型</li><li>瀑布模型与生命周期模型<ul><li><img src="image-20250518192714432.png" alt="image-20250518192714432" style="zoom: 67%;" /></li><li><img src="image-20250518193541199.png" alt="image-20250518193541199" style="zoom: 80%;" /></li><li>第一张图为瀑布模型，图二为简化的软件生命周期阶段</li><li>生命周期模型<ol><li>是什么：一个对软件过程的人为划分</li><li>主要作用：便于传达，复制成功</li></ol></li></ul></li></ul><blockquote><p>下面是各种软件过程改进模型</p></blockquote><ul><li><strong>成熟度模型</strong> 重要<ul><li>最开始是CMM，现在是CMMI</li><li>CMM（Capability Maturity Model），即软件能力成熟度模型，是一种评估和提高组织软件工程能力的标准体系。它可以帮助组织了解自身软件开发过程的成熟度，指导其逐步改进和优化软件开发流程，提高软件产品质量和开发效率。</li><li><img src="d8c3a2b8f9d80d9cd7d1def1dd65b7d7.png" alt="img" style="zoom:40%;" /></li><li>CMMI（Capability Maturity Model Integration），即软件成熟度模型集成，是一个<strong>过程改进模型</strong>，旨在帮助组织改进其软件开发和维护过程。CMMI可以看作是CMM的进化版，它扩展了CMM的领域和深度，提供了更全面的过程改进框架。它不仅覆盖了软件开发领域，还涉及了系统工程、硬件开发和服务业务等。</li><li><img src="image-20250518194051832.png" alt="image-20250518194051832" style="zoom: 67%;" /></li><li>CMMI成熟度分级<ul><li>初始级(Initial)：过程不可预测、项目管理很少、开发相对混乱；个人英雄主义、救火文化</li><li>已管理级(Managed)：以项目为单位进行管理，相对被动的管理；有项目计划和跟踪、需求管理、配置管理等</li><li>已定义级(Defined)：以公司为单位进行管理，相对主动的管理；公司层面有标准流程和相应规范，每个项目小组可以基于此定义自己的流程</li><li>定量管理级(Quantitatively Managed)：过程被度量和管理；构建预测模型，用统计过程控制的手段来管理过程</li><li>优化级(Optimizing)：关注与过程改进；继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题</li></ul></li></ul></li><li><strong>PDCA：软件过程改进模型</strong> 重要</li></ul><ul><li>PDCA：Plan、Do、Check、Action<ul><li><img src="df85b44b1dcf59bf7b5fdea66948a8e6.png" alt="img" style="zoom: 33%;" /></li></ul></li></ul><ul><li><strong>IDEAL：软件过程改进模型</strong> 重要<ul><li>IDEAL模型解决了软件在各种质量改进环境下的需要</li><li><img src="1bfee8d4d21944db9a5455c1bf134b20.png" alt="img" style="zoom:50%;" /></li></ul></li><li><h2 id="其他模型-SPICE模型：软件过程管理模型-ISO-IEC：软件过程改进模型-RUP-Rational-Unified-Process：软件过程框架"><a href="#其他模型-SPICE模型：软件过程管理模型-ISO-IEC：软件过程改进模型-RUP-Rational-Unified-Process：软件过程框架" class="headerlink" title="其他模型  - SPICE模型：软件过程管理模型  - ISO&#x2F;IEC：软件过程改进模型  - RUP Rational Unified Process：软件过程框架"></a>其他模型<br>  - SPICE模型：软件过程管理模型<br>  - ISO&#x2F;IEC：软件过程改进模型<br>  - RUP Rational Unified Process：软件过程框架</h2></li><li>讨论题<ul><li>CMMI是过程改进模型而非软件过程或者软件过程模型（<strong>正确</strong>，CMMI指导软件过程改进，不指导开发。）</li><li>CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较（<strong>正确</strong>，CMMI衡量的是相对的水平，CMMI仅仅关注在本公司的目标下的等级）</li><li>如何理解CMMI VS. Agile（敏捷）？CMMI 和 Agile 都是用于软件过程管理的模型，它们不是对立的。虽然两者在方法和理念上存在差异，但在实际环境中，这两种方法可以互补，帮助组织实现目标。</li></ul></li></ul><h3 id="网络化和服务化"><a href="#网络化和服务化" class="headerlink" title="网络化和服务化"></a>网络化和服务化</h3><ul><li>软件<strong>应用</strong>典型特征<ul><li>功能更复杂，规模更大</li><li>用户数量急剧增加</li><li>快速演化和需求不确定</li><li>分发方式的变化（SaaS，软件即服务，是一种通过Internet提供软件的模式）</li></ul></li><li>典型软件过程和实践<ul><li>迭代式：<strong>大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。</strong></li><li><strong>雪鸟会议和敏捷宣言</strong><ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li><li>也就是说，<strong>尽管右项有其价值，我们更重视左项的价值</strong>。</li></ul></li><li>敏捷软件开发方法：<ul><li>XP（eXtreme Programing） 方法：偏重于一些工程实践的描述</li><li>SCRUM：管理框架和管理实践</li><li>Kanban<ol><li>精益生产（丰田制造法）的具体实现</li><li>可视化工作流、限定WIP、管理周期时间</li><li>马丁提出了微服务架构</li></ol></li><li>开源软件开发方法：是一种基于并行开发模式的软件开发的组织与管理方式<ul><li>Linus 定律：如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</li><li>早发布，常发布，倾听用户的反馈 、把你的用户当成开发合作者对待</li><li>代码管理：严格的代码提交社区审核制度</li></ul></li></ul></li></ul></li></ul><h3 id="当前软件发展现状"><a href="#当前软件发展现状" class="headerlink" title="当前软件发展现状"></a>当前软件发展现状</h3><ul><li><p>软件应用典型特征</p><ol><li>进一步服务化和网络化(移动是主流)</li><li>用户需求多样化进一步凸显</li><li>软件产品和服务的地位变化</li><li>错综复杂的部署环境</li></ol></li><li><p>近乎苛刻的用户期望</p><ol><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ol></li><li><p>空前强大的开发和部署环境——XaaS</p></li><li><p>盛行共享和开源</p></li><li><p>典型DevOps实践和方法</p><ul><li>方法论基础是敏捷软件开发、精益思想以及看板Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务XaaS(X as a Service)的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ul></li></ul><h2 id="3-团队动力学"><a href="#3-团队动力学" class="headerlink" title="3. 团队动力学"></a>3. 团队动力学</h2><ul><li><p><strong>三大目标</strong> 重要：成本、质量、工期</p></li><li><p><strong>软件开发特点</strong> （结合软件开发特点谈谈自主型团队的必要性）</p><ul><li>软件开发是一项既复杂又富有创造性的<strong>知识工作</strong></li><li>软件开发是一种<strong>智力劳动</strong><ul><li>处理和讨论极其抽象的概念</li><li>把不同的部分（不可见）整合成一个可以工作的系统</li><li>全身心地参与</li><li>努力做出卓越的工作</li></ul></li><li>软件开发是一种智力活动，开发者是智力劳动者，而对于智力劳动者而言，管理的第一准则，就是智力劳动者不能被管理，只能<strong>实现自我管理</strong>。</li></ul></li><li><p><strong>知识工作管理</strong> 重要</p><ul><li>管理知识工作的关键规则是：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</li><li>要自我管理，知识工作者必须(如下是自我管理的前提条件)<ol><li>有积极性：不然可能会被其他人替代</li><li>能做出准确的估算和计划</li><li>懂得协商承诺</li><li>有效跟踪他们的计划</li><li>持续地按计划交付高质量产物</li></ol></li></ul></li><li><p><strong>知识工作的领导者</strong> 重要</p><ul><li><p>知识工作者的管理需要的是领导者，而不是经理</p></li><li><p><strong>特点</strong>：</p><ul><li>善于<strong>倾听</strong>团队成员的想法，并加以分析和改进</li><li>善于通过<strong>询问</strong>来诱导团队成员向着正确的方向前进</li><li>善于通过<strong>激励</strong>以及设定挑战目标等方式吸引团队成员努力表现</li><li>当出现不一致意见的时候，领导者则善于提供各种沟通方式，促成团队<strong>达成一致意见</strong></li><li><strong>培养</strong>团队成员技能</li><li>鼓励建立起合理的<strong>授权</strong>机制</li><li>通过挑战<strong>建立目标</strong>，确定团队努力方向</li></ul></li></ul></li><li><p><strong>领导者的激励手段</strong> 重要</p><ul><li>有3种主要的激励方式：<ul><li>威逼</li><li>利诱</li><li>鼓励承诺：位于马斯洛需求理论的4级以上，应当是主要的方式，并且最好以团队为单位做承诺</li><li>鼓励承诺效果最好</li><li>交易型领导方式<ol><li>承诺奖励激励</li><li>人们通常能找到新的方式来获得奖励，同时少做工作。</li><li><strong>威逼和利诱属于交易型领导方式</strong>。</li></ol></li><li>转变型领导方式<ol><li>用成就激励</li><li><strong>鼓励承诺属于转变型领导方式</strong>。</li></ol></li><li>由于交易型领导方式很少能产生成功的并且有创造性的团队，因此<strong>转变型领导方式</strong>是首选。</li></ul></li></ul></li><li><p><strong>马斯洛的需求理论</strong> 重要</p><ul><li><img src="R-C.jfif" alt="马斯洛需求层次理论" style="zoom:50%;" /></li><li><p>注：第三层ppt中是social社交需求，图是网上找的</p></li><li><p>自我实现是最高的层次</p></li><li><p>激励来自为没有满足的需求而努力奋斗</p></li><li><p>低层次的需求必须在高层次需求满足之前得到满足</p></li><li><p>满足高层次的需求的途径比满足低层次的途径更为广泛</p></li></ul></li><li><p><strong>期望理论</strong> 重要</p><ul><li><p>人们在下列情况下能够受到激励并且出大量成果 M &#x3D; V * E</p><ol><li>相信他们的努力很可能会产生成功的结果(V)</li><li>他们也相信自己会因为成功得到相应的回报(E)</li></ol></li><li><p>Motivation &#x3D; Valence x Expectancy(Instrumentality)，即激发力量 &#x3D; 效价 * 期望值</p><ol><li>M 表示激发力量，是指调动一个人的积极性，激发人内部潜力的强度。</li><li>V 表示目标价值（效价），这是一个心理学概念，是指达到目标对于满足他个人需要的价值。同一目标，由于各个人所处的环境不同，需求不同，其需要的目标价值也就不同。同一个目标对每一个人可能有三种效价：正、零、负。效价越高，激励力量就越大</li><li>E 是期望值，是人们根据过去经验判断自己达到某种目标的可能性是大还是小，即能够达到目标的概率。目标价值大小直接反映人的需要动机强弱，期望概率反映人实现需要和动机的信心强弱。</li></ol></li></ul></li><li><p><strong>自主团队</strong> 重要</p></li></ul><ul><li>内部环境（特点）<ul><li>自行定义项目的目标</li><li>自行决定团队组成形式以及成员的角色</li><li>自行决定项目的开发策略</li><li>自行定义项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li><li>外部环境<ul><li>项目启动阶段获得管理层的支持：</li><li>在项目进展过程中获得管理层的支持</li></ul></li></ul></li></ul><ul><li>TSP(Team Software Process)：团队软件过程</li></ul><p><strong>TSP角色与职责</strong> 重要</p><ul><li>项目组长（项目经理）：建设和维持高效率的团队<ul><li>激励团队成员努力工作</li><li><strong>主持</strong>项目周例会</li><li>每周<strong>汇报</strong>项目状态</li><li><strong>分配</strong>工作任务</li><li>维护项目资料</li><li><strong>组织</strong>项目总结</li></ul></li><li>计划经理：开发完整的、准确的团队计划和个人计划<ul><li>带领项目小组<strong>开发项目计划</strong></li><li>带领项目小组<strong>平衡计划</strong></li><li><strong>跟踪项目进度</strong></li><li>参与项目总结</li></ul></li><li>开发经理：开发优秀的软件产品<ul><li>带领团队<strong>制定开发策略</strong>。</li><li>带领团队开展产品规模估算和所需时间资源的<strong>估算</strong>。</li><li>带领团队开发<strong>需求规格说明</strong>。</li><li>带领团队开发<strong>高层设计</strong>。</li><li>带领团队开发<strong>设计规格说明</strong>。</li><li>带领团队<strong>实现软件产品</strong>。</li><li>带领团队开展<strong>集成测试和系统测试</strong>。</li><li>带领团队开发<strong>用户支持文档</strong>。</li><li>参与项目总结</li></ul></li><li>质量经理：保证项目团队严格按照质量计划开展工作，开发出高质量的软件产品<ul><li>带领团队开发和跟踪<strong>质量计划</strong></li><li>向项目组长<strong>警示质量问题</strong></li><li>软件产品提交配置管理之前，对其进行评审，以消除<strong>质量问题</strong></li><li>项目小组<strong>评审的组织者和协调者</strong></li><li>参与项目总结</li></ul></li><li>过程经理：维护所有团队成员准确的记录、报告和跟踪过程数据<ul><li>带领团队<strong>定义</strong>和<strong>记录</strong>开发过程并且支持过程改进。</li><li><strong>建立</strong>和维护团队的<strong>开发标准</strong>。</li><li><strong>记录和维护</strong>项目的<strong>会议记录</strong>。</li><li>参与项目总结。</li></ul></li><li>支持经理：保证项目小组在整个开发过程中都有合适的工具和环境<ul><li>带领团队识别开发过程中所需要的各类工具和设施。</li><li>主持配置管理委员会，<strong>管理配置管理系统</strong>。</li><li>维护软件项目的<strong>词汇表</strong>。</li><li>维护<strong>项目风险和问题跟踪</strong>系统。</li><li>支持软件开发过程中<strong>复用策略</strong>的应用。</li><li>参与项目总结。</li></ul></li><li>开发人员：开发</li></ul><ul><li><p><strong>TSP启动过程</strong> 重要</p><ul><li><img src="image-20250607102225859.png" alt="image-20250607102225859" style="zoom: 50%;" /></li><li><p>第一次和第二次会议由项目经理主持</p></li><li><p>第三次会议</p><ul><li>TSP灵活：自定义的流程让人相信项目可以成功</li><li>开发策略：打算进行几个迭代周期。</li></ul></li></ul></li><li><p><strong>Scrum角色和职责</strong>见邵栋部分 重要</p></li></ul><h2 id="4-估算和计划"><a href="#4-估算和计划" class="headerlink" title="4. 估算和计划"></a>4. 估算和计划</h2><ul><li><p><strong>估算目的</strong> 重要：估算目的是给各类计划提供决策依据</p></li><li><p><strong>PROBE估算方法</strong> 重要</p><ul><li><p>规模度量&#x2F;估算的困境</p><ul><li><strong>精确度量</strong>方式往往不便于<strong>早期规划</strong>&#x2F;估算；</li><li>有助于<strong>早期规划</strong>&#x2F;估算的度量往往难以产生<strong>精确度量</strong>结果；</li></ul></li><li><p>PROBE(PROxy Based Estimation)的作用：<strong>精确度量</strong>和<strong>早期规划</strong>之间的桥梁</p></li><li><p>要做的估算：规模估算和资源估算</p></li><li><p>基本原理：设立合理的代理作为精确度量和早期规划之间的桥梁；相对大小而非绝对大小</p></li><li><p>例子：估算一栋房屋的建造成本，大部分人没有概念。然而，在早期规划中，会有如下认识&#x2F;需求</p></li></ul><table><thead><tr><th>序号</th><th>用途</th><th>相对大小及数量</th></tr></thead><tbody><tr><td>1</td><td>厨房</td><td>1个中等大小</td></tr><tr><td>2</td><td>卧室</td><td>1个大卧室；2个小卧室</td></tr><tr><td>3</td><td>卫生间</td><td>1个中等大小；1个小型</td></tr><tr><td>4</td><td>书房</td><td>1个中等大小</td></tr><tr><td>5</td><td>客厅</td><td>1个大客厅</td></tr></tbody></table><ul><li><p>相对大小矩阵：</p></li><li><img src="15.png" style="zoom:50%;" /></li></ul></li><li><p>PROBE估算流程</p><ul><li><img src="16.png" style="zoom:50%;" /></li></ul></li><li><p>概要设计</p><ul><li>估算的第一步是做出一个概要设计</li><li>为了做出概要设计，需要确定产品功能，以及产生这些功能所需的<strong>程序组件&#x2F;模块</strong></li><li>然后，将这些<strong>程序组件&#x2F;模块</strong>与你以前写的程序相比较，估算它们的规模</li><li>最后，将<strong>程序组件&#x2F;模块</strong>估算综合给出总规模</li></ul></li><li><p><strong>估算要点</strong> 重要</p><ul><li>尽可能划分详细一些</li><li>建立对结果的信心</li><li>依赖数据</li><li>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</li></ul></li><li><p><strong>Scrum故事点</strong> 重要</p><ul><li>度量实现一个故事（Story）需要付出的工作量<ol><li><strong>抽象的</strong>：混合了对于开发特性（feature）所要付出的努力、开发复杂度、个中风险以及类似东西</li><li><strong>相对的</strong>：设定标准之后，考虑其他特性（feature）与标准之间的相对大小关系</li></ol></li><li>Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21,34, 55, 89</li></ul></li><li><p>工作分解结构 WBS</p><ul><li><img src="image-20250607120104805.png" alt="image-20250607120104805" style="zoom: 67%;" /></li></ul></li><li><p>开发策略与计划</p><ul><li>开发策略是在产品组件需求基础之上，明确每个产品组件的获得方式与顺序，从而在项目团队内部建立起大家都理解的产品开发策略。</li><li>注意事项<ol><li>WBS的使用</li><li>产品组件开发顺序的考虑</li><li>产品组件获得方式的考虑</li></ol></li></ul></li><li><p><strong>通用计划框架</strong> 重要</p><ul><li><img src="image-20250607120336736.png" alt="image-20250607120336736" style="zoom: 67%;" /></li><li>必须人为干预的步骤<ol><li>定义需求</li><li>概要设计：划分由人为开始，规模划分好之后估算是自动产生的</li><li>日程计划</li></ol></li><li>这会带来什么的好处？比较容易扛住别人的质疑。<ol><li>攻击点：资源和时间是否被高估了</li><li>解决：估算没有代码行PROBE只有功能点是大中小。</li></ol></li></ul></li><li><p><strong>质量计划</strong> 重要</p><ul><li>项目的质量计划中应当确定需要开展的质量保证活动。</li><li>典型的质量保证活动包括<strong>个人评审、团队评审、单元测试、集成测试、系统测试</strong>以及<strong>验收测试</strong>等。</li><li>在质量计划中需要解决的关键的问题是该<strong>开展哪些活动</strong>，以及这些<strong>活动开展的程度</strong>，如时间、人数和目标分别是什么。</li></ul></li><li><p><strong>风险计划</strong> 重要</p><ul><li>风险管理的目的是在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li><li>风险管理大致分成两部分，即<strong>风险识别</strong>和<strong>风险应对</strong>。</li></ul></li><li><p><strong>挣值管理体系</strong> 重要</p><ul><li><p>项目的挣值管理方法(Earned Value Management，简称EVM)是用来客观度量项目进度的一种项目管理方法。</p><ol><li>每项任务实现附以一定价值（credit）</li><li>100%完成该项任务，就获得相应价值</li></ol></li><li><p>EVM采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p><ul><li>简单实现：添加挣值（EV）</li><li>中级实现：添加成本线（AC）</li><li>高级实现：添加预测线（BAC），当任务足够多的时候，我们就可以让预测线尽可能平直，同时我们延伸挣值（EV），找到与预测线（BAC）的交点，我们就可以明确项目的落后时间</li></ul></li><li><p>分析图示</p><ul><li><img src="40.png"></li><li>上面的线是为了获取这些挣值付出的实际代价，这个线和挣值之间的差异是成本差异。</li><li>中间的线是预算（每天需要完成多少挣值）BAC，理想情况下是一条直线。</li><li>下面的线是挣值（实际的进展情况）（EV），和owner value有关，对应plan value</li><li><img src="image-20250607150946435.png" alt="image-20250607150946435"></li></ul></li><li><p>EVM的变形：燃尽图</p><ul><li><img src="42.png" style="zoom:50%;" /></li><li>燃尽图是简单的挣值管理的变形。</li><li><strong>是剩下的工作占的百分比</strong></li></ul></li><li><p>EVM的局限性</p><ul><li><p>一般不能应用软件项目的质量管理。</p></li><li><p>需要定量化的管理机制</p></li><li><p>完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算</p></li></ul></li><li><p>挣值管理为什么能适应软件项目：它能够将项目进度和成本结合起来，通过量化的方式动态跟踪项目实际完成情况（挣值）与计划进度和预算的对比，及时发现偏差，便于软件项目灵活调整和有效控制进度与成本，提高可控性和透明度。</p></li></ul></li></ul><h2 id="5-质量管理"><a href="#5-质量管理" class="headerlink" title="5. 质量管理"></a>5. 质量管理</h2><ul><li>质量概念<ul><li>软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”。</li><li>软件质量为内外两部分的特性：其外部质量特性面向软件产品的最终用户，其内部质量特性则不直接面向最终用户。</li><li>用户满意度是最为重要的判断标准，对同一款软件而言，不同的用户对其质量有不同的体验。</li></ul></li><li><strong>面向用户的质量观</strong> 重要<ul><li>面向用户的质量观，定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：<ul><li>用户究竟是谁？</li><li>用户需求的优先级是什么？</li><li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ul></li></ul></li><li><strong>质量管理策略</strong> 重要<ul><li>用缺陷管理来替代质量管理</li><li>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷；</li></ul></li><li>测试消除缺陷典型流程<ul><li>发现待测程序的一个异常行为；</li><li>理解程序的工作方式；</li><li>调试程序，找出出错的位置，确定出错原因；</li><li>确定修改方案，修改缺陷；</li><li>回归测试，以确认修改有效；</li></ul></li><li>评审发缺陷典型流程<ul><li>遵循评审者的逻辑来理解程序流程；</li><li>发现缺陷的同时，也知道了缺陷的位置和原因；</li><li>修正缺陷</li></ul></li><li>PSP：个人软件过程</li><li><strong>个人评审</strong> 重要<ul><li>关键控制因素：单元测试和code review，code review优先</li><li>时机选择：编译（UT）之前 VS. 之后</li><li>小组评审是由多人组成的小组共同进行的评审活动，其核心目的是通过小组讨论、集体智慧，对项目的流程和过程进行质量把控，确保过程符合质量要求，及时发现和纠正问题，从而提升整体质量管理水平。</li></ul></li><li><strong>质量控制指标</strong> 重要<ul><li>指标一：Yield（良品率）<ul><li>Yield指标用以度量每个阶段在消除缺陷方面的效率。</li><li>Phase Yield &#x3D; 100 * (某阶段发现的缺陷个数)&#x2F;(某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数)</li><li>Process Yield &#x3D; 100 * (第一次编译前发现的缺陷个数)&#x2F;(第一次编译前注入的缺陷个数)；</li><li><img src="image-20250607144149912.png" alt="image-20250607144149912"></li></ul></li><li>指标二：A&#x2F;FR<ul><li>A&#x2F;FR &#x3D; PSP质检成本&#x2F;PSP失效成本</li><li>帮助团队权衡投入评审、测试等质量活动的成本与后期失效所带来的代价</li><li>理论上，A&#x2F;FR的值越大，往往意味着越高的质量。</li><li>过高的A&#x2F;FR往往意味着做了过多的评审，反而会导致开发效率的下降。</li></ul></li><li>指标三：PQI<ul><li>用于综合反映开发过程中缺陷的密度水平，5个数据乘积(定义成0.0~1.0之间的数值)(以基准值作为1，<strong>最后结果越接近1质量越⾼</strong>)</li><li>5个数据<ol><li>设计质量：min{设计时间&#x2F;编码时间, 1}</li><li>设计评审质量：min{(2 * 设计评审时间 &#x2F; 设计时间), 1}</li><li>代码评审质量：min{(2 * 代码评审时间)&#x2F;编码时间 , 1}</li><li>代码质量：min{20&#x2F;(编译缺陷密度 + 10), 1}</li><li>程序质量：min{10&#x2F;(单元测试缺陷密度 + 5), 1}</li></ol></li></ul></li><li>指标四：Review Rate<ul><li>评审的速度(Review Rate)是一个用以指导软件工程师开展有效评审的指标</li><li>高质量的评审需要软件工程师投入足够的时间进行评审</li></ul></li><li>指标五：DRL<ul><li>缺陷消除效率比度量的是不同缺陷消除手段消除缺陷的效率。</li><li>其计算方式是以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</li></ul></li><li>特点和用途：<ul><li><strong>Yield</strong>：衡量各阶段发现缺陷的能力，用于分析流程质量控制效果。</li><li><strong>A&#x2F;FR</strong>：比较预防成本与失效成本，用于评估质量投入的经济性。</li><li><strong>PQI</strong>：反映开发过程中的缺陷密度，用于整体质量评估。</li><li><strong>Review Rate</strong>：衡量评审效率，用于指导合理评审节奏。</li><li><strong>DRL</strong>：比较不同方法的缺陷发现效率，用于优化缺陷检测手段。</li></ul></li></ul></li><li><img src="image-20250607155442034.png" alt="image-20250607155442034"></li></ul><blockquote><p>下面是sd部分</p></blockquote><h2 id="1-Scrum"><a href="#1-Scrum" class="headerlink" title="1. Scrum"></a>1. Scrum</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><ul><li><p>定义</p><ul><li>Scrum <strong>不是构建产品的一种过程或一项技术，而是一个框架</strong>，在这个框架里可以应用各种流程和技术。Scrum 能使产品管理和开发实践的相对功效显现出来,以便随时改进。</li><li>Scrum 是一个轻量的框架，它通过提供针对复杂问题的自适应解决方案来帮助人们、团队和组织创造价值</li><li>简而言之，Scrum 需要 <strong>Scrum Master</strong> 营造一个环境，从而：<ul><li>一名 Product Owner 将解决复杂问题所需的工作整理成一份 Product Backlog。</li><li>Scrum Team 在 一个 Sprint 期间将选择的工作转化为价值的 Increment</li><li>Scrum Team 和利益攸关者检视结果并为下一个 Sprint 进行调整</li><li>重复</li></ul></li><li>Scrum 基于<strong>经验主义和精益思维</strong>。 经验主义主张<strong>知识源自实际经验以及根据当前观察到的事物作出的判断所获得</strong>。</li></ul></li><li><p>Scrum Team</p><ul><li><p>Scrum Team 由<strong>一名 Scrum Master</strong>，<strong>一名 Product Owner</strong> 和 <strong>Developers</strong> 组成</p></li><li><p>在 Scrum Team 中，没有子团队或层次结构</p></li><li><p>Scrum Team 规模足够小以保持灵活，同时足够大以便可以在 一个 Sprint 中完成重要的工作，通常只有 10 人或更少</p></li><li><p>Scrum Team 是<strong>跨职能</strong>的，这意味着团队成员具有在每个 Sprint 中创造价值而所需的<strong>全部技能</strong>（反例：职能团队，UI团队、业务逻辑团队、测试团队等等）</p></li><li><img src="image-20250519164147432.png" alt="image-20250519164147432" style="zoom:50%;" /></li><li><p>微观管理：在对员工的工作管理中，管理者过度关注和控制工作细节的管理风格和管理行为。会导致团队成员失去主观能动性、工作中出现决策等待和低效、影响到团队的积极性和士气</p></li><li><p>自管理：指个体或团队在明确目标下，通过自我规划、自我监督、自我调整等方式，自主完成任务的机制。</p></li><li><p>自组织：指复杂系统（如生态系统、社会组织）在没有外部指令干预的情况下，通过内部成员或元素的互动，自发形成有序结构和功能的过程。</p></li></ul></li><li><p>用户故事</p><ul><li>用户故事是产品列表的基础构件</li><li><img src="image-20250519155035917.png" alt="image-20250519155035917" style="zoom:50%;" /></li><li>告诉我们想要这个功能的是谁、预期功能是什么 、为什么用户想要这个功能</li><li>用户故事不是完整的需求或说明书，它们是占位符，足以提醒团队有东西要完成</li><li>用户故事地图：是一门在需求拆分过程中保持全景图的技术。敏捷软件开发中使用用户故事地图来发现、管理需求</li><li><img src="image-20250519160110780.png" alt="image-20250519160110780" style="zoom:67%;" /></li></ul></li><li><p><strong>Definition of Done(DoD)</strong></p><ul><li>DoD用于描述一个用户故事、任务或功能何时可以被认为真正“完成”。它是团队对完成工作的标准化定义，确保开发过程中每个增量都符合质量要求并准备好交付。</li><li>作用：提高透明度、保证质量、支持验收流程、防止技术债</li><li><img src="image-20250519155447441.png" alt="image-20250519155447441" style="zoom:67%;" /></li></ul></li><li><p>行为驱动开发 BDD</p><ul><li>是一种基于敏捷的软件开发方法论，其核心思想是通过定义软件的行为来驱动开发过程</li><li>BDD 是从测试驱动开发（TDD）演化而来的，强调在开发开始之前，用自然语言描述软件应如何行为</li><li>过程：编写用户故事 -&gt; 定义验收标准</li></ul></li><li><p>Sprint 管理：白板Scrum任务板</p><ul><li><img src="image-20250519162907182.png" alt="image-20250519162907182" style="zoom: 50%;" /></li></ul></li><li><p>Sprint进度跟踪：燃尽图</p><ul><li><img src="image-20250519163014476.png" alt="image-20250519163014476" style="zoom:67%;" /></li></ul></li></ul><h3 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h3><ul><li><p><strong>Scrum 33355</strong>（重要）</p><ul><li>三大支柱：透明、检视、适应</li><li>三个角色：开发人员(Developers)、产品负责人（Product Owner）、Scrum主管(Scrum Master)</li><li>三个工件：Product Backlog、Sprint Backlog、增量(Increment)</li><li>五个价值：承诺、专注、开放、尊重和勇气</li><li>五个事件：Sprint、Sprint 计划会议(Sprint Planning)、每日 Scrum 会议(Daily Scrum)、Sprint 评审会议(Sprint Review)、Sprint 回顾会议(Sprint Retrospective)</li></ul></li><li><p>三大支柱</p><ul><li>透明：开发的过程和工作必须对执行工作的人员和接受工作的人员都是可见的。在 Scrum 中，重要的决策是基于其 <strong>3 个正式工件</strong>的感知状态。透明使检视成为可能。没有透明的检视会产生误导和浪费。</li><li>检视：Scrum 工件和实现商定目标的进展必须经常地和勤勉地检视，以便发现潜在的不良的差异或问题。为了帮助检视，Scrum 以 <strong>5 个事件</strong>的形式提供了稳定的节奏。检视使适应成为可能。没有适应的检视是毫无意义的。</li><li>适应：如果过程的任何方面超出可接受的范围或所得的产品不可接受，就必须对当下的过程或过程处理的内容加以调整适应，而且调整工作必须尽快执行。</li></ul></li><li><p>三个角色</p><ul><li>Developers：致力于创建每个 Sprint 可用 Increment 的任何方面的人员。所需的特定技能通常很广泛，并且会随着工作领域的不同而变化。职责：<ul><li>为 Sprint 创建计划，即 Sprint Backlog</li><li>通过遵循 Definition of Done 来注入质量</li><li>每天根据 Sprint Goal 调整计划</li><li>作为专业人士对彼此负责</li></ul></li><li>Product Owner：负责将 Scrum Team 的工作所产生的产品价值最大化。职责：<ul><li>开发并明确地沟通 Product Goal</li><li>创建并清晰地沟通 Product Backlog 条目</li><li>对 Product Backlog 条目进行排序</li><li>确保 Product Backlog 是透明的、可见的和可理解的</li></ul></li><li>Scrum Master：负责按照 Scrum 指南的规则来建立 Scrum团队，对 Scrum Team 的效能负责。他们通过帮助 Scrum Team 和组织内的每个人理解 Scrum 理论和实践来做到这一点。职责：<ul><li>作为教练在自管理和跨职能方面辅导 Scrum Team 成员</li><li>帮助 Scrum Team 专注于创建符合 Definition of Done 的高价值 Increment</li><li>促使移除 Scrum Team 工作进展中的障碍，包括协调团队与利益相关者</li><li>确保所有 Scrum 事件都发生并且是积极的、富有成效的，并且在时间盒（timebox）内完成</li><li>帮助Product Owner有效定义 Product Goal 和管理 Product Backlog</li></ul></li></ul></li><li><p>三大工件</p><ul><li><p>Product Backlog</p><ul><li>是<strong>Scrum的核心</strong>，是按重要性排序的需求或故事（Story）的列表（客户语言描述的客户需求）</li><li>能够被 Scrum Team 在一个 Sprint 中完成（Done）的 Product Backlog 条目被认为准备就绪，在Sprint Planning 事件中可供选择。</li><li>Product Backlog 精化是将 Product Backlog 条目分解并进一步定义为更小更精确的行为</li><li>Product Owner必须参加计划会议</li></ul></li><li><p>Sprint Backlog</p><ul><li>一个为当前Sprint准备的任务列表，开发团队负责如何实现这些任务</li></ul></li><li><p>Increment</p><ul><li>每次Sprint结束后交付的工作，应该是“完成”(Done)的并具备可用性</li></ul></li><li><img src="image-20250519164319362.png" alt="image-20250519164319362" style="zoom:50%;" /></li></ul></li><li><p>五个价值</p><ul><li>承诺：专注目标</li><li>专注：聚焦Sprint任务</li><li>开放：坦诚面对挑战</li><li>尊重：认可成员能力</li><li>勇气：解决棘手问题</li></ul></li><li><p>五个事件</p><ul><li>Sprint<ul><li>Sprint 是 <strong>Scrum 的核心</strong>，在这里创意转化为价值</li><li>它们是固定时长的事件，为期一个月或更短，以保持一致性。前一个 Sprint 结束后，下一个新的Sprint 紧接着立即开始</li><li>实现 Product Goal 所需的所有工作，包括 Sprint Planning、Daily Scrum、Sprint Review 和 Sprint Retrospective，都发生在 Sprint 内</li><li>当前，<strong>Scrum 周期通常为2个星期</strong>（重要）</li></ul></li><li>Sprint Planning<ul><li>所有人都可以编写添加条目，但只有Product Owner才能决定优先级</li><li>会议目标：sprint目标、团队成员名单、Sprint backlog(故事列表)、确定好sprint演示日期、确定时间地点(用于每日Sprint会议)</li><li>每个故事都含有三个变量：范围(scope)、重要性(importance)、和估算 (estimate)</li><li>Story point（故事点）：是一种用于评估和比较用户故事（User Story）或开发任务相对复杂性、难度和工作量的度量单位。选取可识别的最小用例为2个story point，其它估算都是<strong>相对值</strong>，在所有sprint中保持该相对值一致</li><li>例子：我们一个迭代周期可以完成20个story point,则我们可以按照优先级顺序在现有product backlog中选取20个story point以内的user story放在本迭代周期内完成。</li><li><strong>估算方法</strong>：扑克估算法、金发女孩估算法</li></ul></li><li>Daily Scrum每日站会<ul><li>回答三个问题：昨天做了什么、今天准备做什么、遇到了什么障碍需要其他人如何帮你</li><li>移动任务板上的即时贴到对应的地方</li><li>每日例会一结束就要计算剩余工作故事点并更新燃尽图</li></ul></li><li>Sprint Review 评审会议<ul><li>也叫Sprint演示会议，内容是演示你的Scrum团队做的东西</li><li><img src="image-20250519163551397.png" alt="image-20250519163551397" style="zoom: 50%;" /></li></ul></li><li>Sprint Retrospective 回顾会议<ul><li>Sprint回顾是<strong>仅次于Sprint计划会议的第二重要的事件</strong></li><li>主题：我们怎样才能在下个Sprint中做的更好，不是追究责任</li></ul></li><li><img src="image-20250519164254131.png" alt="image-20250519164254131" style="zoom:50%;" /></li></ul></li><li><p>Scrum的局限</p><ul><li>没有具体实践</li><li>Scrum关注<strong>项目管理和团队过程</strong>，而XP<strong>侧重工程实践和代码质量</strong></li></ul></li><li><p>Scrum的核心优势</p><ul><li>轻量灵活：仅定义必要规则，兼容多种实践</li><li>持续改进：通过事件循环实现经验反馈</li><li>价值驱动：以Product Goal为导向，确保交付有效性</li><li>协作透明：跨角色协作，信息共享最大化</li></ul></li><li><p>Scrum相关的框架实践</p><ul><li>大规模敏捷SAFe ：SAFe（Scaled Agile Framework），融合了敏捷和精益思想，为大企业提供一个分层次的敏捷实施蓝图。它定义了团队层等层级，强调通过统一节奏和里程碑来协调多个团队</li><li>LeSS(Large-Scale Scrum)：仅在一个产品待办列表下扩展多个Scrum团队，尽量减少额外角色</li></ul></li></ul><h2 id="2-XP背景和变更曲线"><a href="#2-XP背景和变更曲线" class="headerlink" title="2. XP背景和变更曲线"></a>2. XP背景和变更曲线</h2><ul><li>极限编程（XP）作为一种敏捷开发方法诞生于20世纪90年代后期的软件工程实践。其主要创始人是Kent Beck</li><li>最近Scrum成为最主流的敏捷框架，而XP作为一个完整的方法使用相对减少。不过，XP的许多实践（如结对编程、测试驱动开发、持续集成等）已经被广泛接受，并常与Scrum等组合使用</li><li>XP的步骤<ul><li>编写代码</li><li>运行所有测试用例</li><li>迭代测试用例和代码</li><li>如果需要，进行重构</li><li>集成，包括集成测试</li></ul></li><li>说明<ul><li>程序员<strong>两两结对编程</strong>。</li><li>开发由<strong>测试驱动</strong>。</li><li>结对编程不仅仅是让测试用例运行起来。结对编程为系统的分析、设计、实现和测试增加价值。</li><li>开发后立即进行集成，包括集成测试</li></ul></li><li>变更成本曲线<ul><li>软件工程的一个普遍假设是，随着时间的推移，更改程序的成本呈指数增长。在一段软件中修复一个问题的成本会随时间呈指数增长。这导致传统方法强调“早期做好一切”，试图避免后期修改。</li><li><img src="image-20250519170240942.png" alt="image-20250519170240942" style="zoom: 67%;" /></li><li>XP认为变更成本曲线可以变平</li></ul></li><li>XP的技术前提<ul><li>如果变更成本随时间缓慢上升，你的行为将与在成本呈指数增长这一假设下的行为完全不同</li><li>你会在工作中尽可能晚地做出重大决策，以推迟做出决策的成本，并使决策正确的可能性尽可能大</li><li>你只会实现必须实现的内容</li><li>只有当简化现有代码或使编写下一段代码更简单时，你才会将这些设计元素引入代码中</li></ul></li><li>降低变更成本的技术：面向对象、简单设计、自动化测试、重构技术、CICD</li></ul><h2 id="3-XP实践"><a href="#3-XP实践" class="headerlink" title="3. XP实践"></a>3. XP实践</h2><h3 id="一些基本知识"><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h3><ul><li>XP价值观：交流（Communication）、简单（Simplicity）、反馈（FeedBack）、勇气（Courage）</li><li>极限编程（XP）强制要求的沟通方式：单元测试、结对编程、任务估算</li><li>XP方法论主张——今天采用简单方案实施，明日若有需要再付出少许额外成本进行迭代优化，远胜于当下就构建可能永远派不上用场的复杂方案</li><li>反馈<ul><li>即时反馈（分钟&#x2F;天级）<ul><li>程序员：单元测试</li><li>客户：实时估算</li><li>团队：进度跟踪反馈</li></ul></li><li>中长期反馈（周&#x2F;月级）<ul><li>客户：功能测试</li><li>运行软件验证</li></ul></li></ul></li><li>反馈与其他价值的联系<ul><li>反馈增强沟通有效性</li><li>简单系统更易测试</li><li>测试驱动系统简化</li></ul></li><li>勇气<ul><li>简单设计→适度复杂→再简化</li><li>沟通支持勇气，因为它为更多高风险、高回报的实验开辟了可能性</li><li>简洁支持勇气，因为对于一个简单的系统，你可以更加勇敢</li><li>具体的反馈支持勇气，因为如果你按下一个按钮就能看到测试变绿，那么你在对代码进行激进的修改时会感到更加安全</li></ul></li><li>软件开发的基本活动内容：开发的四项基本活动是编码、测试、倾听和设计<ul><li>编码：你工作的成果</li><li>测试：<ul><li>当所有可能的测试用例均已通过且无法再设计出新的失败场景时，即可视为完全完成</li><li>长期来看，为什么要测试的答案是测试能让程序的寿命更长；短期原因是提供信心</li><li>我们将有程序员编写的单元测试，以使他们自己确信他们的程序按照他们认为的方式工作</li><li>我们还将有由客户编写（或至少由客户指定）的功能测试，以使他们自己确信整个系统按照他们认为的整个系统应有的方式工作</li></ul></li><li>倾听：程序员请业务人员说明项目的需求，帮助业务人员了解软件方面哪些容易，哪些困难</li><li>设计<ul><li>良好的设计会组织逻辑，以便系统的一部分发生变化并不总是需要系统的另一部分发生变化</li><li>良好的设计确保系统中的每一段逻辑都有且仅有一个实现位置</li><li>良好的设计将逻辑放在它所操作的数据附近</li><li>良好的设计允许系统扩展，且仅在一个地方进行更改</li></ul></li></ul></li></ul><h3 id="XP基本实践"><a href="#XP基本实践" class="headerlink" title="XP基本实践"></a>XP基本实践</h3><ul><li>计划游戏 Planning Game<ul><li>业务人员需要决定：问题范围、优先级、发布的组成、发布日期</li><li>技术人员决定以下事项：估算（实现功能需要的时间）、后果（技术后果）、流程（团队和工作的组织）、详细的日程安排</li><li>缺陷：你不可能仅凭一个粗略的计划就开始开发工作，不断地更新计划耗时太长</li></ul></li><li>小发布 Small Releases<ul><li>每次发布都应尽可能小，包含最有价值的业务需求</li><li>发布必须作为一个整体有意义</li></ul></li><li>隐喻 Metaphor<ul><li>每个极限编程（XP）软件项目都由一个总体隐喻来指导</li><li>在极限编程中，这个隐喻取代了许多其他人所说的 “架构”</li><li>选择一个系统隐喻，通过一致地命名类和方法让团队保持同步</li><li>例如搜索引擎 —— 一大群蜘蛛，在网上四处寻找要捕捉的东西，然后把东西带回巢穴</li></ul></li><li>简单设计 Simple Design<ul><li>运行所有测试</li><li>没有重复的逻辑</li><li>表明对程序员重要的每一个意图</li><li>具有尽可能少的类和方法</li></ul></li><li>测试 TDD：程序员编写单元测试，客户编写功能测试</li><li>重构 Refactoring：在实现程序功能时，程序员总是会问是否有办法改变现有程序，以使添加该功能变得简单<ul><li>重构是在不改变代码外部可见行为的前提下，<strong>持续优化代码内部结构</strong>的技术</li><li>采用简洁的设计，重构起来更加容易</li><li>有测试，所以不太可能在不知情的情况下破坏原有功能</li><li>有持续集成，所以如果不小心在某个环节破坏了原有功能，或者你们的重构与他人的工作发生冲突，几个小时内就能知晓</li></ul></li><li>结对编程<ul><li>所有生产代码的过程中，都有两个人盯着一台机器，共用一个键盘和一个鼠标</li><li>其中一个人，即手握键盘和鼠标的那位，思考的是在此处实现这个方法的最佳方式</li><li>另一个人则从更具战略性的角度思考</li></ul></li><li>代码集体拥有制 Collective Ownership<ul><li><strong>任何人若发现有机会为代码的任何部分增加价值，都应随时这么做</strong></li><li>无所有权模式：没有任何人拥有特定的某段代码。如果有人想修改代码，就会按照自己的目的去改，而不管修改后的代码与现有代码是否契合。</li><li>个人代码所有权模式：只有代码的正式所有者才能修改某段代码</li></ul></li><li><strong>持续集成</strong> <strong>Continuous Integration</strong><ul><li>代码在几小时内 —— 最多一天的开发时间内 —— 完成集成与测试</li><li>少量变更的持续集成能快速定位问题：若测试失败，责任明确归属于当前集成人员，因上一轮集成已确保测试通过</li></ul></li><li>40 小时工作制 40-Hour Week</li><li>现场客户 On-Site Customer：真正的客户必须与团队坐在一起，随时解答问题、解决争议并确定小规模的优先级</li><li>编码标准 Coding Standards：要有相同的编码规范</li><li>上述所描述的实践方法都有弱点，需要相互支持弥补缺陷</li></ul><h2 id="4-TDD和敏捷设计"><a href="#4-TDD和敏捷设计" class="headerlink" title="4. TDD和敏捷设计"></a>4. TDD和敏捷设计</h2><ul><li>敏捷测试<ul><li>我们将在编码前逐分钟编写测试。我们会永久保留这些测试，并经常一起运行它们。我们还会从客户的角度推导出测试</li><li>测试应当是<strong>独立且自动</strong>的</li><li>应该编写那些能带来回报的测试，测试那些可能会出问题的东西</li></ul></li><li>程序员测试<ul><li>程序员编写的是单元测试</li><li>编写测试的情况：接口不清晰、实现复杂、想到特殊情况、发现问题、准备重构</li></ul></li><li>客户测试<ul><li>客户编写的是功能测试</li><li>客户逐个故事地编写测试，但客户通常无法自行编写功能测试</li></ul></li><li>其他测试<ul><li>并行测试：一种旨在证明新系统的运行与旧系统完全一致的测试</li><li>压力测试 ：一种旨在模拟可能出现的最恶劣负载情况的测试。压力测试适用于性能特征不易预测的复杂系统</li><li>随机测试：一种旨在确保系统在面对无意义输入时能合理响应的测试。</li></ul></li><li>测试驱动开发 TDD<ul><li>目标：创建<strong>可测试、可维护、最小化</strong>的代码</li><li>通过<strong>先写测试再写实现</strong>的逆向流程驱动代码设计：三阶段循环：红（失败测试）→ 绿（通过实现）→ 重构（优化代码）</li><li>标准流程（红绿重构循环）<ul><li><strong>编写失败测试</strong>：仅定义接口与预期行为</li><li><strong>快速实现通过</strong>：用最简单代码让测试变绿</li><li><strong>逐步泛化</strong>：补充更多测试案例，消除硬编码</li><li><strong>持续重构</strong>：在测试保护下优化代码结构</li></ul></li><li>核心价值：缺陷预防、设计引导（迫使开发者先思考接口而非实现细节）、降低耦合、活的文档（测试用例显式描述系统行为）</li></ul></li><li>极限编程涉及大量的设计工作，但它采用的方式与传统的软件流程有所不同。极限编程通过一些实践，让演进式设计这一概念重焕生机，使演进成为一种可行的设计策略。</li><li>计划设计与演进式设计<ul><li><strong>设计是为了长期轻松修改软件</strong></li><li>演进式设计：系统设计随实现过程逐渐生长</li><li>计划设计：理念源自其他工程领域。设计师提前思考重大问题。他们无需编码，因为其工作是设计而非构建。因此他们可以使用UML等设计技术，摆脱编程细节，在更抽象层面工作。设计完成后可转交给另一团队构建</li><li>计划设计方法在许多方面优于“编码-修复”式演进设计，但也有缺陷：<ul><li>编程时必然遇到设计未考虑的问题</li><li>文化冲突：设计师因技能经验被选中，但忙于设计导致编码时间减少；失去程序员的尊重</li></ul></li></ul></li><li>XP的赋能实践<ul><li>XP倡导演进式设计而非计划设计</li><li>赋能实践的核心是<strong>测试</strong>和<strong>持续集成</strong></li></ul></li><li>YAGNI原则<ul><li>You aren’t gonna need it</li><li><img src="image-20250522151457226.png" alt="image-20250522151457226" style="zoom:80%;" /></li><li>是否开发 &#x3D; [当前需求强度] × [功能存活率预测] ÷ [技术贬值因子] &gt; 经济阈值（建议≥1.5）</li><li><strong>YAGNI不是反对设计，而是要求用经济学证据驱动每行代码的投资决策</strong></li></ul></li><li>重构的纪律性<ul><li>与临时调整的本质区别：测试保护下的安全重构</li><li>重构不是推倒重写，而是让代码随时间越变越优雅的持续艺术</li><li>工具：IDE自动化重构、测试框架、代码质量扫描</li></ul></li><li>生长式架构<ul><li>软件架构指系统的核心元素——难以修改的部分，是其余部分的基础</li><li>最激进的XP实践者越来越避免前期架构设计：在真正需要前不引入数据库，先用文件后期重构</li><li>Martin Fowler建议：<strong>评估可能架构</strong>。若预期海量多用户数据，首日就用数据库；若复杂业务逻辑，引入领域模型。但遵从YAGNI，存疑时倾向简单。随时准备简化未增价值的架构部分</li></ul></li><li>UML与XP：有用则用</li><li>通过<strong>降低流程中的不可逆性</strong>来应对复杂性</li><li>XP设计需要以下技能：<ul><li>持续保持代码清晰简洁的渴望</li><li>通过重构自信改进代码的能力</li><li>精通模式（design pattern）：不仅理解解决方案，更懂应用时机与演进路径</li><li>预见变化的眼光：知晓今日决策终将改变</li><li>运用代码、图表及最重要的——对话，向相关人员传达设计</li></ul></li></ul><h2 id="5-XP持续集成"><a href="#5-XP持续集成" class="headerlink" title="5. XP持续集成"></a>5. XP持续集成</h2><ul><li><p>传统集成的痛点</p><ul><li>当集成周期很长时，开发者可能会在数周甚至数月的时间里不与主代码库同步。最终尝试集成时会遇到大量问题和错误。</li><li>对开发者的影响：迫使开发者在自己的代码逻辑和解决冲突的调试工作之间频繁切换上下文；害怕集成麻烦而避免影响范围较大的重构；尽量减少与其他部分的交互，导致技术债的积累和代码质量的下降</li><li>对代码质量和重构的影响：开发者即便意识到结构缺陷也避免进行重要的代码重构；这种对重构的回避，阻止了代码库根据需求变化和经验积累进行健康的演进</li></ul></li><li><p>持续集成概念</p><ul><li>持续集成 (Continuous Integration, CI) 是一种软件开发实践，团队成员频繁地（通常每天至少一次）将他们的代码更改集成到共享的代码库主线中。</li><li>每次集成都会触发一次自动化的构建过程，该过程包括编译、链接以及运行一套全面的自动化测试套件</li><li>通过这种方式，任何个体开发者偏离主线的时间都不会超过几个小时。这意味着每次集成涉及的代码量都相对较小，从而显著降低了合并冲突的可能性和复杂性</li><li>这样做的核心目的是尽早发现并解决集成过程中可能出现的各种问题，包括代码冲突、编译错误、运行时错误以及逻辑缺陷</li><li>CI 旨在降低集成的复杂性和风险，避免在项目后期出现痛苦而漫长的“集成地狱”</li></ul></li><li><p>CI实践步骤</p><ul><li>第一步：获取最新代码。开发工作的第一步是从中央代码仓库获取最新的产品代码，确保本地开发环境与主线的最新状态保持一致。然后，在本地创建一个工作副本。确保本地环境与中央仓库同步是 CI 的基本前提。</li><li>第二步：本地构建与开发。获取了最新代码后，在自己的本地环境中运行完整的自动化构建脚本，需要确保在我开始进行任何代码更改之前，本地构建是成功的，然后才开始着手修改代码</li><li>第三步：集成前检查。在推送前必须再拉取主线代码，防止进行开发的同时有新的代码推送到了主线。需要将这些最新的更改合并（Merge）到本地工作副本中，然后再完整运行本地自动化构建</li><li>第四步：本地构建通过与推送。在合并了主线的最新更改并再次运行本地构建后，如果构建仍然成功就可以推送了。推送操作会触发中央 CI 服务器自动执行一次集成构建</li></ul></li><li><p>CI的核心实践</p><ul><li>维护单一的代码库主线：所有开发活动围绕一个共享的主线进行</li><li>自动化构建：构建过程（编译、打包等）完全自动化，可一键执行</li><li>让构建自测试：构建过程包含自动化测试，验证代码正确性</li><li>每个人每天都向主线提交：频繁集成是 CI 的核心</li><li>每次主线提交都应触发构建：自动化验证每次集成</li><li>保持构建快速：快速反馈是关键</li><li>隐含实践：在类生产环境中测试、让获取最新可执行文件更容易、让每个人都能看到构建状态</li><li>自动化部署：将构建产物部署到测试或生产环境</li></ul></li><li><p>实践一：版本控制与主线</p><ul><li>核心原则： 将项目所需的所有东西都纳入版本控制系统，并维护一个单一的、共享的主线</li><li><strong>主线</strong>是代码库中一个单一的、共享的分支，它代表了项目当前的、经过集成的状态，通常是准备部署到生产（或下一个环境）的状态</li><li>CI 强烈推荐基于主线的开发模式</li><li>版本控制内容：任何人用一个干净的环境，只需要clone就可以构建、测试并运行整个产品。因此要包括源码、各种配置文件、脚本、第三方依赖定义文件等</li><li>部分依赖包可以放链接，然后在脚本中自动下载依赖</li><li>构建产物不应包含在版本控制中</li></ul></li><li><p>实践二：自动化构建</p><ul><li>在软件开发中，任何可以自动化的重复性任务都应该自动化</li><li>单一命令原则：任何人都应该能够检出代码库后，通过执行一个简单、明确的单一命令，就能完成整个系统的构建过程</li></ul></li><li><p>实践三：让构建自测试</p><ul><li>现代静态类型语言可以在编译时捕获许多错误，但仍有大量逻辑错误和边界情况可能溜过编译器的检查。对于持续集成所要求的高频率集成来说，仅仅编译通过是远远不够的。</li><li>核心机制： 在 CI 中，防止错误进入产品的主要技术手段是一个全面的自动化测试套件。每次集成构建时，都会执行这些测试</li><li>工具支持： 自动化测试理念的一个重要推动力来自于 Kent Beck 等人在 Smalltalk 和 Java 社区推广的 Xunit 测试框架（如 JUnit, NUnit, PyUnit 等）</li><li>信心来源： 自测试构建的目标是，当所有的自动化测试都通过时（即构建是“绿色”的），团队应该有足够的信心认为产品中没有引入重大的、明显的错误</li><li>许多编程环境还提供了额外的静态和动态分析工具（代码格式、测试覆盖率等等），可以集成到构建验证流程中</li></ul></li><li><p>实践四：每个人每天提交到主线</p><ul><li>实践中的经验法则是，每个团队成员<strong>每天</strong>至少向主线提交（并推送）<strong>一次</strong>他们的代码更改</li><li>频繁集成有助于快速发现两类冲突：源代码冲突、语义冲突</li><li>语义冲突解决方案： 自测试构建是检测语义冲突的关键武器。良好的自动化测试套件应该能够覆盖代码的主要行为路径。当一个语义冲突破坏了程序的预期行为时，相关的测试就应该失败</li></ul></li><li><p>实践五：每次提交触发主线构建</p><ul><li>需要一种机制来确保每次向主线推送代码时，都会在一致的、独立的环境中自动执行一次完整的集成构建（包括编译和测试）。这通常通过持续集成服务（CI Service）来实现。CI 服务会监控代码仓库的主线分支，一旦检测到新的提交，就会自动触发构建流程</li><li>角色与功能： CI 服务（如 Jenkins, GitLab CI, GitHub Actions, CircleCI, Travis CI, Azure Pipelines 等）是实现自动化主线构建的关键工具。功能：</li><li><img src="image-20250522170914180.png" alt="image-20250522170914180" style="zoom: 67%;" /></li><li>构建失败需要<strong>立即</strong>修复</li><li>修复构建失败的最快、最安全的方法通常是直接恢复（Revert）导致失败的那个提交。导致问题的开发者可以在他们本地修复代码（基于恢复后的主线），经过充分测试后再重新尝试集成</li><li><strong>门禁提交和待定头</strong>：提交先进入一个临时区域进行构建验证，通过后才自动合并到主线。但这可能增加流程复杂性。对于高效团队，直接提交+快速修复&#x2F;恢复通常效果更好。</li></ul></li><li><p>实践六：保持构建快速</p><ul><li>一个经常被引用的经验法则是，主提交构建（即验证每次提交的核心构建）应该在<strong>十分钟</strong>内完成</li><li>主要瓶颈： 对于许多企业级应用来说，自动化构建的主要时间瓶颈通常在于测试，特别是那些需要与外部服务（如数据库、第三方 API）交互的集成测试或端到端测试。</li><li>解决方案：<strong>构建流水线</strong> 。流水线将整个构建和验证过程分解为多个阶段（Stage）。第一个阶段是<strong>提交阶段</strong>（Commit Stage）或<strong>提交构建</strong>（Commit Build），它专注于提供最快的反馈。后续阶段则运行更全面但更慢的测试。提交阶段包括编译、快速单元测试、快速的静态检查；后续阶段包括集成测试、端对端测试、性能测试。只有提交阶段失败会阻塞主线。</li></ul></li><li><p>隐藏未完成的工作</p><ul><li><p>由于需要每天频繁集成，主线上可能随时包含一些未完成的、尚未准备好面向用户发布的代码</p></li><li><img src="image-20250522172352398.png" alt="image-20250522172352398" style="zoom:67%;" /></li></ul></li><li><p>持续集成的好处</p><ul><li>降低风险：降低集成风险、快速发现错误、更容易定位错误、减少“集成地狱”</li><li>促进改进与发布：鼓励并支持重构、提高代码质量、更频繁可靠的发布(主线代码始终接近可发布状态)、发布成为业务决策</li></ul></li><li><p>CI与特性分支</p><ul><li>严格来说，持续集成与长期存在的特性分支（即开发者在独立分支上工作）是互斥的开发模式。在特性分支上运行 CI 工具只是“特性分支上的自动化构建”</li><li>但是短暂的、生命周期不超过一天的特性分支（或个人任务分支）与 CI 是兼容的</li></ul></li><li><p>CI与CD</p><ul><li><strong>持续交付</strong> <strong>(Continuous Delivery, CD)</strong></li><li>持续集成 (CI): 关注点在于开发者将代码更改频繁集成到版本控制系统的主线，并通过自动化构建和测试进行验证。</li><li>持续交付 (CD): 是 CI 的自然延伸。它确保了通过 CI 验证的主线代码，能够通过一系列自动化的后续步骤（如更全面的测试、部署到类生产环境、准备发布包），使得任何版本的主线代码都可以部署到生产环境</li><li>关系： <strong>CI 是实现 CD 的必要前提</strong>。没有有效的 CI，就无法可靠地进行 CD</li></ul></li><li><p>持续部署</p><ul><li>Continuous Deployment，注意跟持续交付CD区分</li><li>持续部署是持续交付的更进一步。在持续交付中，每次主线构建通过所有自动化测试和验证后，软件处于可发布状态，但最终部署到生产环境通常还需要一次手动触发（例如，业务人员点击按钮）。而在持续部署中，这个手动触发步骤也被自动化了：只要主线构建成功通过了部署流水线中的所有阶段（包括所有自动化测试和检查），它就会自动被部署到生产环境中</li><li>总结：<ul><li>CI: 代码集成到主线并通过初始验证。</li><li>CD: CI 产物可随时按需部署到生产。</li><li>Continuous Deployment: CD 产物自动部署到生产</li></ul></li></ul></li><li><p>CI 与拉取请求 (Pull Requests) 及代码评审</p><ul><li>拉取请求，尤其是在需要前置代码评审才能合并到主线的流程中，可能会给 CI 带来挑战（会延迟集成）</li><li>解决方案：结对编程(编码时就已评审)、集成后评审、优化评审流程</li></ul></li><li><p>CI与数据库管理</p><ul><li>程序代码变更过程中需要保证数据库结构和状态同步更新</li><li>解决方案：进化式数据库设计</li><li><img src="image-20250522175606093.png" alt="image-20250522175606093" style="zoom:67%;" /></li></ul></li></ul><h2 id="6-Kanban"><a href="#6-Kanban" class="headerlink" title="6. Kanban"></a>6. Kanban</h2><ul><li>Kanban基本概念<ul><li>Kanban（中文常称“看板方法”）起源于制造业，现已成为IT软件开发和项目管理中广泛应用的敏捷方法之一，强调通过<strong>可视化工作流程</strong>和限制<strong>在制品</strong>（WIP）来实现持续流动（continuous flow）。</li><li>Kanban最早起源于20世纪50年代的日本丰田汽车制造业。丰田工程师大野耐一（Taiichi Ohno）受美国超市补货方式启发，在工厂引入以纸卡片传递生产需求信号的系统，命名为“看板”</li><li>看板是一种通过使用<strong>可视化</strong>、<strong>拉动式系统</strong>来优化流程中价值流动的策略。定义价值的方式可能多种多样，例如，可以考虑客户、终端用户、组织以及环境的需求</li><li>看板由以下三种协同工作的实践组成：<ul><li>定义并可视化工作流程</li><li>主动管理工作流程中的事项</li><li>改进工作流程</li></ul></li><li>在实施过程中，这些看板实践统称为<strong>看板系统</strong>。参与看板系统价值交付的人员称为<strong>看板系统成员</strong></li><li>并列框架: Kanban已被普遍视为与Scrum、XP等并列的重要敏捷实践框架</li></ul></li><li>定义并可视化工作流程<ul><li>把项目工作内容贴在白板上。每个工作项一个记事贴。我们一般称电子工具为“信息冰箱”</li><li><img src="image-20250523151436911.png" alt="image-20250523151436911" style="zoom:50%;" /></li><li><strong>工作流</strong>：Kanban的工作流是指工作项从开始到完成的过程。Kanban 系统成员对于流的明确且共同的认知，就称为 “工作流的定义” (Definition of Workflow，DoW)</li><li><strong>工作项</strong>：在工作流中移动的各个<strong>价值单位</strong>被称为 “<strong>工作项</strong>”，根据工作项的不同，工作流可能有多个起点或终点。每个工作项被表示为一个卡片，描述任务、优先级及其他相关信息。这些卡片在看板上进行移动，以反映工作的实际状态。</li><li><strong>在制品</strong>：工作项自开始到结束流动经过⼀个或多个已定义状态，介于开始节点与结束节点间的任何⼀个工作项就称为 “<strong>在制品</strong>”（work in progress， WIP)</li><li>快速通道：Kanban中的快速通道是一种策略，用于优先处理紧急或高优先级的工作项。这是在看板上专门设置的一条路径或一个位置，用于标识和加快处理那些需要立即注意并快速完成的任务。快速通道的相关规则：任何时候<strong>最多只能有一个</strong>工作项在快速通道内；<strong>每周最多有一个</strong>紧急工作；快速通道内的工作项<strong>无需计入在制品限制</strong></li><li><strong>Kanban看板</strong>：Kanban方法的核心工具，可视化工作及其流程状态。典型看板按流程划分为列（如“待处理”、“进行中”、“待测试”、“已完成”），工作项以卡片形式放置。提供实时透明度，显示任务状态、位置、整体负荷。可以是物理白板或电子工具</li><li><strong>Kanban卡片</strong>：代表具体工作项（用户故事、任务、缺陷等）。记录必要信息（标题、负责人、描述、截止日期等）助成员理解任务。电子卡片可含更多属性（子任务、附件、评论）。卡片从左到右移动反映流动。受阻时标记（红标）或入阻塞区提示解决。卡片流动形成拉动信号</li><li><img src="image-20250523153956240.png" alt="image-20250523153956240" style="zoom:50%;" /></li></ul></li><li>流程阶段与WIP限制<ul><li>WIP上限提醒我们要采取行动，改善瓶颈，而不是把没完成的工作堆个没完</li><li><strong>工作流程阶段与泳道</strong>：Kanban板根据具体流程定制列（如“待开发”、“开发中”、“代码审查”、“测试中”、“已部署”）。列间可设“等待&#x2F;就绪”子列。可设泳道（swimlane）横向分区，并行展示不同类型工作或服务级别（如“紧急Hotfix”泳道）。有助于管理不同优先级或类别工作，提高可视化清晰度。</li><li><strong>在制品限制</strong> (WIP Limit)：给每个工作阶段设WIP限制是Kanban的重要元素。通常在列顶标注数字表示上限。强制团队避免多任务过载，减少排队等待。当某列达上限，需暂停拉入新任务，优先完成现有任务。WIP限制需根据团队能力和工作类型调整，通过观察流动数据优化。</li></ul></li><li>拉动式系统<ul><li><strong>拉动式系统</strong>：在拉动式系统中，工作项的完成是由需求触发的，而不是通过事先计划和推测。团队在有容量和能力时，才从工作队列中“拉动”新的任务进行处理。这与传统的“推动”模式不同，后者通常在事前将大量任务规划并分配，甚至可能超过团队的实际承载能力。</li><li>Kanban采用<strong>拉动理念</strong>，下游主动拉取上游工作，而非上游推送。看板上体现为：完成任务后，下一阶段负责人才在空闲时拉取新卡片。当下游忙碌（达WIP上限），上游完成的任务在就绪区等待</li></ul></li><li>Kanban度量<ul><li>WIP：已开始但未完成的工作项的数量</li><li>产能 (Throughput)：每单位时间（如每天、每周或每月）内完成的工作项的数量</li><li>工作项存续时长 (Work Item Age)：⼀工作项从开始到当前时刻之间所经过的时间长度</li><li>周期时间 (Cycle time)：周期时间指的是一个工作项从正式开始处理到完成交付之间的总时长。区别于存续时长（<strong>未完成</strong>的任务），周期时间统计的是<strong>已经完成</strong>的任务</li></ul></li><li>Kanban与Scrum的差异<ul><li>框架：Scrum是<strong>迭代式框架</strong>，通过固定长度Sprint规划交付增量。Kanban是<strong>流动式框架</strong>，无预定迭代周期，工作项持续流动，完成一个拉一个，可连续交付。Scrum适合节奏明确项目，Kanban适合持续流动工作（如支持维护）</li><li>角色：Scrum规定3个明确角色，Kanban不指定必须角色，通常保留现有组织架构，成员各司其职，通过看板协同。Scrum提供明确分工，Kanban鼓励自行分配</li><li>时间规划：Scrum以Sprint为时间盒进行计划评估。有固定节奏的会议（计划、站会、评审、回顾）。Sprint中通常不接受新需求变更。Kanban无时间盒约束，计划交付连续。需求变更可随时反映在队列，团队按优先级拉取。Kanban对变更反应更灵活，但需自行设定回顾节奏。</li><li>流程和工件：Scrum强调规定事件（会议）和工件（Product Backlog, Sprint Backlog, Increment）。Kanban无指定事件工件，唯一主要工件是看板及相关策略。</li></ul></li><li>Kanban与Scrum的融合<ul><li>互补性: 两者并非对立，可相互借鉴：Scrum团队常用可视化任务板（Kanban实践），设WIP限制改善流动；Kanban团队可引入定期回顾，借鉴Backlog管理</li><li>Scrumban: 最著名的混合实践模式，由Corey Ladas提出，作为Scrum到Kanban的中间态&#x2F;过渡。保留Scrum部分结构（如定期会议），取消固定Sprint承诺，改用Kanban拉动节奏和WIP控制</li></ul></li><li>Kanban与XP的关系<ul><li>定位差异: XP（Extreme Programming）侧重<strong>工程实践</strong>，以TDD、重构、持续集成等代表，聚焦“如何开发更好软件”。Kanban关注<strong>流程和可视化管理</strong>，聚焦“如何管理和改进工作流程”，本身不规定技术实践。XP是工程实践集，Kanban是流程管理方法，不在同一维度</li><li>兼容并用：可完全同时采用XP实践和Kanban方法。XP保证代码质量和开发技法，Kanban确保工作项流动顺畅及时交付。</li></ul></li></ul><h2 id="7-DevOps"><a href="#7-DevOps" class="headerlink" title="7. DevOps"></a>7. DevOps</h2><ul><li>DevOps历史<ul><li><img src="image-20250523162713085.png" alt="image-20250523162713085" style="zoom:67%;" /></li><li><img src="image-20250523162756283.png" alt="image-20250523162756283" style="zoom:50%;" /></li><li>总结: 理念形成 -&gt; 敏捷&#x2F;云&#x2F;工具驱动推广 -&gt; 大规模验证&#x2F;最佳实践 -&gt; 深度融合安全&#x2F;AI。体现软件交付从<strong>瀑布</strong>到<strong>敏捷</strong>持续的范式转变</li></ul></li><li>DevOps概述<ul><li>DevOps 不仅是理念: 更是一系列核心实践和技术工具的体系化应用，贯穿软件生命周期（规划、编码、构建、测试、发布、部署、运行、监控、反馈）。形成持续循环的不间断流程</li><li>核心实践包括：CI&#x2F;CD、自动化测试、IaC、自动化配置管理、容器化、监控反馈</li></ul></li><li>CI&#x2F;CD<ul><li>持续集成 (CI - Continuous Integration):要求开发者频繁 (每天乃至每小时) 将代码变更合并到主干分支，触发自动化构建和测试。</li><li>持续交付 (CD - Continuous Delivery):将 CI 产出的构件自动部署到测试或预生产环境。</li><li>持续部署 (Continuous Deployment):持续交付的极致，代码通过自动化流程验证后直接部署到生产环境。</li></ul></li><li>自动化测试和IaC<ul><li>自动化测试：“测试门禁”只有通过所有自动测试的构建才可部署，前移质量控制</li><li>IaC：基础设施即代码 。使用代码化方式管理和配置基础设施 (服务器、网络等)，将手动运维操作转为可编程脚本&#x2F;配置。可以以声明式配置文件定义所需基础架构环境，自动化部署和变更管理。<strong>效果</strong>：确保环境配置一致性和可重复性，避免“环境漂移”</li><li>IaC工具示例：Chef, Puppet, Ansible, Terraform</li></ul></li><li>配置管理：自动化配置，配置管理工具 (Chef, Puppet) 确保不同服务器系统配置统一</li><li>容器化<ul><li>容器化技术 (Docker)：推动“一次构建，到处运行”。应用及其依赖打包为镜像，保证开发、测试、生产环境一致运行，减少“在我机器上能跑”问题</li><li>容器编排 (Kubernetes)：自动部署、管理容器集群，提供服务发现、弹性伸缩等，使微服务落地更容易</li></ul></li><li>监控反馈<ul><li>实时监控：DevOps 生命周期后半段强调对应用运行状态的<strong>实时监控</strong></li><li>持续反馈：不仅是故障响应 (传统运维关注 MTTR)，更要将正常运行数据用于改进 (分析部署频率与失败率关系、用户行为反馈新功能等)</li><li>工具示例：Prometheus, Nagios, Grafana</li><li>实践：收集系统性能指标、日志、用户行为数据；设置警报及时通知异常</li></ul></li><li>DevOps与敏捷<ul><li>敏捷 (Agile)：<ul><li>核心：项目和产品开发方法学，提高开发过程灵活性和响应速度</li><li>关注点：开发团队内部效率，与客户持续反馈，快速响应需求变更</li><li>目标：“如何更有效地开发软件”</li></ul></li><li>DevOps<ul><li>核心：扩展敏捷理念，范围从开发延伸到软件交付和运维全生命周期</li><li>关注点：开发与运维协作，打破壁垒，实现从开发到部署的持续流动</li><li>目标：“如何更快更可靠地交付软件”</li></ul></li><li>互补性：敏捷提供快速交付增量功能的框架，DevOps 确保功能顺畅、安全部署上线</li><li>实践差异：敏捷强调<strong>组织结构</strong>和<strong>开发流程</strong>敏捷性，DevOps 强调<strong>跨职能协作</strong>和<strong>交付流程自动化</strong>。敏捷遵循 Scrum&#x2F;Kanban，短迭代交付增量；DevOps 在敏捷产出基础上引入 CI&#x2F;CD、自动化部署、监控等，快速推向生产</li></ul></li><li>DevOps与CI&#x2F;CD<ul><li>关系：CI&#x2F;CD (持续集成&#x2F;持续交付) 是技术实践，DevOps 是文化和流程理念。CI&#x2F;CD 是实现 DevOps 目标的核心实践手段之一</li><li>区别：没有 CI&#x2F;CD 很难实现 DevOps，但仅有 CI&#x2F;CD 工具不代表完成 DevOps 转型。CI&#x2F;CD 关注代码构建、测试、部署自动化；DevOps 涵盖人、流程、工具范围更广，包括组织和文化</li></ul></li><li>DevOps与云原生<ul><li><strong>云原生定义</strong>：利用云计算优势设计部署应用的架构理念 (容器化、微服务、不可变基础设施等)。强调应用如何构建运行以适应云环境弹性和分布式特性</li><li>DevOps 定义：强调应用如何快速可靠交付</li><li>二者<strong>目标一致</strong>，都为提升交付速度和弹性；<strong>切入点不同</strong>，云原生关注<strong>架构</strong>，DevOps 关注<strong>流程</strong></li><li><strong>相互促进</strong>：Cloud Native 应用天然需要 DevOps 实践支撑 (如微服务需要 CI&#x2F;CD)。DevOps 需要弹性云资源支持频繁部署测试。云的弹性需 DevOps 自动化才能高效利用。</li><li>总结：DevOps 是过程方法，Cloud Native 是应用架构。二者高度协同，都以加速交付为目标，都推崇自动化和协作。</li></ul></li><li>DevOps与AIOps<ul><li>AIOps 定义：利用 AI 技术提升 <strong>IT 运维</strong>智能化水平 (机器学习分析监控数据、自动发现异常、定位根因等)。是运维领域 AI 工具集和实践集</li><li>DevOps 为敏捷高效运维提供机制和文化基础，AIOps 为复杂运维场景提供智能化手段</li><li>实施使数据收集和流程自动化成为可能，为 AI 算法提供用武之地 (监互相支撑：DevOps控日志性能指标等大数据)。AIOps 工具可基于数据做模式识别、预测故障、自动恢复，与 DevOps 目标一致</li></ul></li><li>DevSecOps<ul><li>DevSecOps &#x3D; 开发 (Dev) + 安全 (Sec) + 运维 (Ops) 的融合</li><li>随着 DevOps 实践深入，意识到安全 (Security) 应融入 DevOps 过程，而非最后检查</li><li>核心目标：将安全保障集成到软件开发生命周期各阶段，而非仅上线前被动检查</li><li>观念转变: 安全不再是独立团队责任，而是 DevOps 团队共享责任，需“<strong>左移</strong>”到开发之初就考虑</li><li>安全需求融入规划: 计划阶段评估风险合规，<strong>用户故事同时定义安全验收标准</strong>。开发&#x2F;运维&#x2F;安全共同参与需求讨论</li><li>实践<ul><li>安全编码实践: 开发人员接受培训，遵循规范 (防 SQL 注入&#x2F;XSS)。引入静态代码分析 (SAST) 工具，代码合并前自动扫描漏洞。</li><li>自动化安全测试: CI 流水线加入 SAST 和 DAST (动态应用安全测试) 工具。容器镜像安全扫描(检查已知漏洞&#x2F;不合规配置)。安全测试同普通测试一样，每次构建&#x2F;部署运行</li><li>基础设施和依赖安全: 利用 IaC 对基础设施配置应用安全策略 (端口限制&#x2F;加密) 并代码审查&#x2F;扫描。</li><li>持续监控与防护: 部署入侵检测、WAF 防火墙，安全日志入集中监控。安全事件发生时，团队快速响应、修复、触发 CI&#x2F;CD 紧急更新。形成闭环反馈</li></ul></li></ul></li><li>常用 DevOps 术语表<ul><li><strong>蓝绿部署</strong> (Blue-Green Deployment)<ul><li>定义：<strong>零停机部署策略</strong>。维护两套环境：蓝 (当前生产)，绿 (部署新版)</li><li>流程：测试验证绿环境正常后，流量从蓝切到绿。切换<strong>瞬时完成</strong></li><li>优缺点：切换快，回退易 (切回蓝)；需双倍资源；一次性切换有风险</li><li>适用：要求短暂无缝切换场景，成本较高</li></ul></li><li><strong>金丝雀发布</strong> (Canary Deployment)<ul><li>定义：渐进式部署策略</li><li>流程：<strong>仅将一小部分用户&#x2F;流量切换到新版本</strong>，其余仍用旧版。观察新版运行情况，无异常则逐步扩大新版流量比例，最终 100% 迁移。有问题可及时止损&#x2F;回滚</li><li>优缺点：更安全可控，常与 A&#x2F;B 测试结合；需实现按用户&#x2F;流量分割的路由机制</li><li>适用：风险最低的发布策略之一</li></ul></li><li>基础设施即代码 (IaC, Infrastructure as Code)：同上</li><li>微服务 (Microservices)<ul><li>定义：软件架构风格，将应用拆分为一组小的、独立部署的服务，每个服务专注单一业务能力</li><li>与 DevOps 关系：相辅相成。服务粒度小，可独立开发部署，使 CD 更易。每个服务由小团队负责全生命周期</li><li>特点：部署频率高，需成熟 CI&#x2F;CD 和监控。通过 DevOps 实现弹性伸缩和故障隔离</li></ul></li><li>持续监控 (Continuous Monitoring)：同上</li><li>MTTR (Mean Time to Recovery&#x2F;Restore)<ul><li>定义：<strong>平均恢复时间</strong>，从故障发生到修复完成的平均时长</li><li>意义：DevOps 度量中反映发布稳定性和运维效率的关键指标。高绩效团队 MTTR 在小时内，低绩效需数天</li><li>改进方式：自动化监控、快速回滚、高效协作可大幅降低 MTTR</li></ul></li></ul></li><li>DORA评价指标<ul><li>DORA：DevOps Research and Assessment</li><li>部署频率<ul><li>是指团队或组织在给定时间范围内将代码成功部署到生产环境的频率，通常以每日、每周、每月或更低的频率进行统计</li><li><img src="image-20250523171301862.png" alt="image-20250523171301862" style="zoom: 67%;" /></li></ul></li><li>变更前置时间<ul><li>从代码提交到代码成功部署到生产环境所需的时间，也即<strong>从开发人员开始写代码到客户真正获得该变更</strong>的间隔时长。</li><li><img src="image-20250523171335641.png" alt="image-20250523171335641" style="zoom: 67%;" /></li></ul></li><li>变更失败率<ul><li>部署到生产环境后的代码变更引发故障或问题，导致需要紧急修复、回滚或出现服务降级等情况的比例</li><li><img src="image-20250523171402600.png" alt="image-20250523171402600" style="zoom:67%;" /></li></ul></li><li>平均恢复时间<ul><li>当生产环境出现故障或服务降级时，从故障发生到完全恢复正常服务所需的平均时间</li><li><img src="image-20250523171431393.png" alt="image-20250523171431393" style="zoom:67%;" /></li></ul></li><li><strong>部署频率</strong>和<strong>变更前置时间</strong>体现了交付的<strong>速度和效率</strong></li><li><strong>变更失败率</strong>和<strong>平均恢复时间</strong>则体现了交付的<strong>质量和稳定性</strong></li></ul></li></ul><h2 id="8-敏捷概述"><a href="#8-敏捷概述" class="headerlink" title="8. 敏捷概述"></a>8. 敏捷概述</h2><ul><li>为什么敏捷与精益出现在软件开发行业？<ul><li><strong>软件开发本质属性</strong>：复杂性、一致性、可变性、不可见性</li><li>敏捷与精益本质上是帮助我们处理软件开发的复杂性、可变性</li></ul></li><li>软件项目成功标准<ul><li>传统观点<ul><li>成功的：按时完成，费用不超过预算，而且所有特性和功能都符合原先的设计规格</li><li>不太成功的：已完成并且可以运行，但费用超出了预算，没有如期完成，拥有的特性和功能少于原先的设计规格</li><li>失败的：在开发周期的某个时刻被取消了</li></ul></li><li>敏捷观点<ul><li>为客户创造价值是评价成功的最重要标准</li><li><strong>所有软件开发实践都应该以提升项目收益为首要目标！</strong></li></ul></li></ul></li><li>敏捷开发知识体系<ul><li><img src="image-20250524095352283.png" alt="image-20250524095352283" style="zoom:50%;" /></li></ul></li><li>敏捷宣言历史<ul><li>2001年，17位超级极客齐聚犹他州的雪鸟滑雪山庄，共同探索有关软件开发未来发展的共同理念。其中包括Scrum、极限编程、水晶、特性驱动开发等一些新生方法论的发起者</li><li>与会者达成了一致意见，将这场“运动”命名为“敏捷”。他们授予自己“敏捷联盟”的称号，草拟出一份言简意赅的《敏捷宣言》</li></ul></li><li><strong>敏捷宣言</strong> 重要<ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li><li>也就是说，<strong>尽管右项有其价值，我们更重视左项的价值</strong>。</li></ul></li><li>个体和互动胜过流程和工具<ul><li>敏捷力的基本宗旨之一就是，干活的人最清楚该如何完成工作</li><li>不要规定团队一定要使用某个方法或工具</li><li>流程和工具必须是为人服务的，而不是反过来</li></ul></li><li>可以工作的软件胜过详尽的文档<ul><li>如果文档着眼于创造价值和以有利方式推动项目进展，那就没问题。例如，对大多数产品来说，用户文档都是很有价值的组成部分</li><li>但如果关注焦点不再是产品本身，而变成了流程文档，就有问题了</li><li><strong>敏捷团队也是会做计划的</strong>，因为计划需要不断地进行细化和更新。敏捷软件项目中的计划以各种形式出现在我们身边，例如用户故事、列表(backlog)、验收测试、和大型可视图表，它们组成了富沟通环境</li></ul></li><li>客户合作胜过合同谈判<ul><li>敏捷价值观着重强调，开发团队和客户之间要保持尽可能公开和顺畅的对话</li><li>基于合同的项目侧重方向不对。相关各方就像是一群合伙人，齐心协力在规定时间和预算范围内努力构建最有价值的系统</li></ul></li><li>响应变化胜过遵循计划<ul><li>计划驱动型组织通常都有“变化控制”流程</li><li>只有在变更可控的情况下，变化控制才会有效果</li><li>创造价值才是衡量软件开发成功的标准</li></ul></li></ul><h2 id="9-新方法学"><a href="#9-新方法学" class="headerlink" title="9. 新方法学"></a>9. 新方法学</h2><ul><li>从无到繁重到敏捷<ul><li>有一些根本性的原则是所有敏捷方法的共同之处，这些 原则与那些传统软件工程方法的前提假设是截然相反的</li><li>code and fix 这种模式对小系统开发其实很管用，但是当系统变得越大越复杂时，要想加入新的功能就越来越困难。同时错误故障越来越多，越来越难于排除</li><li>软件行业中最初的一场运动是要改变这种情况，而引入了“<strong>正规方法</strong>”的概念。这些（正规）方法对开发过程有着严格而详尽的规定，以期使软件开发更有可预设性并提高效率，这种思路是借鉴了其他工程领域的实践，因此我把它们称为<strong>工程方法</strong>，也叫<strong>计划驱动方法</strong></li><li>工程方法最常听见的批评就是它们的<strong>官僚繁琐</strong>，要是按照它的要求来，那有做太多的事情需要做，而延缓整个开发进程</li><li>敏捷方法的发展是对这些工程方法的反弹，它们在无过程和过于繁琐的过程中达到了一种平衡，使得能以不多的步骤过程获取较满意的结果</li></ul></li><li>敏捷方法与工程方法的区别<ul><li>表面区别：敏捷型不是很面向<strong>文档</strong>，对于一项任务，它们通常只要求尽可能少的文档。从许多方面来看，它们更象是“面向源码”（code-oriented）。事实上，最根本的文档应该是源码</li><li>本质区别<ul><li>敏捷型方法是“<strong>适应性</strong>”而非“预见性”。工程方法试图对一个软件开发项目在很长的时间跨度内<strong>作出详细的计划</strong>，然后<strong>依计划进行开发</strong>。这类方法在一般情况下工作良好，但（需求、环境等）有变化时就不太灵了。而敏捷型方法则<strong>欢迎变化</strong>，它们的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化</li><li>敏捷型方法是“<strong>面向人</strong>”的而非“<strong>面向过程</strong>”的。工程型方法的目标是<strong>定义一个过程</strong>，而敏捷型方法则认为<strong>没有任何过程能代替开发人员的技能</strong>，过程起的作用是对开发人员的工作提供支持</li></ul></li></ul></li><li>软件开发与工程<ul><li>传统的软件开发正规方法的基本思路一般是从其他<strong>工程领域</strong>借鉴而来。</li><li><strong>设计</strong>是难于预见的，并且需要昂贵的有创造性的人员，<strong>建造</strong>则要易于预设。我们有了设计之后，便可对建造进行计划了。而有了建造计划后，我们进行建造则可以是非常可预见性的了。</li><li>软件工程方法：我们想要可预见的生产进度计划，以便能使用技能较低的人员</li><li>要达到这一点，我们必须得把设计与建造分离开来。因此，在软件开发中，我们得想法作出这样的设计，使得计划一经完成，建造将会是直接而明确的，例如使用UML进行设计</li><li>在软件开发中，具体建造费用非常低，所有工作都是设计，而创造性的过程是不太容易计划的</li></ul></li><li>需求的不可预见性<ul><li>在建造商用软件系统中，需求变更是常态，问题是我们如何来处理它</li><li>一种方法是把需求变更看成是因需求工程没作好而导致的结果。需求工程（或进行需求分析）是要在着手建造软件之前，获取一幅已完全理解了的待建系统的画面，然后取得客户认可签发，并且还要建立一套规章来限制需求变更</li><li>人们期待需求应该是可变的。软件开发的一切都取决于系统需求，如果需求不固定，你就不能制订出一个可预见性的计划</li><li>如果你不能遵循一个可预见性方法，而你强装能够，那么这是非常危险的。因此在不可预见性的环境中是不能使用预见性方法的</li><li>你所需要的是另一类过程，它们可以让你对不可预设性进行控制，这就是“适应性”的作用了</li></ul></li><li>不可预见的控制过程——<strong>迭代</strong><ul><li>如何对付一个不可预测的世界呢？最重要，也是最困难的是要随时知道我们在开发中的情形处境。这种机制的关键之点是“<strong>迭代式</strong>”（iterative）开发方法。</li><li>迭代式开发的要点是经常不断地生产出最终系统的工作版本，这些版本逐步地实现系统所需的功能。</li><li>需求变更使得长期计划是不稳定的，一个稳定的计划只能是短期的，这通常是一个“<strong>迭代周期</strong>”</li><li>预见性项目是否成功是由它是否很好地按计划执行来衡量的，一个项目如果在规定的时间和预算内完成，那就是成功的。对于敏捷型项目实践者来说，最重要的是商业价值</li><li><strong>一个好的预见性项目是依计划而行，而一个好的敏捷型项目会建造出一个与最初计划不太一样却是更好的软件</strong></li></ul></li><li>把人放在第一位<ul><li>传统正规方法的目标之一是发展出这样一种过程，使得一个项目的参与人员成为可替代的部件。个体是不重要的，只有角色（例如分析员、测试员）才是重要的</li><li>Alistair Cockburn对软件项目的研究导致了如下结论：人是软件开发中最重要的因素</li><li>泰勒主义的一个关键的理念是认为干活的人并非是那些知道怎样才能把这件活干的好的人。泰勒主义让计划部门来决定如何干好一件工作的作法只有当计划者比实际操作者更能知道怎样作时才有效</li><li>而敏捷软件开发是面向人的过程管理。实施敏捷型过程的一个关键之处是让大家接受一个过程而非强加一个过程，另一点是开发人员必须有权作技术方面的<strong>所有</strong>决定</li></ul></li><li>度量的困难性<ul><li>如果有一个过程，<strong>规定工作应该如何来做的人不是具体去干的人</strong>，那么你需要一些方法来度量干工作的人是否工作有效</li><li><strong>度量软件是非常困难的</strong></li><li>Austin的结论是你得在这两种方法中作选择：<strong>基于度量的管理</strong>，或是**“委托式”管理**（干工作的人决定该怎么干）</li><li>基于度量的管理是非常适合简单的、重复性的工作，知识要求低并且易于度量输出－－这恰恰与软件开发相反</li></ul></li><li>自适应过程<ul><li>除了前文说过的适应性（应对需求变更），另一种适应性，即是过程本身随着时间推移变化。例如随着时间的推移，开发团队会发现什么方式对他们的工作最好，然后改变过程以适应之</li><li><img src="image-20250524194221201.png" alt="image-20250524194221201" style="zoom:50%;" /></li></ul></li><li>是否应该选择敏捷<ul><li>找到合适的项目来全面试验敏捷方法</li><li>让客户接受敏捷型方法</li><li>从一个便于管理的小系统开始</li><li>选择对业务影响小的项目开始</li><li>不应该用的情况：这主要是取决于人。如果有关人员对敏捷方法所要求的密切的合作不感兴趣的话，那么，驱赶他们来做敏捷式开发会是一场苦战。因此，我认为，你绝不能把敏捷方法强加给一个不想试用该方法的团队</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件质量与管理</tag>
      
      <tag>敏捷</tag>
      
      <tag>Kanban</tag>
      
      <tag>Scrum</tag>
      
      <tag>极限编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计(设计模式部分)</title>
    <link href="/2025/06/06/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%83%A8%E5%88%86/"/>
    <url>/2025/06/06/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计整理-设计模式部分"><a href="#软件系统设计整理-设计模式部分" class="headerlink" title="软件系统设计整理(设计模式部分)"></a>软件系统设计整理(设计模式部分)</h1><blockquote><p>要知道每个原则和设计模式的英文，因为考试是纯英文。。</p></blockquote><h2 id="1-面向对象设计原则"><a href="#1-面向对象设计原则" class="headerlink" title="1. 面向对象设计原则"></a>1. 面向对象设计原则</h2><blockquote><p>设计原则是最重要的部分，要理解本身概念和应用</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>软件设计<ul><li><strong>需求</strong>定义了系统需要满足的目标</li><li><strong>规约</strong>定义了系统的外部可观察到的行为</li><li><strong>架构</strong>定义了系统一级的主要组成部分、各部分的交互方法、使用的技术</li><li><strong>设计</strong>定义了如何完成任务、需要写的代码</li></ul></li><li>面向对象软件设计<ul><li>将实现的约束条件应用到面向对象分析所产生的概念模型的过程</li><li>用方法和属性来描述用于构成系统的类</li><li>添加不明显属于领域的类，比如抽象类和接口</li><li>描述类是如何构成组件的</li></ul></li><li>如何发现合适的对象<ul><li>OOD的难点在于将一个系统分解成对象</li><li>许多对象直接来自于分析模型或实现空间（数据库、文件、用户界面、IPC…）</li><li>同样，还有其他一些类没有这样的对应类，用来使可能过于特殊的设计变得更为通用，例如策略模式类</li></ul></li><li>软件的可维护性和可复用性<ul><li>一个可维护性(Maintainability) 较低的软件设计，通常由于如下4个原因造成：过于僵硬、过于脆弱、复用率低、黏度过高</li><li>一个好的系统设计应该具备如下三个性质：可扩展性、灵活性、可插入性</li><li>软件的复用(Reuse)或重用拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，<strong>恰当的复用还可以改善系统的可维护性</strong></li><li>面向对象设计复用的目标在于实现支持可维护性的复用，在面向对象的设计里面，可维护性复用都是<strong>以面向对象设计原则为基础的</strong></li><li><strong>重构</strong>(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性</li></ul></li></ul><span id="more"></span><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><blockquote><p>要知道原则的英文</p></blockquote><ul><li><p>面向对象设计原则简介</p><ul><li>常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充</li><li>目的：支持可维护的复用<ul><li>目标：开闭原则</li><li>指导：最小知识原则</li><li>基础：单一职责原则、可变性封装原则</li><li>实现：依赖倒置原则、合成复用原则、里氏代换原则、接口隔离原则</li></ul></li><li><img src="image-20250526160242596.png" alt="image-20250526160242596" style="zoom:67%;" /></li><li><img src="image-20250604145745603.png" alt="image-20250604145745603"></li></ul></li><li><p>单一职责原则 SRP</p><ul><li>定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</li><li>另一个定义：就一个类而言，应该仅有一个引起它变化的原因</li><li>分析<ul><li>一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小</li><li>类的职责主要包括两个方面：<strong>数据职责</strong>和<strong>行为职责</strong>，数据职责通过其属性来体现，而行为职责通过其方法来体现</li><li>单一职责原则是实现高内聚、低耦合的指导方针</li></ul></li><li>例子<ul><li>某基于Java的C&#x2F;S系统的“登录功能”通过如下登录类(Login)实现</li><li><img src="image-20250526161707888.png" alt="image-20250526161707888"></li><li>现使用单一职责原则对其进行重构，把接受请求、访问数据分开</li><li><img src="image-20250526161744252.png" alt="image-20250526161744252" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>开闭原则 OCP</p><ul><li>定义：一个软件实体应<strong>当对扩展开放，对修改关闭</strong>。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</li><li>抽象化是开闭原则的关键</li><li>例子：<ul><li>某图形界面系统提供了各种不同形状的按钮，客户端代码可针对这些按钮进行编程，用户可能会改变需求要求使用不同的按钮</li><li><img src="image-20250526161845119.png" alt="image-20250526161845119" style="zoom:50%;" /></li><li><img src="image-20250526161859438.png" alt="image-20250526161859438" style="zoom: 80%;" /></li><li>其实就是让原来依赖实现类的类去依赖抽象类</li></ul></li></ul></li><li><p>里氏代换(替换)原则 LSP</p><ul><li>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象</li><li>里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象</li><li>里氏代换原则是实现开闭原则的重要方式之一</li><li><strong>在程序中尽量使用基类类型来对对象进行定义，在运行时再确定其子类类型，用子类对象来替换父类对象</strong></li><li>例子<ul><li>某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA和CipherB</li><li><img src="image-20250526162350022.png" alt="image-20250526162350022" style="zoom:80%;" /></li><li><img src="image-20250526162408020.png" alt="image-20250526162408020" style="zoom: 40%;" /></li></ul></li></ul></li><li><p>依赖倒转(置)原则 DIP</p><ul><li>定义：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>另一个定义：要针对接口编程，不要针对实现编程</li><li>如果说开闭原则是面向对象设计的<strong>目标</strong>的话，那么依赖倒转原则就是面向对象设计的<strong>主要手段</strong></li><li>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中</li><li>类之间的耦合：零耦合、具体耦合、抽象耦合</li><li>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键</li><li>例子<ul><li>某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式</li><li><img src="image-20250526163302821.png" alt="image-20250526163302821" style="zoom:67%;" /></li><li><img src="image-20250526163316493.png" alt="image-20250526163316493" style="zoom:80%;" /></li></ul></li><li><strong>为什么里式替换原则和依赖倒置原则要结合起来？</strong><ul><li>单独使用的局限性：如果只满足LSP，而依赖于具体的子类或父类实现，系统的耦合度还是偏高，扩展性不足。如果只满足DIP高层依赖的抽象不能保证子类能够替换父类，可能会导致逻辑错误或行为异常。</li><li>结合使用的好处：<ul><li>可靠性：DIP要求依赖抽象，但抽象的稳定性和正确性很重要。LSP确保不同实现（子类）都能替换抽象，不会破坏原有功能，让依赖倒置变得安全可靠。</li><li>解耦与复用：只要抽象层遵循LSP，实际开发中高层模块只需依赖接口（DIP），而不会关心具体实现。</li><li>降低维护成本：新需求或子类增加时，只要遵守LSP，高层模块无须修改。DIP让系统更灵活、适应变化，而LSP保证变化不会潜移默化破坏功能稳定性。</li></ul></li></ul></li></ul></li><li><p>接口隔离原则 ISP</p><ul><li>定义：客户端不应该依赖那些它不需要的接口</li><li>另一个定义：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可</li><li>接口隔离原则是指<strong>使用多个专门的接口，而不使用单一的总接口</strong></li><li>使用接口隔离原则拆分接口时，首先必须满足单一职责原则</li><li>可以在进行系统设计时采用<strong>定制服务</strong>的方式，即为不同的客户端提供宽窄不同的接口</li><li>例子<ul><li>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构</li><li><img src="image-20250526170217963.png" alt="image-20250526170217963" style="zoom:80%;" /></li><li><img src="image-20250526170226272.png" alt="image-20250526170226272" style="zoom:80%;" /></li></ul></li></ul></li><li><p>合成复用原则 CRP</p><ul><li>定义：尽量使用对象组合，而不是继承来达到复用的目的。HAS-A can be better than IS-A</li><li>合成复用原则就是指<strong>在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分</strong>；新对象通过<strong>委派调用已有对象的方法达到复用其已有功能的目的</strong>。简言之：<strong>要尽量使用组合&#x2F;聚合关系，少用继承</strong>。</li><li>在面向对象设计中，可以通过两种基本方法<strong>在不同的环境中复用已有的设计和实现</strong>，即<strong>通过组合&#x2F;聚合关系或通过继承</strong></li><li>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，<strong>不可能在运行时发生改变，没有足够的灵活性</strong>；只能在有限的环境中使用。（“<strong>白箱</strong>”复用）</li><li>组合&#x2F;聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“<strong>黑箱</strong>”复用）</li><li>组合&#x2F;聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合&#x2F;聚合来实现复用</li><li>例子<ul><li>某教学管理系统部分数据库访问类设计如图所示，如果需要更换数据库连接方式，如原来采用JDBC连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果StudentDAO采用JDBC连接，但是TeacherDAO采用连接池连接，则需要增加一个新的DBUtil类，并修改StudentDAO或TeacherDAO的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差</li><li><img src="image-20250526171224989.png" alt="image-20250526171224989" style="zoom:80%;" /></li><li><img src="image-20250526171247512.png" alt="image-20250526171247512" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>迪米特法则&#x2F;最少知识原则 LoD</p><ul><li>定义：不要和“陌生人”说话，只与你的直接朋友通信。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</li><li>迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用，这样当一个模块修改时，就会尽量少的影响其他的模块</li><li>迪米特法则中，对于一个对象，其<strong>朋友</strong>包括以下几类：<ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul></li><li>迪米特法则可分为<strong>狭义法则</strong>和<strong>广义法则</strong>。在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。狭义法则可以降低类之间的耦合，但是不同模块之间的通信效率低。广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制</li><li>迪米特法则的主要用途在于控制信息的过载：尽量创建松耦合的类；尽量降低成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；一个对象对其他对象的引用应当降到最低</li><li>例子<ul><li>某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂</li><li><img src="image-20250526171952892.png" alt="image-20250526171952892" style="zoom:80%;" /></li><li><img src="image-20250526171959398.png" alt="image-20250526171959398" style="zoom:80%;" /></li></ul></li></ul></li></ul><h2 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><p>软件模式</p><ul><li>软件模式是将模式的一般概念应用于软件开发领域，即<strong>软件开发的总体指导思路或参照样板</strong>。软件模式包括设计模式、架构模式、分析模式、过程模式。在软件生命周期的每个阶段都存在一些模式。</li><li>软件模式的基本结构 (四要素)：问题描述、前提条件（环境或约束条件）、解法和效果</li><li>软件模式在发现过程中需要遵循<strong>大三律(Rule Of Three)</strong>，即只有<strong>经过三个以上不同类型的系统的校验</strong>，一个解决方案才能从候选模式升格成模式</li></ul></li><li><p>设计模式的概念</p><ul><li>设计模式（Design Pattern）是一套<strong>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li></ul></li><li><p>设计模式的作用</p><ul><li>设计模式为您提供了与其他开发人员共享的词汇表。当您使用模式与其他开发人员或团队进行沟通时，您不仅在沟通模式名称，还传达了模式所代表的整套质量属性，特征和约束，为开发团队提供强大的动力</li><li>通过让您在<strong>模式级别</strong>(而不是实质性对象级别)进行思考，还可以提高您对体系结构的思考</li></ul></li><li><p>设计模式的基本要素</p><ul><li>包括模式名称、问题、目的、解决方案、效果、实例代码、相关设计模式</li><li>关键元素（四要素）：模式名称、问题、解决方案、效果</li></ul></li><li><p>设计模式分类</p><ul><li>分类一：目的<ul><li>创建型模式（Creational）：主要用于创建对象；例如：工厂方法模式、抽象工厂模式</li><li>结构型模式（Structural）：主要用于处理类或对象的组合；例如：适配器模式、组合模式、外观模式、装饰模式</li><li>行为性模式（Behavioral）：主要用于描述对类或对象怎样交互和怎样分配职责，例如：模板方法模式、命令模式、中介者模式、观察者模式</li></ul></li><li>分类二：范围<ul><li>类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于<strong>静态的</strong>；例如：工厂方法模式、（类）适配器模式、模板方法模式。</li><li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具<strong>动态性</strong>；例如：抽象工厂模式、（对象）适配器模式、命令模式、中介者模式、观察者模式。</li></ul></li></ul><table><thead><tr><th>范围&#x2F;目的</th><th>创建型模式</th><th>结构型模式</th><th align="left">行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法模式</td><td>(类)适配器模式</td><td align="left">模板方法模式</td></tr><tr><td>对象模式</td><td>抽象工厂模式、建造者模式、原型模式、单例模式</td><td>(对象)适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式</td><td align="left">命令模式、迭代器模式、中介者模式、观察者模式、状态模式、策略模式</td></tr></tbody></table></li><li><p>如何使用设计模式</p><ul><li>依赖库和框架：提供了全部和必要的功能，一般可以直接直接复用</li><li>设计模式帮助我们构建自己的应用程序，以使其更具可维护性和灵活性</li><li>设计模式首先进入你的大脑</li><li>尽量避免过度使用的问题</li></ul></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul><li>概述<ul><li><strong>策略模式定义了一系列算法</strong>，将每个算法封装在一起，并使它们可替换，策略使算法独立于使用该算法的客户端而变化</li><li>目的：定义一系列算法，封装每个算法，并使它们可替换。策略使<strong>算法可以独立于使用该算法的客户端而变化</strong>。</li><li>名称：策略模式 <strong>Strategy Pattern</strong>，也可以是Policy Pattern</li></ul></li><li>应用场景<ul><li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用多种行为之一配置类的方法</li><li>您需要<strong>算法的不同变体</strong>。例如，您可能定义了反映不同空间&#x2F;时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。</li><li>一种算法使用客户端不应该知道的数据。使用策略模式<strong>可避免暴露复杂的、特定于算法的数据结构</strong></li><li>一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的<strong>策略类</strong>中。</li></ul></li><li>策略模式结构<ul><li><img src="image-20250604164256148.png" alt="image-20250604164256148"></li><li>使用策略的上下文、抽象策略接口、具体策略类</li></ul></li><li>策略模式的作用<ul><li>定义了相关算法家族。策略类的层次结构定义了一系列算法或行为，以供上下文重用。</li><li>子类化的替代方法</li><li>消除条件语句</li><li>多种实现方式。策略可以提供相同行为的不同实现。客户可以选择具有不同时间和空间权衡的策略</li></ul></li><li>策略模式的缺点<ul><li>客户必须意识到不同的策略。这种模式有一个潜在的缺点，即<strong>客户在选择合适的策略之前必须先了解策略的不同</strong>，不然客户可能会遇到实现问题。</li><li>策略和上下文之间的通信开销</li><li>对象数量增加</li><li>使用设计模式一般都会有的缺点：<ul><li>增加设计的复杂度和增加类的个数(增加辅助类)</li><li>增加隔阂、方法调用，降低软件运行的效率，但是这已经不是目前主要的问题了</li></ul></li></ul></li></ul><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li>概述<ul><li>动机：考虑一个简单的软件应用场景，<strong>一个软件系统可以提供多个外观不同</strong>的按钮(如圆形按钮、矩形按钮、菱形按钮等)，这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。（<del>人话</del>：当系统有多个相似用途的类，而创建并使用它们时只需要传入几个参数，不需要复杂的设置操作，就可以用工厂模式）</li></ul></li><li>模式定义<ul><li>简单工厂模式(<strong>Simple Factory Pattern</strong>)：又称为<strong>静态工厂</strong>方法(Static Factory Method)模式，它属于<strong>类创建型模式</strong></li><li>简单工厂模式专门定义一个类来负责创建其他类的实例，<strong>被创建的实例通常都具有共同的父类</strong></li><li>工厂角色提供<strong>静态工厂方法</strong>来创建其他类的实例，这样子满足了原则：<ul><li>单一职责原则(封装变化)<strong>将对象的创建和使用分离</strong>(创建本质上和使用强耦合)，将复杂度降低，并将变化的部分和不变的部分分离开。</li><li>但是对开闭原则的支持不太好</li></ul></li></ul></li><li>模式角色<ul><li>Factory：工厂角色</li><li>Product：抽象产品角色</li><li>ConcreteProduct：具体产品角色</li><li><img src="image-20250604170748432.png" alt="image-20250604170748432" style="zoom:50%;" /></li></ul></li><li>模式分析<ul><li><strong>将对象的创建和对象本身业务处理分离</strong>可以<strong>降低系统的耦合度</strong>，使得两者修改起来都相对容易</li><li>在调用工厂类的工厂方法时，由于工厂方法是<strong>静态方法</strong>，可通过类名直接调用，只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的<strong>配置文件</strong>中，修改参数时无须修改任何Java源代码</li><li>简单工厂模式最大的问题在于<strong>工厂类的职责相对过重</strong>，增加新的产品需要修改工厂类的判断逻辑，这一点<strong>与开闭原则</strong>是相违背的</li><li>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</strong></li></ul></li><li>简单工厂模式优点<ul><li>工厂类可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，这种做法<strong>实现了对责任的分割，它提供了专门的工厂类用于创建对象</strong></li><li><strong>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong></li><li><strong>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong></li></ul></li><li>简单工厂模式缺点<ul><li>由于<strong>工厂类集中了所有产品创建逻辑</strong>，一旦不能正常工作，整个系统都要受到影响</li><li><strong>增加系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度</li><li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑</strong>，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</li><li>简单工厂模式由于使用了静态工厂方法，造成<strong>工厂角色无法形成基于继承的等级结构</strong></li></ul></li><li>适用场景<ul><li><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑<strong>太过复杂</strong></li><li><strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数</li></ul></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li>概念<ul><li>在简单工厂模式中，所有的产品都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题</li></ul></li><li>模式定义<ul><li>工厂方法模式(<strong>Factory Method Pattern</strong>)又称为工厂模式，也叫<strong>虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式</strong>，它属于<strong>类创建型模式</strong></li><li>在工厂方法模式中，<strong>工厂父类</strong>负责定义创建产品对象的公共接口，而<strong>工厂子类</strong>则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即<strong>通过工厂子类来确定究竟应该实例化哪一个具体产品类</strong></li><li>工厂方法是以<strong>继承方法</strong>为主，工厂子类是<strong>继承工厂父类</strong>的</li></ul></li><li>模式结构<ul><li><img src="6.png" style="zoom: 50%;" /></li></ul></li><li>模式分析<ul><li>工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<strong>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做</strong>。这使得<strong>工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品</strong></li><li>当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体产品对象以及一个具体工厂对象，<strong>很好地符合了”开闭原则”</strong>。<strong>工厂方法模式退化(抽象工厂和具体工厂合并)后可以演变成简单工厂模式</strong>。</li><li>为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层</li></ul></li><li>模式优点<ul><li><strong>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名</strong>。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使<strong>工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部</strong>。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在<strong>系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品</strong>，而<strong>只要添加一个具体工厂和具体产品就可以了</strong>。</li></ul></li><li>模式缺点<ul><li>在添加新产品时，<strong>需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度</strong>，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，<strong>增加了系统的抽象性和理解难度</strong>，且在实现时可能需要用到DOM、反射等技术，<strong>增加了系统的实现难度</strong>。</li></ul></li><li>适用场景<ul><li><strong>一个类不知道它所需要的对象的类</strong>：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可</li><li><strong>一个类通过其子类来指定创建哪个对象</strong>：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展</li><li>将创建对象的任务委托给多个工厂子类中的某一个，<strong>客户端在使用时可以无须关心是哪一个工厂子类创建产品子类</strong>，需要时再动态指定</li></ul></li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul><li>概述<ul><li>有时候<strong>我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象</strong></li><li><strong>产品等级结构：产品等级结构即产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构</li><li><strong>产品族</strong>：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中</li><li>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<strong>多个位于不同产品等级结构中属于不同类型的具体产品时</strong>需要使用抽象工厂模式</li><li>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong></li></ul></li><li>模式定义<ul><li>抽象工厂模式(<strong>Abstract Factory Pattern</strong>)：提供一个<strong>创建一系列相关或相互依赖对象的接口</strong>，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式</li><li><img src="image-20250526202244530.png" alt="image-20250526202244530" style="zoom: 67%;" /></li></ul></li><li>模式结构<ul><li>抽象工厂模式包含如下角色：<ul><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ul></li><li><img src="image-20250526202357146.png" alt="image-20250526202357146" style="zoom: 50%;" /></li><li>产品族是牌子，产品等级结构是产品类型</li><li><img src="image-20250526202651392.png" alt="image-20250526202651392" style="zoom: 80%;" /></li></ul></li><li>模式优点<ul><li>抽象工厂模式<strong>隔离了具体类的生成</strong>，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此<strong>只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</strong>。另外，应用抽象工厂模式<strong>可以实现高内聚低耦合的设计目的</strong>，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它<strong>能够保证客户端始终只使用同一个产品族中的对象</strong>。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li><strong>增加新的具体工厂和产品族很方便，无须修改已有系统，符合”开闭原则”</strong>。<ol><li>增加新的产品族符合开闭原则</li><li>增加新的产品等级结构麻烦</li></ol></li></ul></li><li>模式缺点<ul><li>在添加新的产品对象时，<strong>难以扩展抽象工厂来生产新种类的产品</strong>，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到<strong>对抽象工厂角色及其所有子类的修改</strong>，显然会带来较大的不便。开闭原则的倾斜性(<strong>增加新的工厂和产品族容易，增加新的产品等级结构麻烦</strong>)</li></ul></li><li>开闭原则的倾斜性<ul><li>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<ol><li>增加产品族：<strong>对于增加新的产品族，工厂方法模式很好的支持了”开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改</strong>。</li><li>增加新的产品等级结构：<strong>对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持”开闭原则”</strong>。</li></ol></li><li>抽象工厂模式的这种性质称为”开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</li></ul></li><li>适用场景<ul><li>一个系统<strong>不应当依赖于产品类实例如何被创建、组合和表达的细节</strong>，这对于所有类型的工厂模式都是重要的。</li><li>系统中有<strong>多于一个的产品族</strong>，而每次只使用其中某一产品族。</li><li><strong>属于同一个产品族的产品将在一起使用</strong>，这一约束必须在系统的设计中体现出来。</li><li>系统提供一个产品类的库，<strong>所有的产品以同样的接口出现</strong>，从而<strong>使客户端不依赖于具体实现</strong>。</li></ul></li><li>退化：当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是<strong>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式</strong>；<strong>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式</strong>。</li></ul><h2 id="4-创建型模式"><a href="#4-创建型模式" class="headerlink" title="4. 创建型模式"></a>4. 创建型模式</h2><blockquote><p>前面的工厂也属于创建型模式(Creational Pattern)</p></blockquote><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul><li>概述<ul><li>对于一些复杂的对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这<br>些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等</li><li><strong>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象</strong>，用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节</li><li>由于组合部件的过程很复杂，因此部件的组合过程往往被“外部化”到一个称作<strong>建造者</strong>的对象里，<strong>建造者返还给客户端的是一个已经建造完毕的完整产品对象</strong>，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机</li></ul></li><li>模式定义<ul><li>建造者模式(<strong>Builder Pattern</strong>)：将<strong>一个复杂对象的构建与它的表示分离</strong>，使得<strong>同样的构建过程可以创建不同的表示</strong></li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</li></ul></li><li>模式结构<ul><li>建造者模式包含如下角色：<ol><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者</li><li>Director：指挥者</li><li>Product：产品角色</li></ol></li><li><img src="image-20250527153536626.png" alt="image-20250527153536626" style="zoom:67%;" /></li></ul></li><li>模式分析<ul><li>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程</li><li>在客户端代码中，<strong>无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可</strong>，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现</li></ul></li><li>模式优点<ul><li>在建造者模式中，<strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</strong>。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象</strong>。</li><li><strong>可以更加精细地控制产品的创建过程</strong>。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合”开闭原则”</strong>。</li></ul></li><li>模式缺点<ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得<strong>很庞大</strong>。</li></ul></li><li>使用场景<ul><li>需要生成的产品对象有<strong>复杂的内部结构</strong>，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的<strong>属性相互依赖，需要指定其生成顺序</strong>。</li><li>对象的创建过程独立于创建该对象的类。<strong>在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中</strong>。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul></li><li>建造者模式的简化<ol><li><strong>省略抽象建造者角色</strong>：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li><li><strong>省略指挥者角色</strong>：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色</li></ol></li><li>建造者模式与抽象工厂模式的比较<ul><li>与抽象工厂模式相比，建造者模式返回<strong>一个组装好的完整产品</strong>，而抽象工厂模式返回<strong>一系列相关的产品</strong>，一个强调组装，一个强调结果的产品</li><li>在抽象工厂模式中，<strong>客户端实例化工厂类，然后调用工厂方法获取所需产品对象</strong>，而在建造者模式中，<strong>客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象</strong>，包括对象的组装过程和建造步骤，它<strong>侧重于一步步构造一个复杂对象，返回一个完整的对象</strong>。</li></ul></li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul><li>概述<ul><li>在面向对象系统中，使用原型模式来复制一个对象自身，从而<strong>克隆出多个与原型对象一模一样的对象</strong></li><li>在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用<strong>复制这个原型对象</strong>的办法创建出更多同类型的对象，这就是原型模式的意图所在</li></ul></li><li>模式定义<ul><li>原型模式(<strong>Prototype Pattern</strong>)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。<strong>原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节</strong>。</li><li>原型模式的基本工作原理是通过<strong>将一个原型对象传给那个要发动创建的对象</strong>，这个要发动创建的对象通过<strong>请求原型对象拷贝原型自己</strong>来实现创建过程</li></ul></li><li>模式结构<ul><li>原型模式包含如下角色：<ol><li>Prototype：抽象原型类</li><li>ConcretePrototype：具体原型类</li><li>Client：客户类</li></ol></li><li><img src="image-20250527154738653.png" alt="image-20250527154738653" style="zoom: 50%;" /></li></ul></li><li>模式分析<ul><li>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单</li><li>能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制，否则调用clone()后Java编译器将抛出一个CloneNotSupportedException异常</li><li>通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆</li><li><img src="image-20250527155020974.png" alt="image-20250527155020974" style="zoom: 40%;" /></li><li>相似对象的复制：通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需<br>对象</li></ul></li><li>模式优点<ul><li>当创建新的对象实例较为复杂时，使用原型模式可以<strong>简化对象的创建过程</strong>，通过一个已有实例可以提高新实例的创建效率。</li><li>可以动态增加或减少产品类。</li><li>原型模式提供了简化的创建结构。</li><li>可以使用深克隆的方式保存对象的状态。</li></ul></li><li>模式缺点<ul><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，<strong>必须修改其源代码，违背了”开闭原则”</strong>。</li><li>在实现深克隆时需要编写较为复杂的代码</li></ul></li><li>适用场景<ul><li><strong>创建新对象成本较大</strong>，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。</li><li>如果系统<strong>要保存对象的状态</strong>，而<strong>对象的状态变化很小，或者对象本身占内存不大的时候</strong>，也可以使用<strong>原型模式配合备忘录模式</strong>来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul></li></ul><h2 id="5-状态和命令模式"><a href="#5-状态和命令模式" class="headerlink" title="5. 状态和命令模式"></a>5. 状态和命令模式</h2><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul><li>概述<ul><li>在很多情况下，<strong>一个对象的行为取决于一个或多个动态变化的属性</strong>，这样的属性叫做<strong>状态</strong>，这样的对象叫做<strong>有状态的(stateful)对象</strong>，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化</li><li>在UML中可以使用<strong>状态图</strong>来描述对象状态的变化</li></ul></li><li>模式定义<ul><li>状态模式(<strong>State Pattern</strong>)：<strong>允许一个对象在其内部状态改变时改变它的行为</strong>，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种<strong>对象行为型</strong>模式。</li><li>设计主要是面对变化，因此我们在分析开始的时候就应该分析变化：<strong>增加新的状态，面向新的状态的部分的行为</strong>。</li><li>封装变化：<strong>封闭 + 委托</strong>(组合关系)</li></ul></li><li>模式结构<ul><li>状态模式包含如下角色：<ol><li>Context: 环境类</li><li>State: 抽象状态类</li><li>ConcreteState: 具体状态类</li></ol></li><li><img src="image-20250527161856099.png" alt="image-20250527161856099" style="zoom:50%;" /></li><li>在结构上<strong>策略模式</strong>和状态模式是一致的，但是在使用上是很不同的</li></ul></li><li>模式分析<ul><li>状态模式描述了<strong>对象状态的变化</strong>以及<strong>对象如何在每一种状态下表现出不同的行为</strong></li><li>状态模式的关键是<strong>引入了一个抽象类来专门表示对象的状态</strong>，这个类我们叫做<strong>抽象状态类</strong>，而对象的每一种具体状态类都继承了该类，并在<strong>不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换</strong>（状态对象持有对上下文(Context)的引用，可以调用setState方法）</li><li>在状态模式结构中需要理解<strong>环境类与抽象状态类</strong>的作用：<ol><li>环境类实际上就是<strong>拥有状态的对象</strong>，环境类有时候可以充当<strong>状态管理器(State Manager)<strong>的角色，可以</strong>在环境类中对状态进行切换操作</strong>。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，<strong>状态类的产生是由于环境类存在多个状态</strong>，同时还满足两个条件：<strong>这些状态经常需要切换，在不同的状态下对象的行为不同</strong>。因此可以<strong>将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类</strong>，而实际上是<strong>由于切换到不同的具体状态类实现的</strong>。</li><li>环境类一般包含所有的行为方法（当然执行时要确保可以执行），而具体的状态类只能有当前状态可以拥有的行为方法</li></ol></li></ul></li><li>模式优点<ul><li><strong>封装了转换规则</strong>。</li><li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以<strong>方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。</li><li>允许<strong>状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li><li>可以<strong>让多个环境对象共享一个状态对象</strong>，从而减少系统中对象的个数。</li></ul></li><li>模式缺点<ul><li>状态模式的使用必然会<strong>增加系统类和对象的个数</strong>。</li><li>状态模式的结构与实现都较为复杂，<strong>如果使用不当将导致程序结构和代码的混乱</strong>。</li><li>状态模式<strong>对“开闭原则”的支持并不太好</strong>，对于可以切换状态的状态模式，<strong>增加新的状态类需要修改那些负责状态转换的源代码</strong>，否则无法切换到新增状态；而且<strong>修改某个状态类的行为也需修改对应类的源代码</strong>。</li></ul></li><li>适用场景<ul><li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与<strong>对象状态有关的条件语句</strong></li></ul></li><li>模式扩展<ul><li>在有些情况下<strong>多个环境对象需要共享同一个状态</strong>，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的<strong>静态成员对象</strong>。例如多个玩家对象可以共享“健康”、“濒死”等状态对象，因为不同的玩家在这些状态下的行为是一样的，没必要创建多个状态对象</li><li><strong>简单状态模式</strong>：简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，它遵循“开闭原则”</li><li><strong>可切换状态的状态模式</strong>：大多数的状态模式都是可以切换状态的状态模式，在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。<strong>可以通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换</strong></li></ul></li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li>概述<ul><li>在软件设计中，我们经常<strong>需要向某些对象发送请求</strong>，但是并<strong>不知道请求的接收者是谁</strong>，<strong>也不知道被请求的操作是哪个</strong>，我们<strong>只需在程序运行时指定具体的请求接收者即可</strong>，此时，可以使用命令模式来进行设计，使得<strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活。</li><li>命令模式可以对<strong>发送者和接收者完全解耦</strong>，发送者与接收者之间<strong>没有直接引用关系</strong>，<strong>发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。</li><li><img src="6-1748336184333.png" style="zoom:50%;" /></li></ul></li><li>模式定义<ul><li>命令模式(Command Pattern)：<strong>将一个请求封装为一个对象</strong>，从而使我们可用<strong>不同的请求对客户进行参数化</strong>；<strong>对请求排队或者记录请求日志，以及支持可撤销的操作</strong>。命令模式是一种<strong>对象行为型模式</strong>，其别名为动作(Action)模式或事务(Transaction)模式。</li></ul></li><li>模式结构<ul><li>命令模式包含如下角色：<ol><li>Command: 抽象命令类</li><li>ConcreteCommand: 具体命令类</li><li>Invoker: 调用者，相当于电灯开关</li><li>Receiver: 接收者，相当于电灯控制模块</li><li>Client:客户类</li></ol></li><li><img src="image-20250527165737670.png" alt="image-20250527165737670" style="zoom:50%;" /></li><li><img src="8-1748423358403.png" style="zoom: 60%;" /></li></ul></li><li>例子：电视机遥控器<ul><li><img src="9.png"></li><li>遥控器是invoker，电视机是receiver</li></ul></li><li>模式优点<ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令(组合命令)。</li><li><strong>可以方便地实现对请求的Undo和Redo</strong>。</li></ul></li><li>模式缺点<ul><li>使用命令模式可能会<strong>导致某些系统有过多的具体命令类</strong>。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用</li></ul></li><li>适用场景<ul><li>系统<strong>需要将请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互。</li><li>系统<strong>需要在不同的时间指定请求、将请求排队和执行请求</strong>。</li><li>系统<strong>需要支持命令的撤销(Undo)操作和恢复(Redo)操作</strong>。</li><li>系统<strong>需要将一组操作组合在一起</strong>，即支持宏命令。</li></ul></li><li>模式扩展<ul><li>撤销：让Invoker维护一个命令的历史记录（通常是一个栈），用于管理命令的执行和撤销。使用栈数据结构可以轻松地实现撤销功能，因为栈支持后进先出，只需要出栈然后调用其undo方法就可以实现撤销</li><li>宏命令：<ul><li>宏命令又称为<strong>组合命令</strong>，它是<strong>命令模式和组合模式</strong>联用的产物。</li><li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，<strong>在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法</strong></li><li><img src="image-20250527171410015.png" alt="image-20250527171410015"></li></ul></li></ul></li></ul><h2 id="6-观察者与行为型模式"><a href="#6-观察者与行为型模式" class="headerlink" title="6. 观察者与行为型模式"></a>6. 观察者与行为型模式</h2><blockquote><p>前面的状态模式和命令模式也是行为型模式</p></blockquote><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul><li>概述<ul><li>建立一种<strong>对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应</strong>。<ol><li>发生改变的对象称为<strong>观察目标</strong></li><li>被通知的对象称为<strong>观察者</strong></li></ol></li><li><img src="image-20250527172855145.png" alt="image-20250527172855145" style="zoom:50%;" /></li><li><strong>一个观察目标可以对应多个观察者</strong>，而且这些观察者之间没有相互联系，<strong>可以根据需要增加和删除观察者，使得系统更易于扩展</strong>，这就是观察者模式的模式动机。</li></ul></li><li>模式定义<ul><li>观察者模式(<strong>Observer Pattern</strong>)：定义对象间的一种<strong>一对多依赖关系</strong>，使得<strong>每当一个对象状态发生改变</strong>时，其<strong>相关依赖对象皆得到通知并被自动更新</strong>。</li><li>观察者模式又叫做<strong>发布-订阅</strong>（Publish&#x2F;Subscribe）模式、<strong>模型-视图</strong>（Model&#x2F;View）模式、<strong>源-监听器</strong>（Source&#x2F;Listener）模式或<strong>从属者</strong>（Dependents）模式。观察者模式是一种<strong>对象行为型</strong>模式。</li></ul></li><li>模式结构<ul><li>观察者模式包含如下角色：<ol><li>Subject: 目标</li><li>ConcreteSubject: 具体目标</li><li>Observer: 观察者</li><li>ConcreteObserver: 具体观察者</li></ol></li><li><img src="image-20250527173140823.png" alt="image-20250527173140823" style="zoom: 80%;" /></li><li><code>attach(Observer obs)</code>: 将观察者添加到观察者列表中。使该观察者可以接收通知。</li><li><code>detach(Observer obs)</code>: 将观察者从观察者列表中移除。停止该观察者接收通知。</li><li><code>notify()</code>: 通知所有注册的观察者调用它们的<code>update()</code>方法。通常会在主题的状态改变时被调用。</li><li><img src="3-1748423350315.png" style="zoom:50%;" /></li></ul></li><li>模式分析<ul><li>观察者模式描述了<strong>如何建立对象与对象之间的依赖关系</strong>，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，<strong>一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知</strong>。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅 (publish-subscribe)</strong>。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</li></ul></li><li>模式优点<ul><li>观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式<strong>在观察目标和观察者之间建立一个抽象的耦合</strong>。</li><li>观察者模式<strong>支持广播通信</strong>。</li><li>观察者模式<strong>符合开闭原则</strong>的要求</li></ul></li><li>模式缺点<ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，<strong>将所有的观察者都通知到会花费很多时间</strong>。</li><li>如果在观察者和观察目标之间有<strong>循环依赖的话</strong>，观察目标会触发它们之间进行循环调用，<strong>可能导致系统崩溃</strong>。</li><li>观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</li></ul></li><li>适用场景<ul><li>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>。将这些方面<strong>封装在独立的对象中使它们可以各自独立地改变和复用</strong>。</li><li><strong>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</strong>，可以降低对象之间的耦合度。</li><li><strong>一个对象必须通知其他对象，而并不知道这些对象是谁</strong>。</li><li><strong>需要在系统中创建一个触发链</strong>，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种<strong>链式触发机制</strong>。</li></ul></li><li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持</li></ul><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ul><li>概述<ul><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们<strong>应该尽量将对象细化，使其只负责或呈现单一的职责</strong>。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，<strong>为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式</strong>，这就是中介者模式的模式动机。</li></ul></li><li>模式定义<ul><li>中介者模式(<strong>Mediator Pattern</strong>)定义：用一个中介对象来<strong>封装一系列的对象交互</strong>，中介者使各对象不需要显式地相互引用，从而<strong>使其耦合松散</strong>，而且<strong>可以独立地改变它们之间的交互</strong>。中介者模式又称为<strong>调停者模式</strong>（只是中文翻译不同），它是一种<strong>对象行为型模式</strong>。</li></ul></li><li>模式结构<ul><li>中介者模式包含如下角色：<ol><li>Mediator: 抽象中介者</li><li>ConcreteMediator: 具体中介者</li><li>Colleague: 抽象同事类</li><li>ConcreteColleague: 具体同事类</li></ol></li><li><img src="9-1748346264390.png"></li></ul></li><li>模式分析<ul><li>中介者模式可以使对象之间的关系数量急剧减少</li><li><img src="image-20250527194516129.png" alt="image-20250527194516129" style="zoom:50%;" /></li><li>中介者承担两方面的职责：<ol><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者<strong>在结构上的支持</strong>。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者<strong>在行为上的支持</strong>。</li></ol></li><li>仅当对象之间交互复杂、流程可变、需要集中协调时，选用中介者模式；如只是多个对象分别调用同一个对象的不同接口，无复杂关联，不用中介者，直接引用最合适</li></ul></li><li>模式优点<ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul></li><li>模式缺点<ul><li>在具体中介者类中包含了同事之间的交互细节，可能会导致<strong>具体中介者类非常复杂</strong>，使得<strong>系统难以维护</strong>。</li></ul></li><li>适用场景<ul><li>系统中<strong>对象之间存在复杂的引用关系</strong>，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致<strong>难以复用该对象</strong>。</li><li><strong>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类</strong>。</li></ul></li><li>模式扩展<ul><li>与迪米特法则关系：在中介者模式中，通过创造出一个中介者对象，<strong>将系统中有关的对象所引用的其他对象数目减少到最少</strong>，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，<strong>中介者模式就是迪米特法则的一个典型应用</strong>。</li><li>中介者模式可以方便地应用于<strong>图形界面(GUI)开发</strong>中，在比较复杂的界面中可能存在<strong>多个界面组件之间的交互关系</strong>。</li></ul></li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul><li><p>概述</p><ul><li>模板方法模式是<strong>基于继承</strong>的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以<strong>将相同的代码放在父类中，而将不同的方法实现放在不同的子类中</strong>。</li><li>在模板方法模式中，我们需要准备一个抽象类，<strong>将部分逻辑以具体方法以及具体构造函数的形式实现</strong>，<strong>然后声明一些抽象方法来让子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现</strong></li></ul></li><li><p>模式定义</p><ul><li>模板方法模式(<strong>Template Method Pattern</strong>)：定义一个操作中<strong>算法的骨架</strong>，而将一些步骤<strong>延迟到子类</strong>中，模板方法使得子类<strong>可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。模板方法是一种<strong>类行为型</strong>模式。</li></ul></li><li><p>模式结构</p><ul><li>模板方法模式包含如下角色：<ol><li>AbstractClass: 抽象类</li><li>ConcreteClass: 具体子类</li></ol></li><li><img src="13.png" style="zoom: 50%;" /></li></ul></li><li><p>模式分析</p><ul><li><p>模板方法模式是一种类的行为型模式，在它的结构图中<strong>只有类之间的继承关系，没有对象关联关系</strong>。</p></li><li><p>在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出<strong>一个算法的轮廓和骨架</strong>，另一些设计师则<strong>负责给出这个算法的各个逻辑步骤</strong>。实现这些具体逻辑步骤的方法称为<strong>基本方法(Primitive Method)</strong>，而将这些基本法方法汇总起来的方法称为<strong>模板方法(Template Method)</strong>，模板方法模式的名字从此而来。</p></li><li><p>模板方法：一个模板方法是<strong>定义在抽象类中的、把基本操作方法组合在一起</strong>形成一个总算法或一个总行为的方法。</p></li><li><p>基本方法：基本方法是<strong>实现算法各个步骤的方法</strong>，是模板方法的组成部分。</p></li><li><p>该模式下的方法有三种：</p><ul><li><p><strong>抽象方法 (Abstract Method)</strong></p><ul><li><strong>定义</strong>：抽象方法是指在抽象类中声明的方法，这些方法没有实现，必须在具体子类中实现。它定义了算法的基本步骤，需要由子类提供具体实现。</li><li><strong>作用</strong>：它提供了一种让子类实现特定任务的机制，使得整体算法架构在抽象类中可见，而具体步骤细节由子类决定。</li></ul></li><li><p><strong>具体方法 (Concrete Method)</strong></p><ul><li><strong>定义</strong>：具体方法由抽象类或其子类提供完整实现，是模板方法的一部分，包含特定步骤的具体操作。</li><li><strong>作用</strong>：具体方法在抽象类中实现或在子类中实现，它用于给出算法中某些步骤的具体操作，通常那些不会变化或不需要由子类提供变更的部分。</li></ul></li><li><p><strong>钩子方法 (Hook Method)</strong></p><ul><li><strong>定义</strong>：钩子方法是指在抽象类中具有默认实现或空实现的方法，子类可以选择性地重写以改变或扩展算法的步骤。它是一种可选的扩展点。</li><li>“挂钩”方法和空方法：<ul><li><strong>“挂钩”方法</strong>：通常是有默认实现的钩子方法，提供基础的但是可定制的行为。子类可以重写这些方法以改变行为。</li><li><strong>空方法</strong>：最简单的钩子方法就是<strong>空方法</strong>，通常是没有实现的钩子方法，即方法体为空。子类可以选择性地提供实现以扩展或变更行为。</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> &#123;<br>    <span class="hljs-comment">// 具体方法</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        start();<br>        <span class="hljs-keyword">if</span> (needInstructions()) &#123;  <span class="hljs-comment">// 这是钩子方法</span><br>            showInstructions();<br>        &#125;<br>        end();<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法：需要子类实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showInstructions</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 钩子方法：具有默认实现，子类可以选择重写</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needInstructions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 默认是需要展示说明，但子类可重写以改变行为</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoccerGame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Game</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Starting the soccer game.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">showInstructions</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Showing soccer game instructions.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Ending the soccer game.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needInstructions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 不需要说明</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，<strong>具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法</strong>，从而可以<strong>通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制</strong>。</li></ul><ul><li><p>模式优点</p><ul><li>模板方法模式<strong>在一个类中抽象地定义算法</strong>，而<strong>由它的子类实现细节的处理</strong>。</li><li>模板方法模式是一种<strong>代码复用的基本技术</strong>。</li><li>模板方法模式导致一种<strong>反向的控制结构</strong>，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，<strong>符合“开闭原则”</strong>。</li></ul></li><li><p>模式缺点</p><ul><li>每个不同的实现都需要定义一个子类，这会<strong>导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。</li></ul></li><li><p>适用场景</p><ul><li>一次性实现一个算法的不变的部分，并<strong>将可变的行为留给子类来实现</strong>。</li><li><strong>各子类中公共的行为应被提取出来并集中到一个公共父类</strong>中以避免代码重复。</li><li><strong>对一些复杂的算法进行分割</strong>，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。</li><li>控制<strong>子类的扩展</strong>。</li></ul></li><li><p>模式扩展</p><ul><li>模板方法模式鼓励我们<strong>恰当使用继承</strong>，此模式可以用来改写一些拥有相同功能的相关类，<strong>将可复用的一般性的行为代码移到父类里面</strong></li><li>在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，<strong>父类控制对子类的调用</strong>，这种机制被称为<strong>好莱坞原则</strong></li></ul></li></ul><h2 id="7-适配器与组合"><a href="#7-适配器与组合" class="headerlink" title="7. 适配器与组合"></a>7. 适配器与组合</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul><li><p>概述</p><ul><li>通常情况下，<strong>客户端可以通过目标类的接口访问它所提供的服务</strong>。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li><li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是<strong>适配器(Adapter)</strong>，它所包装的对象就是<strong>适配者(Adaptee)</strong>，即被适配的类。</li><li>适配器提供客户类需要的接口，<strong>适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用</strong>。也就是说：<strong>当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类</strong>。因此，<strong>适配器可以使由于接口不兼容而不能交互的类可以一起工作</strong>。这就是适配器模式的模式动机</li></ul></li><li><p>模式定义</p><ul><li>适配器模式(Adapter Pattern) ：<strong>将一个接口转换成客户希望的另一个接口</strong>，适配器模式使<strong>接口不兼容的那些类可以一起工作</strong>，其别名为包装器(Wrapper)。</li><li>适配器模式既可以作为<strong>类结构型模式</strong>，也可以作为<strong>对象结构型模式</strong>。</li></ul></li><li><p>模式结构</p><ul><li><p>适配器模式包含如下角色：</p><ol><li>Target：目标抽象类</li><li>Adapter：适配器类</li><li>Adaptee：适配者类</li><li>Client：客户类</li></ol></li><li><p><strong>对象适配器</strong>：适配器和适配者通过对象组合来关联，适配器包含适配者来实现接口转换。它的实现更加灵活，因为它允许在运行时动态的适配不同的适配者。</p></li><li><img src="image-20250528144110116.png" alt="image-20250528144110116" style="zoom: 50%;" /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">private</span> Adaptee adaptee;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>    <span class="hljs-built_in">this</span>.adaptee=adaptee;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    adaptee.specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>类适配器</strong>：通过多重继承来实现适配。适配器在编译时定义接口关系，更适合应用于支持多重继承的语言。在适配步骤上可能更直接，但是继承关系较为固定。</p></li><li><img src="image-20250528144204267.png" alt="image-20250528144204267" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>模式优点</p><ul><li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li><strong>增加了类的透明性和复用性</strong>，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合”开闭原则”。</li><li>类适配器额外的优点：由于适配器类是适配者类的子类，因此<strong>可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</strong>。</li><li>对象适配器额外的优点：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，<strong>同一个适配器可以把适配者类和它的子类都适配到目标接口</strong>。</li></ul></li><li><p>模式缺点</p><ul><li>类适配器缺点：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类(Target)只能为抽象类，不能为具体类，<strong>其使用有一定的局限性</strong>，不能将一个适配者类和它的子类都适配到目标接口。</li><li>对象适配器缺点：与类适配器模式相比，要想<strong>置换适配者类的方法就不容易</strong>。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li></ul></li><li><p>适用情景</p><ul><li>系统<strong>需要使用现有的类</strong>，而这些类的接口不符合系统的需要。</li><li><strong>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类</strong>，包括一些可能在将来引进的类<strong>一起工作</strong>。</li></ul></li><li><p>模式扩展</p><ul><li><p>默认适配器模式</p><ul><li>当不需要全部实现接口提供的方法时，可先设计一个<strong>抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现</strong>（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它<strong>适用于一个接口不想使用其所有的方法的情况</strong>。因此也称为<strong>单接口适配器模式</strong></li><li><img src="image-20250528151251247.png" alt="image-20250528151251247" style="zoom:40%;" /></li></ul></li><li><p>双向适配器</p><ul><li><p>在对象适配器的使用过程中，如果<strong>在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法</strong>，那么该适配器就是一个<strong>双向适配器</strong>。</p></li><li><img src="8-1748423335109.png" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul><li><p>概述</p><ul><li><img src="image-20250528152037197.png" alt="image-20250528152037197" style="zoom: 80%;" /></li><li>对于<strong>树形结构</strong>，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。<strong>（递归调用）</strong></li><li>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须<strong>有区别地对待容器对象和叶子对象</strong>，而实际上<strong>大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂</strong>。</li><li>组合模式描述了<strong>如何将容器对象和叶子对象进行递归组合</strong>，使得<strong>用户在使用时无须对它们进行区分</strong>，可以<strong>一致地对待容器对象和叶子对象</strong>，这就是组合模式的模式动机。</li></ul></li><li><p>模式定义</p><ul><li>组合模式(Composite Pattern)：组合多个对象形成<strong>树形结构</strong>以<strong>表示”整体-部分”的结构层次</strong>。组合模式对<strong>单个对象（即叶子对象）<strong>和</strong>组合对象（即容器对象）<strong>的</strong>使用具有一致性</strong>。</li><li>组合模式又可以称为<strong>整体-部分(Part-Whole)模式</strong>，属于对象结构模式，它<strong>将对象组织到树结构中，可以用来描述整体与部分的关系</strong>。</li></ul></li><li><p>模式结构</p><ul><li>组合模式包含如下角色：<ol><li>Component: 抽象构件</li><li>Leaf: 叶子构件</li><li>Composite: 容器构件</li><li>Client: 客户类</li></ol></li><li><img src="image-20250528152221884.png" alt="image-20250528152221884" style="zoom:50%;" /></li></ul></li><li><p>模式分析</p><ul><li><p>组合模式的关键是<strong>定义了一个抽象构件类</strong>，它既可以代表叶子，又可以代表容器，而<strong>客户端针对该抽象构件类进行编程</strong>，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p></li><li><p>同时<strong>容器对象与抽象构件类之间还建立一个聚合关联关系</strong>，在容器对象中既可以包含叶子，也可以包含容器，以此<strong>实现递归组合，形成一个树形结构</strong>。</p></li><li><img src="11.png" style="zoom:50%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>  &#123;<br>  <span class="hljs-comment">//实现代码</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span><br>  &#123;<br>    list.add(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span><br>  &#123;<br>    list.remove(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>  &#123;<br>    (Component)list.get(i);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>  &#123;<br>    <span class="hljs-keyword">for</span>(Object obj:list)<br>    &#123;<br>      ((Component)obj).operation();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模式优点<ul><li>可以清楚地定义<strong>分层次的复杂对象</strong>，表示对象的全部或部分层次，使得增加新构件也更容易。</li><li>客户端调用简单，<strong>客户端可以一致的使用组合结构或其中单个对象</strong>。</li><li>定义了包含叶子对象和容器对象的<strong>类层次结构</strong>，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，<strong>可以形成复杂的树形结构</strong>。</li><li><strong>更容易在组合体内加入对象构件</strong>，客户端不必因为加入了新的对象构件而更改原有代码。</li></ul></li><li>模式缺点<ul><li><strong>使设计变得更加抽象</strong>，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</li><li>增加新构件时可能会产生一些问题，<strong>很难对容器中的构件类型进行限制</strong>。</li></ul></li><li>适用场景<ul><li>需要表示一个<strong>对象整体或部分层次</strong>，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li><li>让客户能够忽略不同对象层次的变化，<strong>客户端可以针对抽象构件编程，无须关心对象层次结构的细节</strong>。</li><li><strong>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们</strong>。</li></ul></li></ul><h2 id="8-桥接与装饰者"><a href="#8-桥接与装饰者" class="headerlink" title="8. 桥接与装饰者"></a>8. 桥接与装饰者</h2><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><blockquote><p>个人理解：桥接模式就是把拥有两个维度的物体（如有颜色的形状）其中一个维度单独拉出来变成一个抽象层，例如颜色，然后用组合关系实现动态的变化和扩展</p></blockquote><ul><li><p>概述</p><ul><li>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：<ol><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li><li><img src="image-20250528154351400.png" alt="image-20250528154351400" style="zoom:50%;" /></li></ol></li><li>对于有<strong>两个变化维度（即两个变化的原因）<strong>的系统，采用</strong>方案二</strong>来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式<strong>将继承关系转换为关联关系</strong>，从而<strong>降低了类与类之间的耦合</strong>，减少了<strong>代码编写量</strong>。</li><li><img src="2.png" style="zoom:50%;" /></li></ul></li><li><p>模式定义</p><ul><li>桥接模式(Bridge Pattern)：<strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化</strong>。它是一种<strong>对象结构型模式</strong>，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li></ul></li><li><p>模式结构</p><ul><li>桥接模式包含如下角色：<ol><li><strong>Abstraction（抽象类）</strong>：<ul><li>定义抽象类的接口，包含对 <code>Implementor</code> 接口的引用。这通常是应用程序中客户端需要使用的接口。</li><li>不一定是抽象类，可以是具体类，关键是定义操作的接口。</li></ul></li><li><strong>RefinedAbstraction（扩充抽象类）</strong>：<ul><li><code>Abstraction</code> 的具体实现，扩展抽象类，实现其中定义的方法。它通过接口操作实现部分。</li><li>处理并调用 <code>Implementor</code> 的方法，细化接口以匹配具体需求。</li></ul></li><li><strong>Implementor（实现类接口）</strong>：<ul><li>定义实现类的接口，它是实现细节部分的接口，与 <code>Abstraction</code> 组件无直接关系。</li><li>提供实现类需要的特定功能。</li></ul></li><li><strong>ConcreteImplementor（具体实现类）</strong>：<ul><li><code>Implementor</code> 接口的具体实现，提供具体的功能实现。</li><li>这些类对 <code>RefinedAbstraction</code> 的请求作出响应。</li></ul></li></ol></li><li><img src="3.png" style="zoom:50%;" /></li><li>例子：现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5&#x3D;15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5&#x3D;8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。</li><li><img src="4.png" style="zoom: 50%;" /></li></ul></li><li><p>模式分析</p><ul><li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，<strong>将对象的共同性质抽取出来形成类的过程即为抽象化的过程</strong>。</li><li><strong>实现化</strong>：<strong>针对抽象化给出的具体实现，就是实现化</strong>，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li><strong>脱耦</strong>：脱耦就是<strong>将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系</strong>。</li></ul></li><li><p>模式优点</p><ul><li><strong>分离抽象接口及其实现部分。</strong></li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，<strong>桥接模式是比多继承方案更好的解决方法</strong>。</li><li>桥接模式<strong>提高了系统的可扩充性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li><strong>实现细节对客户透明，可以对用户隐藏实现细节。</strong></li></ul></li><li><p>模式缺点</p><ul><li>桥接模式的引入会<strong>增加系统的理解与设计难度</strong>，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此<strong>其使用范围具有一定的局限性</strong>。</li></ul></li><li><p>适用场景</p><ul><li>如果一个系统<strong>需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系</strong>，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li><strong>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响</strong>，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类<strong>存在两个独立变化的维度</strong>，且这两个维度都需要进行扩展。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li><li>对于那些<strong>不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统</strong>，桥接模式尤为适用。</li></ul></li><li><p>模式扩展</p><ul><li>适配器模式与桥接模式：桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li><li><img src="7.png" style="zoom:50%;" /></li></ul></li></ul><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><blockquote><p>个人理解：用另一个继承或实现了抽象类&#x2F;接口的类对原来的对象进行装饰，从而实现给它增加属性或行为</p></blockquote><ul><li><p>概述</p><ul><li>一般有两种方式可以实现给一个类或对象增加行为：<strong>继承机制</strong>和<strong>关联机制</strong>（即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为来扩展自己）</li><li>与继承关系相比，关联关系的主要优势在于<strong>不会破坏类的封装性</strong>，而且<strong>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。</li><li>由于关联关系使系统具有较好的松耦合性，因此使得<strong>系统更加容易维护</strong>。当然，关联关系的缺点是<strong>比继承关系要创建更多的对象</strong></li><li>装饰模式以<strong>对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在<strong>不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</li><li><img src="image-20250528160913422.png" alt="image-20250528160913422" style="zoom:50%;" /></li></ul></li><li><p>模式定义</p><ul><li>装饰模式(Decorator Pattern) ：<strong>动态地给一个对象增加一些额外的职责</strong>(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为<strong>包装器</strong>(Wrapper)，<strong>与适配器模式的别名相同，但它们适用于不同的场合</strong>。根据翻译的不同，装饰模式也有人称之为”油漆工模式”，它是一种<strong>对象结构型模式</strong>。</li></ul></li><li><p>模式结构</p><ul><li><p>装饰模式包含如下角色：</p><ol><li>Component: 抽象构件</li><li>ConcreteComponent: 具体构件</li><li>Decorator: 抽象装饰类</li><li>ConcreteDecorator: 具体装饰类</li></ol></li><li><img src="image-20250528161025917.png" alt="image-20250528161025917" style="zoom:50%;" /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span><br>&#123;<br>  <span class="hljs-keyword">private</span> Component component;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component component)</span><br>  &#123;<br>    <span class="hljs-built_in">this</span>.component=component;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>   &#123;<br>   component.operation();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Component component)</span><br>  &#123;<br>    <span class="hljs-built_in">super</span>(component);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>  &#123;<br>    <span class="hljs-built_in">super</span>.operation(); <span class="hljs-comment">// 原来的行为</span><br>    addedBehavior(); <span class="hljs-comment">// 装饰器给它增加的行为</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span><br>  &#123;<br>    <span class="hljs-comment">//新增方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs haxe">  <br>- 例子：假设我们要实现一个简单的文本处理系统，其中文本可以被多种方式格式化（比如加上装饰、颜色、尺寸等）。<br>  <br><br>​````java<br><span class="hljs-comment">// Component: 定义接口</span><br><span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">Text</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> getContent();<br>&#125;<br><br><span class="hljs-comment">// ConcreteComponent: 实现基本功能的文本类</span><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainText</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Text</span></span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> content;<br>    <br>    <span class="hljs-keyword">public</span> PlainText(<span class="hljs-keyword">String</span> content) &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getContent() &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Decorator: 定义一个抽象装饰者，持有一个组件</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">TextDecorator</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Text</span></span> </span>&#123;<br>    protected Text text;<br>    <br>    <span class="hljs-keyword">public</span> TextDecorator(Text text) &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ConcreteDecorator: 具体的修饰者，实现装饰功能</span><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">BoldDecorator</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">TextDecorator</span></span> </span>&#123;<br>    <span class="hljs-keyword">public</span> BoldDecorator(Text text) &#123;<br>        <span class="hljs-keyword">super</span>(text);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getContent() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;b&gt;&quot;</span> + text.getContent() + <span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ItalicDecorator</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">TextDecorator</span></span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ItalicDecorator(Text text) &#123;<br>        <span class="hljs-keyword">super</span>(text);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getContent() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + text.getContent() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户代码：使用装饰模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">// 创建一个基本文本对象</span><br>        Text simpleText = <span class="hljs-keyword">new</span><span class="hljs-type"></span> PlainText(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用装饰者动态添加功能</span><br>        Text boldText = <span class="hljs-keyword">new</span><span class="hljs-type"></span> BoldDecorator(simpleText);<br>        Text italicBoldText = <span class="hljs-keyword">new</span><span class="hljs-type"></span> ItalicDecorator(boldText);<br>        <br>        <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;Plain Text: &quot;</span> + simpleText.getContent());<br>        System.out.println(<span class="hljs-string">&quot;Bold Text: &quot;</span> + boldText.getContent());<br>        System.out.println(<span class="hljs-string">&quot;Italic and Bold Text: &quot;</span> + italicBoldText.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>模式优点</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是<strong>装饰模式可以提供比继承更多的灵活性</strong>。</li><li>可以<strong>通过一种动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li><strong>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合</strong>。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li><strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合”开闭原则”。</li></ul></li><li><p>模式缺点</p><ul><li>使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐</strong>。</li></ul></li><li><p>适用场景</p><ul><li>在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong>。</li><li>需要<strong>动态地给一个对象增加功能</strong>，这些功能也可以<strong>动态地被撤销</strong>。</li><li><strong>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</strong>。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul></li><li><p>模式扩展</p><ul><li><strong>一个装饰类的接口必须与被装饰类的接口保持相同</strong>，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个”轻”类，也就是说<strong>不要把太多的逻辑和状态放在具体构件类中</strong>，可以通过装饰类对其进行扩展。</li><li><strong>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类</strong>。（就不用继承抽象Component或者实现接口了）</li></ul></li></ul><h2 id="9-结构型模式"><a href="#9-结构型模式" class="headerlink" title="9. 结构型模式"></a>9. 结构型模式</h2><blockquote><p>前面的适配器、组合、桥接、装饰都是结构型模式</p></blockquote><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><ul><li><p>模式定义</p><ul><li>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个<strong>统一的外观对象</strong>进行，为子系统中的一组接口<strong>提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口<strong>使得这一子系统更加容易使用</strong>。外观模式又称为<strong>门面模式</strong>，它是一种<strong>对象结构型模式</strong>。</li><li>引入外观角色之后，<strong>用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现</strong>，从而降低了系统的耦合度。</li><li><img src="image-20250528163853341-1748421559700.png" alt="image-20250528163853341" style="zoom:50%;" /></li></ul></li><li><p>模式结构</p><ul><li><p>外观模式包含如下角色：</p><ol><li>Facade: 外观角色</li><li>SubSystem:子系统角色</li></ol></li><li><img src="2-1748423305989.png" style="zoom: 40%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    obj1.method1();<br>    obj2.method2();<br>    obj3.method3();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>模式分析</p><ul><li>根据“单一职责原则”，<strong>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性</strong>，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是<strong>引入一个外观对象</strong>，它<strong>为子系统的访问提供了一个简单而单一的入口</strong>。</li><li>外观模式也是“迪米特法则”的体现，<strong>通过引入一个新的外观类可以降低原有系统的复杂度</strong>，同时<strong>降低客户类与子系统类的耦合度</strong>。</li><li>外观模式要求一个子系统的外部与其内部的通信<strong>通过一个统一的外观对象进行</strong>，外观类将客户端与子系统的内部复杂性分隔开，使得<strong>客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</strong>。</li><li>外观模式的目的在于<strong>降低系统的复杂程度</strong>。</li><li>外观模式从很大程度上<strong>提高了客户端使用的便捷性</strong>，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li><li>例子：电源总开关<ul><li><img src="3-1748421781646.png" style="zoom:50%;" /></li></ul></li></ul></li><li><p>模式优点</p><ul><li><strong>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易</strong>。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li><strong>实现了子系统与客户之间的松耦合关系</strong>，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li><strong>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li><strong>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</strong>。</li></ul></li><li><p>模式缺点</p><ul><li><strong>不能很好地限制客户使用子系统类</strong>，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入<strong>抽象外观类</strong>的情况下，<strong>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</strong>。</li></ul></li><li><p>适用场景</p><ul><li><strong>当要为一个复杂子系统提供一个简单接口时可以使用外观模式</strong>。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li><strong>客户程序与多个子系统之间存在很大的依赖性</strong>。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以<strong>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</strong>。</li></ul></li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul><li><p>概述</p><ul><li>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。<strong>当对象数量太多时，将导致运行代价过高，带来性能下降等问题</strong>。</li><li><strong>享元模式</strong>正是为解决这一类问题而诞生的。<strong>享元模式通过共享技术实现相同或相似对象的重用</strong>。</li><li>在享元模式中<strong>可以共享的相同内容称为内部状态</strong>(Intrinsic State)，而那些<strong>需要外部环境来设置的不能共享的内容称为外部状态</strong>(Extrinsic State)，相同的内部状态是可以共享的</li><li>在享元模式中通常会出现工厂模式，需要<strong>创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象</strong>。</li><li>在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此<strong>享元对象一般都设计为较小的对象</strong>，它所包含的内部状态较少，这种对象也称为细粒度对象。<strong>享元模式的目的就是使用共享技术来实现大量细粒度对象的复用</strong>。</li></ul></li><li><p>模式定义</p><ul><li>享元模式(<strong>Flyweight Pattern</strong>)：运用<strong>共享技术</strong>有效地支持大量<strong>细粒度对象</strong>的复用。系统只使用少量的对象，<strong>而这些对象都很相似，状态变化很小</strong>，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为<strong>轻量级模式</strong>，它是一种<strong>对象结构型模式</strong>。</li></ul></li><li><p>模式结构</p><ul><li><p>享元模式包含如下角色：</p><ol><li>Flyweight: 抽象享元类</li><li>ConcreteFlyweight: 具体享元类</li><li>UnsharedConcreteFlyweight: 非共享具体享元类</li><li>FlyweightFactory: 享元工厂类</li></ol></li><li><img src="8.png" style="zoom:50%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">flyweights</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>  <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span><br>  &#123;<br>    <span class="hljs-keyword">if</span>(flyweights.containsKey(key))<br>    &#123;<br>      <span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">Flyweight</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>();<br>      flyweights.put(key,fw);<br>      <span class="hljs-keyword">return</span> fw;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span><br>&#123;<br>  <span class="hljs-comment">//内部状态作为成员属性</span><br>  <span class="hljs-keyword">private</span> String intrinsicState;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Flyweight</span><span class="hljs-params">(String intrinsicState)</span><br>  &#123;<br>    <span class="hljs-built_in">this</span>.intrinsicState = intrinsicState;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span><br>  &#123;<br>  ......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>模式分析</p><ul><li>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能</li><li>享元模式的核心在于<strong>享元工厂类</strong>，<strong>享元工厂类的作用在于提供一个用于存储享元对象的享元池</strong>，用户需要对象时，首先从享元池中获取，<strong>如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象</strong>。</li></ul></li><li><p>模式优点</p><ul><li>享元模式的优点在于它可以<strong>极大减少内存中对象的数量</strong>，使得相同对象或相似对象在内存中只保存一份。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得<strong>享元对象可以在不同的环境中被共享</strong>。</li></ul></li><li><p>模式缺点</p><ul><li>享元模式使得系统更加复杂，需要<strong>分离出内部状态和外部状态，这使得程序的逻辑复杂化</strong>。</li><li>为了使对象可以共享，享元模式<strong>需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</strong>。</li></ul></li><li><p>适用场景</p><ul><li>一个系统有<strong>大量相同或者相似的对象</strong>，由于这类对象的大量使用，造成内存的大量耗费。</li><li>对象的<strong>大部分状态都可以外部化</strong>，可以将这些外部状态传入对象中。</li><li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，<strong>应当在多次重复使用享元对象时才值得使用享元模式</strong>。</li></ul></li><li><p>模式扩展</p><ul><li><strong>单纯享元模式</strong>：在单纯享元模式中，<strong>所有的享元对象都是可以共享的</strong>，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</li><li><strong>复合享元模式</strong>：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享</li><li>在享元模式的享元工厂类中通常<strong>提供一个静态的工厂方法用于返回享元对象</strong>，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此<strong>享元工厂类可以使用单例模式进行设计</strong>。</li><li>享元模式可以结合组合模式形成<strong>复合享元模式</strong>，统一对享元对象设置外部状态。</li></ul></li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li><p>概述</p><ul><li>在某些情况下，<strong>一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用</strong>。代理对象可以在<strong>客户端和目标对象之间起到中介的作用</strong>，并且可以<strong>通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务</strong>。</li><li>通过引入一个新的对象来实现<strong>对真实对象的操作</strong>或者<strong>将新的对象作为真实对象的一个替身</strong>，这种实现机制即为<strong>代理模式</strong>。通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</li></ul></li><li><p>模式定义</p><ul><li>代理模式(<strong>Proxy Pattern</strong>) ：给某一个对象<strong>提供一个代理</strong>，并<strong>由代理对象控制对原对象的引用</strong>。代理模式的英文叫做<strong>Proxy或Surrogate</strong>，它是一种<strong>对象结构型模式</strong>。</li><li>思想简单，但是变体很多</li></ul></li><li><p>模式结构</p><ul><li><p>代理模式包含如下角色：</p><ol><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ol></li><li><img src="17.png" style="zoom:40%;" /></li><li><img src="image-20250528174952509.png" alt="image-20250528174952509" style="zoom:50%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preRequest</span><span class="hljs-params">()</span><br>  &#123;......&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span><br>  &#123;<br>    preRequest();<br>    realSubject.request();<br>    postRequest();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postRequest</span><span class="hljs-params">()</span><br>  &#123;......&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>模式优点</p><ul><li>代理模式能够<strong>协调调用者和被调用者</strong>，在一定程度上降低了系统的耦合度。</li><li><strong>远程代理使得客户端可以访问在远程机器上的对象</strong>，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li><strong>虚拟代理</strong>通过使用一个小对象来代表一个大对象，<strong>可以减少系统资源的消耗，对系统进行优化并提高运行速度。</strong></li><li><strong>保护代理可以控制对真实对象的使用权限。</strong></li></ul></li><li><p>模式缺点</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此<strong>有些类型的代理模式可能会造成请求的处理速度变慢</strong>。</li><li><strong>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</strong>。</li></ul></li><li><p>适用场景</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件系统设计</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计整理(架构部分)</title>
    <link href="/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/"/>
    <url>/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计整理-架构部分"><a href="#软件系统设计整理-架构部分" class="headerlink" title="软件系统设计整理(架构部分)"></a>软件系统设计整理(架构部分)</h1><span id="more"></span><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><ul><li>理解软件工程<ul><li>软件和硬件：<ul><li>软件是不可见的：软件是虚拟的，而硬件是实体的。</li><li>软件制作出来就是为了被修改和改变的(软件的演化是他的本质属性)</li></ul></li><li>科学和工程<ul><li>科学的研究是研究这个世界既有的部分，而工程是研究的是人类创造新的世界(是不是因为人才产生的)，下面的图是很重要的。</li><li><img src="1.png" style="zoom:40%;" /></li></ul></li></ul></li></ul><blockquote><p>注：Architecture可以翻译为架构，也可以是体系结构</p></blockquote><ul><li><p><strong>什么是软件架构</strong> Software Architecture 重要</p><ul><li>定义1：程序或计算系统的软件架构是系统的一个或多个结构，其中包括<strong>软件组件</strong>，这些<strong>组件的外部可见属性</strong>以及<strong>它们之间的关系</strong></li><li>定义2：系统的基本组织，体现在其<strong>组件</strong>，<strong>它们之间的相互关系</strong>以及<strong>环境</strong>以及<strong>支配其设计和演进的原则</strong>。</li><li>架构的一些概念<ul><li>Module，模块 是还没有实现出来的软件部分。</li><li>Component，组件 是已经实现出来的软件部分。</li><li>Connector，连接件 ：连接组件的部分</li><li>Element，元素：包含 Component和 Connector。</li></ul></li></ul></li><li><p><strong>架构与设计</strong> Architecture vs. Design 重要</p><ul><li>架构是属于软件设计的<ul><li>所有的架构都是软件设计，但不是所有的软件设计都是架构</li><li>架构是设计过程的一个部分</li></ul></li><li>其他观点<ul><li>架构是更高层的设计</li><li>架构是设计决策的组合</li><li>架构是根据不同项目而不同的</li></ul></li><li>系统的结构或组织<ul><li>元素(Elements)：部件(Components)和连接件(Connectors)</li><li>关系：静态(static)和动态(dynamic)的关系</li><li>属性：元素，元素组和整个系统</li></ul></li></ul></li><li><p><strong>架构与结构</strong> Architecture vs. Structure 重要</p><ul><li>架构是包含结构信息的。结构是一种静态的、逻辑的、是关于系统如何构成的。架构除了包含结构，还会包含组件之间的相关的关系结构，还会定义一些动态的行为（组件可能和谁进行交互）</li><li>架构将系统分解成组件、模块和子系统，降低每一个部分的复杂度</li><li>架构定义了组件接口（组件可以干什么）、 组件交流和依赖（组件间如何沟通交流） 、 组件职责 （当我们询问它时，组件能明确知道自己的职责）</li><li>架构确定通信、通信需要<br>i. 数据通过机器传递，比如函数调用、 RMI、异步信息等<br>ii. 控制流， 组件的信息流来满足 需要的功能，比如序列化、并发并行和同步等。</li><li>架构强调 NFA（非功能性需求）<br>i. 功能性需求定义了系统能做什么，NFA定义了系统运行的多好<br>ii. NFA（又名架构需求 Architecture requirements 很少在功能性需求中被发现 ，必须由架构引出，包括：技术约束、商业约束、质量属性</li></ul></li><li><p>架构与软件架构</p><ul><li>架构的作用仍然保持一致： 倾听用户理解需求、 检查灵活性、形成实际结构版本创建蓝图 、监督构建过程保证计划符合规范、引导暴风雨式的设计变更、危机和歧义。</li><li>软件架构是监督软件的构造过程：开发人员、工程师和设计者。</li></ul></li><li><p><strong>软件系统架构的来源</strong> 重要</p><ul><li>NFRs、ASRs（<strong>关键架构需求</strong> architecturally significant requirement，ASR）、质量需求、涉众、组织、技术环境等等</li></ul></li><li><p><strong>架构师的职责</strong> 重要</p><ul><li><strong>联络</strong><ul><li>在客户、技术团队和业务&#x2F;需求分析师之间</li><li>与管理层或市场部门</li></ul></li><li><strong>软件工程</strong><ul><li>软件工程最佳实践</li></ul></li><li><strong>技术知识</strong><ul><li>对技术领域的深入理解</li></ul></li><li><strong>风险管理</strong><ul><li>与设计、技术选择相关的风险</li></ul></li></ul></li><li><p><strong>设计策略</strong> 重要，要理解</p><ul><li>分解 Decomposition：针对某⼀个系统关注点分解后处理，⽐如将整个系统分解或将某个模块分解</li><li>抽象 Abstraction：使用抽象让设计师关注本身结构⽽不关注实现，⽐如将系统抽象为组件和连接件或抽象为模块</li><li>分治 Divide &amp; Conquer：将某个模块分别处理</li><li>生成与测试 Generation and Test：将一个特定的设计看作是⼀个假设；根据测试路径生成测试用例</li><li>迭代与细化 Iteration：使用迭代的⽅法，ADD 方法多次迭代直到满足所有 ASR</li><li>复用 Reuse：重用在设计过程中出现的可以复用的元素，重用现有架构</li></ul></li><li><p>如何创建一个设计</p><ul><li>设计活动目标：生成一个适应约束并且达到系统质量和业务目标的设计</li><li>广义设计策略<ol><li>分解 ：针对某一个系统关注点进行分解后处理。<ul><li>质量属性可以分解 ，并分配给分解后的元素</li><li>如何对非 ASR进行设计 ASR仅意味着需求的优先级仍然可以满足非 ASR 需求来满足其他人 ，除非您即将满足需求 、需要重新确定需求优先级并重新设计，和您不能满足需求</li><li>一次设计所有的ASR还是一个ASR？通过经验和教育 ，我们会有直观的设计方法 ，并使用模式&#x2F;策略来设计多个ASR</li></ul></li><li>抽象：使用抽象让设计师关注本身结构而不是实现</li><li>分而治之：对于一个大规模系统，每次聚焦一部分。</li><li>生成和测试</li><li>迭代和细化：使用迭代的方法，每次对上一迭代进行精化。</li><li>重用元素：复用在设计过程中出现的可以复用的元素。</li></ol></li></ul></li><li><p><strong>架构视图</strong> 重要</p><ul><li><p>为什么使用架构视图？ 架构视图主要是为了应对软件不可见的问题，屏蔽其他没有影响的部分，将关注点分离。</p></li><li><p>什么是架构视图？一组系统元素和它们之间的关系表示（不是所有的系统元素 ，而是特定类型的元素）</p></li><li><p>**为什么软件系统架构需要用不同的视图来文档化？**不同的视图支持不同的目标和用途 ，突出不同的系统元素和关系，在不同程度上暴露了不同的质量属性。</p></li><li><p><strong>K.Kruchen的4+1视图模型</strong>（会画图）</p><ul><li><p>逻辑视图：描述了体系结构中在体系结构上明显重要的元素以及他们之间的关系</p></li><li><p>进程视图：描述了体系结构中的并发和交流元素</p></li><li><p>物理视图：描述了主要过程和部件是如何映射到应用硬件上的</p></li><li><p>开发视图：描述了软件部件是如何在软件内部组织的，比如配置管理工具</p></li><li><p>用例场景(Use Case Scenarios)：捕获架构需求，与一个或多个特定视图相关</p></li><li><p><img src="image-20250528202710016.png" alt="image-20250528202710016"></p></li><li><p><img src="45ed3af0f45c4fdb8500c92a0d7455a3.png" alt="img"></p></li><li><p><a href="https://blog.csdn.net/qq_29068607/article/details/143194772">https://blog.csdn.net/qq_29068607/article/details/143194772</a></p></li></ul></li></ul><table><thead><tr><th>视图名</th><th>关注点</th><th>面向对象角色</th><th>表示方式</th></tr></thead><tbody><tr><td><strong>1️⃣ 逻辑视图</strong></td><td>功能划分，类的结构和交互</td><td>开发人员</td><td>UML 类图、对象图</td></tr><tr><td><strong>2️⃣ 开发视图（实现视图）</strong></td><td>模块结构，代码组织</td><td>开发&#x2F;构建者</td><td>包图、组件图</td></tr><tr><td><strong>3️⃣ 进程视图</strong></td><td>运行时行为，多线程、通信</td><td>测试&#x2F;性能分析者</td><td>活动图、通信图</td></tr><tr><td><strong>4️⃣ 物理视图（部署视图）</strong></td><td>部署拓扑、服务器结构</td><td>运维工程师</td><td>部署图、网络图</td></tr><tr><td><strong>➕ 场景视图（用例视图）</strong></td><td>主要功能场景、用例驱动</td><td>所有人（尤其是客户）</td><td>用例图、文本</td></tr></tbody></table></li><li><p>软件架构 Software Architecture</p><ul><li>定义：上面有了，此处不重复</li><li>活动：<ul><li>创建系统的商业案例</li><li>理解用户的需求</li><li>创建和选择架构</li><li>沟通体系结构（在涉众、开发商之间）</li><li>分析或评估架构（整体方法论和具体技术的质量）</li><li>实现架构</li><li>保证架构的一致性</li></ul></li><li>软件系统架构担当的角色：<ul><li>代表决定如何实现需求的决策的第一批人工制品 （早期设计决策），代表了最难更改的设计决策，值得最详细的考虑。</li><li>架构是完成产品生产线工程 (Product line Engineering) 的关键， 与独立开发每个系统相比，以较少的工作量、成本和风险来对一系列相似系统进行严格的开发。</li><li>当人开始在系统上工作时， 构架通常是首先要检查的设计工件。</li><li>软件架构为<strong>维护和修改</strong>决策提供了参考框架</li></ul></li><li>为什么软件架构是重要的<ul><li>软件架构提供了沟通的工具：是可以确定和谈判利益冲突的参考框架</li><li>软件架构表现了最早期的决策集合</li><li>软件架构促进或阻碍质量属性的实现</li><li>软件架构会影响质量</li><li>软件架构引发有关潜在变更的讨论：软件架构将更改分为三种类型，本地（单组件修改）、 非本地（多组件修改）、架构（修改系统基本结构、通信和协调结构）</li><li>软件架构是一种可迁移和可重用的抽象</li><li>软件架构是产品通用性的基础： 整个产品线共享一个软件架构</li><li>可以通过体系结构集成独立开发组件来开发系统</li></ul></li><li><strong>软件架构过程(活动)</strong> 重要<ul><li><img src="image-20250530192359706.png" alt="image-20250530192359706"></li><li>通过 StackHolder获取到 ASRs</li><li>通过分析得到 Prioritized Quality Attribute Scenarios(高优先级质量属性场景 )和 Requirements Constraints(需求和约束 )</li><li>将上述部分，结合模式和策略，综合可以得到架构的设计</li><li>根据架构的设计得到由模式决定的候选视图的示意图，之后完成文档化</li><li>选择、组合视图，将文档进行进一步的评估，这一部分需要 StackHolder的参与、也需要 Prioritized Quality Attribute Scenarios和文档等作为参考。</li></ul></li><li>体系结构生命周期<ul><li>Systhesis：合成，混合，综合</li><li><img src="7.png" style="zoom:50%;" /></li></ul></li><li>架构知识域<ul><li>上下文（ Context）：软件开发生命周期，需求、设计、构造、测试</li><li>关键点：并发、控制和处理时间、分布式、异常处理、交互系统、持久化</li><li>软件设计方法：架构方法 ADD、设计方法</li></ul></li></ul></li></ul><h2 id="2-质量属性-Quality-Attributes"><a href="#2-质量属性-Quality-Attributes" class="headerlink" title="2. 质量属性 Quality Attributes"></a>2. 质量属性 Quality Attributes</h2><p><img src="image-20250529195836443.png" alt="image-20250529195836443"></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>需求分类<ul><li>功能性需求 functional requirements</li><li>质量需求 quality requirements，也叫非功能需求NFR</li><li>约束 constraints</li></ul></li><li>功能性需求<ul><li>定义系统必须做什么，并且强调系统如何提供价值给涉众</li><li>功能是系统完成其预期工作的能力，很大程度上与结构无关</li></ul></li><li><strong>质量需求</strong>（替代术语：非功能需求、体系结构需求） 重要<ul><li>系统应在功能性需求之上提供的整个系统的合乎需求的特性</li><li>质量属性是由软件系统的<strong>业务目标</strong>所决定的</li><li>如果质量需求很重要，软件系统架构会将其映射到各种结构上</li><li>分为两类：<ul><li>执行过程中可观察（外部）：系统满足其行为要求的程度如何 ？例如性能 、安全性、 可用性等</li><li>执行期间不可观察（内部）：系统的维护 、集成或测试有多容易 ？例如可修改性、 可移植性、可重用性和可测试性等。</li></ul></li></ul></li><li><strong>约束</strong> 重要<ul><li>约束是具有<strong>零自由度</strong>的设计决策</li><li>约束是已经做出的<strong>预先</strong>指定的设计决策</li><li>通过<strong>接受</strong>设计决策并将其与其他受影响的设计决策进行<strong>协调</strong>，可以满足约束条件</li></ul></li><li>为什么软件系统结构被认为是解决质量问题的最合适层次：<ul><li>开发完成后，质量不能被添加到软件密集型系统中，软件开发的所有阶段都需要解决质量问题：即没有办法先实现功能，然后再尝试实现非功能性需求。</li><li>软件体系结构限制了各种质量属性的实现，例如性能、安全性和可用性等。</li></ul></li><li>质量属性 Quality Attributes<ul><li><strong>开发完成后</strong>，质量<strong>不能</strong>添加到软件密集型系统中</li><li>在<strong>软件开发的所有阶段</strong>都需要解决质量问题</li><li>业务目标确定系统必须具备的质量</li><li>质量属性是<strong>系统功能的基础</strong>，而功能是系统功能、服务和行为的基本说明</li><li>软件体系结构限制了各种质量属性的实现，例如性能，安全性，可用性等</li></ul></li><li><strong>质量属性分类</strong> 重要<ul><li>内部属性：对于开发人员而言的，例如可测试性</li><li>外部属性：对于用户而言的，例如性能</li></ul></li><li>如何定义质量属性<ul><li>为了在架构级别对其进行<strong>评估</strong>，必须对质量属性进行<strong>精确定义</strong>。</li><li>可以使用质量属性场景(Quality attribute scenarios)定义所需的质量属性</li></ul></li><li><strong>质量属性场景</strong> Quality attribute scenarios 重要<ul><li>场景是具有一定结构的简单句子。场景的两个主要类别是：<ul><li><strong>通用场景</strong>是与<strong>系统无关</strong>的方案，用于指导质量属性要求的规范</li><li><strong>具体场景</strong>是系统<strong>特定</strong>方案，用于指导特定系统的质量属性要求的规范。它们是通用场景的<strong>实例</strong></li></ul></li><li>这个场景就是4+1视图中的1(Use Case)</li></ul></li><li>通用场景 General Scenarios<ul><li>通用方案提供了一个<strong>框架</strong>，用于生成<strong>大量</strong>通用的，独立于系统的，质量属性特定的方案</li><li>每种情况都可能，但不一定与我们所关注的系统相关</li><li>为了使一般情况对特定系统有用，我们必须使它们<strong>特定于系统</strong></li><li>使通用场景系统特定于特定环境意味着将其<strong>转换</strong>为特定系统的具体术语</li></ul></li><li><strong>质量属性场景建模</strong> 重要<ul><li><img src="5.png" style="zoom:50%;" /></li><li>刺激(Stimulus)：到达系统时需要考虑的<strong>条件</strong></li><li>刺激源(Source of Stimulus)：产生刺激的<strong>实体</strong>(人，系统或任何促动器)</li><li>响应(Response)：刺激措施到来之后开展的<strong>活动</strong></li><li>响应度量(Response Measure)：对刺激的响应应以某种方式进行<strong>测量</strong>，以便可以<strong>测试</strong>需求</li><li>环境(Environment)：发生刺激时系统的状况，例如过载，正常运行等</li><li>工件(Artifact)：需求适用的<strong>整个</strong>系统或系统的一部分</li><li>只要定义好这6个元素，就能锁定架构的一个场景，之后可以用来进行架构的设计</li></ul></li><li>策略&#x2F;战术(原子级别的最小的决定) Tactics<ul><li>Tactics是影响质量属性相应控制的设计决策，比如冗余。</li><li>体系结构策略 Architecture Strategy：策略的集合。</li><li>像模式(pattern)一样，策略也可以由其他策略组成，例如，冗余可以由数据的冗余，计算的冗余组成。设计人员根据需求选择一个或另一个</li></ul></li><li>质量设计决策 Quality Design Decisions<ul><li>架构是设计决策的集合</li><li>七种设计决策<ul><li><strong>职责分配</strong> Allocation of responsibilities：将大的职责进行分配</li><li><strong>协调模型</strong> Coordination model：各部分之间的沟通、交互</li><li><strong>数据模型</strong> Data model：数据格式、存储方式(缓存等)</li><li><strong>资源管理</strong> Management of resources：CPU、网络、内存、<strong>时间(部分时间敏感的场景)等资源</strong></li><li><strong>架构元素之间的映射</strong> Mapping among architecture elements：将架构元素如何映射到软件的实现上</li><li><strong>绑定时间决策</strong> Binding time decisions：<ol><li>系统的变化可以在什么时间点前需要固定下来，也就是这个时间前，系统还是可以变化的，但是这个时间之后就不可以变化了</li><li>比如选择安装环境是需要在一个时间点前完成的，技术是否添加、编译时间、初始化时间，运行时绑定，但运行时是弹性最大的</li><li>实际上我们希望绑定时间越往后越好，但是也就要付出相应的代价。</li></ol></li><li><strong>技术选择</strong> Choice of technology：前面的部分都确定后，我们可以选择技术栈的相对比较局限，解空间已经被压缩了。</li></ul></li></ul></li></ul><blockquote><p>课上涉及的7个质量属性都要会，尤其是可用性</p></blockquote><h3 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h3><ul><li><p>可用性是应用程序的关键要求，以可用的时间来度量</p></li><li><p>一些指标</p><ul><li>MTBF Mean Time Between Failure</li><li>MTTR Mean Time To Repair</li><li>可用性：MTBF &#x2F; (MTBF + MTTR)</li></ul></li><li><p>通用场景</p><ul><li><img src="image-20250529153004954.png" alt="image-20250529153004954" style="zoom: 50%;" /></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>内部&#x2F;外部：人员，硬件，软件，物理基础设施，物理环境</td></tr><tr><td>刺激</td><td>故障：遗漏，崩溃，错误时序，错误响应</td></tr><tr><td>工件</td><td>处理器，通信渠道，持久存储，进程</td></tr><tr><td>环境</td><td>正常操作，启动，关闭，修复模式，降级运行，超负荷运行</td></tr><tr><td>响应</td><td>防止故障成为故障。 检测故障：1.记录故障 2. 通知适当的实体 故障恢复：1.禁用引发故障事件的源 2. 在修复过程中暂时不可用 3. 修复或掩盖故障&#x2F;失败或抑制其造成的损害 4. 在修复过程中以降级模式运行</td></tr><tr><td>响应度量</td><td>系统必须可用的时间或时间间隔、可用百分比（如99.999%）、检测故障时间、修复故障时间、系统可在降级模式运行的时间或时间间隔、预防某类故障或处理不失败的比例（如99%）或速率（如每秒最多100次）</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529154100715.png" alt="image-20250529154100715"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>心跳监视器</td></tr><tr><td>刺激</td><td>服务器无响应</td></tr><tr><td>工件</td><td>处理流程</td></tr><tr><td>环境</td><td>正常操作</td></tr><tr><td>响应</td><td>通知操作组件继续操作</td></tr><tr><td>响应度量</td><td>无下线时间</td></tr></tbody></table></li><li><p>可用性策略</p><ul><li><img src="image-20250529153805503.png" alt="image-20250529153805503" style="zoom: 80%;" /></li><li>输入：Fault</li><li>可用性策略：检测错误、错误恢复、预防错误</li><li>一些重要的策略<ul><li>错误检测<ul><li>Ping&#x2F;Echo：隔一段时间交流一次状态信息</li><li>HeartBeat：持续传输状态信息</li><li>Exception：抛出异常并捕获处理</li></ul></li><li>错误恢复<ul><li>Vote：多个处理器同时执行相同的计算。一个“投票器”机制会比较这些处理器的结果；如果有一个处理器的输出与其他的显著不同，它会被认为是故障并被忽略。系统会采用其他处理器一致的结果。这是一种容错方式，可以屏蔽单个组件的错误。</li><li>主动冗余（Active Redundancy）：所有冗余组件都处于活动状态，并同时处理相同的输入。但只会使用其中一个组件的输出，其余的则被丢弃。如果某个组件出现故障，其他组件会立即继续，无需中断，因为备用始终就绪，几乎没有停机时间。</li><li>被动冗余（Passive Redundancy）：一个主组件承担工作，另一个从组件处于被动监控状态。如果主组件故障，从组件接管工作。但从组件需要先同步最新状态以确保一致性，因此在切换过程中会有短暂的停机时间。</li><li>备用（Spare）：准备一个完整的备用系统，以便在多个组件发生故障时，能够整体替换。</li><li>Shadow operation：之前出现过错误的组件先以Shadow operation模式运行，确认正常后再恢复它的地位</li><li>Checkpoint&#x2F;Rollback：错误发生后回滚到检查点</li></ul></li><li>预防错误<ul><li>Removal from service：将一些高风险组件移出服务组</li><li>Transaction：以事务方式服务，一旦出错立刻回滚</li><li>Process monitor：监控器可以检测到不正常的进程，并创建一个新的实例，将其初始化为某个适当的状态，就像备用策略一样。</li></ul></li></ul></li><li>输出：Fault被屏蔽或完成恢复</li></ul></li></ul><h3 id="互操作性（Interoperability"><a href="#互操作性（Interoperability" class="headerlink" title="互操作性（Interoperability)"></a>互操作性（Interoperability)</h3><ul><li><p>互操作性是指两个或多个系统可以在特定的上下文中通过接口有效交换有意义的信息的程度，包括语法可操作性（ 交换数据的能力）和语义可操作性 （能够正确解释数据）。互操作性需要确定谁、什么以及在什么情况下（上下文）。</p></li><li><p>影响因素：发现（发现服务位置、身份和接口）、处理响应（返回、转发、广播）</p></li><li><p>通用场景</p><ul><li><img src="image-20250529183555510.png" alt="image-20250529183555510"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>系统发起与另一个系统进行互操作的请求</td></tr><tr><td>刺激</td><td>请求在系统之间交换信息</td></tr><tr><td>工件</td><td>希望进行互操作的系统</td></tr><tr><td>环境</td><td>希望互操作的系统在运行时被发现或在运行前已知</td></tr><tr><td>响应</td><td>以下之一或多个：1.请求被（适当地）拒绝，并通知了适当的实体（人员或系统）2.请求被（适当地）接受，信息交换成功 3.请求被参与的一个或多个系统记录</td></tr><tr><td>响应度量</td><td>以下之一或多个：1.正确处理信息交换的百分比 2.正确拒绝信息交换的百分比</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529185634800.png" alt="image-20250529185634800"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>车辆的信息系统</td></tr><tr><td>刺激</td><td>发送当前位置</td></tr><tr><td>工件</td><td>交通流量检测系统</td></tr><tr><td>环境</td><td>系统知道运行情况</td></tr><tr><td>响应</td><td>系统结合当前位置信息和谷歌地图、卫星数据等</td></tr><tr><td>响应度量</td><td>信息准确率达到99.9%</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529183844839.png" alt="image-20250529183844839" style="zoom:67%;" /></li><li>输入：信息交换请求</li><li>具体策略：<ul><li>定位：发现服务</li><li>管理接口：编排、定制界面</li></ul></li><li>输出：请求被正确处理</li></ul></li></ul><h3 id="可修改性-Modifiability"><a href="#可修改性-Modifiability" class="headerlink" title="可修改性 Modifiability"></a>可修改性 Modifiability</h3><ul><li><p>可修改性涉及到更改以及进行更改所需花费的时间或金钱，包括这种可变更性影响其他功能或质量属性的程度</p></li><li><p>影响因素：变更是什么？变更可能性？何时谁进行变更？变更成本？</p></li><li><p>通用场景</p><ul><li><img src="image-20250529184529017.png" alt="image-20250529184529017"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>终端用户，开发人员，系统管理员</td></tr><tr><td>刺激</td><td>指令去增加&#x2F;删除&#x2F;修改功能，或更改质量属性、容量或技术</td></tr><tr><td>工件</td><td>代码，数据，接口，组件，资源，配置等</td></tr><tr><td>环境</td><td>运行阶段，编译阶段，构建阶段，启动阶段，设计阶段</td></tr><tr><td>响应</td><td>以下之一或多个：1.进行修改 2.测试修改 3.部署修改</td></tr><tr><td>响应度量</td><td>以以下方面衡量的成本：1.受影响工件的数量、大小、复杂性 2.所需努力 3. 需要的时间 4. 花费的金钱 5. 修改影响其他功能或质量属性的程度 6. 引入的新缺陷</td></tr></tbody></table></li></ul><ul><li><p>具体场景</p><ul><li><img src="image-20250529185615365.png" alt="image-20250529185615365"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>开发者</td></tr><tr><td>刺激</td><td>想要修改UI</td></tr><tr><td>工件</td><td>代码</td></tr><tr><td>环境</td><td>设计阶段</td></tr><tr><td>响应</td><td>完成修改并通过测试</td></tr><tr><td>响应度量</td><td>在3小时内完成</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529185027406.png" alt="image-20250529185027406"></li><li>输入：更改到来</li><li>具体策略：<ul><li>减小模块大小：拆分模块</li><li>增强内聚：增加语义一致性</li><li>降低耦合：封装、使用中介打破依赖、重构</li><li>推迟绑定</li></ul></li><li>输出：在时间和预算范围内完成更改</li></ul></li></ul><h3 id="性能-Performance"><a href="#性能-Performance" class="headerlink" title="性能 Performance"></a>性能 Performance</h3><ul><li><p>性能与时间有关，和系统满足时序要求的能力有关（单位时间能做多少事情）</p></li><li><p>影响要素：处理时间（正在响应）和阻塞时间（无法响应）</p></li><li><p>通用场景</p><ul><li><img src="image-20250529185416629.png" alt="image-20250529185416629"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>系统内部或外部</td></tr><tr><td>刺激</td><td>周期性事件、零星事件或随机事件的到来</td></tr><tr><td>工件</td><td>系统或系统中的一个或多个组件</td></tr><tr><td>环境</td><td>操作模式：正常、紧急、峰值负载、超负荷</td></tr><tr><td>响应</td><td>处理事件，改变服务级别</td></tr><tr><td>响应度量</td><td>延迟、截止时间、吞吐量、抖动、错失率</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529185703769.png" alt="image-20250529185703769"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>用户</td></tr><tr><td>刺激</td><td>初始事务</td></tr><tr><td>工件</td><td>系统</td></tr><tr><td>环境</td><td>正常操作</td></tr><tr><td>响应</td><td>事务执行</td></tr><tr><td>响应度量</td><td>平均延迟为2秒</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529191237976.png" alt="image-20250529191237976"></li><li>输入：事件到达</li><li>具体策略<ul><li>控制资源请求：管理采样频率、限制事件响应（排队）、事件优先级排序、减少过载、限制处理时间、提高资源利用率。</li><li>管理资源：增加资源、引入并发、计算资源多备份、 数据资源多备份、限制队列长度、调度资源。</li></ul></li><li>输出：在一定时间限制内生成响应</li></ul></li></ul><h3 id="安全性-Security"><a href="#安全性-Security" class="headerlink" title="安全性 Security"></a>安全性 Security</h3><ul><li><p>安全性衡量系统保护数据和信息免遭未授权应用的能力，同时仍提供对授权人员和系统的访问权限</p></li><li><p>影响要素：保密性（Confidentiality 防止未授权访问）、完整性（Integrity 防止未授权操作）、可用性（Availability 系统可供合法使用）</p></li><li><p>通用场景</p><ul><li><img src="image-20250529191903342.png" alt="image-20250529191903342" style="zoom: 80%;" /></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>人或其他系统，之前可能被正确或错误地识别，或当前未知。攻击者可能来自组织外部或内部。</td></tr><tr><td>刺激</td><td>未授权尝试显示数据、更改或删除数据、访问系统服务、更改系统行为或降低可用性。</td></tr><tr><td>工件</td><td>系统服务、系统内的数据、系统组件或资源、系统产生或消费的数据。</td></tr><tr><td>环境</td><td>系统是在线还是离线；连接或断开连接到网络；在防火墙后面或开放网络；完全运行、部分运行或不运行。</td></tr><tr><td>响应</td><td>事务以如下方式进行： 1.保护数据或服务不被未经授权访问 2.防止未经授权的数据或服务操作 3.参与事务方明确识别，确保可靠 4.事务参与方无法否认其参与 5.数据、资源和系统服务可用于合法使用  系统通过以下方式追踪活动： 1.记录访问或修改 2.记录访问数据、资源或服务的尝试 3.在明显攻击发生时通知适当实体(人员或系统)</td></tr><tr><td>响应度量</td><td>以下之一或多个： 1.系统在特定组件或数据值被破坏时的损失程度 2.从攻击检测到的时间 3.成功抵御多少次攻击 4.从成功攻击中恢复所需时间 5.特定攻击下的数据易受损害程度</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529192206966.png" alt="image-20250529192206966"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>远程的恶意用户</td></tr><tr><td>刺激</td><td>试图修改支付率</td></tr><tr><td>工件</td><td>系统数据</td></tr><tr><td>环境</td><td>正常操作</td></tr><tr><td>响应</td><td>系统维持审计踪迹</td></tr><tr><td>响应度量</td><td>正确数据在一天内恢复并且攻击来源被标识</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529192602450.png" alt="image-20250529192602450"></li><li>输入：攻击</li><li>具体策略<ul><li>检测攻击： 发现入侵（通过流量或签名） 、检测服务拒绝、检查消息完整性（ 通过校验或哈希)、检查消息延迟</li><li>防御攻击：验证(Identity)、授权(Authorize)、认证(Authenticate)请求者、限制资源访问、限制暴露、加密数据、分离实体、修改默认设置</li><li>响应攻击：撤销对敏感资源访问、锁定电脑、告知请求者</li><li>从攻击中恢复：对系统的追踪、 快照存储</li></ul></li><li>输出：系统检测、防御、响应或恢复</li></ul></li></ul><h3 id="可测试性-Testability"><a href="#可测试性-Testability" class="headerlink" title="可测试性 Testability"></a>可测试性 Testability</h3><ul><li><p>可测试性是指可以使软件通过（通常是基于执行）测试来证明其故障的难易程度</p></li><li><p>通用场景</p><ul><li><img src="image-20250529192822172.png" alt="image-20250529192822172"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>单元测试员、集成测试员、系统测试员、验收测试员、终端用户，手动执行测试或使用自动化测试工具</td></tr><tr><td>刺激</td><td>由于编码增量的完成而执行一组测试，如类层或服务，子系统完整集成、整个系统的完整实现或系统交付给客户。</td></tr><tr><td>工件</td><td>系统正在被测试的部分</td></tr><tr><td>环境</td><td>设计阶段、开发阶段、编译阶段、集成阶段、部署阶段、运行阶段</td></tr><tr><td>响应</td><td>以下之一或多个：1.执行测试套件并记录结果 2.记录导致故障的活动 3.控制并监控系统状态。</td></tr><tr><td>响应度量</td><td>以下之一或多个：1. 找到故障或故障类别的工作量 2. 实现给定状态空间覆盖百分比的工作量 3. 故障被下一个测试揭示的概率 4. 执行测试所需时间 4.发现故障需要的工作量 5. 测试中的最长依赖链长度 6. 准备测试环境所需时间 7. 降低风险暴露（损失大小×出现概率）</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529193135500.png" alt="image-20250529193135500" style="zoom: 80%;" /></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>单元测试人员</td></tr><tr><td>刺激</td><td>代码单元完成</td></tr><tr><td>工件</td><td>代码单元</td></tr><tr><td>环境</td><td>开发环境</td></tr><tr><td>响应</td><td>捕获测试结果</td></tr><tr><td>响应度量</td><td>3小时内达到85%路径覆盖率</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529194315617.png" alt="image-20250529194315617" style="zoom: 80%;" /></li><li>输入：执行测试</li><li>具体策略<ul><li>控制和观察系统状态：专用界面、记录或回放故障、本地化状态存储、沙盒（保证实验消除后果）</li><li>限制复杂度：限制结构复杂性（减少依赖关系、继承深度、多态和动态调用、限制行为不确定性。</li></ul></li><li>输出：检测到错误</li></ul></li></ul><h3 id="易用性-Usability"><a href="#易用性-Usability" class="headerlink" title="易用性 Usability"></a>易用性 Usability</h3><ul><li><p>易用性与用户完成所需任务的难易程度以及系统提供的用户支持的类型相关。</p></li><li><p>影响因素：学习系统功能、有效使用系统、 最小化错误影响、 使 系统适应 用户需求、增强 信息和满意度。</p></li><li><p>通用场景</p><ul><li><img src="image-20250529194826560.png" alt="image-20250529194826560"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>最终用户，可能在一个专门化角色中</td></tr><tr><td>刺激</td><td>最终用户尝试高效使用系统、学习使用系统、最小化错误影响、调整或配置系统。</td></tr><tr><td>工件</td><td>系统或用户正在交互的特定系统部分</td></tr><tr><td>环境</td><td>运行阶段或配置阶段</td></tr><tr><td>响应</td><td>系统应为用户提供所需功能或预见用户需求</td></tr><tr><td>响应度量</td><td>以下之一或多个：任务时间、错误数量、完成任务数量、用户满意度、用户知识获取、成功操作与总操作的比例、错误发生时丢失的时间或数据量</td></tr></tbody></table></li><li><p>具体场景</p><ul><li><img src="image-20250529195328527.png" alt="image-20250529195328527"></li></ul><table><thead><tr><th>场景要素</th><th>可能的值</th></tr></thead><tbody><tr><td>刺激源</td><td>用户</td></tr><tr><td>刺激</td><td>下载一个新应用</td></tr><tr><td>工件</td><td>系统</td></tr><tr><td>环境</td><td>运行时</td></tr><tr><td>响应</td><td>用户高效使用系统</td></tr><tr><td>响应度量</td><td>在2分钟的试用之后</td></tr></tbody></table></li><li><p>策略</p><ul><li><img src="image-20250529195644114.png" alt="image-20250529195644114" style="zoom:80%;" /></li><li>输入：用户请求</li><li>具体策略<ul><li>支持用户操作： 取消、撤销、暂停恢复、 将对象成组操作</li><li>支持系统操作：维护任务模型（确定上下文对任务建模）、 维护用户模型（预期的知识)、维护系统模型（预期的系统行为）</li></ul></li><li>输出：用户被给出正确的反馈和帮助</li></ul></li></ul><h2 id="3-架构模式"><a href="#3-架构模式" class="headerlink" title="3. 架构模式"></a>3. 架构模式</h2><h3 id="架构攸关的需求-ASR"><a href="#架构攸关的需求-ASR" class="headerlink" title="架构攸关的需求 ASR"></a>架构攸关的需求 ASR</h3><ul><li><p><strong>什么是ASR</strong>(Architecturally Significant Requirements) 重要：架构攸关需求是对体系结构产生深远影响的需求（影响了关键体系结构设计决策）。大部分的质量需求和所有的约束就是ASR</p></li><li><p><strong>如何系统地识别ASR和其他因素</strong> 重要</p><ul><li><p><strong>从需求文档中收集 ASR</strong>：可以使用“ MoSCoW”法则或用户故事来收集需求（不过难以收集质量需求 ）,但它对于质量需求的定义是很有限的</p></li><li><p><strong>通过采访涉众来收集 ASR</strong>：可以使用质量属性工作坊（QAW，Quality Attribute Workshop，用于在软件架构初期阶段识别、澄清并优先排序系统的质量属性需求）</p></li><li><p><strong>通过了解业务目标来收集 ASR</strong></p></li><li><p><strong>通过质量属性效能树（Utility Tree）来管理 ASR</strong>：把Utility拆分成质量属性和场景，最后变成指标，叶节点要有两个维度评价：对用户的重要程度和开发难易程度。它以“树”的形式，从高层的质量属性（如性能、安全性）向下展开为更具体的场景，使得系统性分析质量需求变得可视、清晰且可评估。</p><ul><li><img src="image-20250530200152966.png" alt="image-20250530200152966"></li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">    Utility</span><br><span class="hljs-section">       |</span><br><span class="hljs-section">---------------------</span><br>|         |         |<br>性能      安全性     可用性<br><span class="hljs-code">  |         |         |</span><br>首页加载≤2s   拒绝SQL注入   宕机≤5分钟<br><span class="hljs-code"> (重要5/难度2) (重要4/难度3) (重要5/难度4)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><ul><li><strong>架构模式</strong> Architecture pattern 重要<ul><li>定义：架构模式是在实践中反复发现的一套设计决策，具有允许重复使用的已知属性，并且描述了一类架构</li><li>架构模式关联了如下三种角色：<ul><li>上下文(Context)：世界上经常发生问题的场景。</li><li>问题(Problem)：在给定上下文中出现经过适当概括的问题。</li><li>解决方案(Solution)：针对问题的成功的经过适当抽象的解决方案。</li></ul></li></ul></li><li><strong>分类</strong> 重要<ul><li>模块化模式 Module Patterns<ul><li>特指开发态（静态）</li><li>例如：分层模式 layered pattern、微内核模式 micro-kernel pattern</li></ul></li><li>组件-连接器模式 Component-Connector(C&amp;C) Patterns<ul><li>倾向于描述运⾏态（动态）</li><li>其中 Component 可以连接 1 对多的关系，Connector 只能连接⼀对⼀的关系</li><li>例如：中继器模式 Broker Pattern、MVC 模式、管道-过滤器模式 Pipe-Filter Pattern、客户端-服务端 client-server 模式、P2P 模式、服务优先模式 service-oriented pattern、发布-订阅模式 publish-subscribe pattern、共享数据模式 share-data pattern 、SOA 模式</li></ul></li><li>分配模式 Allocation Patterns<ul><li>把软件的元素部署&#x2F;分配到⾮软件的环境当中</li><li>⽐如：<ul><li>Map-reduce Pattern：充分引⼊并⾏，在不同计算资源上部署</li><li>Multi-tier Pattern：把⼀组运⾏在相同计算资源上的元素进⾏不同的组合（逻辑关系）</li></ul></li></ul></li></ul></li></ul><h3 id="分层模式"><a href="#分层模式" class="headerlink" title="分层模式"></a>分层模式</h3><ul><li><p>概述</p><ul><li>分层模式用来构造可以分解为子任务组的程序，每个子任务组都处于一个特定的抽象级别，每层都为下一个提供更高层次的服务。分层模式的关键点在于<strong>确定依赖</strong>，核心是<strong>关注点分离</strong>（必须逐层访问）</li><li>上下文：一般桌面应用、 Web（OSI的七层网络模型）</li><li>优点：高内聚、松耦合、易于维护</li><li>缺点：降低系统的性能，导致级联修改增加开发成本</li></ul></li><li><p>分层模式变体</p><ul><li><img src="image-20250529202144119.png" alt="image-20250529202144119"></li></ul></li><li><p>微内核模式：</p><ul><li><p>微内核架构（Microkernel Architecture），也被称为插件化架构（Plugin-in Architecture），是一种面向功能进行拆分的可扩展架构。</p></li><li><p>微内核架构包含两类核心的组件：核心系统（Core System）和插件模块（Plug-in modules）。核心系统负责与具体功能无关的通用功能，例如应用生命周期的管理、插件模块的管理；插件模块负责实现具体的功能，每个模块都通过插件实现，每一个插件都只做一件事情。</p></li><li><img src="v2-03b6d52599d7a97b4362ca83bbffd96d_r.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>概述<ul><li>Broker Pattern，属于组件-连接器模式</li><li>代理体系结构模式可以用于构建分布式软件系统，其中具有通过RMI交互的分离组件，代理组件负责协调通信，如转发请求，以及传输结果和异常。</li><li>上下文：多个同步或异步交互的远程对象组成的系统。</li><li>解决方案：通过提供隔离通讯相关的代理，将系统通信功能与主应用程序分开</li><li>优点：提高了 Client和 Server之间的交互性，提高可伸缩性和可扩展性，整体大集群的性能可能会提高 (QPS等提高 )，但是局部单点性能会下降，多次网络请求、多次匹配，有可能会抵消。</li><li>缺点：代理增加前期复杂度 、 可能成为通信的屏障 、 可能成为安全攻击的目标 、 难以测试。</li></ul></li><li><img src="image-20250529202959043.png" alt="image-20250529202959043"></li></ul><h3 id="模型-视图-控制器模式"><a href="#模型-视图-控制器模式" class="headerlink" title="模型-视图-控制器模式"></a>模型-视图-控制器模式</h3><ul><li>概述<ul><li>MVC： Model，View，Controller</li><li>使用运行时、动态、相互之间的关系来审视，集成到了开发框架中，也是分层架构的变种 （强调模块间约束关系 model不可以直接返回到 controller），分为 model（业务逻辑）、 view（处理用户展示，接收用户操作）、 controller（对用户操作进行处理，将信息通知给model）</li><li>优点：耦合性低，重用性高 ，生命周期成本低，部署快，可维护性高，方便管理</li><li>缺点：没有明确定义，不适于中小型应用程序，增加实现复杂度，视图和控制器过于紧密，视图对模型访问低效</li></ul></li><li>概述图<ul><li><img src="image-20250529203220288.png" alt="image-20250529203220288" style="zoom:80%;" /></li></ul></li></ul><h3 id="管道和过滤模式"><a href="#管道和过滤模式" class="headerlink" title="管道和过滤模式"></a>管道和过滤模式</h3><ul><li>Pipe-and-Filter Pattern，属于组件-连接器模式</li><li>管道和过滤器模式应用在顺序处理结构中，有一系列filter体现依赖关系。</li><li>Filter 相当于 Component，起数据处理、计算作用，每个 Filter 有 input 和多个 output，将数据处理后传递给后续部分。</li><li>Pipe 相当于 Connector，连接 filter，将 output 导入到其他的 filter 的 input 中去，不会独立存在。</li><li>缺点：不适用于互动式系统，过多的过滤器导致大量的计算开销。</li><li>结构图<ul><li><img src="image-20250530103446068.png" alt="image-20250530103446068"></li><li><img src="v2-d01cefd6ccd37b11d6bd6192349a31fb_1440w.jpg" alt="img"></li><li>每一个组件表示filter 连接组件的部分是 pipe，任何一个 filter都依赖于前一个filter的输出（没有其他机会接收外部交互），不适合 交互 的场景（破坏依赖关系）</li></ul></li></ul><h3 id="客户端服务器模式"><a href="#客户端服务器模式" class="headerlink" title="客户端服务器模式"></a>客户端服务器模式</h3><ul><li>Client-Server Pattern 属于组件-连接器模式</li><li>客户端-服务器模型是一种分布式应用程序结构，它在资源或服务（称为服务器）和服务请求者（称为客户端）的提供者之间划分任务或工作负载。客户端和服务器通常通过计算机网络在单独的硬件上进行通信，但客户端和服务器可能位于同一系统中。服务器主机运行一个或多个与客户共享资源的服务器程序。客户端不共享其任何资源，但请求服务器的内容或服务功能。因此，客户端启动与等待传入请求的服务器的通信会话</li><li>包含了两类不同的Component，没有 broker可以动态改变 Client 和 Server 的关系，成对的关系相对固定。</li><li>上下文：Windows的客户端应用（桌面应用）</li><li>缺点：服务器成为性能瓶颈、可能单点失效、决定在哪里实现功能的决定也是复杂的（并且难以修正）</li><li>结构图<ul><li><img src="image-20250530104235595.png" alt="image-20250530104235595" style="zoom: 67%;" /></li><li>ATM验证身份，某一个验证 Server可以给很多设备提供服务</li><li>ATM操作安全监控、 盗刷之类，通过 monitoring可以发现问题找到记录。</li><li>对于银行工作人员，需要添加新的业务，policy发生变化，银行工作人员可以定义ATM的操作</li><li>银行负责安全金融的可以根据ATM、对照用户操作行为是否有安全隐患，多对多</li></ul></li><li>与代理模式(Broker Pattern)的比较<ul><li>Broker也存在 Client和 Server之间的关系 但Client-Server架构导致互操作性有所降低（没有 broker，需要人为制定固定连接），而 CS不采用 broker 可能导致被拦截</li><li>而在小型局域网（互联网还没有普及）时，规模有限，直接联系，性能与安全性平衡可能带来更大的收益。</li></ul></li></ul><h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><ul><li>Peer-to-Peer Pattern 属于组件-连接器模式</li><li>点对点模式中的组件，可能这一时刻为提供者，下一时刻是消费者（对等的）。同时点对点模式不仅仅提供服务，还能提供物流 ，每个 peer可能有一个规定对的连接数。</li><li>上下文：分布式应用程序体系结构，应用于对等体之间划分任务或工作负载。</li><li>缺点：安全性管理、数据持久化、数据&#x2F;服务可用性（availability）、备份、修复更复杂 、 小型点对点系统不能持续实现质量目标，类似性能（ performance）和可用性(availability)</li><li>结构图<ul><li><img src="image-20250530105059192.png" alt="image-20250530105059192" style="zoom:80%;" /></li><li><strong>安全性</strong>：节点既是Client又是 Server，被攻击的可能性提高。</li><li><strong>可用性</strong>：数据分布在不同节点上，相同数据多处拷贝，可能导致数据不一致 ，但是能保证个别数据出现问题不影响整体。</li><li><strong>性能</strong>：多个节点同时提供服务，性能好</li></ul></li><li>客户端-服务器架构与点对点架构的比较<ul><li>除了客户端-服务器模型之外， 分布式计算应用程序通常使用点对点 (P2P) 应用程序架构。</li><li>在客户端-服务器模型中，服务器通常设计为作为为许多客户端提供服务的集中式系统运行。服务器的计算能力，内存和存储要求必须适当地缩放到预期的工作负载（即同时连接的客户端数量）。负载平衡和故障转移系统通常用于扩展服务器实现</li><li>在点对点网络中，两个或多个计算机（对等体）汇集其资源并在分散的系统中进行通信。 对等体是非分层网络中的同等节点或等效节点。与客户端 -服务器或客户端-队列-客户端 网络中的客户端不同，对等体直接相互通信。在对等网络中，对等通信协议中的算法平衡负载，即使是具有适度资源的对等体也可以帮助共享负载。<strong>如果节点变得不可用，则只要其他节点提供服务，其共享资源就保持可用</strong>。理想情况下，对等体不需要实现享资源就保持可用</li><li>客户端 -服务器和主 -从都被视为分布式对等系统的子类。</li></ul></li></ul><h3 id="面向服务的模式"><a href="#面向服务的模式" class="headerlink" title="面向服务的模式"></a>面向服务的模式</h3><ul><li>Service-Oriented Pattern SOA，属于组件-连接器模式</li><li>面向服务的体系结构（SOA）是一种软件设计风格，其服务通过应用程序组件，通过网络上的通信协议提供给其他组件。</li><li>面向服务的体系结构的基本原则独立于供应商，产品和技术。服务是一个独立的功能单元，可以远程访问并独立操作和更新</li><li>缺点：构建复杂 、无法管理独立服务的演化 、服务可能成为性能瓶颈（无法提供性能保障）、使用中间件导致的性能开销</li><li>结构图<ul><li><img src="image-20250530110643885.png" alt="image-20250530110643885" style="zoom: 50%;" /></li><li>SOAP（简单对象访问协议）：服务提供者和提供者通过 通常在 HTTP之上交换请求&#x2F;答复XML消息进行交互。</li><li>REST（代表性状态传输协议）：服务使用者依赖于四个基本状态（ POST、 GET、PUT、 DELETE）的 HTTP请求的 REST</li><li>异步消息传递（即发即忘）：参与者不必等待确认。</li></ul></li><li>SOA和其他架构的区别<ul><li>SOA具备 Broker的优势（而又不继承Broker）</li><li>SOA具有更高的互操作性和更高的伸缩性</li><li>出现类似基础设施的组件（代替单一节点 broker），解决单点失效的问题，满足互联网普及、参与人数规模较大的问题。</li><li>符合商业模式的变化与技术可用性</li></ul></li></ul><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><ul><li>Publish-Subscribe Pattern，属于组件-连接器模式</li><li>在软件体系结构中 ，发布 -订阅是一种消息模式 ，其中消息的发送者（称为发布者）不将消息直接发送到称为订阅者的特定接收者，而是将发布的消息送到连接器中（不知道有哪些订阅者）。类似地，订阅者表达对一个或多个类的兴趣并且仅接收感兴趣的消息，会接受到连接器的通知，而不知道哪些发布者（如果有的话）存在。</li><li>优点：松耦合、可伸缩性、此模式提供更高的网络可扩展性和更动态的网络拓扑从而降低了修改发布者和已发布数据结构的代价。</li><li>缺点：通常会增加延迟并对消息传递时间的可伸缩性和可预测性产生负面影响。对消息排序的控制较少，并且不保证消息的传递。</li><li><img src="image-20250530111230616.png" alt="image-20250530111230616" style="zoom:67%;" /></li></ul><h3 id="共享数据模式"><a href="#共享数据模式" class="headerlink" title="共享数据模式"></a>共享数据模式</h3><ul><li>Shared-Data Pattern，属于组件-连接器模式</li><li>一致性实现：最终一致性（不保证任何时间数据访问都一致但是保证最终结果要一致）、互联网不可能牺牲可用性来保障一致性保障一致性（信号要求高），因此设计难度非常大</li><li>缺点：共享数据模型可能存在性能瓶颈、可能存在单点失效、数据的生产者和消费者紧密耦合、中心点被攻击有安全风险</li><li><img src="image-20250530111902992.png" alt="image-20250530111902992" style="zoom:50%;" /></li></ul><h3 id="分配模式"><a href="#分配模式" class="headerlink" title="分配模式"></a>分配模式</h3><ul><li>Map-Reduce Pattern</li><li>Map负责对数据进行抽取所需的信息，完成信息转换。可以有很多个 Map，每个Map处理的数据工作内容不一 样 ，他们互相独立运行。 Reduce负责进行合并，产出最终的答案。</li><li>典型示例（词频统计）：每个Partition对应一个 Map，每个 Map分别完成词汇词频的统计，最后由 Reduce合并后进行排序。</li><li>缺点：如果没有足够大的数据集，那么 Map-Reduce的开销是不能被接受的；如果不能将数据集切分成相似大小，那么并行的好处会消失；多次归纳是难以编排的。</li><li><img src="image-20250530122749200.png" alt="image-20250530122749200"></li></ul><h3 id="多层模式"><a href="#多层模式" class="headerlink" title="多层模式"></a>多层模式</h3><ul><li><p>Multi-Tier Pattern 分配模式</p></li><li><p>Layer是真实存在的，<strong>这里的层是逻辑的组合，没有层次模式的强依赖关系</strong>，在不同的部署环境中分层不同，但是软件完成内容一致。</p></li><li><p>许多系统的执行结构被组织成一组逻辑组件。每个分组被称为一个层。将组件分组到层中可能基于各种标准，例如组件的类型、共享相同的执行环境或具有相同的运行时目的。</p></li><li><p>上下文：旅行社</p></li><li><p>缺点：大量的前期成本和复杂性。</p></li><li><p>结构图</p><ul><li><img src="image-20250530123151554.png" alt="image-20250530123151554"></li><li>三大类Modular类、 Runtime Process动态类、 软件和非软件环境关系（部署关系）</li></ul></li><li><p><strong>多层模式和分层模式比较</strong> 重要</p><ul><li><p><strong>分层模式（Layered Pattern）</strong>：强调<strong>软件职责的逻辑分离</strong>，主要是<strong>程序结构内部</strong>的组织方式。</p></li><li><p><strong>多层模式（Multi-Tier Pattern）</strong>：强调<strong>部署结构的物理分离</strong>，主要是<strong>系统运行时在物理环境中的分布方式</strong>。</p></li></ul><table><thead><tr><th>对比项</th><th>分层模式（Layered）</th><th>多层模式（Multi-Tier）</th></tr></thead><tbody><tr><td>关注点</td><td><strong>逻辑结构、职责划分</strong></td><td><strong>物理结构、部署分布</strong></td></tr><tr><td>表现形式</td><td><strong>在同一进程中组织不同的逻辑层</strong></td><td><strong>不同层运行在不同服务器或容器中</strong></td></tr><tr><td>交互方式</td><td>方法调用（in-process）</td><td>网络通信（HTTP&#x2F;RPC）</td></tr><tr><td>举例</td><td>DDD 的四层架构、Spring MVC 结构等</td><td>Web客户端 + Nginx + Java服务 + MySQL 等</td></tr><tr><td>通常的关系</td><td>分层模式是多层模式的<strong>逻辑基础</strong></td><td>多层模式是分层模式的<strong>物理体现</strong></td></tr></tbody></table></li></ul><h3 id="架构模式-vs-策略-Tactics"><a href="#架构模式-vs-策略-Tactics" class="headerlink" title="架构模式 vs 策略 Tactics"></a>架构模式 vs 策略 Tactics</h3><ul><li><strong>pattern和tactic的关系</strong> 重要<ul><li>策略比模式更简单；它们使用单一结构或机制来应对单一架构力量。</li><li>模式通常将多个设计决定组合成一个包。</li><li>模式和策略共同构成软件架构师的主要工具。</li><li>策略是创建架构模式的设计“构件”。</li><li>大多数模式由几种不同策略组成，这些策略可能：<ul><li>都服务于一个共同目的，</li><li>常常被选择以实现不同质量属性的平衡。</li></ul></li></ul></li></ul><h2 id="4-属性驱动设计-ADD"><a href="#4-属性驱动设计-ADD" class="headerlink" title="4. 属性驱动设计 ADD"></a>4. 属性驱动设计 ADD</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li><p>软件架构生命周期</p><ul><li><img src="image-20250530142622943.png" alt="image-20250530142622943" style="zoom:67%;" /></li></ul></li><li><p>ADD 3.0核心概念</p><ul><li><p>Design Purpose（设计目的）</p><ul><li>ADD 从设计的目标出发，比如你是为了新系统架构、旧系统演化，或者为了满足某个质量属性（如性能或可扩展性）进行架构设计。</li></ul></li><li><p><strong>Drivers（驱动因素）</strong> 重要，要会分析</p><ul><li><strong>功能需求（Functional Requirements）</strong>：系统应该做什么。</li><li><strong>质量属性（Quality Attributes）</strong>：性能、可用性、安全性、可维护性等非功能需求。</li><li><strong>约束（Constraints）</strong>：比如成本和时间、部署在特定平台、采用某种协议等。</li></ul></li><li><p>Module Types（模块类型）</p><ul><li><strong>Component-and-Connector（C&amp;C）</strong>：关注运行时交互（如微服务、进程、线程、消息通道等）</li><li><strong>Module</strong>：关注代码静态结构（如类、包、库等）</li><li><strong>Allocation</strong>：关注模块与部署环境的映射（如进程到服务器）</li></ul></li><li><p>Decomposition（分解）</p><ul><li>根据驱动因素，决定如何将系统分解为子系统或模块。需要明确每个模块的职责、接口、交互方式。每次分解主要考虑：</li><li>模块的功能划分<ul><li>哪些质量属性受到影响</li><li>如何满足这些质量属性（采用哪些架构策略，如缓存、负载均衡、容错等）</li><li>如何分配资源和约束（如部署、语言、协议等）</li></ul></li></ul></li><li><p>Design Decisions（设计决定）</p><ul><li>ADD 强调<strong>记录每一个设计决定</strong>，包括：</li><li>决定内容<ul><li>解决的问题</li><li>所依据的质量属性或约束</li><li>所评估的备选方案</li></ul></li></ul></li><li><p>Architecture Views（架构视图）</p><ul><li><strong>模块视图（Module View）</strong>：体现代码结构</li><li><strong>组件-连接器视图（C&amp;C View）</strong>：体现运行时结构</li><li><strong>分配视图（Allocation View）</strong>：体现物理部署结构</li></ul></li><li><p><strong>Iteration（迭代）</strong> 重要，会分析迭代目标</p><ul><li><p>ADD 是一个<strong>迭代式过程</strong>，每次迭代：</p><ul><li>选择一个模块</li><li>分析其驱动因素</li><li>应用架构策略进行分解</li><li>记录设计决策和产生的架构视图</li></ul></li><li><p>这个过程不断重复，直到系统架构满足所有需求，或达到合理的粒度。</p></li></ul></li></ul></li><li><p>ADD步骤 （ADD 3.0）</p><ul><li><img src="image-20250530144434061.png" alt="image-20250530144434061"></li><li>第一步：<strong>回顾输入</strong>。确认主要功能和质量属性场景需要已经按照优先级排序，如果没有就QAW和效能树等方式确定。检查在最初的需求获取（分析）过程中是否有任何重要的利益相关者被遗漏。检查自优先级排序完成以来，业务条件是否发生了变化</li><li>第二步：<strong>通过选择驱动因素建立迭代目标</strong>。将复杂系统“分解”成可设计的部分，并明确当前迭代的关注点（驱动因素）。系统被分解为子模块，选择一个子模块实现。驱动因素包括关键子系统或组件，高优先级的质量属性场景（如高并发登录模块），和有明确风险或不确定性的部分。</li><li>第三步：<strong>选择一个或多个系统要素来完善</strong>。从上一步选出的子模块中，挑选出要进行设计或细化的系统元素</li><li>第四步：<strong>选择一个或多个满足驱动因素的架构策略</strong>。</li><li>第五步：<strong>分解该模块，并定义其接口和交互</strong>。</li><li>第六步：<strong>记录设计决定和构建架构视图</strong>。将每一步的设计结果形成结构化文档和架构视图。</li><li>第七步：<strong>评估设计结果是否满足驱动因素</strong>。如果有必要回到第二步进行多轮迭代</li></ul></li><li><p><strong>设计决定中要考虑的因素</strong> 重要：responsibility职责、Coodination协作、操作与服务的mapping、Data和Resources的管理、binding time确定时间（该部分开发完成不再修改）</p></li></ul><h3 id="架构文档化"><a href="#架构文档化" class="headerlink" title="架构文档化"></a>架构文档化</h3><ul><li><p>为什么要文档化架构</p><ul><li>即使是最好的架构，如果需要架构的人不知道它是什么或不能有效理解并使用它，那么它就是无用的</li><li>架构团队所有工作、设计、分析都会是无用的</li></ul></li><li><p>架构文档化要求</p><ul><li>文档要足够透明易懂以被使用者快速理解</li><li>文档要足够具体，以作为开发的蓝图</li><li>信息要足够充分，以作为分析的基础</li></ul></li><li><p>Notation</p><ul><li>在软件架构文档化中，<strong>Notation（表示法、符号体系）<strong>是指用来</strong>表达架构元素、它们之间关系、交互和行为的可视化符号或语法</strong></li><li>分类<ul><li>Informal Notations（非正式表示法）：使用通用绘图工具绘制，没有正式语法规则，<strong>不能进行自动化分析</strong>。</li><li>Semiformal Notations（半正式表示法）：有标准图形符号和构图规则（比如 UML），没有完整的形式语义，因此<strong>分析能力有限</strong></li><li>Formal Notations（正式表示法）：使用有严格数学语义的语言来描述架构，可以进行<strong>形式化分析和验证</strong></li></ul></li></ul></li><li><p>Views 视图</p><table><thead><tr><th>视图类型</th><th>Elements</th><th>Relations</th><th>Constraints</th><th>Usage</th></tr></thead><tbody><tr><td><strong>Module View</strong></td><td>类、模块、包、接口</td><td>静态依赖、包含、实现</td><td>模块层次、依赖方向、封装</td><td>开发构建、代码组织、接口定义</td></tr><tr><td><strong>C&amp;C View</strong></td><td>组件、连接器（进程、服务、通信机制）</td><td>调用、数据流、事件传播</td><td>通信路径、服务可访问性</td><td>运行时交互、通信机制设计、性能分析</td></tr><tr><td><strong>Allocation View</strong></td><td>软件单元、物理节点、平台资源</td><td>部署关系、物理链接</td><td>性能、安全、部署限制</td><td>部署架构、资源映射、运维支持</td></tr></tbody></table><ul><li><p>质量视图 Quality Views：安全视图、性能视图、可靠性视图、沟通视图、异常（错误处理）视图</p></li><li><p>组合视图 Combining Views：包括各种 C&amp;C视图、带有 SOA或通信进程视图的部署视图、分解视图和任何工作分配、实施、使用或分层视图。</p></li></ul></li><li><p>如何选择视图</p><ul><li>第一步：构建涉众&#x2F;视图表。行为涉众，列为视图，格子填写涉众对视图的细节了解程度。</li><li>第二步：合并视图。识别涉众&#x2F;视图表中的边缘视图，通过关联一个视图中的元素和另一个视图中的元素 ，将每个边缘视图与另一个具有更强表示能力的视图相结合。</li><li>第三步：确定优先级和完成阶段。</li></ul></li><li><p>架构文档中应该包含 View 和 Beyond 部分，还有系统行为。</p></li><li><p>如何文档化视图</p><ul><li>使用视图模板，包括五个部分</li><li>第一部分：主要介绍，显示视图的元素和关系 ，以及图例</li><li>第二部分：元素介绍 ，详细介绍第一部分中描述的元素、元素属性、关系属性和元素接口和行为</li><li>第三部分：上下文图，描述系统如何与环境相关</li><li>第四部分：可变性指南，告知视图中可能发生的变化</li><li>第五部分：基本原理，为什么设计反映在视图中，并且说明其合理性</li></ul></li><li><p>文档化视图之外的部分(Beyond)</p><ul><li>⽂档路线图：包含了范围和总结、简单摘要等</li><li>视图的⽂档组织⽅式：描述了本⽂档中视图是如何组织的</li><li>系统概述：从整体上描述了当前架构的简要说明、业务⽬标（驱动因素）等等</li><li>视图之间的映射关系：描述了不同视图之间的映射关系</li><li>系统原理：从整体上描述了当前架构的设计原理</li><li>⽬录-索引、词汇表、⾸字⺟缩略词表</li></ul></li><li><p>文档化系统行为</p><ul><li>行为文档化可以通过描述元素之间的交互关系来补充视图</li><li>可用的工具：用例图、顺序图、通信图、活动图、信息顺序图、时间图、状态机</li></ul></li></ul><h2 id="5-微服务架构"><a href="#5-微服务架构" class="headerlink" title="5. 微服务架构"></a>5. 微服务架构</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>主流架构风格<ul><li><img src="image-20250530162639760.png" alt="image-20250530162639760"></li></ul></li><li>单体架构<ul><li>单体(Monolithic) 架构：单体应用的全部功能被集成在一起作为一个统一的单元，更多作为应用部署架构。</li><li>通信方式：进程间通信、方法间调用，无需网络调用</li><li>事务管理：单一数据库，所有事务单一上下文，事务提交和回滚操作简单</li><li>好处：易于开发、修改、测试、部署、伸缩(多个实例负载均衡)</li><li>问题：系统过于复杂、开发速度慢、难以扩展、可靠性差</li></ul></li><li>分层架构<ul><li>对复杂系统进行抽象和分层、结构化设计的架构方案</li><li>垂直架构（结构简单，易于组织开发、测试和维护）<ul><li>表现层、业务层、（持久层）、数据层</li><li><img src="image-20250530163124749.png" alt="image-20250530163124749" style="zoom: 50%;" /></li></ul></li></ul></li><li>面向服务架构 SOA<ul><li>面向服务架构是一个分布式组件的集合，这些组件为其他组件提供服务或者消费其他组件提供的服务，而无需知道其他组件的细节。</li><li>企业服务总线（ESB）为服务间相互调用提供支持环境，路由服务间信息，并对信息和数据进行必要转换。</li><li>服务编排引擎（Orchestration Engine）可以根据预定义的脚本对服务消费者与服务提供者之间交互进行指挥。</li><li><img src="image-20250530163341259.png" alt="image-20250530163341259" style="zoom:150%;" /></li><li>面向服务架构实现原则：<ul><li>服务契约：服务按照描述文档所定义的服务契约行事</li><li>服务封装：除了服务契约所描述内容，服务将对外部隐藏实现逻辑</li><li>服务重用：将逻辑分布在不同的服务中，以提高服务的重用性</li><li>服务组合：一组服务可以协调工作，组合起来形成定制组合业务需求</li><li>服务自治：服务对所封装的逻辑具有控制权</li><li>服务无状态：服务将一个活动所需保存的资讯最小化</li></ul></li></ul></li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul><li><p>定义：微服务架构是把应用程序功能性分解为一组服务的架构风格，每一个服务都是由一组专注、内聚的功能职责组成。</p></li><li><p>例子：电商平台和外卖平台</p><ul><li><img src="image-20250531122914808.png" alt="image-20250531122914808" style="zoom:40%;" /></li><li><img src="image-20250531122934220.png" alt="image-20250531122934220" style="zoom:50%;" /></li></ul></li><li><p><strong>主要特性</strong> 重要，会考简答</p><ul><li>服务组件化</li><li>围绕业务能力组织</li><li>内聚和解耦</li><li>去中心化：微服务治理、数据存储、数据管理</li><li>基础设施自动化</li><li>服务设计与演进：高可用设计、演进式设计</li></ul></li><li><p>与SOA对比</p><ul><li><img src="image-20250530164414125.png" alt="image-20250530164414125"></li></ul></li><li><p>微服务架构的问题</p><ul><li>服务的拆分和定义（粒度问题）：如何拆？怎么评估？</li><li>分布式系统带来的复杂性<ul><li>进程间通信机制复杂性高于方法调用、局部故障</li><li>跨服务的事务和查询</li><li>编写包含多项服务在内的自动化测试</li><li>运维复杂性（自动化部署工具、产品化PaaS平台、Docker容器编排平台）</li><li>部署跨服务的功能需要协调更多开发团队</li></ul></li></ul></li><li><p>微服务架构的核心设计模式</p><ul><li>模式 pattern：针对特定上下文中发生的问题的可重用解决方案</li><li>核心模式：针对采用微服务系统在特定场景下的特定问题所使用的程序的架构解决方案的集合。</li></ul></li><li><p>核心模式——微服务的拆分和定义</p><ul><li><p>问题：如何将应用拆分为微服务？</p></li><li><p>需求：</p><ul><li>高内聚：实现一组密切相关的功能</li><li>松耦合：封装内部细节，API交互</li><li>单一职责原则（SRP）</li><li>共同封闭原则（CCP）</li></ul></li><li><p><strong>步骤：定义系统操作-&gt;定义微服务（围绕业务概念）-&gt;定义服务API和协作方式 重点</strong></p><ul><li><p>定义系统操作：将需求提炼为系统必须处理的关键请求，由抽象的领域模型定义</p><ul><li><p>输入：需求，用户故事&#x2F;相关用户场景&#x2F;源代码恢复等</p></li><li><p>流程：创建领域模型-&gt;确定系统操作</p></li><li><p>补充：领域模型</p><ul><li><p>领域模型是对领域内概念类或现实世界中对象的可视化表示，也称为概念模型。领域模型被描述为一组没有定义操作的类图，是对真实世界中概念类的表示，而不是软件对象的表示</p></li><li><img src="image-20250602174120502.png" alt="image-20250602174120502" style="zoom:50%;" /></li></ul></li></ul></li><li><p>定义微服务：根据业务能力、子域（<strong>涉及DDD，领域驱动设计，会考</strong>）、动静态调用关系进行拆分</p><ul><li><p>根据业务能力拆分：业务架构建模的术语</p><ul><li><p>业务能力是企业产生价值的商业活动，较为稳定</p></li><li><p>能力可分解为子能力</p></li><li><img src="image-20250531124625876.png" alt="image-20250531124625876" style="zoom: 67%;" /></li></ul></li><li><p>子域见下面的补充</p></li><li><p>根据动静态调用关系拆分</p><ul><li>收集单体应用动静态调用信息，构建有向带权图（调用频率、变更频率等），最后基于聚类算法拆分</li><li>静态：用例分析、字节码解析、API接口</li><li>动态：调用链路、数据流图、控制流图</li></ul></li></ul></li><li><p>定义服务API和协作方式：将标识的系统操作分配给服务，独立或与其他服务协作（涉及通信方式）实现操作</p></li></ul></li></ul></li><li><p>核心模式——服务注册与发现：服务消费者获取服务提供者的机制 ，以实现两者间的解耦服务发现组件</p></li><li><p>核心模式——API网关： 所有客户端的单一入口点，针对不同客户端提供不同的 API，解决了微服务结构的应用客户端如何访问各项服务。</p></li><li><p>核心模式——断路器（Circuit Breaker）：避免任何服务或网络出现问题导致的级联故障</p><ul><li>闭合状态：请求直接引起方法调用</li><li>断开状态：请求立即返回错误响应</li><li>半断开状态：允许一定数量的请求调用，如成功则切换到闭合状态，否则切换到断开状态。</li></ul></li></ul><h3 id="补充：领域驱动设计"><a href="#补充：领域驱动设计" class="headerlink" title="补充：领域驱动设计"></a>补充：领域驱动设计</h3><blockquote><p>会结合微服务架构的微服务拆分定义核心模式考</p></blockquote><ul><li>概念：以业务领域为中心进行建模和开发，使技术服务于业务目标。</li><li>核心理念</li></ul><table><thead><tr><th>核心理念</th><th>说明</th></tr></thead><tbody><tr><td><strong>关注领域（Domain）</strong></td><td>系统的核心是业务逻辑，而不是技术实现。</td></tr><tr><td><strong>模型驱动设计（Model）</strong></td><td>使用统一的“模型”作为沟通工具，贯穿分析、设计、实现。</td></tr><tr><td><strong>与专家密切合作</strong></td><td>持续与领域专家沟通，提炼出通用语言（Ubiquitous Language）</td></tr></tbody></table><ul><li>DDD架构<ul><li><img src="image-20250530171428382.png" alt="image-20250530171428382"></li><li><strong>领域层是重中之重</strong>，业务核心逻辑应尽可能集中于此</li></ul></li><li><strong>DDD与微服务架构</strong> 非常重要，一定会考大题<ul><li>微服务架构中的微服务拆分核心模式中，可以根据子域拆分，用到了DDD</li><li>DDD解决复杂软件业务领域范围&#x2F;业务边界划分的问题，它从业务出发，以面向对象和领域模型为核心</li><li>领域：描述问题域，一种特定的范围，电商、外卖、保险…</li><li>子域是领域的细分，例如电商中的订单、商品、物流</li><li>领域分为核心域、通用域、支撑域</li><li>领域模型：以解决具体问题的方式包含一个领域的知识</li><li>限界上下文：领域模型的边界，包括实现模型的代码集合，对应微服务架构中一个或一组服务</li><li>统一语言：定义领域内相关团队的词汇表，统一、简单、清晰、准确描述业务规则和业务</li><li>DDD流程<ul><li>将问题域逐级细分，降低理解和实现的复杂度</li><li>从业务需求中提炼统一语言</li><li>战略设计：<ul><li>构建领域模型，识别限界上下文，确定领域边界</li><li>上下文映射建立领域间关系</li><li>划分（微）服务的逻辑和物理边界</li></ul></li><li>战术设计：限界上下文内领域建模，指导程序设计、编码和重构</li></ul></li></ul></li></ul><h3 id="补充：微服务部署和运维模式和策略"><a href="#补充：微服务部署和运维模式和策略" class="headerlink" title="补充：微服务部署和运维模式和策略"></a>补充：微服务部署和运维模式和策略</h3><blockquote><p>可能会考一个小题</p></blockquote><ul><li>部署模式<ul><li>单主机部署多个服务实例<ul><li>在主机（物理机或虚拟机）上运行不同服务的多个实例</li><li>优点：资源利用率相对较高</li><li>缺点：资源需求冲突、依赖冲突、难以监控和限制每个实例资源消耗</li></ul></li><li>单主机部署单个服务实例<ul><li>在自己的主机上部署单个服务实例</li><li>优点：服务实例彼此隔离，无冲突，监控管理简单</li><li>缺点：资源利用效率可能较低</li></ul></li><li>将服务部署到虚拟机<ul><li>将服务打包为虚拟机镜像，并将每个服务实例部署为单独的VM</li><li>优点：通过增加实例数量来扩展服务很简单；构建服务的技术细节封装好；服务隔离性好</li><li>缺点：资源利用效率低，部署慢，系统管理开销（操作系统、运行补丁）</li></ul></li><li>将服务部署到容器<ul><li>将服务打包为 (Docker) 容器镜像并将每个服务实例部署到容器</li><li>优点：更改容器实例的数量可以管理服务数量；构建服务的技术细节封装好；服务隔离性好；<strong>容器的构建和启动速度非常快</strong></li><li>缺点：大量的容器镜像管理工作</li></ul></li><li>服务部署平台<ul><li>使用部署平台作为应用程序部署的自动化基础设施，如K8s</li></ul></li><li>无服务器部署<ul><li>使用公有云提供的serverless部署机制部署服务。将服务的代码打包到一个 ZIP 文件中，将其上传到 AWS Lambda</li><li>优点：AWS服务集成简单；消除系统管理任务；弹性伸缩</li><li>缺点：配置和启动应用慢，某些请求延迟高</li></ul></li><li><img src="image-20250531144609140.png" alt="image-20250531144609140"></li></ul></li><li>可观测性模式（维护）<ul><li>日志聚合<ul><li>使用集中式日志记录服务聚合来自每个服务实例的日志</li><li>缺点：处理大量日志需要大量的基础设施</li></ul></li><li>审计日志<ul><li>向业务逻辑中添加审计日志代码，创建审核日志条目并保存在数据库中</li><li>优点：提供用户操作的记录</li><li>缺点：审计代码与业务逻辑交织，使业务逻辑复杂化</li></ul></li><li>应用程序指标<ul><li>检测服务以收集有关各个操作的统计信息，在集中式指标服务中聚合指标，提供报告和警报（相当于用一个专门的服务来检测其他服务）</li><li>优点：提供对应用程序行为的深入洞察</li><li>缺点：指标代码与业务逻辑交织在一起，使其更加复杂；需要大量的基础设施</li></ul></li><li>分布式跟踪<ul><li>为每个外部请求分配ID，记录请求范围以内的信息，并在集中式服务器中跟踪它</li><li>优点：方便查看某个请求的处理路径，发现延迟来源</li><li>缺点：聚合和存储追踪数据可能需要大量的基础设施</li></ul></li><li>异常跟踪<ul><li>向集中式异常跟踪服务报告所有异常，该服务聚合和跟踪异常并通知开发人员</li><li>优点：更容易查看异常并跟踪其解决方案</li><li>缺点：额外的基础设施</li></ul></li><li>健康检查API<ul><li>服务具有&#x2F;health返回服务健康状况的健康检查 API端点，可以定期“ping”调用端点来检查服务实例的健康状况</li><li>优点：定期测试服务实例的健康状况</li><li>缺点：不全面，服务实例可能在健康检查之间失败</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件系统设计</tag>
      
      <tag>软件架构</tag>
      
      <tag>质量属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式八股</title>
    <link href="/2025/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="8-分布式"><a href="#8-分布式" class="headerlink" title="8. 分布式"></a>8. 分布式</h2><ul><li>CAP理论<ul><li><strong>一致性(C) :</strong> 在分布式系统中的所有数据备份, 在同一时刻是否同样的值</li><li><strong>可用性(A):</strong> 在集群中一部分节点故障后, 集群整体是否还能响应客户端的读写请求</li><li><strong>分区容忍性(P):</strong> 以实际效果而言, 分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性, 就意味着发生了分区的情况，需要在C和A里选择</li><li>Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）, 三者不可得兼</li><li><img src="https://cdn.xiaolincoding.com//picgo/1735888630256-ee5fbbb2-811d-411d-91e4-5976c72daf2a.webp" alt="img" style="zoom:50%;" /></li></ul></li><li>Zookeeper<ul><li>zookeeper是 <strong>分布式协调服务</strong>，它能很好地支持集群部署，并且具有很好的分布式协调能力，可以让我们在分布式部署的应用之间传递数据， 保证 <strong>顺序一致性（全序广播）</strong> 而不是强一致性</li><li>zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</li><li>数据模型<ul><li>永久节点：节点创建后，不会因为会话失效而消失</li><li>临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点</li><li>顺序节点：创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</li></ul></li><li>监视器：当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时watch会触发，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次</li><li>应用场景<ul><li><strong>配置管理</strong>：将不同节点相同的配置信息（如数据库连接参数、服务端口等）集中存储，当配置发生变更时，能及时通知到各个节点</li><li><strong>服务注册与发现</strong>：服务提供者在启动时将自己的服务信息（如服务名称、地址、端口等）注册到 ZooKeeper 中，服务消费者通过 ZooKeeper 查找并获取服务提供者的信息。并且服务信息变化时zookeeper会及时更新</li><li><strong>分布式锁</strong>：在分布式环境下，多个进程或线程可能会竞争同一资源，为了避免数据不一致等问题，需要实现分布式锁</li></ul></li></ul></li><li>分布式锁的实现方式<ul><li>第一种：用redis实现（见Redis部分）</li><li>第二种：用zookeeper实现。利用Zookeeper的临时顺序节点和监听机制两大特性，可以帮助我们实现分布式锁。首先有一个持久节点<code>/locks</code>, 请求进来时首先在<code>/locks</code>创建临时有序节点，然后判断当前创建得节点是不是<code>/locks</code>路径下面最小的节点，如果是，获取锁，不是，阻塞线程，同时设置监听器，监听前一个节点。获取到锁以后，开始处理业务逻辑，最后delete当前节点，表示释放锁。后一个节点就会收到通知，唤起线程，重复上面的判断。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1728721036831-d9c8124c-b9ac-4490-92c6-2e52e5636c55.png" alt="img"></li></ul></li><li>RPC<ul><li>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</li><li>步骤：客户端调用-&gt;请求发送(序列化) -&gt; 服务器接受并处理(反序列化) -&gt; 结果返回(序列化) -&gt; 客户端接收结果(反序列化)</li><li>常见的 RPC 框架：gRPC、Thrift、Dubbo</li></ul></li><li>分布式限流算法<ul><li>滑动窗口限流算法：将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。在窗口内对请求计数，超过阈值的丢弃</li><li>漏桶限流算法：按顺序一个个处理请求，新的请求占满桶后再来就丢弃</li><li>令牌桶限流算法：模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Zookeeper</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列八股</title>
    <link href="/2025/05/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="7-消息队列"><a href="#7-消息队列" class="headerlink" title="7. 消息队列"></a>7. 消息队列</h2><ul><li>消息队列是一个<strong>使用队列来通信</strong>的组件。它的本质，就是个<strong>转发器</strong>，包含<strong>发消息、存消息、消费消息</strong>的过程。</li><li><img src="image-20250427091223499.png" alt="image-20250427091223499" style="zoom:80%;" /></li><li>消息队列使用的场景<ul><li><strong>解耦</strong>：在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，这样项目之间不会存在耦合，系统之间不会产生太大的影响</li><li><strong>异步</strong>：把不需要同步的操作放入MQ，可加快系统的访问速度，提供更好的客户体验</li><li><strong>削峰</strong>：如果流量太大导致系统、数据库可能会崩溃，可以使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，可以保证系统的稳定</li></ul></li><li>防止消息重复消费的方法：业务端自己做控制，对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</li><li>保证幂等性<ul><li>唯一标识（幂等键）：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</li><li>数据库事务 + 乐观锁：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作</li><li>数据库唯一约束：利用数据库唯一索引防止重复数据写入，适用场景数据插入场景（如订单创建）</li><li>分布式锁：通过锁机制保证同一时刻仅有一个请求执行关键操作</li><li>消息去重：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID是否已经处理过，如果已经处理过则丢弃该消息</li></ul></li><li>消息队列处理阶段<ul><li><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142107477.png" alt="image-20250407142107477" style="zoom: 40%;" /></li><li><strong>消息生产阶段</strong>：从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件）的 ack 确认响应，就表示发送成功，返回异常则进行消息重发。</li><li><strong>消息存储阶段</strong>：Kafka 在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，其中一个节点挂了不会影响整个系统</li><li><strong>消息消费阶段</strong>：消费者接收消息+消息处理之后，才回复 ack 。消息队列只有收到确认后，才会将消息从队列中移除。</li></ul></li><li>消息积压解决方案：优化处理逻辑，批量处理消息；考虑水平扩容，增加Topic的队列数和消费组机器的数量</li><li>事务消息<ul><li><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142122992.png" alt="image-20250407142122992" style="zoom: 40%;" /></li></ul></li><li>Kafka的优缺点<ul><li>优点：Kafka的最大优势就在于它的高吞吐量、高并发，在普通机器4CPU8G的配置下，一台机器可以抗住十几万的QPS。Kafka支持集群部署，如果部分机器宕机不可用，则不影响Kafka的正常使用。kafka集群支持热扩展，可扩展性好。Kafka中消息被持久化到本地磁盘，保证可靠性。</li><li>缺点：Kafka有可能会造成数据丢失，因为它在收到消息的时候，并不是直接写到物理磁盘的，而是先写入到磁盘缓冲区里面的。Kafka功能比较单一，主要就是支持收发消息，高级功能基本没有，就会造成适用场景受限。</li></ul></li><li>RocketMQ优缺点<ul><li>优点：支持功能比较多，比如延迟队列、消息事务等等，吞吐量也高，单机吞吐量达到 10 万级，支持大规模集群部署，线性扩展方便，Java语言开发，满足了国内绝大部分公司技术栈</li><li>缺点：性能相比 kafka 弱一点，因为 kafka 用到了 sendfile 的零拷贝技术，而 RocketMQ 主要是用 mmap+write 来实现零拷贝。</li></ul></li><li>如何实现消息顺序读取<ul><li>RocketMQ采用了局部顺序一致性的机制，实现了单个队列中的消息严格有序。也就是说，如果想要保证顺序消费，必须将一组消息发送到同一个队列中，然后再由消费者进行注意消费</li><li>要在 Kafka 中保证顺序读取消息，需要结合生产者、消费者的配置以及合适的业务处理逻辑来实现。<ul><li>生产者端确保消息顺序：为了保证消息写入同一分区从而确保顺序性，生产者需要将消息发送到指定分区</li><li>消费者端保证顺序消费：消费者在消费消息时，需要单线程消费同一分区的消息，这样才能保证按顺序处理消息</li></ul></li></ul></li><li>Kafka快的原因<ul><li><strong>顺序写入优化</strong>：Kafka将消息顺序写入磁盘，减少了磁盘的寻道时间。</li><li><strong>批量处理技术</strong>：Kafka支持批量发送消息，这意味着生产者在发送消息时可以等待直到有足够的数据积累到一定量，然后再发送。</li><li><strong>零拷贝技术</strong>：Kafka使用零拷贝技术，可以直接将数据从磁盘发送到网络套接字，避免了在用户空间和内核空间之间的多次数据拷贝。</li><li><strong>压缩技术</strong>：Kafka支持对消息进行压缩，这不仅减少了网络传输的数据量，还提高了整体的吞吐量</li></ul></li><li>消费模型<ul><li><strong>推送模型</strong>：基于推送模型（push）的消息系统，由消息代理记录消费者的消费状态。消息代理在将消息推送到消费者后，标记这条消息已经消费，但这种方式无法很好地保证消费被处理。push模式很难适应消费速率不同的消费者</li><li>拉取模型：由消费者自己记录消费状态，每个消费者互相独立地顺序拉取每个分区的消息。这种由消费者控制偏移量的优点是：<strong>消费者可以按照任意的顺序消费消息</strong>。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1717921512808-fb0372de-7ada-4bc4-bfb5-7e599d9335ac.png" alt="img" style="zoom:67%;" /></li><li>kafka 消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition。</li></ul></li><li>Kafka消息积压解决方案：增加消费者实例可以提高消息的消费速度，从而缓解积压问题。增加 Kafka 主题的分区数量可以提高消息的并行处理能力。</li><li><strong>Broker 模式是一种用于处理分布式系统中的消息传递的架构模式</strong>。 它的核心思想是通过一个中介层 (Broker) 来协调消息的发送和接收，从而解耦消息生产者 (Producer) 和消费者 (Consumer)。</li><li>Kafka消息确认机制<ul><li><strong>ACK&#x3D;0</strong>：这是最不可靠的模式。生产者在发送消息后不会等待来自服务器的确认</li><li><strong>ACK&#x3D;1</strong>：这是默认模式，也是一种折衷方式。在这种模式下，生产者会在消息发送后等待来自分区领导者（leader）的确认，但不会等待所有副本（replicas）的确认。</li><li><strong>ACK&#x3D;-1</strong>：这是最可靠的模式。在这种模式下，生产者会在消息发送后等待所有副本的确认。</li></ul></li><li>RocketMQ 提供了三种消息发送方式：同步发送（等待响应后才发下一条）、异步发送（不等待，通过回调接口处理响应）和单向发送（只发送请求不等待应答）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统八股</title>
    <link href="/2025/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="6-操作系统"><a href="#6-操作系统" class="headerlink" title="6. 操作系统"></a>6. 操作系统</h2><ul><li><p>用户态和内核态</p><ul><li>在内核态下，CPU可以执行所有的指令和访问所有的硬件资源</li><li>在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源</li><li>内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。</li></ul></li><li><p>进程和线程</p><ul><li>进程是操作系统<strong>资源分配</strong>的基本单位，而线程是<strong>任务调度和执行</strong>的基本单位</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程<strong>共享代码和数据空间</strong>，系统<strong>不会为线程分配内存</strong>，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li>进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，由于进程间的隔离性（不共享内存和资源），并不会影响其他进程。</li></ul></li><li><p>多线程</p><ul><li>多线程可以充分利用多核处理器的资源，提高程序的运行效率，但是会存在并发和死锁问题</li><li>线程的创建和切换会消耗系统资源，线程过多会增大开销</li></ul></li><li><p>线程切换与进程切换</p><ul><li>进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符</li><li>线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源</li><li>线程切换过程：上下文保存-&gt;调度器决定下一个线程-&gt;上下文恢复-&gt;调度执行</li></ul></li><li><p>进程的状态</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1715669823633-dcd21d9d-1bc9-44b0-b708-7afda68c2257.webp" alt="img" style="zoom:67%;" /></li></ul></li><li><p>进程通信</p><ul><li>通信方式：管道、消息队列、共享内存、信号、信号量</li><li>管道分为匿名管道和命名管道</li><li>信号：一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接收进程有某种事件发生</li><li>信号量：进程间通信处理同步互斥的机制。常用于解决共享内存的并发问题</li><li>共享内存的实现方式是将两个进程的某块虚拟内存映射到同一块物理内存</li></ul></li><li><p>线程通信</p><ul><li>Linux系统提供了五种用于线程通信的方式：<strong>互斥锁、读写锁、条件变量、自旋锁和信号量</strong></li><li><strong>自旋锁</strong>通过 CPU 提供的 <code>CAS</code> 函数在<strong>用户态</strong>完成加锁和解锁操作，不会主动产生线程上下文切换。加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</li><li>读写锁由读锁和写锁两部分构成，如果只读取共享资源用读锁加锁，如果要修改共享资源则用写锁加锁。<strong>读写锁在读多写少的场景，能发挥出优势</strong></li></ul></li><li><p>进程调度算法</p><ul><li>先来先服务（FIFO）</li><li>最短作业优先（Shortest Job First, SJF）</li><li>高响应比优先 （Highest Response Ratio Next, HRRN）</li><li>时间片轮转调度算法（RR）</li><li>最高优先级调度算法（HPF）</li><li>多级反馈队列调度算法</li></ul></li><li><p>虚拟内存</p><ul><li>虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外</li><li>每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题</li><li>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，虚拟地址与物理地址之间通过<strong>页表</strong>来映射</li><li>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作</li><li>分页下：物理地址 &#x3D; 页框号 * 页大小 + 页内偏移；分段下：物理地址 &#x3D; 段基址 + 段内偏移量；段页式下：虚拟地址 &#x3D; 段号 + 页号 + 页内偏移量</li><li><img src="image-20250426104458693.png" alt="image-20250426104458693" style="zoom: 33%;" /></li><li><img src="image-20250426104549291.png" alt="image-20250426104549291" style="zoom: 50%;" /></li></ul></li><li><p>写时复制</p><ul><li>主进程在执行 fork 的时候，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存。这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong></li><li>但是当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，操作系统会在写保护中断处理函数里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong></li></ul></li><li><p>brk()和mmap()</p><ul><li>malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。它会用brk()和mmap()两种方式向操作系统申请堆内存</li><li>通过 brk() 系统调用从<strong>堆</strong>分配内存会将「堆顶」指针向高地址移动，获得新的内存空间</li><li>通过 mmap() 系统调用，会用私有匿名映射的方式，在<strong>文件映射区</strong>分配一块内存，也就是从文件映射区“偷”了一块内存</li><li><img src="https://cdn.xiaolincoding.com//picgo/1716194642870-ef8ccbf7-1812-4ab9-a970-d0e51bb57bd2.png" alt="img" style="zoom:50%;" /></li></ul></li><li><p>页面置换算法</p><ul><li>当出现缺页异常，需调入新页面而内存已满时，会用页面置换算法选择被置换的物理页面</li><li>最佳页面置换算法（<em>OPT</em>）：置换在未来最长时间不访问的页面</li><li>先进先出置换算法（<em>FIFO</em>）</li><li>最近最久未使用的置换算法（<em>LRU</em>）</li><li>最不常用置换算法（<em>LFU</em>）</li><li>时钟页面置换算法（<em>Clock</em>）</li><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法" style="zoom:50%;" /></li></ul></li><li><p>中断和异常</p><ul><li>外中断又称中断或异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备等。外中断又可以分为可屏蔽中断和不可屏蔽中断，各个中断具有不同中断优先级</li><li>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于程序执行过程中，发现与当前指令相关的、不正常或错误的时间</li><li><img src="image-20250426111139062.png" alt="image-20250426111139062" style="zoom: 80%;" /></li></ul></li><li><p>IO模型：阻塞、非阻塞（轮询）、异步、IO多路复用</p></li><li><p>select&#x2F;poll&#x2F;epoll</p><ul><li>select&#x2F;poll&#x2F;epoll 是内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</li></ul></li></ul><ul><li>在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接<ul><li>select&#x2F;poll：将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select&#x2F;poll 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核通过遍历（select遍历bitmap，bitmap定长有上限，poll遍历链表无上限）来检查是否有网络事件产生，如果有将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里。用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket</li></ul></li><li>epoll：epoll 支持手动将需要监视的socket传入epoll对象，并在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，而select&#x2F;poll 每次操作时都传入整个 socket 集合给内核。epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不用遍历socket集合<ul><li><strong>IO多路复用</strong>：通过select、poll、epoll等系统调用，同时监听多个IO通道的事件。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>bind(s, ...);<br>listen(s, ...);<br><br><span class="hljs-type">int</span> epfd = epoll_create(...);<br>epoll_ctl(epfd, ...); <span class="hljs-comment">//将所有需要监听的socket添加到epfd中</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> n = epoll_wait(...);<br>    <span class="hljs-keyword">for</span>(接收到数据的socket)&#123;<br>        <span class="hljs-comment">//处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>reactor模型</p><ul><li>属于<strong>事件驱动</strong>架构，核心思想是通过<strong>IO多路复用</strong>技术来同时处理大量的客户端连接，而不是为每个连接创建线程，大大提高了服务器的可扩展性和性能。</li><li><strong>Reactor（反应器）</strong>：相当于事件分发器，负责监听和分发事件（如新连接、读写事件）给对应的处理器（Handler）。</li><li><strong>Acceptor（连接器）</strong>：当有新连接请求到达时，<code>Acceptor</code>负责接收这些请求。具体来说，它调用系统的<code>accept</code>方法，从监听套接字中提取新连接的描述符。</li><li><strong>Handler（处理器）</strong>：负责具体的事件处理逻辑，如读取数据、业务处理及响应输出。</li><li>工作流程<ul><li><code>Acceptor</code>通过绑定和监听一个特定的端口来准备好接收连接。</li><li>当Reactor通知<code>Acceptor</code>有新的连接到来时，<code>Acceptor</code>使用<code>accept</code>方法接受连接。</li><li>创建一个新的<code>Handler</code>或<code>Connection</code>对象，来专门处理新连接上的I&#x2F;O操作。</li><li>把新连接的套接字和相关<code>Handler</code>注册到事件分发器上，以便Reactor能够分发后续的I&#x2F;O事件。</li></ul></li><li>下图为多reactor方案（单reactor参考redis）</li><li><img src="https://cdn.xiaolincoding.com//picgo/1720420601537-460e47c6-27b5-4daa-a631-01e17b7d71f5.webp" alt="img" style="zoom:67%;" /></li></ul></li><li><p>零拷贝</p><ul><li>传统方式：磁盘 –(拷贝1)–&gt; 内核缓冲区 –(拷贝2)–&gt; 用户空间 –(拷贝3)–&gt; socket缓冲区 –(发送)–&gt; 网卡</li><li>零拷贝：磁盘 –(内核空间直接传递)–&gt; socket缓冲区 –(发送)–&gt; 网卡</li><li><img src="https://cdn.xiaolincoding.com//picgo/1713775083722-bd89e407-dfca-487e-83ee-1563e46f1d85.png" alt="img" style="zoom: 50%;" /></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>I/O模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis八股</title>
    <link href="/2025/05/14/Redis%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/14/Redis%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a>5. Redis</h2><ul><li><p>Redis数据结构</p><ul><li>常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</li><li>集合和列表里存的都是字符串</li><li>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的。如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构，否则用跳表。在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现</li></ul></li><li><p>跳表</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png" alt="img" style="zoom:80%;" /></li><li>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来</li><li>Redis <strong>跳表在创建节点的时候，随机生成每个节点的层数</strong></li><li>Redis用跳表而不是B+树的原因：Redis 是内存数据库，跳表基于链表，插入&#x2F;删除时仅需调整局部指针，且核心代码短，在实现简单性、写入性能、内存访问模式等方面有优势</li></ul></li><li><p>压缩列表</p><ul><li>是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组</li><li><img src="https://cdn.xiaolincoding.com//picgo/1720432496229-46da5ac0-0e89-45cd-b1f8-151f7c6d4660.png" alt="img" style="zoom: 67%;" /></li></ul></li><li><p>Listpack</p><ul><li>Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，只记录当前节点长度，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1719035634415-c436d60e-58a7-4dfc-9e69-db8e2f96d19c.png" alt="img" style="zoom:67%;" /></li></ul></li><li><p>Hash表扩容过程</p><ul><li><strong>一般扩容</strong>：有两个哈希表，分别为表1和表2，初始时表2为空表，数据都插入表1。触发rehash扩容时，先给表2分配比1更大的空间，然后把表1的数据迁移到表2中，最后把表1释放，表2赋给表1，然后再创建一个空表作为新的表2</li><li>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能，Redis采用<strong>渐进式rehash</strong>：先给表2分配空间，然后在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将表1中索引位置上的所有 key-value 迁移到表2上。这样随着客户端不断请求，最终表1的数据会全部迁移入表2</li><li>在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在两个表中进行，查找时表1找不到就去表2，但插入数据只会插入表2。</li></ul></li><li><p>SDS（字符串的数据结构）</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/image-20240725232549832.png" alt="image-20240725232549832" style="zoom: 33%;" /></li></ul></li><li><p>Redis的线程模型</p><ul><li>Redis <strong>单线程</strong>指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</li><li>Redis 会在后台启动多线程异步处理一些“重量级”操作，包括关闭文件、AOF 刷盘、释放 Redis 内存等，使用多线程处理后台任务，不影响前端请求的响应速度。</li><li>为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理</li></ul></li><li><p>IO多路复用</p><ul><li>IO 多路复用（I&#x2F;O multiplexing），简单来说，就是<strong>用一个线程同时监听多个网络连接（socket）上的读写事件</strong>。</li><li>Redis 主线程首先使用 IO 多路复用（如 <code>epoll</code>）监听所有客户端的 socket 连接。</li><li>一旦某个 socket 有新的请求或数据到达，Redis 就会被唤醒，处理这个请求。</li><li>处理完后再次进入监听状态，继续等待其它连接的事件发生。</li></ul></li><li><p>Redis网络模型</p><ul><li><p>6.0前用单线程reactor，6.0后多线程</p></li><li><img src="https://cdn.xiaolincoding.com//picgo/1721630566038-d16ec13e-e7e6-4e0b-a48c-e7affdbf312e.png" alt="img" style="zoom:67%;" /></li></ul></li><li><p>Redis 的事务（Transaction）可以让你<strong>一次性、按顺序、批量执行多个命令</strong>，但是不是完全原子的，也没有回滚机制</p></li><li><p>Redis 共有两种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘</li><li><img src="https://cdn.xiaolincoding.com//picgo/1719110103571-b6bd31d1-7955-4e57-aee5-ae95302183b9.webp" alt="img" style="zoom:80%;" /></li></ul></li><li><p>Redis过期删除和内存淘汰策略</p><ul><li><strong>内存淘汰策略</strong>是在内存满了的时候，redis 会触发内存淘汰策略，来淘汰一些不必要的内存资源</li><li><img src="https://cdn.xiaolincoding.com//picgo/1717480443917-64e65a05-b9f9-4a6e-a969-8f18f72f2133.png" alt="img"></li><li><strong>过期键删除策略</strong>是将已过期的键值对进行删除，Redis 采用的删除策略是惰性删除（访问时判断是否过期）+定期删除（隔一段时间随机抽出一些key检查一次）</li></ul></li><li><p>redis速度快的原因：在内存中、数据结构简单、单线程省去上下文切换开销</p></li><li><p>Redis集群的同步</p><ul><li>完全同步：发生在初次同步、主节点数据变化、从节点数据丢失三种情况下。通过发送RDB快照实现同步。</li><li>增量同步：允许从服务器从断点处继续同步，而不是每次都进行完全同步。主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。实现机制是利用一个环形缓冲区和一个同步偏移量，通过偏移量判断从服务器丢失的数据是否还在缓冲区中，不在的话就用完全同步</li></ul></li><li><p>Redis哨兵节点</p><ul><li>哨兵的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</li><li>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong></li></ul></li><li><p><strong>Redis实现分布式锁</strong></p><ul><li>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁</li><li>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，如果 key 不存在，则显示插入成功，可以用来表示加锁成功，如果 key 存在，则会显示插入失败，可以用来表示加锁失败</li><li>解锁的过程要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。由于有两个操作，因此要用lua脚本实现原子性</li></ul></li><li><p>大key问题：某个key对应的value值所占的内存空间比较大，导致Redis的性能下降、内存不足、数据不均衡以及主从同步延迟等问题</p></li><li><p>热key问题：可以将对应热Key进行复制并迁移至其他数据分片，来解决单个数据分片的热Key压力</p></li><li><p>缓存问题</p><ul><li>缓存雪崩：当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，造成数据库宕机，然后系统崩溃。<strong>解决方案</strong>：均匀设置过期时间、失效时用互斥锁构建缓存</li><li>缓存击穿：如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</li><li>缓存穿透：当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增</li></ul></li><li><p>在SpringBoot中使用Redis</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-comment">// 存入字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        redisTemplate.opsForValue().set(key, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 读取字符串</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().get(key);<br>    &#125;<br>&#125;<br><br>redisService.setValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisService.getValue(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(name); <span class="hljs-comment">// 输出：Alice</span><br><br>redisTemplate.opsForHash().put(<span class="hljs-string">&quot;user:1001&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash().get(<span class="hljs-string">&quot;user:1001&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br><br>redisTemplate.opsForZSet().add(<span class="hljs-string">&quot;myzset&quot;</span>, <span class="hljs-string">&quot;member1&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li><p>秒杀实现（有好几种，这里就放一种）</p><ul><li>利用分布式锁+分段缓存：把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候把他们分到不同的段就可以实现并发修改</li><li>例如100个库存分为5个20的段</li><li>当某段锁的库存不足，一定要实现自动释放锁然后换下一个分段库存再次尝试加锁处理</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>数据库</tag>
      
      <tag>NoSQL</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL八股</title>
    <link href="/2025/05/14/MySQL%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/14/MySQL%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4. MySQL"></a>4. MySQL</h2><ul><li><p>范式</p><ul><li>1NF：要求数据库表的每一列都是不可分割的原子数据项</li><li>2NF：所有非码属性完全函数依赖于候选码</li><li>3NF：所有非主属性不依赖于其他非主属性，消除传递依赖</li></ul></li><li><p><code>VARCHAR</code> 后面括号里的数字代表的是字符数，而不是字节数</p></li><li><p><code>INT(1)</code> 和 <code>INT(10)</code> 的区别主要在于 <strong>显示宽度</strong>，而不是存储范围或数据类型本身的大小</p></li><li><p><code>EXISTS</code> 的性能优于 <code>IN</code>，特别是当子查询的表很大时。这是因为<code>EXISTS</code> 一旦找到匹配项就会立即停止查询，而<code>IN</code>可能会扫描整个子查询结果集</p></li><li><p>MySQL函数：CONCAT、LENGTH、SUBSTRING、REPLACE、ABS、POWER、NOW、CURDATE、COUNT、SUM、AVG、MAX、MIN</p></li><li><p><img src="image-20240820114027032.png" alt="image-20240820114027032"></p></li><li><p>MySQL存储引擎</p><ul><li>InnoDB：InnoDB是MySQL的<strong>默认存储引擎</strong>，具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。</li><li>MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景，但不支持事务、行级锁和外键约束，在并发写入和数据完整性方面有一定的限制。</li><li>Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，在服务器重启或崩溃时数据会丢失，也不支持事务、行级锁和外键约束</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁；InnoDB 是聚簇索引，MyISAM 是非聚簇索引</li><li><img src="1719803663459-11b9a82a-6bf2-46cd-b882-e0b85e5a4256.png" alt="img" style="zoom:80%;" /></li></ul></li><li><p>聚簇索引(一级)和二级索引</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据</li><li>一张表最多只有一个主键索引，索引列的值不允许有空值。后面新建的索引都是二级索引</li><li>当通过非聚簇索引查找数据时，首先在非聚簇索引中找到对应的主键值，然后通过这个主键值回溯到聚簇索引中查找实际的数据行，这个过程称为“<strong>回表</strong>”。</li><li>区分度小的字段（如性别只有两种）不适合做索引，因为只能选出50%的数据</li></ul></li><li><p>前缀索引是指对字符类型字段的前几个字符建立的索引</p></li><li><p>联合索引</p><ul><li>建立在多列上的索引称为联合索引。使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</li><li>如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了</li><li><strong>建立联合索引时，要把区分度大的字段排在前面</strong></li><li>例：创建了一个 (a, b, c) 联合索引，a&#x3D;1 and b&#x3D;2 and c&#x3D;3或a&#x3D;1 and b&#x3D;2这种可以使用联合索引。而b&#x3D;2这种不可以，a&#x3D;1and c&#x3D;3这种可以部分使用索引。</li></ul></li><li><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列</li></ul></li><li><p><strong>UUID与自增ID比较</strong></p><ul><li>uuid 相对顺序的自增 id 来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以 innodb 无法做到总是把新行插入到索引的最后，会频繁导致数据页的读取和B+树页分裂</li><li>而且，UUID 太占用内存。每个 UUID 由 36 个字符组成，查询时比较时间长，性能低</li></ul></li><li><p>B+树的好处</p><ul><li>非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，B+树的非叶子节点可以存放更多的索引，树高度更低</li><li>B+ 树有大量的冗余节点，在插入、删除的效率都更高</li><li>B+ 树叶子节点之间用双向链表连接了起来，有利于范围查询和正反向遍历</li></ul></li><li><p>索引失效</p><ul><li>使用左或者左右模糊匹配，也就是like %xx 或者 like %xx%</li><li>在查询条件中对索引列使用函数</li><li>在查询条件中对索引列进行表达式计算</li><li>联合索引不遵循最左匹配原则</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</li></ul></li><li><p><strong>覆盖索引</strong>是指一个索引包含了查询所需的所有列，因此不需要访问表中的数据行就能完成查询</p></li><li><p>事务的ACID特性</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成。执行过程中发生错误，会被回滚到事务开始前的状态。原子性是通过 undo log（回滚日志） 来保证的</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。一致性是通过持久性+原子性+隔离性来保证</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。持久性是通过 redo log （重做日志）来保证的</li></ul></li><li><p>并发问题</p><ul><li>脏读：一个事务「读到」了另一个「未提交事务修改过的数据」</li><li>不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况</li><li>幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，前后两次查询到的记录数量不一样</li></ul></li><li><p>事务隔离级别</p><ul><li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到</li><li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到。不可能发生脏读现象</li><li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>。不可能脏读和不可重复读现象</li><li><strong>串行化（serializable）</strong>；会对记录加上读写锁，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成，才能继续执行。所有并发问题都不会发生。</li></ul></li><li><p>MVCC实现机制：开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的</p></li><li><p>MySQL锁</p><ul><li>根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png" alt="img" style="zoom:67%;" /></li></ul></li><li><p>MySQL日志</p><ul><li>redo log 重做日志和undo log 回滚日志</li><li>bin log 二进制日志，是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>。binlog 有 3 种格式类型，分别是 STATEMENT（默认格式，记录修改数据的 SQL）、ROW（记录最终行数据）、 MIXED</li><li>relay log 中继日志，用于主从复制场景下，slave通过io线程拷贝master的bin log后本地生成的日志</li></ul></li><li><p>binlog 两阶段提交</p><ul><li>事务的提交过程有两个阶段，就是将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</li><li><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231904598.png" alt="image-20240725231904598" style="zoom: 50%;" /></li></ul></li><li><p>redo log与WAL(Write-Ahead Logging)技术</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1717920899043-30125c0d-bd83-4ca7-9784-07b70c362168.png" alt="img" style="zoom:80%;" /></li><li>当有一条记录需要更新的时候，InnoDB 引擎会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong></li><li>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</li></ul></li><li><p>主从复制</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1721631517714-ff2f274c-763c-40ac-a80f-7d33872ca9a4.png" alt="img" style="zoom:80%;" /></li></ul></li><li><p>分库和分表</p><ul><li>指把一个数据库&#x2F;表中的数据分开存储</li><li>垂直指按逻辑分开，水平指把相同类型的数据分开存</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2025/05/14/%E8%B4%AA%E5%BF%83/"/>
    <url>/2025/05/14/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="10-贪心"><a href="#10-贪心" class="headerlink" title="10. 贪心"></a>10. 贪心</h2><blockquote><p>贪心是 DP 的子集。能贪心的一定可以 DP（但是时间复杂度可能不一样），能 DP 的不一定能贪心。</p><p>比如选或不选这个思路，DP 的想法是，枚举每个数选或不选，把所有的情况都枚举到，从中比较哪个最优，本质上是暴力的优化（不重复计算重叠子问题）；贪心的想法是（如果可以贪心），每一步都选最优的，选或不选哪个更好，可以直接算出来，有一种「人为介入」的感觉。</p></blockquote><h3 id="10-1-基本贪心策略"><a href="#10-1-基本贪心策略" class="headerlink" title="10.1 基本贪心策略"></a>10.1 基本贪心策略</h3><ul><li>有两种基本贪心策略：<ul><li>从最小&#x2F;最大开始贪心，优先考虑最小&#x2F;最大的数，从小到大&#x2F;从大到小贪心。在此基础上，衍生出了反悔贪心。</li><li>从最左&#x2F;最右开始贪心，思考第一个数&#x2F;最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题。</li></ul></li><li>从最小&#x2F;最大开始贪心<ul><li>优先考虑最小&#x2F;最大的数，从小到大&#x2F;从大到小贪心。</li><li>如果答案与数组元素顺序无关，一般需要<strong>排序</strong>。排序后，可以遍历计算。</li></ul></li><li>从最左&#x2F;最右开始贪心<ul><li>对于无法排序的题目，尝试从左到右&#x2F;从右到左贪心。思考第一个数&#x2F;最后一个数的贪心策略，把 <em>n</em> 个数的原问题转换成 <em>n</em>−1 个数（或更少）的子问题。要思考什么情况下只能 DP 不能贪心，加深对「局部最优」和「全局最优」的理解。</li><li>划分型贪心：把数组&#x2F;字符串划分成满足要求的若干段，最小化&#x2F;最大化划分的段数。</li><li>先枚举再贪心：枚举题目的其中一个变量，将其视作已知条件，然后在此基础上贪心。也可以枚举答案，检查是否可以满足要求。（类似二分答案）</li></ul></li><li>相邻不同<ul><li>给定正整数数组，每次操作，把数组中的两个数各减少一，并去掉变成 0 的数。目标：使最后剩下的数最小，或者最大化操作次数。</li><li>相当于给出很多个物品和它们的数量，一样的物品不能相邻</li><li>由于每次操作的都是两个下标不同的数，把这些下标按顺序拼接，可以构造出一个相邻元素不同的序列。例如 (1,2),(2,3),(3,4) 这三个操作，可以拼接成 [1,2,3,2,3,4]。</li><li><strong>解法</strong>：用一个最大堆实现，每次都取最大的两个数（堆顶），将它们减一后放回堆（是0就不用加入）</li><li>特殊情况：如果数据量很大，用堆慢慢每次减一模拟会超时，需要用规律直接计算能排多少个物品</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1953.你能工作的最大周数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">numberOfWeeks</span><span class="hljs-params">(<span class="hljs-type">int</span>[] milestones)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : milestones)&#123;<br>            s += num;<br>            m = Math.max(m, num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> m &gt; s - m + <span class="hljs-number">1</span> ? <span class="hljs-number">2</span> * (s - m) + <span class="hljs-number">1</span> : s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>反悔贪心<ul><li>当你在遍历时发现前面选了不该选的（即把那次机会用来选当前的更好），那么就进行反悔</li><li>实现方法是用一个最大堆，每次选择当前元素时把它入堆，当需要反悔时就弹出堆顶元素，并把新选的这个入堆</li></ul></li></ul><h3 id="10-2-区间贪心"><a href="#10-2-区间贪心" class="headerlink" title="10.2 区间贪心"></a>10.2 区间贪心</h3><ul><li>区间贪心有如下经典问题：<ul><li>不相交区间（单机器调度&#x2F;活动安排）：给定一些区间，从中选出尽量多的两两互不相交的区间。</li><li>区间分组（任务调度&#x2F;会议室）：给定一些区间，把这些区间分成最少的组，使得每组内的区间互不相交。</li><li>区间选点（射气球，Interval Stabbing）：给定一些区间，在数轴上放置最少的点，使得每个区间都包含至少一个点。最少要放置多少个点？</li><li>区间覆盖（灌溉花园）：给定一些区间，从中选出尽量少的区间，覆盖一条指定线段 [s,t]。</li></ul></li><li>不相交区间<ul><li>按区间右端点排序，然后遍历选择右端点最小的那个。因为如果能选右端点更大的那么这个一定可以选，并且不会影响后面的。然后左端点小于 <em>A</em> 的右端点的区间都与 <em>A</em> 相交，都不能选。</li><li>我的方法：按左端点排序，左端点相同按右端点排序。遍历时记录前一个区间pre，如果cur与pre相交，则选择右端点小的那个保留。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preR</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : intervals) &#123;<br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] &gt;= preR) &#123;<br>                ans++;<br>                preR = p[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.length - ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>区间分组<ul><li>按照 <em>left</em> 排序后，用最小堆模拟，堆顶存储每个组最后一个区间的 <em>right</em>。</li><li>如果当前的 <em>left</em> 大于堆顶，则可以接在这个组的末尾，更新堆顶为 <em>right</em>；否则需要创建一个新的组。</li><li>原题是会议室II。理解方法：每次都查看最早结束的那一场会议的结束时间，如果最早的那场都没结束那就要分配新的会议室。</li><li><img src="v2-f1c3c5341f34b5704a0238c71821b47b_r.jpg" alt="img"></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2406.将区间分为最少组数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(); <span class="hljs-comment">// 存储每个组的最大右端点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] interval : intervals)&#123;<br>            <span class="hljs-keyword">if</span>(!heap.isEmpty() &amp;&amp; heap.peek() &lt; interval[<span class="hljs-number">0</span>]) heap.poll();<br>            heap.offer(interval[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> heap.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>区间选点<ul><li>与不相交区间类似。灵神方法是按右端点排序，遍历区间，如果 <em>start</em>≤<em>pre</em>，那么这个区间已经被包含。如果 <em>start</em>&gt;<em>pre</em>，那么必须再放一个点。</li><li>我经过实践发现先按左端点排序也可以。通过while循环找到所有能够用这支箭射掉的气球集合（过程中合法区间会不断缩小）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 452.用最少数量的箭射爆气球</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Arrays.sort(points, Comparator.comparingInt(p -&gt; p[<span class="hljs-number">1</span>])); <span class="hljs-comment">// 按照右端点从小到大排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : points) &#123;<br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] &gt; pre) &#123; <span class="hljs-comment">// 上一个放的点在区间左边</span><br>                ans++;<br>                pre = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 在区间的最右边放一个点</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123; <span class="hljs-comment">// 我的做法</span><br>        Arrays.sort(points, (a, b) -&gt; a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>] ?Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]) : Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; points.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> points[i][<span class="hljs-number">0</span>], r = points[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span>(i + <span class="hljs-number">1</span> &lt; points.length &amp;&amp; points[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;= r)&#123;<br>                i++;<br>                l = points[i][<span class="hljs-number">0</span>];<br>                r = Math.min(r, points[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>区间覆盖<ul><li>思路：在向前遍历的同时记录遍历过的点中能到达的最远处，每当目前的线段不够用了就取那个最远的补上。</li><li>如果后面的会影响前面的选择，例如<code>1326.灌溉花园的最少水龙头数目</code>，那么可以先遍历一次得到一个数组rightMost，代表每个点能到达的最大右端点</li><li><img src="1727057167-mGElnQ-45-c.png" alt="45-c.png" style="zoom: 20%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 跳跃游戏II</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++)&#123;<br>            maxRight = Math.max(maxRight, nums[i] + i);<br>            <span class="hljs-keyword">if</span>(i &gt;= curRight)&#123;<br>                curRight = maxRight;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1326.灌溉花园的最少水龙头数目</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minTaps</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] ranges)</span> &#123;<br>        <span class="hljs-type">int</span>[] rightMost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> ranges[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(i - r, <span class="hljs-number">0</span>);<br>            rightMost[left] =  Math.max(rightMost[left], i + r);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 已建造的桥的右端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 下一座桥的右端点的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 如果走到 n-1 时没有返回 -1，那么必然可以到达 n</span><br>            nextRight = Math.max(nextRight, rightMost[i]);<br>            <span class="hljs-keyword">if</span> (i == curRight) &#123; <span class="hljs-comment">// 到达已建造的桥的右端点</span><br>                <span class="hljs-keyword">if</span> (i == nextRight) &#123;<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 无论怎么造桥，都无法从 i 到 i+1</span><br>                &#125;<br>                curRight = nextRight; <span class="hljs-comment">// 造一座桥</span><br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关于对区间数组排序的想法<ul><li>当题目意思中存在一条递增的轴，要从最左边慢慢选到最右边（例如时间，从起点跳到终点），要以左端点排序</li><li>当题目倾向于求区间间的相交关系，并没有其他限制时，按右端点排序</li><li>但其实我发现要按右端点排序的题用左端点排序+一些额外的贪心思想也可以解决，但是代码会更复杂且易出错</li></ul></li></ul><h3 id="10-3-字符串贪心"><a href="#10-3-字符串贪心" class="headerlink" title="10.3 字符串贪心"></a>10.3 字符串贪心</h3><ul><li>字典序最小&#x2F;最大<ul><li>字典序定义：对于两个字符串 <em>a</em> 和 <em>b</em>，从左到右依次比较 <em>a</em>[<em>i</em>] 和 <em>b</em>[<em>i</em>] 的字符 ASCII 值的大小。a[i] !&#x3D; b[i] 时，如果 a[i] &lt; b[i]，那么 <em>a</em> 的字典序更小，否则 <em>b</em> 的字典序更小。如果其中一个到了结尾那么短的那个字典序更小。</li><li>贪心策略一般是从最左端或最右端开始构造，每次都尽量选最小或最大的字母&#x2F;数字</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring八股</title>
    <link href="/2025/05/13/Spring%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/13/Spring%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="3-Spring"><a href="#3-Spring" class="headerlink" title="3. Spring"></a>3. Spring</h2><ul><li>Spring核心思想<ul><li><strong>IoC</strong>：即控制反转的意思，它是一种创建和获取对象的技术思想，依赖注入(DI)是实现这种技术的一种方式。我们不通过new关键字创建对象，而是通过IoC容器来帮我们实例化对象，可以降低对象间耦合度。</li><li><strong>AOP</strong>：是面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，以减少系统的重复代码，降低模块间的耦合度。</li></ul></li><li>JDK Proxy 是一种只针对接口的动态代理机制，可以在运行时生成实现对应接口的代理对象，用于统一处理接口方法调用逻辑，比如增强日志、权限、事务等。</li><li>IOC（Inversion Of Control）<ul><li>实现机制<ul><li><strong>反射</strong>：Spring IOC容器利用Java的反射机制动态地加载类、创建对象实例及调用对象方法</li><li><strong>依赖注入</strong>：IOC的核心概念是依赖注入，即容器负责管理应用程序组件之间的依赖关系，包括构造函数注入、属性注入和方法注入</li><li><strong>工厂模式</strong>：Spring IOC容器通常采用工厂模式来管理对象的创建和生命周期。容器作为工厂负责实例化Bean并管理它们的生命周期</li></ul></li><li>在Spring中，开发者可以通过XML配置文件或者基于注解的方式声明组件之间的依赖关系。当应用程序启动时，Spring容器会扫描这些配置或注解，然后利用反射来实例化Bean（即Java对象），并根据配置自动装配它们的依赖。</li></ul></li><li>AOP<ul><li>AOP 中最小的单元是“切面”。一个“切面”可以包含很多种类型和对象，对它们进行模块化管理，例如事务管理。</li><li>在面向切面编程的思想里面，把功能分为核心业务和周边功能。核心业务功能和周边功能是分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起</li><li>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</li><li>实现依赖于动态代理技术，JDK Proxy负责有接口的类，而没有实现接口的类用CGLIB（生成一个被代理类的子类）</li><li>相关注解<ul><li>@Aspect：用于定义切面，标注在切面类上。</li><li>@Pointcut：定义切点，标注在方法上，用于指定连接点。</li><li>@Before：在方法执行之前执行通知。</li><li>@After：在方法执行之后执行通知。</li><li>@Around：在方法执行前后都执行通知。</li><li>@AfterReturning：在方法执行后返回结果后执行通知。</li><li>@AfterThrowing：在方法抛出异常后执行通知。</li><li>@Advice：通用的通知类型，可以替代@Before、@After等。</li></ul></li></ul></li><li>Spring中的循环依赖<ul><li>循环依赖分类：<ul><li>通过构造方法进行依赖注入时产生的循环依赖问题</li><li>通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题</li><li>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题</li></ul></li><li>只有第三种依赖可以解决，方法是三级缓存。三级缓存都是Map类型的</li><li>三级缓存结构<ul><li><strong>一级缓存 singletonObjects</strong>：存放完全初始化好的单例 bean（getBean() 正常返回的对象）。</li><li><strong>二级缓存 earlySingletonObjects</strong>：存放早期暴露的（还没被初始化、AOP增强等的）bean 实例，解决循环依赖。</li><li><strong>三级缓存 singletonFactories</strong>：存放用于创建 bean 的 ObjectFactory，对 AOP 代理等动态包装很关键。</li></ul></li><li>Bean的创建过程：<ul><li>实例化Bean后，放【ObjectFactory】到三级缓存。</li><li>属性赋值后，提前暴露“半成品”bean到二级缓存（没有AOP增强，只是原始对象）。</li><li>初始化和AOP增强后，将“完整，可用的”Bean放入一级缓存，将二三级缓存对应数据删除。</li></ul></li><li>getBean(A)  → new A 实例  → singletonFactories.put(“A”, ObjectFactory)  → injection: @Autowired B → getBean(B)       → new B 实例       → singletonFactories.put(“B”, ObjectFactory)       → injection: @Autowired A → getBean(A)[循环]           → 1级无 2级无 3级有           → 使用A的ObjectFactory生成A实例，放到2级缓存           → 返回A实例（未初始化）       → B.a &#x3D; A (半成品A)       → B初始化完，放到1级缓存，清理2级、3级  → A.b &#x3D; B  → A初始化完，放到1级缓存，清理2级、3级</li></ul></li><li>Spring用到的设计模式：工厂模式、代理模式、单例模式、观察者模式、适配器模式、模板方法模式</li><li>Spring常见注解<ul><li>@Autowired：主要用于自动装配bean</li><li>@Component：用于标记一个类作为Spring的bean</li><li>@Configuration：用于标记一个类作为Spring的配置类</li><li>@Bean：用于标记一个方法作为Spring的bean工厂方法，Spring会将该方法的返回值作为一个bean</li><li>@Service：用于标记一个类作为服务层的组件</li><li>@Repository：用于标记一个类作为数据访问层的组件</li><li>@Controller：用于标记一个类作为控制层的组件</li></ul></li><li>Spring事务<ul><li>事务管理在Spring Boot中通常是通过 @Transactional 注解来实现的</li><li>Spring事务是通过<strong>代理对象</strong>来控制的</li><li>事务失效情况：抛出未捕获异常、事务嵌套时配置有误、事务方法调用非事务方法、方法不是public</li></ul></li><li>Spring 中的 Bean 默认都是单例的。但是也支持将Bean设置为多例模式，即每次请求都会创建一个新的Bean实例。</li><li>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 <code>prototype</code> 的 Bean，Spring 在创建好交给使用者之后不再管理后续生命周期</li><li><img src="image-20250421212230096.png" alt="image-20250421212230096" style="zoom: 80%;" /></li><li>在Spring框架中，如果你希望在Bean加载（即实例化、属性赋值、初始化等过程完成后）或销毁前后执行某些逻辑，你可以使用Spring的生命周期回调接口或注解。这些接口和注解允许你定义在Bean生命周期的关键点执行的代码。</li><li>Bean的注入有XML注入和注解注入两种方法。使用 XML 文件进行 Bean 注入时，Spring 在启动时会读取 XML 配置文件，注入过程：bean定义解析-&gt;bean定义注册-&gt;实例化和依赖注入。注解方式只有第一步不同，是类路径扫描（查找带@service、@controller等注解的类）</li><li>Spring MVC<ul><li>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</li><li><img src="1713944902120-e35c2b4f-e290-4973-aa1a-3193af3bb371.png" alt="img" style="zoom:80%;" /></li><li><img src="https://cdn.xiaolincoding.com//picgo/1716791047520-ac0d9673-be0a-4005-8732-30bdedc8f1af.webp" alt="img" style="zoom:80%;" /></li><li>HandlerMapping作用是将请求映射到对应的controller，HandlerAdapter负责调用controller来处理请求</li></ul></li><li>SpringBoot与Spring<ul><li><strong>Spring</strong> 是 Java 开发的基础生态，提供核心功能。<strong>Spring Boot</strong> 是对 Spring 的进一步封装和增强，让你更简单、更快捷地开发和部署 Spring 应用。</li><li>SpringBoot的优势<ul><li>Spring Boot提供一系列的开箱即用的组件和自动配置，通过引入不同的 Starter，可以快速集成常用的框架和库</li><li>Spring Boot提供了快速的应用程序启动方式，可通过内嵌的Tomcat、Jetty或Undertow等容器快速启动应用程序</li><li>Spring Boot通过自动配置功能，根据项目中的依赖关系和约定俗成的规则来配置应用程序</li></ul></li><li>约定大于配置是Spring Boot的核心设计理念，它通过<strong>预设合理的默认行为和项目规范</strong>，大幅减少开发者需要手动配置的步骤，从而提升开发效率和项目标准化程度</li><li><img src="https://cdn.xiaolincoding.com//picgo/1721712159282-79195670-9acf-4bfb-93b1-47d089a4bc1c.png" alt="img" style="zoom: 67%;" /></li></ul></li><li>Spring Boot starter<ul><li><strong>starter（起步依赖）</strong>，本质是<strong>一个标准的 Maven 依赖包（Jar）</strong>，它里面会“串联”或聚合好一组常见的相关依赖和默认配置，目的是让你<strong>只需要引入一个 starter，就能轻松用上一个完整的技术功能模块，提升开发效率</strong>。</li><li><strong>spring-boot-starter-web</strong>：这是最常用的起步依赖之一，它包含了Spring MVC和Tomcat嵌入式服务器，用于快速构建Web应用程序</li><li><strong>spring-boot-starter-security</strong>：提供了Spring Security的基本配置，帮助开发者快速实现应用的安全性，包括认证和授权功能。</li><li><strong>mybatis-spring-boot-starter</strong>：用于简化在Spring Boot应用中集成MyBatis的过程</li><li><strong>spring-boot-starter-data-jpa</strong> 或<strong>spring-boot-starter-jdbc</strong>：如果使用的是Java Persistence API (JPA)进行数据库操作则引入前者（包含了Hibernate等JPA实现），用JDBC就引入后者。</li><li><strong>spring-boot-starter-data-redis</strong>：用于集成Redis缓存和数据存储服务</li><li><strong>spring-boot-starter-test</strong>：包含了单元测试和集成测试所需的库</li></ul></li><li>Spring Boot常见注解<ul><li><strong>@SpringBootApplication</strong>：用于标注主应用程序类，标识一个Spring Boot应用程序的入口点，同时启用自动配置和组件扫描。</li><li><strong>@RestController</strong>：结合@Controller和@ResponseBody，返回RESTful风格的数据。</li><li><strong>@RequestMapping</strong>：用于映射HTTP请求路径到Controller的处理方法</li><li><strong>@GetMapping</strong>、<strong>@PostMapping</strong>、<strong>@PutMapping</strong>、<strong>@DeleteMapping</strong>：简化@RequestMapping的GET、POST、PUT和DELETE请求</li><li>其余与Spring相同</li></ul></li><li>过滤器和拦截器<ul><li><img src="image-20250421225420345.png" alt="image-20250421225420345" style="zoom: 67%;" /></li><li>过滤器在请求进入 Servlet 容器后，在到达目标 Servlet 或控制器之前执行；拦截器在请求到达控制器之后，在控制器方法执行前后执行。</li></ul></li><li>JDBC连接数据库步骤<ul><li><strong>加载数据库驱动程序</strong>：如可以通过 Class.forName(“com.mysql.jdbc.Driver”) 加载MySQL驱动程序</li><li><strong>建立数据库连接</strong>：使用 DriverManager 类的 getConnection(url, username, password) 连接</li><li><strong>创建 Statement 对象</strong>：通过 Connection 对象的createStatement() 方法创建一个 Statement 对象用于执行操作</li><li><strong>执行 SQL 查询或更新操作</strong>：使用 Statement 对象的executeQuery(sql) 、executeUpdate(sql) 方法来执行</li><li><strong>处理查询结果</strong>：如果是 SELECT 查询操作，通过 ResultSet对象来处理查询结果</li><li><strong>关闭连接</strong>：在完成数据库操作后，需要<strong>逐级</strong>关闭数据库连接相关对象</li></ul></li><li>Mybatis简单介绍（<del>复杂的暂时不管</del>）<ul><li><strong>MyBatis 就是一个让你手写 SQL，然后帮你自动把 SQL 执行&amp;结果转对象、简化数据库操作的 Java 框架</strong>。它是一款优秀的开源 <strong>ORM（对象关系映射）框架</strong>，主要用于简化 Java 程序对关系型数据库的操作。</li><li>MyBatis 让你用 <strong>XML 文件（或注解）来写 SQL 语句</strong>，并把这些 SQL 和 Java 方法做一一对应映射。只需要写 SQL，MyBatis 自动把参数填进去，结果查出来转成相应的 Java 对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.mapper;<br><br><span class="hljs-keyword">import</span> com.example.demo.entity.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Mapper</span>  <span class="hljs-comment">// 必须标注为 @Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.demo.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.demo.entity.User&quot;</span>&gt;</span><br>        SELECT * FROM user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>Spring Cloud<ul><li>Spring Cloud是用于构建分布式系统中的微服务架构的工具，提供了服务注册与发现、负载均衡、断路器、网关等功能。</li><li>微服务常用的组件：<ul><li><strong>注册中心</strong>：注册中心是微服务架构最核心的组件，作用是对新节点的注册与状态维护，通常会采用心跳机制最大程度保证已登记过的服务节点都是可用的</li><li><strong>负载均衡</strong>：通常微服务在互相调用时，并不是直接通过IP、端口进行访问调用，而是先通过服务名在注册中心查询该服务拥有哪些节点，注册中心将该服务可用节点列表返回给服务调用者，这个过程叫服务发现。服务调用者要从多个节点中选择，因此服务调用者一端必须内置负载均衡器，通过负载均衡策略选择合适的节点发起实质性的通信请求</li><li><strong>服务通信</strong>：封装了服务间通信的协议</li><li><strong>配置中心</strong>：通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。</li><li><strong>集中式日志管理</strong>：通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。</li><li><strong>服务保护</strong>：如果某个微服务出现高延迟导致线程池满载，或是业务处理失败，这里就需要引入服务保护组件来实现高延迟服务的快速降级，避免系统崩溃。</li></ul></li><li><strong>应用结构</strong><ul><li><strong>服务注册中心</strong>（如Nacos）</li><li><strong>配置中心</strong>（Spring Cloud Config 或 Nacos）</li><li><strong>网关服务</strong>（Spring Cloud Gateway）</li><li><strong>业务服务</strong>（多个，服务之间通过Feign调用）</li><li><strong>监控与追踪</strong>（Sleuth、Zipkin）</li></ul></li><li>负载均衡算法：简单轮询、加权轮询、简单随机、加权随机、一致性哈希（可实现同一个客户端或相同参数的请求对应一台服务器）、最小活跃数</li><li>服务熔断：当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</li><li>服务降级：对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的错误处理信息</li></ul></li></ul><table><thead><tr><th>组件</th><th>作用简介</th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册与发现中心（已被 Spring 官方弃用）</td></tr><tr><td>Nacos</td><td>推荐的注册中心 + 配置中心（阿里开源）</td></tr><tr><td>Config</td><td>分布式配置中心</td></tr><tr><td>Gateway</td><td>微服务 API 网关，替代 Zuul</td></tr><tr><td>OpenFeign</td><td>声明式 HTTP 客户端，用于服务之间远程调用</td></tr><tr><td>Hystrix</td><td>熔断降级，已弃用，推荐使用 Resilience4j</td></tr><tr><td>Sleuth + Zipkin</td><td>分布式链路追踪</td></tr><tr><td>Bus</td><td>配置自动刷新总线</td></tr><tr><td>Consul</td><td>可选的注册中心+配置中心（HashiCorp 提供）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Spring Boot</tag>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八股</title>
    <link href="/2025/05/13/Java%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/13/Java%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="2-Java"><a href="#2-Java" class="headerlink" title="2. Java"></a>2. Java</h2><h3 id="2-1-Java基础"><a href="#2-1-Java基础" class="headerlink" title="2.1 Java基础"></a>2.1 Java基础</h3><ul><li><p>Java的特点：平台无关性、面向对象、内存管理</p></li><li><p>JVM、JRE、JDK</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="image-20240725230247664" style="zoom: 33%;" /></li><li>JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JRE是Java运行时环境，JDK是Java开发工具包</li></ul></li><li><p>Java解释和编译</p><ul><li>编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用</li><li>解释性：JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件</li><li><img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="img" style="zoom: 67%;" /></li></ul></li><li><p>使用BigDecimal而不是double的情景：涉及金钱等需要精确计算的情况</p></li><li><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，如int和Integer。在Java中，泛型只能使用引用类型，而不能使用基本类型，因此需要使用包装类。基本类型数据在读写效率方面，要比包装类高效，且占用空间少。</p></li><li><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。</p></li><li><p>Java面向对象的三大特性包括：<strong>封装、继承、多态</strong></p><ul><li><strong>封装</strong>：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。</li><li><strong>继承</strong>：继承是一种可以使得子类自动共享父类数据结构和方法的机制，是代码复用的重要手段</li><li><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写），接口和对象类型转换也体现了多态。</li></ul></li><li><p>面向对象编程中的六大原则：</p><ul><li><img src="image-20250331094625361.png" alt="image-20250331094625361"></li></ul></li><li><p>普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。抽象类中的方法可以有实现也可以没有实现。抽象类用于描述类的共同特性和行为，接口只描述行为。</p></li><li><p>Java不允许多继承，但是可以实现多个接口。接口成员变量默认为public static final，必须赋初值，不能被修改，所有的成员方法都是public、abstract的。在接口中，不可以有构造方法。</p></li><li><p>静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</p></li><li><p>使用静态变量、方法的好处</p><ul><li>不依赖对象实例，节省内存，提高性能</li><li>方便全局访问，易于调用和管理</li><li>实现类级别的数据共享</li></ul></li><li><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p></li><li><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类（不能继承）、方法（不能重写）和变量（不能再赋值）。</p></li><li><p>实现对象深拷贝的方法：实现 Cloneable 接口并重写 clone() 方法、实现 Serializable 接口进行序列化和反序列化、手动递归复制</p></li><li><p>Java中创建对象的方式：new、反射（Class类的newInstance()和Constructor类的newInstance()）、clone()、序列化和反序列化</p></li><li><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性</p></li><li><p>Java注解：注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的<strong>动态代理类</strong>。作用域为类、方法、字段。</p></li><li><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="img" style="zoom:67%;" /></li><li><p>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。throws关键字：用于在方法声明中声明可能抛出的异常类型。</p></li><li><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理。finally子块中的代码<strong>一定会执行</strong>，即使在try&#x2F;catch中写了return语句也会被finally覆盖</p></li><li><p>重写 <code>equals</code> 方法时必须重写 <code>hashCode</code> 方法，equals为true则hashcode一定相同，反之不成立（哈希冲突）</p></li><li><p><code>StringBuilder</code> 不是线程安全的，<code>StringBuffer</code> 是线程安全的（用了synchronized）</p></li><li><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。它对应的并行流是 ParallelStream。</p></li><li><p>把一个对象从一个jvm传到另一个jvm：序列化和反序列化、消息队列、网络套接字、rpc、共享数据库或缓存</p></li><li><p>单例模式</p></li></ul><ul><li>lazy初始化的含义是指在调用<code>getInstance()</code>时才进行初始化<ul><li>volatile主要包含两个功能：保证修饰的变量对所有线程的可见性，禁止指令重排序优化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>            &#125; <br>        &#125; <br>    &#125; <br>    <span class="hljs-keyword">return</span> singleton;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Java NIO（non-blocking IO）、AIO（Asynchronous IO）、BIO（blocking IO）</p><ul><li>NIO是一种<strong>同步非阻塞</strong>的I&#x2F;O模型，也是<strong>I&#x2F;O多路复用</strong>的基础，可以只用一个线程处理多个客户端I&#x2F;O。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务</li><li>AIO是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，是基于事件和回调机制实现的</li><li>BIO是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里</li><li><img src="image-20250331121506850.png" alt="image-20250331121506850"></li></ul></li><li><p>native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码</p></li></ul><p><img src="image-20250331121606829.png" alt="image-20250331121606829"></p><h3 id="2-2-Java集合"><a href="#2-2-Java集合" class="headerlink" title="2.2 Java集合"></a>2.2 Java集合</h3><ul><li><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="img"></p></li><li><p>线程安全集合</p><ul><li><strong>Vector</strong>：线程安全的动态数组，内部方法基本都经过synchronized修饰</li><li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体。其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素</li><li><strong>Hashtable</strong>：线程安全的哈希表，给每个方法加上 synchronized 关键字。由于同步导致的性能开销，所以已经很少被推荐使用，可以用ConcurrentHashMap。</li><li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是二者加锁粒度的不同。JDK1.7加段锁，1.8换成行级锁</li><li><strong>ConcurrentSkipListMap</strong>：实现了一个基于SkipList（跳表）的可排序的并发集合</li><li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li><li><strong>CopyOnWriteArraySet</strong>：是线程安全的Set实现，它是线程安全的无序的集合</li><li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。</li><li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。它提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。生产进程同理。</li><li>同样也有<strong>ConcurrentLinkedDeque</strong>和<strong>BlockingDeque</strong></li></ul></li><li><p>集合遍历方法：普通带索引for循环、for-each、迭代器、forEach方法、Stream API</p></li><li><p>hashmap的put过程：</p><ul><li>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。</li><li>第二步：检查该位置是否为空（即没有键值对存在）</li><li>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</li><li>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键。如果找到了相同的键，则使用新的值取代旧的值。如果没有找到相同的键，则将新的键值对添加到链表的头部。红黑树同理。</li><li>第五步：检查链表长度是否达到阈值（默认为8），达到要转换成红黑树</li><li>第六步：检查负载因子是否超过阈值（默认为0.75）</li><li>第七步：扩容操作<img src="image-20250412111148416.png" alt="image-20250412111148416" style="zoom: 67%;" /></li><li>第八步：完成添加操作。</li></ul></li><li><p>HashMap在多线程下可能会出现的问题：JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。此外，多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p></li><li><p>HashMap默认容量：JDK1.7的时候初始容量是16，但是JDK1.8的时候初始化HashMap的时候并没有指定容量大小，而是在第一次执行put数据，才初始化容量。</p></li><li><p>ConcurrentHashMap实现：</p><ul><li>JDK 1.7 中使用是数组加链表的形式实现，而数组又分为：大数组 Segment 和小数组 HashEntry。一个 ConcurrentHashMap 里包含一个 Segment <strong>数组</strong>，一个 Segment 里包含一个 HashEntry <strong>数组</strong>。分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li>JDK 1.8 使用了数组 + 链表&#x2F;红黑树的方式优化了实现，主要通过 volatile + CAS 或者 synchronized 来实现线程安全</li><li>CAS是指compare and swap，意识是指一个旧的预期值A,主内存的值是B，要修改的值C，当且仅当A&#x3D;&#x3D;B的时候，A的值才会被修改成C，而且这个操作是<strong>原子性</strong>的，是一个非阻塞性的 <strong>乐观锁</strong>。在Java中，CAS操作主要依赖于<em>Unsafe</em>类，该类提供了硬件级别的原子操作支持。Unsafe类中的<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>方法用于实现CAS操作</li><li>添加元素时首先会判断容器是否为空：<ul><li>如果为空则使用 <strong>volatile 加 CAS （乐观锁）</strong> 来初始化</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空(键值)</li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树</li></ul></li></ul></li></ul><h3 id="2-3-Java并发编程"><a href="#2-3-Java并发编程" class="headerlink" title="2.3 Java并发编程"></a>2.3 Java并发编程</h3><ul><li>Java的线程安全在三个方面体现：原子性、可见性、有序性</li><li>保证数据的一致性的方案：事务机制、锁、版本号</li><li>线程的创建方式：继承thread类、实现runnable接口、使用线程池（Executor框架）</li><li>调用 <code>Thread.sleep()</code> 时，线程会释放 CPU，主动让出 CPU 时间片，但不会释放持有的锁。调用<code>wait</code>方法时，线程<strong>会释放持有的对象锁</strong>，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它</li><li>blocked状态不会使进程释放之前持有的锁，而waiting状态会</li><li>线程间通信方式<ul><li>Object 类的 wait()、notify() 和 notifyAll() 方法</li><li><code>Lock</code> 和 <code>Condition</code> 接口。<code>Lock</code> 接口提供了比<code>synchronized</code> 更灵活的锁机制，<code>Condition</code> 接口则配合 <code>Lock</code> 实现线程间的等待 &#x2F; 通知机制。Condition相当于条件变量，执行<code>await()</code>方法和<code>signal()</code>方法；Lock是锁，执行<code>lock()</code>和<code>unlock()</code>。</li><li><code>volatile</code> 关键字。当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新的值。</li><li>Semaphore。<code>Semaphore</code> 是一个计数信号量，它可以控制同时访问特定资源的线程数量。构造函数为<code>Semaphore(int permits)</code>，<code>acquire()</code>对应P操作，<code>release()</code>对应V操作</li><li>CountDownLatch和CyclicBarrier略。</li></ul></li><li>Thread的<code>interrupt()</code>方法不会立刻终止线程，只是设置中断标志位。线程需手动检查中断状态（<code>isInterrupted()</code>）或触发可中断操作（如<code>sleep()</code>，<code>wait()</code>，<code>join()</code>)响应中断。阻塞操作中收到中断请求时，会抛出 <code>InterruptedException</code> 并清除中断状态</li><li>在多线程编程中，join() 方法用于确保一个线程在另一个线程完成之前不会继续执行。具体来说，当一个线程调用另一个线程的 join() 方法时，调用线程将被阻塞，直到被调用的线程完成执行</li><li>线程池相关类<ul><li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等</li><li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池</li></ul></li><li><code>ThreadLocal</code>类<ul><li>可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</li><li><img src="1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="img" style="zoom: 67%;" /></li><li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key<strong>是</strong>ThreadLocal<strong>本身</strong>，value是ThreadLocal的泛型对象值。</li><li>当一个线程结束时，其<code>ThreadLocalMap</code>也会随之销毁，但是<code>ThreadLocal</code>对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。因此，在使用<code>ThreadLocal</code>时需要注意，如果不显式调用<code>remove()</code>方法，或者线程结束时未正确清理<code>ThreadLocal</code>变量，可能会导致内存泄漏</li></ul></li><li>实现线程同步的方法：synchronized、Lock(ReentrantLock)、volatile、Atomic类</li><li>Atomic类在实现细节上利用了CAS实现无锁的线程安全</li><li>锁机制相关<ul><li><strong>乐观锁和悲观锁</strong>：悲观锁通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。<code>synchronized</code>和<code>ReentrantLock</code>都是悲观锁的例子。乐观锁通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用CAS、版本号或时间戳来实现。</li><li><strong>自旋锁</strong>是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但<strong>过度自旋会浪费CPU资源</strong>。</li><li>“<strong>可重入</strong>”意味着同一个线程对同一把锁可以多次获取而不会死锁</li><li><strong>公平锁和非公平锁</strong>：公平锁指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。非公平锁中多个线程加锁时先通过 <strong>CAS</strong> 尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。非公平锁避免了线程休眠和恢复的操作，减少了内核态和用户态的切换，因此吞吐量更大。</li><li>偏向锁：对象在被某个线程第一次获取锁（例如 synchronized）时，JVM 会把这个线程的ID记录在对象头（Mark Word）中，将锁“偏向”这个线程。之后这个线程再次进入同步块时，只需检查对象头中记录的线程ID等于自己，无需做任何同步操作。</li><li>轻量级锁：将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁，该过程可以自旋（有次数限制）。出临界区同样也要用CAS进行替换。</li><li>重量级锁：线程会被操作系统调度然后挂起，这可以节约CPU资源。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="image.png" style="zoom:40%;" /></li></ul></li><li>Lock类相关<ul><li><code>ReentrantLock</code> 是 Java 并发包（<code>java.util.concurrent.locks</code>）中的一个可重入互斥锁实现，它提供了比 <code>synchronized</code> 关键字更灵活、更强大的锁机制。它支持设置超时时间，公平和非公平策略(默认是非公平锁)，且支持多个条件变量（<code>Condition condition = lock.newCondition();</code>）。</li><li><code>ReadWriteLock</code>接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</li><li><code>ReentrantLock</code>基于AQS(AbstractQueuedSynchronizer)实现。AQS 是一个用于构建锁和同步器的基础框架，它通过一个先进先出的等待队列管理多个线程的同步操作。</li><li>ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。</li><li>ReentrantLock的tryLock() 方法不遵守设定的公平原则</li></ul></li><li>synchronized相关<ul><li>synchronized修饰普通方法锁的是当前实例，而修饰静态方法锁的是class对象</li><li>synchronized 工作原理：基于对象的监视器锁。监视器锁是关联在某个对象上的锁，当线程执行同步代码时需要先获得该对象的监视器锁。主要依赖于字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>，分别是获取和释放监视器锁</li><li>synchronized 属于<strong>非公平锁</strong></li><li>synchronized是可重入锁，底层是利用系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。</li><li>锁膨胀：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，属于JVM对synchronized的优化</li></ul></li><li>CAS<ul><li>CAS 是一种乐观锁机制，它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS 操作的逻辑是，如果内存位置 V 的值等于预期值 A，则将其更新为新值 B，否则不做任何操作。</li><li>CAS的缺点主要有3点：<ul><li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A。</li><li><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行</li></ul></li><li>Java 提供的工具类会在 CAS 操作中增加<strong>版本号</strong>以避免ABA问题</li></ul></li><li>volatile并不能解决多线程并发下的复合操作问题，比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。</li><li>死锁条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>，即给资源设置全局获取顺序。</li><li>线程池<ul><li><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" alt="img" style="zoom: 80%;" /></li><li>线程池参数：<ul><li><strong>corePoolSize</strong>：线程池核心线程数量</li><li><strong>maximumPoolSize</strong>：线程池中最多可容纳的线程数量。</li><li><strong>keepAliveTime</strong>：线程数超过核心数时启用，空闲时间超过被销毁</li><li><strong>unit</strong>：就是keepAliveTime时间的单位</li><li><strong>workQueue</strong>：工作队列。</li><li><strong>threadFactory</strong>：线程工厂。可以用来给线程取名字等等</li><li><strong>handler</strong>：拒绝策略。可以用预置的也可以自定义</li></ul></li><li>预置拒绝策略<ul><li>CallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务</li><li>AbortPolicy，直接抛出一个任务被线程池拒绝的异常</li><li>DiscardPolicy，不做任何处理，静默拒绝提交的任务</li><li>DiscardOldestPolicy，抛弃最老的任务，然后执行该任务</li></ul></li><li>线程池种类<ul><li>ScheduledThreadPool：可以定期执行任务，比如每隔 10 秒钟执行一次</li><li>FixedThreadPool：核心线程数和最大线程数一样</li><li>CachedThreadPool：线程数是几乎可以无限增加的</li><li>SingleThreadExecutor：它会使用唯一的线程去执行任务，任务按被提交的顺序依次执行</li><li>SingleThreadScheduledExecutor：定期 + 唯一线程</li></ul></li><li>线程池关闭方法：shutdown ()，shutdownNow()。前者使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断，再提交任务会抛异常。后者置状态为STOP，并通过调用 Thread.interrupt() 方法，试图停止所有正在执行的线程（可能无法成功），不再处理还在池队列中等待的任务，它会返回那些未执行的任务列表(<code>List&lt;Runnable&gt;</code>)</li><li>提交的任务可以通过返回的Future对象的<code>cancel(boolean mayInterruptIfRunning)</code>方法取消，参数为ture允许中断正在执行的任务</li></ul></li></ul><h3 id="2-4-Java虚拟机"><a href="#2-4-Java虚拟机" class="headerlink" title="2.4 Java虚拟机"></a>2.4 Java虚拟机</h3><ul><li><p>JVM内存模型</p><ul><li>根据 JDK 8 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，通过 NIO 类引入，属于操作系统的本地内存，也是可以直接操作的。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt="img" style="zoom:67%;" /></li><li><strong>程序计数器</strong>：存储当前线程正在执行的 Java 方法的 JVM 指令地址</li><li><strong>虚拟机栈</strong>：每个线程都有自己独立的 Java 虚拟机栈，生命周期与线程相同，用于存储局部变量表、操作数栈、动态链接、方法出口</li><li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务</li><li><strong>堆</strong>：被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</li><li><strong>元空间</strong>：从Java 8开始，永久代被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息、方法的字节码等）。</li><li>一些细节<ul><li>创建一个对象时，对象的<strong>引用</strong>在当前方法的栈上，对象的<strong>实例</strong>在堆上</li><li>类的<strong>class对象</strong>存储在<strong>堆</strong>上(Java 8及以后)，元空间存的是类的<strong>字节码和类元数据</strong>而非对象。而在Java7及以前这两个都存在永久代中</li><li>在 Java 8 及以后，静态变量存储在<strong>堆</strong>中，和它所在的class对象在一起</li><li>在 Java 8 及以后，字符串常量池被移动到 Java <strong>堆</strong>中（实际的字符串值），而这些常量的符号引用存储在元空间</li></ul></li></ul></li><li><p>堆相关</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt="img" style="zoom:80%;" /></li><li><strong>新生代</strong>：新生代分为Eden Space和Survivor Space。大多数新创建的对象首先存放在Eden Space中，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间</li><li><strong>老年代</strong>：存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低</li><li>大对象通常会直接分配到老年代，有助于减少内存碎片的产生</li></ul></li><li><p>引用类型主要分为强引用（一般的赋值）、软引用（内存溢出前回收）、弱引用（每次GC都会回收，用于缓存系统）、虚引用四种</p></li><li><p>内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。发生情景：静态属性、未关闭的资源、ThreadLocal</p></li><li><p>创建对象过程</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img" style="zoom: 67%;" /></li></ul></li><li><p>类加载器与双亲委派模型</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt="img" style="zoom: 40%;" /></li><li><strong>启动类加载器</strong>：最顶层的类加载器，负责加载Java的核心库，是JVM的一部分</li><li><strong>扩展类加载器</strong>：是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录下的包和类库。扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</li><li><strong>系统类加载器&#x2F; 应用程序类加载器</strong>：是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是我们平时编写Java程序时默认使用的类加载器。</li><li>双亲委派模型：核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</li><li>双亲委派模型的作用：保证类的唯一性，防止用户自定义类覆盖核心类库；保证安全性，只加载信任的类；支持不同层次的类加载器服务于不同的类加载需求，简化流程</li></ul></li><li><p>类加载过程</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt="img" style="zoom: 55%;" /></li><li>加载：将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象）</li><li>连接：验证（符合JVM规范）、准备（创建并为静态变量赋0值）、解析（将符号引用转换为直接引用）</li><li>初始化：执行类的构造器方法（编译器自动生成的）</li></ul></li><li><p>判断垃圾算法</p><ul><li>引用计数法：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。无法处理循环引用。</li><li>可达性分析算法（主要）：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连，那么这个对象就被认为是不可达的，可以被回收。</li><li><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img" style="zoom:50%;" /></li></ul></li><li><p>垃圾回收算法</p><ul><li><strong>标记-清除算法</strong>：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。缺点是效率不高和内存碎片。</li><li><strong>复制算法</strong>：将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上，然后将然后再把已使用的内存整个清理掉。缺点是只能用一半，内存利用率不足</li><li><strong>标记-整理算法</strong>：“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理，而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</li><li><strong>分代回收算法</strong>：分代收集是将内存划分成了新生代和老年代。当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。年龄超过阈值（默认15）进入老年代。</li></ul></li><li><p>垃圾回收器</p><ul><li><img src="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" alt="img" style="zoom:80%;" /></li><li>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段</li><li>STW(Stop The World)：指垃圾回收时停止应用线程的阶段，G1中包括初始标记阶段、再标记阶段、清理阶段、复制(转移)阶段<ul><li><img src="image-20250421194434463.png" alt="image-20250421194434463" style="zoom:80%;" /></li></ul></li></ul></li><li><p>GC分类</p><ul><li>Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC</li><li>Full GC触发条件：直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法、Minor GC时老年代放不下存活的对象、元空间的空间不足时</li></ul></li><li><p>除了堆，GC也会对元空间（方法区）进行垃圾回收</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java虚拟机</tag>
      
      <tag>Java集合</tag>
      
      <tag>Java并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网八股</title>
    <link href="/2025/05/13/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/"/>
    <url>/2025/05/13/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-计网八股"><a href="#1-计网八股" class="headerlink" title="1. 计网八股"></a>1. 计网八股</h2><h3 id="1-1-基础部分"><a href="#1-1-基础部分" class="headerlink" title="1.1 基础部分"></a>1.1 基础部分</h3><ul><li><p>OSI</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul></li><li><p>TCP&#x2F;IP</p><ul><li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</li><li>传输层，负责端到端的通信，比如 TCP、UDP 等；</li><li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</li><li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、MAC 寻址、差错检测，以及通过网卡传输网络帧等；</li></ul></li><li><p>网络包发送过程</p><ul><li><img src="image-20250513180034091.png" alt="image-20250513180034091" style="zoom: 67%;" /></li><li><p>先创建 <code>socket</code> ，之后把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从<strong>用户态进入到内核态</strong>，最后会调用到 <code>sock_sendmsg</code> 方法。然后进入传输层带上<code>TCP</code>头，网络层带上<code>IP</code>头，数据链路层带上 <code>MAC</code>头等一系列操作后，进入网卡的<strong>发送队列 ring buffer</strong> ，顺着网卡就发出去了</p></li><li><p>发送网络数据的时候，涉及几次内存拷贝操作？</p><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p></li></ul></li><li><p>在浏览器输入网址后发生了什么</p><ul><li>解析URL：分析 URL 所需要使用的传输协议和请求的资源路径。</li><li>缓存判断：浏览器缓存 → 系统缓存（hosts 文件） → 路由器缓存 → ISP 的 DNS 缓存，如果其中某个缓存存在，直接返回服务器的IP地址。</li><li>DNS解析：如果缓存未命中，浏览器向本地 DNS 服务器发起请求，最终可能通过根域名服务器、顶级域名服务器（.com）、权威域名服务器逐级查询，最终获取到服务器IP</li><li>获取MAC地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址</li><li>建立TCP连接：使用目标 IP地址和目标MAC地址三次握手</li><li>HTTPS 的 TLS 四次握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的四次握手。</li><li>发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求</li><li>服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理</li><li>最后浏览器收到http响应后进行相应渲染和操作</li></ul></li><li><img src="image-20250425151648202.png" alt="image-20250425151648202" style="zoom:67%;" /></li></ul><h3 id="1-2-http"><a href="#1-2-http" class="headerlink" title="1.2 http"></a>1.2 http</h3><ul><li><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p></li><li><p>状态码</p><ul><li><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><ul><li>「<strong>101 Switching Protocols</strong>」协议切换，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。</li></ul></li><li><p><code>2xx</code> 服务器<strong>成功</strong>处理了客户端的请求</p><ul><li><p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul></li><li><p><code>3xx</code> ：资源<strong>重定向</strong></p><ul><li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul></li><li><p><code>4xx</code> ：客户端发送的<strong>报文有误</strong></p><ul><li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li><p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p></li><li><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul></li><li><p><code>5xx</code> ：服务器处理时内部发生了错误</p><ul><li>「<strong>500 Internal Server Error</strong>」是个笼统通用的错误码</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端</li></ul></li></ul></li><li><p>常见字段</p><ul><li>Host</li><li>Connection（keep-alive，默认开启）</li><li>Content-Length</li><li>Content-Type</li><li>Content-Encoding</li></ul></li><li><p>http报文结构</p><ul><li><img src="1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png"></li></ul></li><li><p>缓存</p><ul><li>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</li><li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</li><li><img src="image-20250513180117111.png" alt="image-20250513180117111" style="zoom:50%;" /></li></ul></li><li><p>HTTP&#x2F;1.1</p><ul><li>HTTP&#x2F;1.1 的优点：简单、灵活和易于扩展、应用广泛和跨平台。</li><li>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是无状态、明文传输，同时还有一大缺点不安全。</li><li>HTTP&#x2F;1.1性能相关：长连接、管道传输（队头阻塞）</li></ul></li><li><p>HTTPS</p><ul><li>在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议<ul><li><strong>信息加密</strong>：交互信息无法被窃取</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网</li></ul></li><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li><li>为了保证传输的内容不被篡改，需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</li><li><img src="image-20250513180142887.png" alt="image-20250513180142887"></li><li>TLS 四次握手（1.2）<ul><li>ClientHello：TLS 协议版本、Client Random、密码套件列表（如RSA）</li><li>SeverHello：确认 TLS 协议版本、Server Random、密码套件列表（如RSA）、服务器的数字证书</li><li>客户端回应：验证证书拿公钥、pre-master key、加密通信算法改变通知</li><li>服务器的最后回应：加密通信算法改变通知</li><li><img src="0877fe78380bf34ad3b28768e59fb53a.png" alt="图片" style="zoom: 60%;" /></li></ul></li><li>证书有信任链，先从根证书出发一步步拿公钥验证下一级</li><li>HTTPS本身一定是可靠的，不可靠的原因是用户手动信任了伪造的证书或中病毒被植入了根证书</li></ul></li><li><p>性能比较</p><ul><li>HTTP&#x2F;1.1与1.0相比：长连接、管道</li><li>HTTP&#x2F;2.0比HTTP&#x2F;1.1优：头部压缩（1.1只对body压缩）、二进制格式、并发传输（stream）、服务器主动推送资源</li><li>stream：针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</li><li>HTTP&#x2F;2队头阻塞：TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当前 1 个字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据</li><li>HTTP&#x2F;3：无队头阻塞（UDP，只会阻塞一个stream）、更快的连接建立（QUIC 内部包含了 TLS1.3）、连接迁移</li><li><img src="4cad213f5125432693e0e2a512c2d1a1.png" style="zoom:67%;" /></li></ul></li><li><p>前向安全性：即使长期密钥在未来被破解或泄露，也不会危及过去的通信内容</p></li><li><p>Socket与WebSocket</p><ul><li>Socket是操作系统提供的一个抽象层，用于应用程序与网络之间的通信，它允许应用程序通过 TCP 或 UDP 协议进行数据传输。它与WebSocket<strong>没有关联</strong></li><li>WebSocket 是一个<strong>协议</strong>，它提供了一种在单个 TCP 连接上进行<strong>全双工</strong>通信的机制。与传统的 HTTP 请求不同，WebSocket 允许服务器和客户端之间进行实时、双向的数据交换。</li><li>浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。如果想要升级成WebSocket协议，可以在header里添加相关字段表示申请升级协议</li><li><img src="f4edd3018914fe6eb38fad6aa3fd2d65.png" alt="图片" style="zoom:50%;" /></li></ul></li><li><p>DNS</p><ul><li>全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。</li><li>DNS服务器按级别分为根域、顶级域、权威服务器</li><li><img src="1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png" alt="img" style="zoom: 40%;" /></li></ul></li><li><p>Cookie、Session、Token</p><ul><li>Cookie的数据存储在<strong>客户端</strong>（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带Cookie中的数据，服务器可以通过读取这些Cookie来识别用户、管理会话状态以及保持特定的用户状态</li><li>Session的数据存储在<strong>服务器端</strong>。服务器为每个用户分配一个唯一的Session ID，客户端后续的请求会带上这个Session ID，服务器根据ID查找对应的Session数据。<strong>Session ID通常保存在Cookie中</strong>，因此禁用Cookie会使Session无法使用</li><li>token类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户，需要开发者手动添加。</li><li>由于cookie存储在客户端，因此容易受攻击，不安全，而session中敏感数据存储在服务器端，更加安全</li><li>Cookie可以设置过期时间，过期后自动删除。也可以设置为会话Cookie，即浏览器关闭时自动删除。Session在默认情况下，当用户关闭浏览器时Session结束。但服务器也可以设置Session的超时时间</li><li>SessionStorage是 Web Storage API 的一部分，用于在**同一个会话（session）**中存储数据。<code>localStorage</code> 的数据会被持久化到本地硬盘，<code>sessionStorage</code> 的数据只在当前会话中有效。<strong>SessionStorage与Session没有直接关联！</strong></li></ul></li><li><p>JWT令牌（JSON Web Token）</p><ul><li>JWT是无状态的令牌，包含了所有必要的信息，如用户身份、权限，不需要在服务器端存储会话信息。</li><li>JWT使用密钥对令牌进行签名，确保令牌的完整性和真实性。</li><li>JWT能解决集群部署。在传统的基于会话和Cookie的身份验证方式中，会话信息通常存储在服务器的内存或数据库中。但在集群部署中，不同服务器之间没有共享的会话信息，这会导致用户在不同服务器之间切换时需要重新登录或引入额外机制。而JWT令牌通过在令牌中包含所有必要的身份验证和会话信息，使得服务器无需存储会话信息。</li><li>如果JWT令牌泄露了，可以通过使其失效、加入黑名单的方式解决</li></ul></li><li><p>为什么有Http了还需要RPC</p><ul><li>RPC 本质上不算是协议，而是一种调用方式。从发展历史来说，HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构，但是现在不区分了。对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li></ul></li><li><p>nginx</p><ul><li>Nginx是一个 轻量级&#x2F;高性能的反向代理Web服务器，实现非常高效的反向代理、负载均衡，支持很高的并发</li><li>nginx位于应用层，是七层负载均衡</li><li>nginx负载均衡算法：轮询、IP哈希、URL哈希、最短响应时间、加权轮询</li></ul></li></ul><h3 id="1-3-TCP"><a href="#1-3-TCP" class="headerlink" title="1.3 TCP"></a>1.3 TCP</h3><ul><li>TCP头中需要关注：序列号seq，确认号ack，控制位（SYN、ACK、RST、FIN）<ul><li><img src="1718240465754-594d5aab-cb68-408a-b228-70fd33b094f4.png" alt="img" style="zoom: 50%;" /></li></ul></li><li>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</li><li>TCP 四元组（源地址、源端口、目的地址、目的端口）可以唯一的确定一个连接<ul><li>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，有一个不同就没事</li><li>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接</li></ul></li></ul><h4 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h4><ul><li><p>TCP和UDP可以用一个端口</p></li><li><p>三次握手</p><ul><li><img src="image-20250513180241917.png" alt="image-20250513180241917" style="zoom:67%;" /></li></ul></li></ul><ul><li>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接<ul><li>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样：为了防止历史报文被下一个相同四元组的连接接收（主要），防止黑客伪造的相同序列号的 TCP 报文被对方接收</li></ul></li></ul><ul><li>每次超时重传的间隔时间是上一次的 2 倍，到达系统规定的最大次数后关闭连接</li><li>TCP 半连接和全连接队列<ul><li><img src="format,png-20230309230622886.png" alt="正常流程" style="zoom:60%;" /></li><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5/3.jpg" alt="半连接队列与全连接队列" style="zoom:50%;" /></li><li>全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的半连接队列里的连接给删掉，并回复RST。</li><li>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</li><li>SYN 攻击解决方法：增大 TCP 半连接队列；开启 tcp_syncookies；减少 SYN+ACK 重传次数</li></ul></li><li>四次挥手<ul><li><img src="format,png-20230309230538308.png" alt="客户端调用 close 过程" style="zoom:50%;" /></li><li>等待2MSL的原因：相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</li><li>关于close和shutdown：<a href="https://blog.csdn.net/qq_41754573/article/details/103440516">https://blog.csdn.net/qq_41754573/article/details/103440516</a></li><li>如果连接是用 shutdown 函数关闭的，连接可以一直处于 FIN_WAIT2 状态，因为它可能还可以发送或接收数据。但对于 close 函数关闭的孤儿连接，由于无法再发送和接收数据，所以这个状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长默认为60s</li><li>当被动关闭方在 TCP 挥手过程中，没有数据要发送并且开启了 <strong>TCP 延迟确认机制</strong>，第二和第三次挥手就会合并传输，这样就出现了三次挥手</li></ul></li></ul><h4 id="TCP的一些机制"><a href="#TCP的一些机制" class="headerlink" title="TCP的一些机制"></a>TCP的一些机制</h4><blockquote><p>保活，socket各种函数，快速重传、流量控制，拥塞控制，FAST OPEN，close和shutdown，TCP延迟确认机制</p></blockquote><ul><li>TCP保活机制：定义一个时间段（一般是2小时），在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</li><li><img src="format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作" style="zoom:50%;" /></li><li>快速重传：当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li><li>SACK：在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</li><li>Duplicate SACK：又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉发送方有哪些数据被重复接收了。</strong></li><li>窗口：窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。<ul><li><img src="image-20250513180326229.png" alt="image-20250513180326229" style="zoom:67%;" /></li></ul></li><li>拥塞控制<ul><li>发生了超时重传，就会认为网络出现了拥塞</li><li>拥塞控制算法：<ul><li>慢启动（慢启动门限 <code>ssthresh</code>）：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</li><li>拥塞避免：每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd</li><li>拥塞发生：超时重传（ssthresh’ &#x3D; cwnd&#x2F;2, cwnd’ &#x3D; 1）、快速重传（cwnd’ &#x3D; cwnd&#x2F;2, ssthresh’ &#x3D; cwnd’, 进入快速恢复）</li><li>快速恢复：cwnd’ &#x3D; ssthresh’ + 3</li><li><img src="image-20250513180355283.png" alt="image-20250513180355283" style="zoom: 50%;" /></li></ul></li></ul></li><li>Fast Open：第一次请求结束时时缓存 Fast Open 选项中的 Cookie，以后再请求带上Cookie只需要两次握手<ul><li><img src="image-20250513180425727.png" alt="image-20250513180425727" style="zoom:50%;" /></li></ul></li><li>close和shutdown<ul><li><em>close()</em> 函数会立即关闭套接字的所有功能，而 <em>shutdown()</em> 函数可以选择关闭读、写或读写功能</li><li>close 函数同时关闭 socket 发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li>shutdown 函数可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响</li><li><img src="3b5f1897d2d74028aaf4d552fbce1a74.png" alt="close()" style="zoom:50%;" /></li><li><img src="71f5646ec58849e5921adc08bb6789d4.png" alt="优雅关闭.drawio.png" style="zoom:50%;" /></li></ul></li><li>TCP 延迟确认机制<ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></li></ul><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><ul><li>QUIC 使用Packet Number 单调递增的设计，并且即便是重传以前的报文这个序号也会增大，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</li><li>QUIC帧控制信息<ul><li>Stream ID：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID</li><li>Offset：类似于 TCP 协议中的 Seq 序号，保证数据的顺序性和可靠性</li><li>Length：指明了 Frame 数据的长度</li><li>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</li></ul></li><li>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</li><li>QUIC 实现流量控制的方式<ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据</li><li><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲</li><li><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量</li></ul></li><li>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，所以 TCP 拥塞控制算法迭代速度是很慢的。</li><li>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li><li>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，与TCP使用<strong>四元组</strong>区别开来</li></ul><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li>TCP 粘包问题：两个消息的某个部分内容被分到同一个 TCP 报文。这时接收方不知道消息的边界的话，是无法读出有效的消息。解决：固定长度的消息、特殊字符边界、自定义消息结构</li><li>SYN 报文被丢弃的两种场景：<ul><li>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，如果后来的连接请求时间戳比之前关闭的小就会被丢弃，造成 SYN 报文被丢弃</li><li>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</li></ul></li><li>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 <strong>Challenge ACK</strong>。客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端会释放连接。</li><li>在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？<ul><li>合法：客户端的  SYN 的序列号比服务端期望下一个收到的序列号要大，此时会重用此四元组连接</li><li>非法：客户端的  SYN 的序列号比服务端期望下一个收到的序列号要小，此时回RST</li></ul></li><li>如果客户端进程崩溃，客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手。但是如果客户端宕机（例如断电），那么是不会发生四次挥手的，下面要看服务端发送报文或者触发保活机制。</li><li>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文</li><li>就算不执行accept()方法，三次握手照常进行，并顺利建立连接。甚至在服务端执行accept()前，如果客户端发送消息给服务端，服务端是能够正常回复ack确认包的。</li><li>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手，不一定得调用关闭连接的函数</li><li>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</li><li>服务端主动断开连接的情况：HTTP 没有使用长连接、HTTP长连接超时、HTTP长连接请求数量达到上限</li><li>TCP 序列号和确认号的变化<ul><li>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li><li>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li><li><img src="dadf9a94328a4446b32ebabf1623c729.png" alt="TCP 序列号和确认号1" style="zoom: 50%;" /></li><li><img src="ae18cbf6071c47b98014a68d05c37d16.png" alt="TCP 序列号和确认号2" style="zoom:50%;" /></li></ul></li></ul><h3 id="1-4-IP"><a href="#1-4-IP" class="headerlink" title="1.4 IP"></a>1.4 IP</h3><ul><li><img src="image-20250513180553364.png" alt="image-20250513180553364" style="zoom: 50%;" /></li><li><img src="image-20250513180622526.png" alt="image-20250513180622526" style="zoom:50%;" />- 主机号全为 1 指定某个网络下的所有主机，用于广播- 主机号全为 0 指定某个网络</li><li>多播使用的 D 类地址，其前四位是 <code>1110</code> 就表示是多播地址，而剩下的 28 位是多播的组编号</li><li>无分类地址CIDR：a.b.c.d&#x2F;x，<code>/x</code> 表示前 x 位属于网络号</li><li><img src="image-20250513180641931.png" alt="image-20250513180641931" style="zoom:67%;" />- 可以通过子网掩码划分出网络号和主机号。上子网掩码还有一个作用，那就是**划分子网**。</li><li>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 <code>localhost</code> 的主机名。</li><li>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。一个 IP 地址中只允许出现一次两个连续的冒号。</li><li>IP 协议相关技术<ul><li>DNS 域名解析：TCP和UDP均可，一般默认UDP</li><li>ARP 与 RARP 协议</li><li>DHCP 动态获取 IP 地址：基于UDP</li><li>NAT 网络地址转换：网络地址与端口转换 NAPT<ul><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg" alt="NAPT" style="zoom:67%;" /></li></ul></li><li>ICMP 互联网控制报文协议<ul><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:50%;" /></li><li>ping使用查询类型报文</li><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/17.png" alt="主机 A ping 主机 B 期间发送的事情"></li></ul></li><li>IGMP 因特网组管理协议<ul><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/42.jpg" alt="组播模型" style="zoom:50%;" /></li></ul></li></ul></li><li>关于回环地址<ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于<code>127.0.0.1</code>（可修改）</li><li>到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。当发现<strong>目标IP是外网IP</strong>时，会从”真网卡”发出。当发现<strong>目标IP是回环地址</strong>时，就会选择<strong>本地网卡</strong>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>，将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。</li><li>0.0.0.0在ipv4中是无效目的地址，但如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，则表示本机上的<strong>所有IPV4地址</strong>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些其他模板</title>
    <link href="/2025/05/09/%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%A8%A1%E6%9D%BF/"/>
    <url>/2025/05/09/%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="一些其他模板"><a href="#一些其他模板" class="headerlink" title="一些其他模板"></a>一些其他模板</h2><span id="more"></span><h3 id="1-快速求阶乘（带模）"><a href="#1-快速求阶乘（带模）" class="headerlink" title="1. 快速求阶乘（带模）"></a>1. 快速求阶乘（带模）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">200005</span>; <span class="hljs-comment">// 根据题目最大 n 设置</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span>[] fact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[MAX];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br><br>        initFactorial();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> ans;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-number">2L</span> * fact[even] % MOD * fact[even] % MOD;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = fact[even] * fact[n - even] % MOD;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理阶乘数组</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFactorial</span><span class="hljs-params">()</span> &#123;<br>        fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>            fact[i] = fact[i - <span class="hljs-number">1</span>] * i % MOD;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-组合数模板（带模）"><a href="#2-组合数模板（带模）" class="headerlink" title="2. 组合数模板（带模）"></a>2. 组合数模板（带模）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Combinatorics</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">200005</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span>[] fact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[MAX];     <span class="hljs-comment">// 阶乘数组</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span>[] invFact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[MAX];  <span class="hljs-comment">// 阶乘逆元数组</span><br><br>    <span class="hljs-comment">// 初始化阶乘和逆元</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        fact[<span class="hljs-number">0</span>] = invFact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>            fact[i] = fact[i - <span class="hljs-number">1</span>] * i % MOD;<br>        &#125;<br>        invFact[MAX - <span class="hljs-number">1</span>] = modInverse(fact[MAX - <span class="hljs-number">1</span>], MOD);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> MAX - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            invFact[i] = invFact[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % MOD;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 快速幂求 a^b % mod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">modPow</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> mod)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res = res * a % mod;<br>            a = a * a % mod;<br>            b &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 费马小定理求逆元（当 mod 是质数时）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">modInverse</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> mod)</span> &#123;<br>        <span class="hljs-keyword">return</span> modPow(a, mod - <span class="hljs-number">2</span>, mod);<br>    &#125;<br><br>    <span class="hljs-comment">// 求 C(n, k) % mod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span> || k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使用示例</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Combinatorics.init(); <span class="hljs-comment">// 先初始化</span><br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> in.nextInt();<br><br>        System.out.println(Combinatorics.C(n, k)); <span class="hljs-comment">// 输出 C(n, k) % MOD</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>,<span class="hljs-number">44</span>,<span class="hljs-number">23</span>,<span class="hljs-number">67</span>,<span class="hljs-number">88</span>,<span class="hljs-number">65</span>,<span class="hljs-number">34</span>,<span class="hljs-number">48</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>&#125;;<br><span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];    <span class="hljs-comment">//新建一个临时数组存放</span><br>mergeSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,tmp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>System.out.print(arr[i]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high,<span class="hljs-type">int</span>[] tmp)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low,k = mid+<span class="hljs-number">1</span>;  <span class="hljs-comment">//左边序列和右边序列起始索引</span><br><span class="hljs-keyword">while</span>(j &lt;= mid &amp;&amp; k &lt;= high)&#123;<br><span class="hljs-keyword">if</span>(arr[j] &lt; arr[k])&#123;<br>tmp[i++] = arr[j++];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tmp[i++] = arr[k++];<br>&#125;<br>&#125;<br><span class="hljs-comment">//若左边序列还有剩余，则将其全部拷贝进tmp[]中</span><br><span class="hljs-keyword">while</span>(j &lt;= mid)&#123;    <br>tmp[i++] = arr[j++];<br>&#125;<br><br><span class="hljs-keyword">while</span>(k &lt;= high)&#123;<br>tmp[i++] = arr[k++];<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;i;t++)&#123;<br>arr[low+t] = tmp[t];<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high,<span class="hljs-type">int</span>[] tmp)</span>&#123;<br><span class="hljs-keyword">if</span>(low&lt;high)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low+high)/<span class="hljs-number">2</span>;<br>mergeSort(arr,low,mid,tmp); <span class="hljs-comment">//对左边序列进行归并排序</span><br>mergeSort(arr,mid+<span class="hljs-number">1</span>,high,tmp);  <span class="hljs-comment">//对右边序列进行归并排序</span><br>merge(arr,low,mid,high,tmp);    <span class="hljs-comment">//合并两个有序序列</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4. 正则表达式"></a>4. 正则表达式</h3><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>任意一个字符（除换行）</td></tr><tr><td><code>\\d</code></td><td>一个数字，等价于 <code>[0-9]</code></td></tr><tr><td><code>\\w</code></td><td>单词字符，等价于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\\s</code></td><td>空白字符（空格、Tab、换行）</td></tr><tr><td><code>*</code></td><td>前一个字符重复 0 次或多次</td></tr><tr><td><code>+</code></td><td>前一个字符重复 1 次或多次</td></tr><tr><td><code>?</code></td><td>前一个字符重复 0 或 1 次</td></tr><tr><td><code>&#123;n&#125;</code></td><td>恰好 n 次</td></tr><tr><td>{a, b}</td><td>匹配前一个字符a~b次，b不写的话表示任意次</td></tr><tr><td><code>[abc]</code></td><td>匹配 a 或 b 或 c</td></tr><tr><td><code>[^abc]</code></td><td>除了 a b c 以外的字符</td></tr><tr><td><code>()</code></td><td>分组，提取数据用</td></tr></tbody></table><ul><li>常见用法有String类的matches()方法，regex库的Pattern类和Matcher类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123-456-7890&quot;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> Pattern.matches(pattern, text);<br>        System.out.println(match); <span class="hljs-comment">// true</span><br>        <br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(<span class="hljs-string">&quot;abc123def456&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Found: &quot;</span> + matcher.group()); <span class="hljs-comment">// 123, 456</span><br>        &#125;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Name: John, Age: 30&quot;</span>;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;Name: (\\w+), Age: (\\d+)&quot;</span>);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(text);<br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Name = &quot;</span> + matcher.group(<span class="hljs-number">1</span>)); <span class="hljs-comment">// John</span><br>            System.out.println(<span class="hljs-string">&quot;Age = &quot;</span> + matcher.group(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 30</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-计数排序"><a href="#5-计数排序" class="headerlink" title="5. 计数排序"></a>5. 计数排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countSort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-comment">//1.得到数列的最大值与最小值，并算出差值d</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] &gt; max) &#123;<br>            max = array[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(array[i] &lt; min) &#123;<br>            min = array[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> max - min;<br>    <span class="hljs-comment">//2.创建基于差值长度的统计数组并统计填充对应元素个数</span><br>    <span class="hljs-type">int</span>[] countArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[d + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        countArray[array[i] - min]++;<br>    &#125;<br>    <span class="hljs-comment">//3.统计数组变形，后面的元素等于前面的元素之和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; countArray.length; i++) &#123;<br>        countArray[i] = countArray[i] + countArray[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组</span><br>    <span class="hljs-type">int</span>[] sortedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> countArray[array[i] - min] -<span class="hljs-number">1</span>;<br>        sortedArray[index] = array[i];<span class="hljs-comment">//按存取的方式取出临时数组的元素</span><br>        countArray[array[i] - min]--;  <span class="hljs-comment">// 临时数组相应位置减1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sortedArray;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后的倒序遍历是为了实现稳定性</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
      <tag>正则表达式</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/2025/05/09/%E6%95%B0%E8%AE%BA/"/>
    <url>/2025/05/09/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="12-数论"><a href="#12-数论" class="headerlink" title="12. 数论"></a>12. 数论</h2><h3 id="12-1-质数相关"><a href="#12-1-质数相关" class="headerlink" title="12.1 质数相关"></a>12.1 质数相关</h3><ul><li>判断质数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n &gt;= <span class="hljs-number">2</span>; <span class="hljs-comment">// 1 不是质数</span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>预处理质数（筛质数）<ul><li>如果 <em>x</em> 是质数，那么大于 <em>x</em> 的 <em>x</em> 的倍数 2<em>x</em>,3<em>x</em>,… 一定不是质数</li><li>从 2x 开始标记是冗余的，直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 埃氏筛</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(isPrime, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i] == <span class="hljs-number">1</span>) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 预处理示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MX</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">78500</span>];<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-type">boolean</span>[] np = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MX + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 为true不是质数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= MX; ++i)<br>        <span class="hljs-keyword">if</span> (!np[i]) &#123;<br>            primes[pi++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= MX / i; ++j) <span class="hljs-comment">// 避免溢出的写法</span><br>                np[i * j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    primes[pi++] = MX + <span class="hljs-number">1</span>;<br>    primes[pi++] = MX + <span class="hljs-number">1</span>; <span class="hljs-comment">// 保证下面下标不会越界</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-其他数论"><a href="#12-2-其他数论" class="headerlink" title="12.2 其他数论"></a>12.2 其他数论</h3><ul><li>n!末尾有多少个0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 循环 k 次后，n 变成了 floor(n/5^k)</span><br>            n /= <span class="hljs-number">5</span>;<br>            ans += n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最大公因数 gcd</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : gcd(y, x % y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最小公倍数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a / gcd(a, b) * b;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-3-模运算与组合数"><a href="#12-3-模运算与组合数" class="headerlink" title="12.3 模运算与组合数"></a>12.3 模运算与组合数</h3><blockquote><p><a href="https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/">https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/</a></p></blockquote><ul><li>模运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">MOD = <span class="hljs-number">1_000_000_007</span><br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 把任意整数 a 取模到 [0,MOD-1] 中，无论 a 是正是负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘（注意使用 64 位整数）</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * qpow(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><ul><li>组合数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100_001</span>; <span class="hljs-comment">// 根据题目数据范围修改</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] F = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[MX]; <span class="hljs-comment">// F[i] = i!</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] INV_F = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[MX]; <span class="hljs-comment">// INV_F[i] = i!^-1</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; MX; i++) &#123;<br>            F[i] = F[i - <span class="hljs-number">1</span>] * i % MOD;<br>        &#125;<br><br>        INV_F[MX - <span class="hljs-number">1</span>] = pow(F[MX - <span class="hljs-number">1</span>], MOD - <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> MX - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            INV_F[i - <span class="hljs-number">1</span>] = INV_F[i] * i % MOD;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; n &gt; <span class="hljs-number">0</span>; n /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                res = res * x % MOD;<br>            &#125;<br>            x = x * x % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 n 个数中选 m 个数的方案数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">comb</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">return</span> m &lt; <span class="hljs-number">0</span> || m &gt; n ? <span class="hljs-number">0</span> : F[n] * INV_F[m] % MOD * INV_F[n - m] % MOD;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 预处理的逻辑写在 static 块中，这样只会初始化一次</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速幂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> N;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// x^-n = (1/x)^n</span><br>            n = -n;<br>            x = <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 从低到高枚举 n 的每个比特位</span><br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 这个比特位是 1</span><br>                ans *= x; <span class="hljs-comment">// 把 x 乘到 ans 中</span><br>            &#125;<br>            x *= x; <span class="hljs-comment">// x 自身平方</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续枚举下一个比特位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2025/05/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2025/05/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11. 动态规划"></a>11. 动态规划</h2><span id="more"></span><h3 id="11-1-动态规划基础"><a href="#11-1-动态规划基础" class="headerlink" title="11.1 动态规划基础"></a>11.1 动态规划基础</h3><ul><li>记忆化搜索<ul><li>使用一个数组存储递归过程中算过的答案，例如<code>dfs(i, j)</code>对应<code>cache[i][j]</code>，这样可以避免重复计算</li><li><img src="image-20250403154236533.png" alt="image-20250403154236533"></li></ul></li><li>从递归到递推<ul><li><img src="image-20250403154332297.png" alt="image-20250403154332297"></li><li>由于每次计算并不需要数组中前面出现的所有值，因此可以用几个变量优化空间复杂度</li></ul></li></ul><h3 id="11-2-背包"><a href="#11-2-背包" class="headerlink" title="11.2 背包"></a>11.2 背包</h3><blockquote><p>核心思路：选货不选</p></blockquote><ul><li><p>0-1背包</p><ul><li><img src="image-20250403154634314.png" alt="image-20250403154634314" style="zoom:80%;" /></li><li>求方案数：把Math.max改成加法<br><img src="image-20250403154955666.png" alt="image-20250403154955666"></li></ul></li><li><p>完全背包</p><ul><li><p><img src="image-20250403155350531.png" alt="image-20250403155350531"></p></li><li><p><img src="image-20250403155529153.png" alt="image-20250403155529153"></p></li><li><p>例：零钱兑换</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 零钱兑换1 求最少多少枚</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp[<span class="hljs-number">0</span>], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= coins[i - <span class="hljs-number">1</span>]) dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - coins[i - <span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dp[n][amount] == Integer.MAX_VALUE / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> dp[n][amount];<br>&#125;<br><br><span class="hljs-comment">// 零钱兑换2 求方案数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= coins[i - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - coins[i - <span class="hljs-number">1</span>]];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>分组背包</p><ul><li><p>与其他背包问题区别在于每个物品有数量限制，可以选一个或多个但不能超过数量</p></li><li><p>例：2585.获得分数的方法数 <a href="https://leetcode.cn/problems/number-of-ways-to-earn-points/">https://leetcode.cn/problems/number-of-ways-to-earn-points/</a></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">waysToReachTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[][] types)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> types.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> types[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">marks</span> <span class="hljs-operator">=</span> types[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; j++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= Math.min(count, j / marks); k++)&#123;<br>                    res += dp[i - <span class="hljs-number">1</span>][j - k * marks];<br>                &#125;<br>                dp[i][j] = (<span class="hljs-type">int</span>)(res % MOD);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-3-最长公共子序列LCS"><a href="#11-3-最长公共子序列LCS" class="headerlink" title="11.3 最长公共子序列LCS"></a>11.3 最长公共子序列LCS</h3><ul><li><p>LCS</p><ul><li><img src="image-20250403161109074.png" alt="image-20250403161109074"></li><li><img src="image-20250403161144691.png" alt="image-20250403161144691"></li><li><img src="image-20250403161605938.png" alt="image-20250403161605938"><br>答案是不需要，所以最终可以简化：<br><img src="image-20250403161831815.png" alt="image-20250403161831815"></li></ul></li><li><p>最长公共子串</p><ul><li>字串是连续的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> in.next(), s2 = in.next();<br>        String short_str, long_str;<br>        <span class="hljs-keyword">if</span>(s1.length() &lt; s2.length())&#123;<br>            short_str = s1;<br>            long_str = s2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            short_str = s2;<br>            long_str = s1;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[short_str.length() + <span class="hljs-number">1</span>][long_str.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= short_str.length(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= long_str.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(short_str.charAt(i - <span class="hljs-number">1</span>) == long_str.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(dp[i][j] &gt; max_len)&#123;<br>                        max_len = dp[i][j];<br>                        end = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(short_str.substring(end - max_len, end));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-4-最长递增子序列-LIS"><a href="#11-4-最长递增子序列-LIS" class="headerlink" title="11.4 最长递增子序列 LIS"></a>11.4 最长递增子序列 LIS</h3><ul><li><p>记忆化搜索&#x2F;动态规划做法</p><ul><li><img src="image-20250403163700347.png" alt="image-20250403163700347"></li><li><img src="image-20250403163940255.png" alt="image-20250403163940255"></li><li>时间复杂度O(n^2)</li></ul></li><li><p>二分查找 + 贪心</p><ul><li><p><img src="image-20250403164536440.png" alt="image-20250403164536440"></p></li><li><p><img src="image-20250403164604852.png" alt="image-20250403164604852"></p></li><li><p><img src="image-20250403164628151.png" alt="image-20250403164628151"></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> lowerBound(g, x);<br>            <span class="hljs-keyword">if</span> (j == g.size()) &#123;<br>                g.add(x); <span class="hljs-comment">// &gt;=x 的 g[j] 不存在</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                g.set(j, x);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> g.size();<br>    &#125;<br><br>    <span class="hljs-comment">// 开区间写法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(List&lt;Integer&gt; g, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = g.size(); <span class="hljs-comment">// 开区间 (left, right)</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g.get(mid) &lt; target) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-5-状态机DP"><a href="#11-5-状态机DP" class="headerlink" title="11.5 状态机DP"></a>11.5 状态机DP</h3><blockquote><p>以买卖股票的最佳时机为例 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p></blockquote><ul><li><p><img src="image-20250403190355135.png" alt="image-20250403190355135"></p></li><li><p>不限交易次数</p><ul><li><img src="image-20250403190421591.png" alt="image-20250403190421591" style="zoom:80%;" /></li><li><img src="image-20250403190517177.png" alt="image-20250403190517177" style="zoom:80%;" /></li><li><img src="image-20250403192520618.png" alt="image-20250403192520618" style="zoom:80%;" /></li><li><img src="image-20250403192659077.png" alt="image-20250403192659077" style="zoom:80%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, f1 = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">old_f0</span> <span class="hljs-operator">=</span> f0;<br>            f0 = Math.max(f0, f1 + prices[i]);<br>            f1 = Math.max(f1, old_f0 - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>至多交易 k 次</p><ul><li><img src="image-20250403193009644.png" alt="image-20250403193009644" style="zoom:80%;" /></li><li><img src="image-20250403193127475.png" alt="image-20250403193127475" style="zoom:80%;" /></li><li><img src="image-20250403193433705.png" alt="image-20250403193433705" style="zoom:80%;" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] mat : f) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : mat) &#123;<br>                Arrays.fill(row, Integer.MIN_VALUE / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k + <span class="hljs-number">1</span>; j++) &#123;<br>            f[<span class="hljs-number">0</span>][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k + <span class="hljs-number">1</span>; j++) &#123;<br>                f[i + <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] = Math.max(f[i][j][<span class="hljs-number">0</span>], f[i][j][<span class="hljs-number">1</span>] + prices[i]);<br>                f[i + <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] = Math.max(f[i][j][<span class="hljs-number">1</span>], f[i][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][k + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-6-区间DP"><a href="#11-6-区间DP" class="headerlink" title="11.6 区间DP"></a>11.6 区间DP</h3><ul><li><p><img src="image-20250403194112286.png" alt="image-20250403194112286"></p></li><li><p>最长回文子序列</p><ul><li>思路一：将字符串反转后和原字符串求LCS</li><li>思路二：选或不选，从两侧向中间缩小</li><li><img src="image-20250404143917429.png" alt="image-20250404143917429" style="zoom:80%;" /></li><li><img src="image-20250404144016447.png" alt="image-20250404144016447" style="zoom:80%;" /></li><li><img src="image-20250404144141621.png" alt="image-20250404144141621" style="zoom:80%;" /></li></ul></li><li><p>多边形三角剖分的最低得分</p><ul><li><p>思路：枚举出一个三角形后可以把多边形拆分成两个新的多边形（子问题）</p></li><li><img src="image-20250414165706185.png" alt="image-20250414165706185" style="zoom:50%;" /><blockquote><p>注意图中的max写错了，应该是min</p></blockquote></li><li><p>递归边界：多边形只有两个点，即<code>dfs(i, i + 1) = 0</code>;</p></li><li><img src="image-20250414170630968.png" alt="image-20250414170630968" style="zoom: 80%;" /></li></ul></li></ul><h3 id="11-7-划分型-DP"><a href="#11-7-划分型-DP" class="headerlink" title="11.7 划分型 DP"></a>11.7 划分型 DP</h3><ul><li><p>题型是将给定的一个序列划分为几段，求对应的一些子数组个数、方案数、相关最优值</p><ul><li><p>判定能否划分：一般定义 <em>f</em>[<em>i</em>] 表示长为 <em>i</em> 的前缀 <em>a</em>[:<em>i</em>] 能否划分。做法是枚举最后一个子数组的左端点 <em>L</em>，从 <em>f</em>[<em>L</em>] 转移到 <em>f</em>[<em>i</em>]，并考虑 <em>a</em>[<em>L</em>:<em>i</em>] 是否满足要求。</p></li><li><p>最优划分：一般定义 f[i] 表示长为 i 的前缀 a[:i] 在题目约束下，分割出的最少（最多）子数组个数（或者定义成分割方案数）。枚举最后一个子数组的左端点 L，从 f[L] 转移到 f[i]，并考虑 a[L:i] 对最优解的影响。</p></li><li><p>限制划分次数：一般定义 f[i] [j] 表示将长为 j 的前缀 a[:j] 分成 i 个连续子数组所得到的最优解。</p><p>枚举最后一个子数组的左端点 L，从 f[i−1] [L] 转移到 f[i] [j]，并考虑 a[L:j] 对最优解的影响。</p></li></ul></li><li><p>模板：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 132.分割回文串II https://leetcode.cn/problems/palindrome-partitioning-ii/description/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[][] check = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> row : check) Arrays.fill(row, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &lt; i) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == j) check[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> check[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; check[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++)&#123;<br>            <span class="hljs-keyword">if</span>(check[<span class="hljs-number">0</span>][r]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; l &lt;= r; l++)&#123;<br>                <span class="hljs-keyword">if</span>(check[l][r])&#123;<br>                    ans = Math.min(ans, dp[l - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            dp[r] = ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-8-状态压缩DP"><a href="#11-8-状态压缩DP" class="headerlink" title="11. 8 状态压缩DP"></a>11. 8 状态压缩DP</h3><blockquote><p>核心思想是用一个二进制数代替容器记录集合元素的选择情况</p><p>位运算相关看这个：<a href="https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/">https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/</a></p></blockquote><h4 id="11-8-1-排列型（相邻无关）"><a href="#11-8-1-排列型（相邻无关）" class="headerlink" title="11.8.1 排列型（相邻无关）"></a>11.8.1 排列型（相邻无关）</h4><ul><li>一般有两种定义方式：<ul><li>定义 f[S] 表示已经排列好的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。</li><li>定义 f[S] 表示可以选的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 526.优美的排列，求的是排列数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; n]; <span class="hljs-comment">// 共有1 &lt;&lt; n种状态，即0 ~ (1 &lt;&lt; n) - 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; s &lt;= (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; s++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.bitCount(s); <span class="hljs-comment">// 已经选了的数个数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-comment">// j被选过且合法</span><br>                <span class="hljs-keyword">if</span>((s &gt;&gt; (j - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> &amp;&amp; (i % j == <span class="hljs-number">0</span> || j % i == <span class="hljs-number">0</span>))&#123; <br>                    dp[s] += dp[s ^ (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))]; <span class="hljs-comment">// 用异或来还原j的位置</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 3376.破解锁的最少时间I，求的是最小时间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinimumTime</span><span class="hljs-params">(List&lt;Integer&gt; strength, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strength.size();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; n];<br>        Arrays.fill(dp, Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); s++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.bitCount(s);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                    dp[s] = Math.min(dp[s], dp[s ^ (<span class="hljs-number">1</span> &lt;&lt; j)] + (<span class="hljs-type">int</span>)Math.ceil(<span class="hljs-number">1.0</span> * strength.get(j) / (<span class="hljs-number">1</span> + k * (i - <span class="hljs-number">1</span>))));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-8-2-排列型（相邻相关）"><a href="#11-8-2-排列型（相邻相关）" class="headerlink" title="11.8.2 排列型（相邻相关）"></a>11.8.2 排列型（相邻相关）</h4><ul><li>一般定义 <code>f[S][i]</code> 表示未选（或者已选）的集合为 <em>S</em>，且上一个填的元素（下标）为 <code>i</code> 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 996.平方数组的数目</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquarefulPerms</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">1</span> &lt;&lt; j][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); s++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 枚举前一个选的</span><br>                <span class="hljs-keyword">if</span>((s &gt;&gt; i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(i != j &amp;&amp; (s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; isSquare(nums[i], nums[j]))&#123;<br>                        dp[s][i] += dp[s ^ (<span class="hljs-number">1</span> &lt;&lt; i)][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ans += dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][i];<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            map.merge(num, <span class="hljs-number">1</span>, (ov, nv) -&gt; (ov + nv));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt : map.values()) temp *= factorial(cnt);<br>        <span class="hljs-keyword">return</span> ans / temp;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> num1 + num2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.sqrt(sum);<br>        <span class="hljs-keyword">return</span> temp * temp == sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= num; i++) &#123;<br>            product *= i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-9-树形DP"><a href="#11-9-树形DP" class="headerlink" title="11.9 树形DP"></a>11.9 树形DP</h3><h3 id="11-9-1-树的直径"><a href="#11-9-1-树的直径" class="headerlink" title="11.9.1 树的直径"></a>11.9.1 树的直径</h3><ul><li>见二叉树部分</li></ul><h3 id="11-9-2-树上最大独立集"><a href="#11-9-2-树上最大独立集" class="headerlink" title="11.9.2 树上最大独立集"></a>11.9.2 树上最大独立集</h3><ul><li><strong>最大独立集</strong>需要在树上找出尽可能多(也可能是总价值高)的点并且使它们互不相邻</li><li><img src="image-20250528192653920.png" alt="image-20250528192653920"></li><li>思路：每个点有两种状态，即选或不选，分别会对应一个值，那么一个节点就有两个值</li><li><img src="image-20250528192725572.png" alt="image-20250528192725572"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] ans = dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(ans[<span class="hljs-number">0</span>], ans[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] l = dfs(root.left);<br>        <span class="hljs-type">int</span>[] r = dfs(root.right);<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        ans[<span class="hljs-number">0</span>] = l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>] + root.val;<br>        ans[<span class="hljs-number">1</span>] = Math.max(l[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>], r[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>拓展：一般树<ul><li><img src="image-20250528192847467.png" alt="image-20250528192847467" style="zoom:50%;" /></li></ul></li><li><img src="hexoimage-20250528192917742.png" alt="image-20250528192917742"></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2025/05/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2025/05/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9. 并查集"></a>9. 并查集</h2><ul><li>当你发现数据可以被分组，那么就可以考虑用并查集</li></ul><span id="more"></span><ul><li><p><a href="https://blog.csdn.net/Royalic/article/details/119832038">https://blog.csdn.net/Royalic/article/details/119832038</a></p></li><li><p>模板</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] fa; <span class="hljs-comment">// 代表元</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] size; <span class="hljs-comment">// 集合大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> cc; <span class="hljs-comment">// 连通块个数</span><br><br>    UnionFind(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 一开始有 n 个集合 &#123;0&#125;, &#123;1&#125;, ..., &#123;n-1&#125;</span><br>        <span class="hljs-comment">// 集合 i 的代表元是自己，大小为 1</span><br>        fa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fa[i] = i;<br>        &#125;<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(size, <span class="hljs-number">1</span>);<br>        cc = n;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 x 所在集合的代表元</span><br>    <span class="hljs-comment">// 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 如果 fa[x] == x，则表示 x 是代表元</span><br>        <span class="hljs-keyword">if</span> (fa[x] != x) &#123;<br>            fa[x] = find(fa[x]); <span class="hljs-comment">// fa 改成代表元</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 x 和 y 是否在同一个集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// 如果 x 的代表元和 y 的代表元相同，那么 x 和 y 就在同一个集合</span><br>        <span class="hljs-comment">// 这就是代表元的作用：用来快速判断两个元素是否在同一个集合</span><br>        <span class="hljs-keyword">return</span> find(x) == find(y);<br>    &#125;<br><br>    <span class="hljs-comment">// 把 from 所在集合合并到 to 所在集合中</span><br>    <span class="hljs-comment">// 返回是否合并成功</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> find(from);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> find(to);<br>        <span class="hljs-keyword">if</span> (x == y) &#123; <span class="hljs-comment">// from 和 to 在同一个集合，不做合并</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        fa[x] = y; <span class="hljs-comment">// 合并集合。修改后就可以认为 from 和 to 在同一个集合了</span><br>        size[y] += size[x]; <span class="hljs-comment">// 更新集合大小（注意集合大小保存在代表元上）</span><br>        <span class="hljs-comment">// 无需更新 size[x]，因为我们不用 size[x] 而是用 size[find(x)] 获取集合大小，但 find(x) == y，我们不会再访问 size[x]</span><br>        cc--; <span class="hljs-comment">// 成功合并，连通块个数减一</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 x 所在集合的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> size[find(x)]; <span class="hljs-comment">// 集合大小保存在代表元上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>例子：T990.等式方程的可满足性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equationsPossible</span><span class="hljs-params">(String[] equations)</span> &#123;<br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String str : equations) &#123;<br>            <span class="hljs-keyword">if</span> (str.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">3</span>) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                union(parent, index1, index2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String str : equations) &#123;<br>            <span class="hljs-keyword">if</span> (str.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">3</span>) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (find(parent, index1) == find(parent, index2)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parent, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        parent[find(parent, index1)] = find(parent, index2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parent, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">while</span> (parent[index] != index) &#123;<br>            parent[index] = parent[parent[index]];<br>            index = parent[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2025/05/09/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2025/05/09/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="8-前缀和"><a href="#8-前缀和" class="headerlink" title="8. 前缀和"></a>8. 前缀和</h2><span id="more"></span><h3 id="8-1-基础"><a href="#8-1-基础" class="headerlink" title="8.1 基础"></a>8.1 基础</h3><ul><li>讲解：<a href="https://leetcode.cn/problems/range-sum-query-immutable/solutions/2693498/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/">https://leetcode.cn/problems/range-sum-query-immutable/solutions/2693498/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/</a></li><li>模板：T303</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] s;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            s[i + <span class="hljs-number">1</span>] = s[i] + nums[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> s[right + <span class="hljs-number">1</span>] - s[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-前缀和-哈希表"><a href="#8-2-前缀和-哈希表" class="headerlink" title="8.2 前缀和 + 哈希表"></a>8.2 前缀和 + 哈希表</h3><ul><li>通常要用到「枚举右，维护左」的技巧，即定下一个值并通过遍历求它对应的另一个值</li><li>通常做法是一边遍历求前缀和，一边查看哈希表中有无想要的另一个前缀和，并更新答案</li><li>例子：560.和为k的子数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(nums.length + <span class="hljs-number">1</span>); <span class="hljs-comment">// 设置容量可以快 2ms</span><br>        cnt.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// s[0]=0 单独统计</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            s += x;<br>            ans += cnt.getOrDefault(s - k, <span class="hljs-number">0</span>);<br>            cnt.merge(s, <span class="hljs-number">1</span>, Integer::sum); <span class="hljs-comment">// cnt[s]++</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-距离和"><a href="#8-3-距离和" class="headerlink" title="8.3 距离和"></a>8.3 距离和</h3><ul><li>核心是把一个有序数组分成比要求的数小的部分和大的部分，然后分别求其距离和</li><li><img src="1679808210-FVsAou-t3.png" alt="t3.png" style="zoom:50%;" /></li><li>例题：T2602.使数组元素全部相等的最少操作次数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] queries)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;Long&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Long[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(s, <span class="hljs-number">0L</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) s[i + <span class="hljs-number">1</span>] = s[i] + nums[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> queries[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> binarySearch(nums, q);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len_l</span> <span class="hljs-operator">=</span> idx, len_r = n - idx;<br>            ans.add((<span class="hljs-type">long</span>)q * len_l - s[idx] + s[n] - s[idx] - (<span class="hljs-type">long</span>)q * len_r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123; <span class="hljs-comment">// 找第一个 &gt;= target的index</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, r = nums.length;<br>        <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-4-二维前缀和"><a href="#8-4-二维前缀和" class="headerlink" title="8.4 二维前缀和"></a>8.4 二维前缀和</h3><ul><li>用于矩阵的前缀和</li><li><img src="1692152740-dSPisw-matrix-sum.png" alt="matrix-sum.png" style="zoom: 33%;" /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[][] sum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                sum[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = sum[i + <span class="hljs-number">1</span>][j] + sum[i][j + <span class="hljs-number">1</span>] - sum[i][j] + matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回左上角在 (r1,c1) 右下角在 (r2,c2) 的子矩阵元素和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> c1, <span class="hljs-type">int</span> r2, <span class="hljs-type">int</span> c2)</span> &#123;<br>        <span class="hljs-keyword">return</span> sum[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>] - sum[r2 + <span class="hljs-number">1</span>][c1] - sum[r1][c2 + <span class="hljs-number">1</span>] + sum[r1][c1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="/2025/05/09/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2025/05/09/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><h3 id="7-1-单调栈"><a href="#7-1-单调栈" class="headerlink" title="7.1 单调栈"></a>7.1 单调栈</h3><ul><li>基本概念<ul><li>先进先出<ul><li>记录的数放在栈顶</li><li>丢掉数据也从栈顶开始</li></ul></li><li>单调性<ul><li>在记录<code>t[i]</code>之前会把所有<code>≤t[i]</code>的数据弹出，，不可能出现上面大下面小</li></ul></li></ul></li></ul><span id="more"></span><ul><li>例：739.每日温度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i])<br>                stack.pop();<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty()) ans[i] = stack.peek() - i;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="1681051452-jbvxIo-1019-1-c.png" alt="1019-1-c.png" style="zoom: 33%;" /><h3 id="7-2-单调队列"><a href="#7-2-单调队列" class="headerlink" title="7.2 单调队列"></a>7.2 单调队列</h3><ul><li>典型场景：不断有元素进出队列（窗口）的同时需要维护一个最大&#x2F;最小值</li><li>原理是队尾新进来的元素一定比之前入队的元素晚过期，因此可以把队内不需要的元素“挤出去”</li><li>过程：新元素入队，把队尾开始不需要的元素挤出去，然后检查队头元素是否过期</li><li>模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 239.滑动窗口最大值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]) queue.removeLast();<br>            queue.offerLast(i);<br>            <span class="hljs-keyword">if</span>(queue.peekFirst() &lt;= i - k) queue.removeFirst();<br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) ans[i - k + <span class="hljs-number">1</span>] = nums[queue.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2025/05/09/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2025/05/09/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="6-回溯"><a href="#6-回溯" class="headerlink" title="6. 回溯"></a>6. 回溯</h2><ul><li>回溯三问<ul><li>当前操作？</li><li>子问题是什么？</li><li>下一个子问题是什么？</li></ul></li></ul><span id="more"></span><h3 id="6-1-子集型回溯"><a href="#6-1-子集型回溯" class="headerlink" title="6.1 子集型回溯"></a>6.1 子集型回溯</h3><h4 id="6-1-1-写法一：输入的视角（选或不选）"><a href="#6-1-1-写法一：输入的视角（选或不选）" class="headerlink" title="6.1.1 写法一：输入的视角（选或不选）"></a>6.1.1 写法一：输入的视角（选或不选）</h4><ul><li>对于输入的nums，考虑每个nums[i] 是选还是不选，由此组合出2^n个不同的子集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == nums.length) &#123; <span class="hljs-comment">// 子集构造完毕</span><br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 复制 path</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 不选 nums[i]</span><br>        dfs(i + <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 选 nums[i]</span><br>        path.add(nums[i]);<br>        dfs(i + <span class="hljs-number">1</span>);<br>        path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 恢复现场</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-写法二：答案的视角（枚举选哪个）"><a href="#6-1-2-写法二：答案的视角（枚举选哪个）" class="headerlink" title="6.1.2 写法二：答案的视角（枚举选哪个）"></a>6.1.2 写法二：答案的视角（枚举选哪个）</h4><ul><li>枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 复制 path</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123; <span class="hljs-comment">// 枚举选择的数字</span><br>            path.add(nums[j]);<br>            dfs(j + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 恢复现场</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-划分型回溯"><a href="#6-2-划分型回溯" class="headerlink" title="6.2 划分型回溯"></a>6.2 划分型回溯</h3><ul><li>把分割线（逗号）看成是可以「选或不选」的东西，本质是子集型回溯。</li><li>例题：131.分割回文串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String s;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-built_in">this</span>.s = s;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// start 表示当前这段回文子串的开始位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == s.length()) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 复制 path</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不选 i 和 i+1 之间的逗号（i=n-1 时一定要选）</span><br>        <span class="hljs-keyword">if</span> (i &lt; s.length() - <span class="hljs-number">1</span>) &#123;<br>            dfs(i + <span class="hljs-number">1</span>, start);<br>        &#125;<br><br>        <span class="hljs-comment">// 选 i 和 i+1 之间的逗号（把 s[i] 作为子串的最后一个字符）</span><br>        <span class="hljs-keyword">if</span> (isPalindrome(start, i)) &#123;<br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            dfs(i + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一个子串从 i+1 开始</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 恢复现场</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-排列型回溯"><a href="#6-3-排列型回溯" class="headerlink" title="6.3 排列型回溯"></a>6.3 排列型回溯</h3><ul><li>举例：46.全排列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[nums.length]); <span class="hljs-comment">// 所有排列的长度都是一样的 n</span><br>        <span class="hljs-type">boolean</span>[] onPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(<span class="hljs-number">0</span>, nums, ans, path, onPath);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, <span class="hljs-type">boolean</span>[] onPath)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!onPath[j]) &#123;<br>                path.set(i, nums[j]); <span class="hljs-comment">// 从没有选的数字中选一个</span><br>                onPath[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 已选上</span><br>                dfs(i + <span class="hljs-number">1</span>, nums, ans, path, onPath);<br>                onPath[j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 恢复现场</span><br>                <span class="hljs-comment">// 注意 path 无需恢复现场，因为排列长度固定，直接覆盖就行</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2025/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2025/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5. 二叉树"></a>5. 二叉树</h2><h3 id="5-1-遍历二叉树"><a href="#5-1-遍历二叉树" class="headerlink" title="5.1 遍历二叉树"></a>5.1 遍历二叉树</h3><h4 id="5-1-1-递归写法"><a href="#5-1-1-递归写法" class="headerlink" title="5.1.1 递归写法"></a>5.1.1 递归写法</h4><ul><li>前(先)序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderRecur</span><span class="hljs-params">(TreeNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>    preOrderRecur(head.left);<br>    preOrderRecur(head.right);<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderRecur</span><span class="hljs-params">(TreeNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    preOrderRecur(head.left);<br>    System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>    preOrderRecur(head.right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderRecur</span><span class="hljs-params">(TreeNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    postOrderRecur(head.left);<br>    postOrderRecur(head.right);<br>    System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-1-2-迭代写法"><a href="#5-1-2-迭代写法" class="headerlink" title="5.1.2 迭代写法"></a>5.1.2 迭代写法</h4><ul><li>前(先)序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                res.add(node.val);<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            node = node.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() || node != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            ans.add(node.val);<br>            node = node.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() || node != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            <span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">null</span> || node.right == prev) &#123;<br>                ans.add(node.val);<br>                prev = node;<br>                node = <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                stack.push(node);<br>                node = node.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-二叉树的DFS"><a href="#5-2-二叉树的DFS" class="headerlink" title="5.2 二叉树的DFS"></a>5.2 二叉树的DFS</h3><h4 id="5-2-1-自顶向下"><a href="#5-2-1-自顶向下" class="headerlink" title="5.2.1 自顶向下"></a>5.2.1 自顶向下</h4><ul><li>在**【递】**的过程中维护一个值，如深度或最大值等</li><li>举例：104.二叉树的最大深度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> depth;<br>        <span class="hljs-keyword">return</span> Math.max(dfs(node.left, depth + <span class="hljs-number">1</span>), dfs(node.right, depth + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2-自底向上-DFS"><a href="#5-2-2-自底向上-DFS" class="headerlink" title="5.2.2 自底向上 DFS"></a>5.2.2 自底向上 DFS</h4><ul><li>在**【归】**的过程中计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lDepth</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rDepth</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(lDepth, rDepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>自底向上 DFS删点<ul><li>注意删点时只能由父节点删子节点（如<code>node.left = null</code>），因此要通过递归返回一个布尔值来让父节点判断是否要删</li><li>如果根节点要删除，只能通过主函数来让root &#x3D; null</li></ul></li></ul><h4 id="5-2-3-寻找最近公共祖先"><a href="#5-2-3-寻找最近公共祖先" class="headerlink" title="5.2.3 寻找最近公共祖先"></a>5.2.3 寻找最近公共祖先</h4><ul><li><img src="1681546069-BZfraI-236.png" alt="236.png"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 左右都找到</span><br>            <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 当前节点是最近公共祖先</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> left != <span class="hljs-literal">null</span> ? left : right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4-求二叉树的直径"><a href="#5-2-4-求二叉树的直径" class="headerlink" title="5.2.4 求二叉树的直径"></a>5.2.4 求二叉树的直径</h4><ul><li>二叉树的直径定义为二叉树中任意两个节点之间最长路径的长度，可以包含从子节点向父节点方向的边</li><li>路径可能经过也可能不经过根节点</li><li>算法核心思想是局部最长路径一定包含两个子树的最大深度路径，那么局部的最长路径长度就是两个子树深度之和，对所有节点重复该过程不断更新ans</li><li>有两个关键概念：<ul><li>链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。</li><li>直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lLen</span> <span class="hljs-operator">=</span> dfs(node.left) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子树最大链长+1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rLen</span> <span class="hljs-operator">=</span> dfs(node.right) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右子树最大链长+1</span><br>        ans = Math.max(ans, lLen + rLen); <span class="hljs-comment">// 两条链拼成路径</span><br>        <span class="hljs-keyword">return</span> Math.max(lLen, rLen); <span class="hljs-comment">// 当前子树最大链长</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-5-回溯"><a href="#5-2-5-回溯" class="headerlink" title="5.2.5 回溯"></a>5.2.5 回溯</h4><ul><li>常见于题目要返回走过的路径（如节点编号1-&gt;3-&gt;6-&gt;4）</li><li>核心思路是维护一个全局的List，在对子树递归前将当前节点对应的值放入List，结束后再remove</li></ul><h4 id="5-2-6-二叉搜索树"><a href="#5-2-6-二叉搜索树" class="headerlink" title="5.2.6 二叉搜索树"></a>5.2.6 二叉搜索树</h4><ul><li>前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> node.val;<br>        <span class="hljs-keyword">return</span> left &lt; x &amp;&amp; x &lt; right &amp;&amp;<br>               isValidBST(node.left, left, x) &amp;&amp;<br>               isValidBST(node.right, x, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中序遍历<ul><li>注意，二叉搜索树的中序遍历所得结果正好是按元素升序排列的，这一性质有很多运用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left) || root.val &lt;= pre) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = root.val;<br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>] != Long.MAX_VALUE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] dfs(TreeNode node) &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;Long.MAX_VALUE, Long.MIN_VALUE&#125;;<br>        &#125;<br>        <span class="hljs-type">long</span>[] left = dfs(node.left);<br>        <span class="hljs-type">long</span>[] right = dfs(node.right);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> node.val;<br>        <span class="hljs-comment">// 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了</span><br>        <span class="hljs-keyword">if</span> (x &lt;= left[<span class="hljs-number">1</span>] || x &gt;= right[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;Long.MIN_VALUE, Long.MAX_VALUE&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;Math.min(left[<span class="hljs-number">0</span>], x), Math.max(right[<span class="hljs-number">1</span>], x)&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除二叉搜索树的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-keyword">if</span>(root.left == root.right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br>            root.val = getLMaxVal(root.left);<br>            root.left = deleteNode(root.left, root.val);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            root.left = deleteNode(root.left, key);<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLMaxVal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val;<br>        <span class="hljs-keyword">return</span> getLMaxVal(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>插入二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        insert(root, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(node.val &gt; val)&#123;<br>            <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span>)&#123;<br>                node.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            insert(node.left, val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">null</span>)&#123;<br>                node.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            insert(node.right, val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-7-构造二叉树"><a href="#5-2-7-构造二叉树" class="headerlink" title="5.2.7 构造二叉树"></a>5.2.7 构造二叉树</h4><ul><li>从前序和中序构造<ul><li>如果是二叉搜索树且只给了前序，可以对前序进行排序获得中序，从而转化成本问题</li><li>步骤：<ul><li><strong>确定根节点</strong>：在前序遍历序列中，第一个元素即为根节点。</li><li><strong>定位中序中的根节点位置</strong>：在中序遍历序列中找到根节点的位置，这将分割序列为左右子树。</li><li><strong>递归构建子树</strong>：使用相同的方法递归地构建左右子树。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorder_root</span> <span class="hljs-operator">=</span> preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_root]);<br>        <br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left_subtree</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从后序和中序构造<ul><li>为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（元素，下标）键值对的哈希表。</li><li>定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，递归入口为helper(0, n - 1) ：<ul><li>如果 in_left &gt; in_right，说明子树为空，返回空节点。</li><li>选择后序遍历的最后一个节点作为根节点。</li><li>利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。</li><li>根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。注意这里有需要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。</li><li>返回根节点 root。</li></ul></li></ul></li><li>前序和后序<ul><li>说明：无法确定一棵二叉树，有多个答案，返回一个即可</li><li>没看懂。。T_T 链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructFromPrePost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        Map&lt;Integer, Integer&gt; postMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            postMap.put(postorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(preorder, postorder, postMap, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] postorder, Map&lt;Integer, Integer&gt; postMap, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span> postLeft, <span class="hljs-type">int</span> postRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preLeft &gt; preRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (preLeft &lt; preRight) &#123;<br>            leftCount = postMap.get(preorder[preLeft + <span class="hljs-number">1</span>]) - postLeft + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preLeft],<br>            dfs(preorder, postorder, postMap, preLeft + <span class="hljs-number">1</span>, preLeft + leftCount, postLeft, postLeft + leftCount - <span class="hljs-number">1</span>),<br>            dfs(preorder, postorder, postMap, preLeft + leftCount + <span class="hljs-number">1</span>, preRight, postLeft + leftCount, postRight - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-二叉树的BFS"><a href="#5-3-二叉树的BFS" class="headerlink" title="5.3 二叉树的BFS"></a>5.3 二叉树的BFS</h3><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                cur.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>            &#125;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(cur));<br>            cur.clear();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>回溯</tag>
      
      <tag>递归</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2025/05/09/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2025/05/09/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="4-图论"><a href="#4-图论" class="headerlink" title="4. 图论"></a>4. 图论</h2><ul><li>DFS适用于需要计算连通块个数、大小的题目，BFS适用于需要计算最短距离（最短路）的题目。</li></ul><span id="more"></span><h3 id="4-1-DFS"><a href="#4-1-DFS" class="headerlink" title="4.1 DFS"></a>4.1 DFS</h3><h4 id="4-1-1-基础"><a href="#4-1-1-基础" class="headerlink" title="4.1.1 基础"></a>4.1.1 基础</h4><ul><li>图用矩阵存时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> cur)</span>&#123;<br>    visited[cur] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[cur] &amp;&amp; graph[cur][i] == <span class="hljs-number">1</span>) dfs(graph, visited, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>图用邻接表存时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表构建示例</span><br>ArrayList&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : edges)&#123;<br>    adj[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>    adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(ArrayList&lt;Integer&gt;[] adj, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> cur)</span>&#123;<br>    visited[cur] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : adj[cur])&#123;<br>        <span class="hljs-keyword">if</span>(!visited[cur]) cnt += dfs(adj, visited, next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当图为有向图时，不需要visited数组</li></ul><h3 id="4-2-BFS"><a href="#4-2-BFS" class="headerlink" title="4.2 BFS"></a>4.2 BFS</h3><h4 id="4-2-1-基础"><a href="#4-2-1-基础" class="headerlink" title="4.2.1 基础"></a>4.2.1 基础</h4><ul><li>使用BFS求最短路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(List&lt;Integer&gt;[] adj, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span>[] steps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        steps[i] = -<span class="hljs-number">1</span>;<br>    &#125;<br>    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(<span class="hljs-number">0</span>);<br>    visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : adj[cur])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[next])&#123; <span class="hljs-comment">// 也可以用dist[next] == -1 作为条件</span><br>                queue.add(next);<br>                visited[next] = <span class="hljs-literal">true</span>;<br>                 steps[next] = steps[cur] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> steps[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-拓扑排序"><a href="#4-3-拓扑排序" class="headerlink" title="4.3 拓扑排序"></a>4.3 拓扑排序</h3><ul><li>把拓扑排序想象成一个黑盒，给它一堆杂乱的先修课约束，它会给你一个井井有条的课程学习安排。这是一种在图上的「排序」，可以把杂乱的点排列一排。前提条件是<strong>图中无环</strong>，从而保证每条边是从排在前面的点，指向排在后面的点。</li><li><img src="1738131168-tWFNGZ-006-toposort.png"></li><li>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：<ul><li>如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。这是因为假设图中存在环<code>x1, x2...xn</code>，那么在排列中 x1 必须出现在 xn 的前面，但同时 xn 也必须出现在 x1 的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；</li><li>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li></ul></li></ul><h4 id="4-3-1-解法一：DFS"><a href="#4-3-1-解法一：DFS" class="headerlink" title="4.3.1 解法一：DFS"></a>4.3.1 解法一：DFS</h4><ul><li>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。这样一来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终<strong>从栈顶到栈底的序列</strong>就是一种拓扑排序。</li><li>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：<ul><li>「未搜索」：我们还没有搜索到这个节点；</li><li>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</li><li>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</li></ul></li><li>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：<ul><li>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</li><li>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</li><li>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</li></ul></li><li>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</li><li>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt;[] adj;<br>    <span class="hljs-type">int</span>[] visited;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[numCourses];<br>        Arrays.setAll(adj, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] pre : prerequisites)&#123;<br>            adj[pre[<span class="hljs-number">1</span>]].add(pre[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>&#123;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : adj[u])&#123;<br>            <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">0</span>)&#123;<br>                dfs(v);<br>                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">1</span>)&#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-解法二：BFS"><a href="#4-3-2-解法二：BFS" class="headerlink" title="4.3.2 解法二：BFS"></a>4.3.2 解法二：BFS</h4><ul><li>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的前置要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门前置要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这个节点可以加入答案。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</li><li>算法<ul><li>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</li><li>在广度优先搜索的每一步中，我们取出队首的节点 u：<ul><li>我们将 u 放入答案中；</li><li>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</li></ul></li><li>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-type">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : prerequisites)&#123;<br>            adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>            inDegree[edge[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i] == <span class="hljs-number">0</span>) q.offer(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                ans[index++] = cur;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : adj[cur])&#123;<br>                    <span class="hljs-keyword">if</span>(--inDegree[next] == <span class="hljs-number">0</span>) q.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != numCourses) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-最短路"><a href="#4-4-最短路" class="headerlink" title="4.4 最短路"></a>4.4 最短路</h3><h4 id="4-4-1-单源最短路：Dijkstra算法"><a href="#4-4-1-单源最短路：Dijkstra算法" class="headerlink" title="4.4.1 单源最短路：Dijkstra算法"></a>4.4.1 单源最短路：Dijkstra算法</h4><ul><li><p>定义 <code>g[i][j] </code>表示节点 i 到节点 j 这条边的边权。如果没有 i 到 j 的边，则 g<code>[i][j] </code>&#x3D; <code>∞</code>。</p></li><li><p>定义 dis[i] 表示起点 k 到节点 i 的最短路长度，一开始 dis[k]&#x3D;0，其余 dis[i]&#x3D;∞ 表示尚未计算出。</p></li><li><p>我们的目标是计算出最终的 dis 数组。</p></li><li><p>算法步骤：</p><ul><li>首先更新起点 k 到其邻居 y 的最短路，即更新 dis[y] 为 g<code>[k][y]</code>。</li><li>然后取除了起点 k 以外的 dis[i] 的最小值，假设最小值对应的节点是 3。此时可以断言：dis[3] 已经是 k 到 3 的最短路长度，不可能有其它 k 到 3 的路径更短！此时我们得到了 dis[3] 的最终值。</li><li>用节点 3 到其邻居 y 的边权 g<code>[3][y] </code>更新 dis[y]：如果 dis[3]+g<code>[3][y]</code>&lt;dis[y]，那么更新 dis[y] 为 dis[3]+g<code>[3][y]</code>，否则不更新。</li><li>然后取除了节点 k,3 以外的 dis[i] 的最小值，重复上述过程。</li><li>由数学归纳法可知，这一做法可以得到每个点的最短路。当所有点的最短路都已确定时，算法结束。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 743.网络延迟时间 https://leetcode.cn/problems/network-delay-time/description/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : g) &#123;<br>            Arrays.fill(row, INF);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] t : times) &#123;<br>            g[t[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>][t[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] = t[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dis, INF);<br>        dis[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] done = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!done[i] &amp;&amp; (x &lt; <span class="hljs-number">0</span> || dis[i] &lt; dis[x])) &#123;<br>                    x = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> maxDis; <span class="hljs-comment">// 全算完了</span><br>            <span class="hljs-keyword">if</span>(dis[x] == INF) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            maxDis = dis[x];<br>            done[x] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>                <span class="hljs-comment">// 更新 x 的邻居的最短路</span><br>                dis[y] = Math.min(dis[y], dis[x] + g[x][y]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-全源最短路：Floyd-算法"><a href="#4-4-2-全源最短路：Floyd-算法" class="headerlink" title="4.4.2 全源最短路：Floyd 算法"></a>4.4.2 全源最短路：Floyd 算法</h4><p><del>我发现跑n次dijkstra也是可以的</del></p><blockquote><p>递推部分略</p></blockquote><ul><li>相应的递推式（状态转移方程）也和 dfs 是一样的：<code>f[k][i][j]=min(f[k−1][i][j],f[k−1][i][k]+f[k−1][k][j])</code><br>但是，这种定义方式没有状态能表示递归边界，即 k&#x3D;−1 的情况。</li><li>解决办法：把 f 数组的长度加一（在前面插入一个二维数组），用 <code>f[0][i][j] </code>表示<code> dfs(−1,i,j)=w[i][j]</code>。由于<code> f[0]</code> 被占用，f 第一维度的下标需要全部向右偏移一位，也就是把<code>f[k]</code>改为 <code>f[k+1]</code>。</li><li>修改后<code>f[k+1][i][j]</code>表示从 i 到 j 的最短路长度，并且这条最短路的中间节点编号都 ≤k。</li><li>修改后的递推式为：<code>f[k+1][i][j]=min(f[k][i][j],f[k][i][k]+f[k][k][j])</code>。初始值<code> f[0][i][j]=w[i][j]</code>，翻译自 <code>dfs(−1,i,j)=w[i][j]</code>。</li><li>从 i 到 j 的最短路长度为<code> f[n][i][j]</code>，翻译自<code> dfs(n−1,i,j)</code>。<br>链接：<a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2525946/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/">https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2525946/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[][] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : w) &#123;<br>            Arrays.fill(row, Integer.MAX_VALUE / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止加法溢出</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], y = e[<span class="hljs-number">1</span>], wt = e[<span class="hljs-number">2</span>];<br>            w[x][y] = w[y][x] = wt;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n][n];<br>        f[<span class="hljs-number">0</span>] = w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    f[k + <span class="hljs-number">1</span>][i][j] = Math.min(f[k][i][j], f[k][i][k] + f[k][k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minCnt</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i &amp;&amp; f[n][i][j] &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= minCnt) &#123; <span class="hljs-comment">// 相等时取最大的 i</span><br>                minCnt = cnt;<br>                ans = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-最小生成树"><a href="#4-5-最小生成树" class="headerlink" title="4.5 最小生成树"></a>4.5 最小生成树</h3><h4 id="4-5-1-Kruskal算法"><a href="#4-5-1-Kruskal算法" class="headerlink" title="4.5.1 Kruskal算法"></a>4.5.1 Kruskal算法</h4><p><del>太复杂了先空着hhh</del></p><h4 id="4-5-2-Prim算法"><a href="#4-5-2-Prim算法" class="headerlink" title="4.5.2 Prim算法"></a>4.5.2 Prim算法</h4><ul><li><img src="image-20240108115459395.png" alt="image-20240108115459395" style="zoom:50%;" /></li><li><img src="image-20240108115748149.png" alt="image-20240108115748149" style="zoom:50%;" /></li><li>模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dist, inf);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; (u == -<span class="hljs-number">1</span> || dist[u] &gt; dist[j])) &#123;<br>                    u = j;<br>                &#125;<br>            &#125;<br>            visited[u] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[j]) &#123;<br>                    <span class="hljs-comment">//更换距离函数，其他的完全还是模板，一模一样</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newDist</span> <span class="hljs-operator">=</span> Math.abs(points[j][<span class="hljs-number">0</span>] - points[u][<span class="hljs-number">0</span>]) + Math.abs(points[j][<span class="hljs-number">1</span>] - points[u][<span class="hljs-number">1</span>]);<br>                    dist[j] = Math.min(dist[j], newDist);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> Arrays.stream(dist).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-6-二分图染色"><a href="#4-6-二分图染色" class="headerlink" title="4.6 二分图染色"></a>4.6 二分图染色</h3><ul><li><p>对于图中的任意两个节点 u 和 v，如果它们之间有一条边直接相连，那么 u 和 v 必须属于不同的集合。</p></li><li><p>如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成红色。随后我们对整个图进行遍历，将该节点直接相连的所有节点染成绿色，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，直到无向图中的每个节点均被染色。</p></li><li><p>如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同，也就说明这个无向图不是一个二分图。</p></li><li><p>算法的流程如下：</p><ul><li><p>我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；</p></li><li><p>在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况：</p><ul><li>如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；</li><li>如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 false 作为答案。</li></ul></li><li><p>当遍历结束时，说明给定的无向图是二分图，返回 true 作为答案。</p></li></ul></li><li><pre><code class="language-java">// DFSclass Solution &#123;    private static final int UNCOLORED = 0;    private static final int RED = 1;    private static final int GREEN = 2;    private int[] color;    private boolean valid;    public boolean isBipartite(int[][] graph) &#123;        int n = graph.length;        valid = true;        color = new int[n];        Arrays.fill(color, UNCOLORED);        for (int i = 0; i &lt; n &amp;&amp; valid; ++i) &#123;            if (color[i] == UNCOLORED) &#123;                dfs(i, RED, graph);            &#125;        &#125;        return valid;    &#125;    public void dfs(int node, int c, int[][] graph) &#123;        color[node] = c;        int cNei = c == RED ? GREEN : RED;        for (int neighbor : graph[node]) &#123;            if (color[neighbor] == UNCOLORED) &#123;                dfs(neighbor, cNei, graph);                if (!valid) &#123;                    return;                &#125;            &#125; else if (color[neighbor] != cNei) &#123;                valid = false;                return;            &#125;        &#125;    &#125;&#125;// BFSclass Solution &#123;    private static final int UNCOLORED = 0;    private static final int RED = 1;    private static final int GREEN = 2;    private int[] color;    public boolean isBipartite(int[][] graph) &#123;        int n = graph.length;        color = new int[n];        Arrays.fill(color, UNCOLORED);        for (int i = 0; i &lt; n; ++i) &#123;            if (color[i] == UNCOLORED) &#123;                Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();                queue.offer(i);                color[i] = RED;                while (!queue.isEmpty()) &#123;                    int node = queue.poll();                    int cNei = color[node] == RED ? GREEN : RED;                    for (int neighbor : graph[node]) &#123;                        if (color[neighbor] == UNCOLORED) &#123;                            queue.offer(neighbor);                            color[neighbor] = cNei;                        &#125; else if (color[neighbor] != cNei) &#123;                            return false;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>递归</tag>
      
      <tag>数据结构</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>最短路</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2025/05/09/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/05/09/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-删除节点"><a href="#3-1-删除节点" class="headerlink" title="3.1 删除节点"></a>3.1 删除节点</h3><ul><li>要想删除节点 <em>node</em>，必须在 <em>node</em> 的前一个节点执行删除操作。</li><li>例如链表 1→2→3，要想删除 2，必须在节点 1 处操作，也就是把节点 1 的 <em>next</em> 更新为节点 3。</li><li>如果头节点可能被删除，那么要在头节点之前添加一个<strong>哨兵节点</strong>（dummy node），这样我们无需特判头节点被删除的情况，从而简化代码逻辑。</li><li>算法细节<ol><li>初始化哨兵节点 dummy，其 next 为 head。</li><li>遍历链表，初始化 cur&#x3D;dummy。</li><li>循环直到 cur 的下一个节点为空。</li><li>如果 cur 的下一个节点的值等于 val，那么删除下一个节点，把 cur.next 更新为 cur.next.next。</li><li>如果 cur 的下一个节点的值不等于 val，那么不删除下一个节点，继续看下下一个节点是否要删除，即更新 cur 为 cur.next。</li><li>循环结束，返回 dummy.next，即删除节点后的新链表的头节点。</li></ol></li></ul><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val == val) &#123;<br>                cur.next = cur.next.next; <span class="hljs-comment">// 删除下一个节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next; <span class="hljs-comment">// 继续向后遍历链表</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-插入节点"><a href="#3-2-插入节点" class="headerlink" title="3.2 插入节点"></a>3.2 插入节点</h3><ul><li>算法：<ol><li>遍历链表，在当前节点 cur 后面插入新节点，同时新节点指向 cur 的下一个节点。</li><li>插入后，cur 更新为 cur.next.next，也就是 cur 原来的下一个节点，开始下一轮循环。</li><li>循环直到 cur 没有下一个节点为止。</li></ol></li></ul><h3 id="3-3-反转链表"><a href="#3-3-反转链表" class="headerlink" title="3.3 反转链表"></a>3.3 反转链表</h3><blockquote><p>注：当我们遇到需要倒着遍历链表的情况，就可以通过反转实现（当然也可以用递归）</p></blockquote><h4 id="3-3-1-反转整个链表"><a href="#3-3-1-反转整个链表" class="headerlink" title="3.3.1 反转整个链表"></a>3.3.1 反转整个链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>while循环里的四行是核心，顺序不能改</li><li>记住一次循环只会更改一个节点的next指针</li></ul><h4 id="3-3-2-反转部分链表"><a href="#3-3-2-反转部分链表" class="headerlink" title="3.3.2 反转部分链表"></a>3.3.2 反转部分链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            p0 = p0.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> p0.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; right - left + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre; <span class="hljs-comment">// 每次循环只修改一个 next，方便大家理解</span><br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br><br>        <span class="hljs-comment">// 见下方解释</span><br>        p0.next.next = cur;<br>        p0.next = pre;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意循环不变量：反转后从原链表顺序上看pre指向被反转序列的末尾，而cur指向被反转序列的下一个节点</li><li><img src="image-20250226154221263.png" alt="image-20250226154221263" style="zoom:67%;" /></li><li>p0是反转序列前的最后一个节点，但是可能出现从头翻转的情况，因此需要引入哨兵dummy node</li></ul><h4 id="3-3-3-分组反转"><a href="#3-3-3-分组反转" class="headerlink" title="3.3.3 分组反转"></a>3.3.3 分组反转</h4><ul><li>要先遍历一次求出链表总长度，只有当剩余长度大于等于k才能进行反转</li><li><img src="image-20250226170211661.png" alt="image-20250226170211661" style="zoom: 67%;" /></li><li>在一组反转后要更新p0为上一次反转的链表的最后一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            n++;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(n &gt;= k)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> p0.next;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>                cur.next = pre;<br>                pre = cur;<br>                cur = nxt;<br>            &#125;<br>            <span class="hljs-comment">// 每次循环的末尾要加上对p0的更新</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> p0.next;<br>            p0.next.next = cur;<br>            p0.next = pre;<br>            p0 = nxt;<br>            n -= k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-前后指针"><a href="#3-4-前后指针" class="headerlink" title="3. 4 前后指针"></a>3. 4 前后指针</h3><ul><li>目的是求链表的倒数第k个节点</li><li>算法思想是让前后两个指针相距k，这样当右指针为null时左指针恰好为倒数第k个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 由于可能会删除链表头部，用哨兵节点简化代码</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;<br>            right = right.next; <span class="hljs-comment">// 右指针先向右走 n 步</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (right.next != <span class="hljs-literal">null</span>) &#123;<br>            left = left.next;<br>            right = right.next; <span class="hljs-comment">// 左右指针一起走</span><br>        &#125;<br>        left.next = left.next.next; <span class="hljs-comment">// 左指针的下一个节点就是倒数第 n 个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-快慢指针"><a href="#3-5-快慢指针" class="headerlink" title="3.5 快慢指针"></a>3.5 快慢指针</h3><ul><li>目的是求链表的中间节点</li><li>算法思想是维护快慢两个指针，快的一次走两个节点，慢的一次走一个，这样快的遍历完时慢的恰好到中间（偶数长度情况下是中间偏右那个）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-双指针"><a href="#3-6-双指针" class="headerlink" title="3.6 双指针"></a>3.6 双指针</h3><ul><li>用两个指针分别遍历链表，它们各自遵循自己的规则遍历特定节点（例如奇偶下标，或是值满足某个大小关系）</li><li>也可以是分别遍历两个链表，做一些判断后将它们指向的节点连起来，最终得到一个新链表</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2025/05/09/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/09/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><blockquote><p>灵神讲解视频：<a href="https://www.bilibili.com/video/BV1AP41137w7/">https://www.bilibili.com/video/BV1AP41137w7/</a></p></blockquote><h3 id="2-1-基本二分查找"><a href="#2-1-基本二分查找" class="headerlink" title="2.1 基本二分查找"></a>2.1 基本二分查找</h3><blockquote><p>注：以下的写法都是找第一个 &gt;&#x3D; x的下标，其他三种可以转换：</p><p>&gt; x 转换成 &gt;&#x3D; (x + 1)</p><p>&lt;&#x3D; x 转换成 (&gt; x) - 1，注意这种方法找到的是最后一个满足&lt;&#x3D; x 的</p><p>&lt; x 转换成 (&gt;&#x3D; x) - 1，注意这种方法找到的是最后一个满足&lt; x 的</p></blockquote><span id="more"></span><ul><li><p>左闭右闭写法</p><ul><li>初始化：<code>L = 0, R = n - 1</code></li><li>循环条件：<code>L &lt;= R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M + 1 / R = M - 1</code></li><li>最终答案为 L 或 R + 1（结束时满足L &#x3D; R + 1）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>) nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>左闭右开写法</p><ul><li>初始化：<code>L = 0, R = n</code></li><li>循环条件：<code>L &lt; R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M + 1 / R = M</code></li><li>最终答案为 L 或 R（结束时满足L &#x3D; R）</li></ul></li><li><p>左开右开写法</p><ul><li>初始化：<code>L = -1, R = n</code></li><li>循环条件：<code>L + 1 &lt; R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M / R = M</code></li><li>最终答案为 L + 1 或 R（结束时满足L + 1 &#x3D; R）</li></ul></li></ul><h3 id="2-2-二分答案"><a href="#2-2-二分答案" class="headerlink" title="2.2 二分答案"></a>2.2 二分答案</h3><ul><li>核心思路：题目求什么，就对这个值的范围进行二分查找并<code>check</code></li></ul><h4 id="2-2-1-求最小与求最大"><a href="#2-2-1-求最小与求最大" class="headerlink" title="2.2.1 求最小与求最大"></a>2.2.1 求最小与求最大</h4><ul><li><p>注意「求最小」和「求最大」的二分写法上的区别。</p><ul><li>前面的「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。</li><li>「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。</li></ul></li></ul><ul><li>以开区间二分为例：<ul><li>求最小：<code>check(mid) == true</code> 时更新 <code>right = mid</code>，反之更新 <code>left = mid</code>，最后返回 <code>right</code></li><li>求最大：<code>check(mid) == true</code> 时更新 <code>left = mid</code>，反之更新 <code>right = mid</code>，最后返回 <code>left</code></li></ul></li><li>对于<strong>开区间</strong>写法，简单来说 <code>check(mid) == true</code> 时<strong>更新的是谁最后就返回谁</strong>。相比其他二分写法，开区间写法不需要思考加一减一等细节，<strong>推荐使用开区间写二分</strong>。</li></ul><h4 id="2-2-2-二分间接值"><a href="#2-2-2-二分间接值" class="headerlink" title="2.2.2 二分间接值"></a>2.2.2 二分间接值</h4><ul><li>二分的不是答案，而是一个和答案有关的值（间接值）</li></ul><h4 id="2-2-3-第-K-小-大"><a href="#2-2-3-第-K-小-大" class="headerlink" title="2.2.3 第 K 小&#x2F;大"></a>2.2.3 第 K 小&#x2F;大</h4><ul><li>第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。</li><li>第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口与双指针</title>
    <link href="/2025/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2025/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-滑动窗口与双指针"><a href="#1-滑动窗口与双指针" class="headerlink" title="1. 滑动窗口与双指针"></a>1. 滑动窗口与双指针</h2><blockquote><p>写在最前面：LeetCode算法刷题笔记中一部分图文和代码来自于LeetCode上的 @灵茶山艾府 大佬，仅供学习转载。<br>灵神题单：<a href="https://leetcode.cn/discuss/post/3141566/ru-he-ke-xue-shua-ti-by-endlesscheng-q3yd/">https://leetcode.cn/discuss/post/3141566/ru-he-ke-xue-shua-ti-by-endlesscheng-q3yd/</a></p></blockquote><h3 id="1-1-滑动窗口"><a href="#1-1-滑动窗口" class="headerlink" title="1.1 滑动窗口"></a>1.1 滑动窗口</h3><h4 id="1-1-1-定长滑动窗口"><a href="#1-1-1-定长滑动窗口" class="headerlink" title="1.1.1 定长滑动窗口"></a>1.1.1 定长滑动窗口</h4><ul><li><p>总结成三步：入-更新-出。</p><p>入：下标为 i 的元素进入窗口，更新相关统计量。如果 i&lt;k−1 则重复第一步。<br>更新：更新答案。一般是更新最大值&#x2F;最小值。<br>出：下标为 i−k+1 的元素离开窗口，更新相关统计量。</p></li></ul><span id="more"></span><ul><li>题目列表：<a href="https://leetcode.cn/circle/discuss/0viNMK/">https://leetcode.cn/circle/discuss/0viNMK/</a></li></ul><h4 id="1-1-2-不定长滑动窗口"><a href="#1-1-2-不定长滑动窗口" class="headerlink" title="1.1.2 不定长滑动窗口"></a>1.1.2 不定长滑动窗口</h4><ul><li>与定长区别在于当窗口右侧新进入的元素破坏限制条件时，需要用一个while循环移动左指针，直到限制条件重新被满足</li><li>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。</li></ul><h4 id="1-1-3-求子数组个数"><a href="#1-1-3-求子数组个数" class="headerlink" title="1.1.3 求子数组个数"></a>1.1.3 求子数组个数</h4><ul><li>这种题型下一般都要求子数组是连续的</li><li>越长越合法<ul><li>一般要写 ans +&#x3D; left。</li><li>滑动窗口的内层循环结束时，右端点固定在 right，左端点在0,1,2,…,left−1 的所有子数组（子串）都是合法的，这一共有 left 个。</li></ul></li><li>越短越合法<ul><li>一般要写 ans +&#x3D; right - left + 1。</li><li>滑动窗口的内层循环结束时，右端点固定在 right，左端点在 left,left+1,…,right 的所有子数组（子串）都是合法的，这一共有 right−left+1 个。</li></ul></li><li>恰好型滑动窗口<ul><li>例如，要计算有多少个元素和恰好等于k 的子数组，可以把问题变成：<ul><li>计算有多少个元素和 ≥k 的子数组。</li><li>计算有多少个元素和 &gt;k，也就是 ≥k+1的子数组。</li></ul></li><li>答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 &gt; 转换成 ≥，从而可以把滑窗逻辑封装成一个函数f，然后用f(k) - f(k + 1)计算，无需写两份滑动窗口代码</li><li>注：也可以把问题变成 ≤k 减去 ≤k−1（两个至多）。可根据题目选择合适的变形方式。</li></ul></li></ul><h3 id="1-2-双指针"><a href="#1-2-双指针" class="headerlink" title="1.2 双指针"></a>1.2 双指针</h3><h4 id="1-2-1-单序列双指针"><a href="#1-2-1-单序列双指针" class="headerlink" title="1.2.1 单序列双指针"></a>1.2.1 单序列双指针</h4><ul><li>相向双指针<ul><li>两个指针 left&#x3D;0, right&#x3D;n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。</li><li>遇到多于两个变量的题（如三数之和、四数之和、有效三角形的个数），对双指针以外的变量用for进行遍历，然后对剩下的部分数组（可以是左侧也可是右侧，具体看情况）进行双指针遍历</li></ul></li><li>同向双指针<ul><li>两个指针的移动方向相同（都向右，或者都向左）</li><li>类似于滑动窗口，通常做法是用for循环枚举一端的端点，然后通过内层while移动另一端端点</li></ul></li><li>背向双指针<ul><li>两个指针从数组中的同一个位置出发，一个向左，另一个向右，背向移动</li></ul></li><li>原地修改<ul><li>一般要对数组元素进行位置交换，通过同向双指针进行遍历（枚举其中一个，元素满足某个条件时移动另一个并进行处理）</li></ul></li></ul><h4 id="1-2-2-双序列双指针"><a href="#1-2-2-双序列双指针" class="headerlink" title="1.2.2 双序列双指针"></a>1.2.2 双序列双指针</h4><ul><li>双指针<ul><li>一般会给两个数组，用两个指针分别同时遍历两个数组</li><li>可能是正序遍历，可能是倒序遍历</li></ul></li><li>判断子序列<ul><li>一般会给两个字符串，判断其中一个是不是另一个的子序列</li><li>对子序列的每一个字母，通过遍历另一个字符串（长的那个）找到该字母后再找下一个字母，一直到其中一个字符串遍历完（子序列先遍历完结果为true，反之为false）</li></ul></li></ul><h4 id="1-2-3-三指针"><a href="#1-2-3-三指针" class="headerlink" title="1.2.3 三指针"></a>1.2.3 三指针</h4><ul><li>一般是遍历其中一个变量，然后对剩下的子问题用（单序列）双指针进行求解</li><li>核心思路是先确定区间的其中一个端点，例如右端点，然后在右端点的左边求合法的左端点。由于左端点的合法取值是一个区间，因此又可以用双指针解决，因此称为三指针</li></ul><h3 id="1-3-分组循环"><a href="#1-3-分组循环" class="headerlink" title="1.3 分组循环"></a>1.3 分组循环</h3><ul><li>适用于按照题目要求，数组会被分割成若干组，且每一组的判断&#x2F;处理逻辑是一样的。</li><li>外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。</li><li>内层循环负责遍历组，找出这一组最远在哪结束。</li><li>一般来说，分组循环的模板如下（可根据题目调整）：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">len</span>(nums)<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; n:<br>    start = i<br>    <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> ...:<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 从 start 到 i-1 是一组</span><br>    <span class="hljs-comment"># 下一组从 i 开始，无需 i += 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动互联网软件工程</title>
    <link href="/2025/01/11/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2025/01/11/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="移动互联网软件工程"><a href="#移动互联网软件工程" class="headerlink" title="移动互联网软件工程"></a>移动互联网软件工程</h1><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><ul><li><p>HMS（HUAWEI Mobile Services，华为移动服务）则是华为公司推出的⼀系列服务的合集</p></li><li><p>HarmonyOS的<strong>核心技术理念</strong>：一次开发，多端部署；可分可合，自由流转；统一生态，原生智能</p></li><li><p>Harmony OS应用支持：1. 需要下载安装的应用，2. 轻量级，具备免安装，即用即走，服务直达，自由流转等关键特征的<strong>元服务</strong>（不支持快应用和Web网站）</p></li><li><p>如果开发者在原生应用版本的基础上，想要提供多种服务给用户，最优选是开发多个元服务，按需组合为一个复杂的应用</p></li><li><p>当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力：<strong>自由流转</strong></p></li></ul><span id="more"></span><ul><li><p>多设备按需分发</p><ul><li><img src="image-20241213125422767.png" alt="image-20241213125422767" style="zoom:67%;" /></li></ul></li><li><p>两种打包上架模式：</p><ul><li>开发态代码共享，应用和服务生命周期完全独立</li><li>开发态代码共享，应用和服务生命周期完全共享</li></ul></li><li><p>系统架构</p><ul><li>HarmonyOS采用分层结构，⼤致可以分为内核层、系统服务层、框架层和应用层</li><li>内核层<ul><li>内核层是整个操作系统的核心，提供操作系统最基础的服务，主要分为内核子系统和驱动子系统</li><li>与Android不同的是，HarmonyOS除了可以支持Linux内核之外，还可以支持多种不同的操作系统，为支持多种不同的设备提供了便利并提高了效率</li><li>对于设备驱动的问题，HarmonyOS则是利用驱动子系统中的硬件驱动框架（HDF，Hardware Driver Framework）提供了统⼀的外设访问能力和驱动开发管理框架</li></ul></li><li>系统服务层：HarmonyOS的核心能力集合，通过框架层对应用程序提供服务<ul><li>系统基础能力子系统：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力。</li><li>基础软件服务子系统：主要是⼀些设备之间公共的、通用的软件服务。</li><li>增强软件服务子系统：提供针对不同设备的、差异化的能力增强型软件服务。</li><li>硬件服务子系统：提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。</li></ul></li><li>框架层：提供了⽤户语⾔框架、Ability框架和UI框架<ul><li>⽤户语⾔框架支持了Java&#x2F;C&#x2F;C++&#x2F;JS等多种编程语⾔</li><li>Ability框架则是对系统服务能力的⼀种抽象的框架</li><li>Harmony的UI框架提供了适⽤于JS语⾔的JS UI框架</li></ul></li><li>应用层：包括系统应用和扩展应用&#x2F;第三方非系统应用</li></ul></li><li><p><strong>一次开发，多端部署</strong></p><ul><li>为了实现这一目的，HarmonyOS需要提供的能力：多端开发环境；多端开发能力；多端分发机制</li><li><img src="image-20241213134025588.png" alt="image-20241213134025588"></li></ul></li><li><p><strong>APP结构</strong> 重要</p><ul><li>在开发态，⼀个应⽤包含⼀个或者多个Module，可以在DevEco Studio⼯程中创建⼀个或者多个Module</li><li>Module是HarmonyOS应用&#x2F;服务的基本功能单元，包含了源代码、资源文件、第三⽅库及应⽤&#x2F;服务配置⽂件，每⼀个Module都可以独⽴进行编译和运行</li><li>Module分为“Ability”和“Library”两种类型，“Ability”类型的Module对应于编译后的HAP（Harmony Ability Package）；“Library”类型的Module对应于HAR（Harmony Archive），或者HSP（Harmony Shared Package）</li><li>HAP：</li></ul><p><img src="image-20241213141643550.png" alt="image-20241213141643550"></p><ul><li><img src="image-20241213141803296.png" alt="image-20241213141803296"></li></ul></li><li><p><strong>stage模型</strong> 重要</p><ul><li><img src="image-20241213142005320.png" alt="image-20241213142005320" style="zoom:67%;" /></li><li>在基于Stage模型开发的应用项目代码下，都存在⼀个app.json5及⼀个或多个module.json5这两种配置文件<ul><li><strong>app.json5</strong>：主要包含应用的全局配置信息，包含应用的包名、开发厂商、版本号等基本信息。特定设备类型的配置信息。</li><li><strong>module.json5</strong>主要包含：<ul><li>Module的基本配置信息，例如Module名称、类型、描述、<strong>支持的设备类型</strong>等基本信息。</li><li>应用组件信息，包含UIAbility组件和ExtensionAbility组件的描述信息。</li><li>应⽤运行过程中所需的<strong>权限信息</strong>。</li></ul></li></ul></li><li>Stage模型原生支持<strong>组应用组件级的跨端迁移和多端协同</strong>，体现在：<strong>Albility与Ul分离</strong>、<strong>UI展示与服务能力合一的Ability组件</strong></li><li>Stage模型支持<strong>多设备形态和多窗口形态</strong>，体现在以下方面：<strong>Ability生命周期定义</strong>、<strong>组件管理和窗口管理解耦</strong></li><li>Stage模型的优势<ul><li><img src="image-20241213144616019.png" alt="image-20241213144616019" style="zoom:67%;" /></li></ul></li></ul></li><li><p><strong>UIAbility生命周期</strong> 重要</p><ul><li><img src="image-20241213142356683.png" alt="image-20241213142356683" style="zoom:67%;" /></li><li><img src="image-20241213142424937.png" alt="image-20241213142424937" style="zoom: 80%;" /></li></ul></li><li><p><strong>UIAbility启动模式</strong> 重要</p><ul><li>singleton（单实例模式）：默认启动模式</li><li>standard（标准实例模式）：每次启动UIAbility组件，都会创建一个新的该类型实例</li><li>specified（指定实例模式）：支持拉起指定标识的实例</li></ul></li><li><p><strong>Want</strong> 重要</p><ul><li><img src="image-20241213143206215.png" alt="image-20241213143206215"></li><li>Want类型<ul><li>显式Want：在启动Ability时指定了abilityName和bundleName的Want称为显式Want。当有明确处理请求的对象时，通过提供目标Ability所在应用的bundleName，并在Want内指定abilityName便可启动目标Ability。显式Want通常用于在当前应用开发中启动某个已知的Ability。</li><li>隐式Want：在启动UIAbility时未指定abilityName的Want称为隐式Want。用于希望调用其他应用的某个服务又不关心是哪个应用提供的该服务，系统将匹配声明支持该请求的所有应用</li></ul></li><li>隐式Want的action和entities<ul><li><img src="image-20241213143956947.png" alt="image-20241213143956947"></li></ul></li></ul></li><li><p>HiLog日志</p><ul><li>HiLog⽇志系统可以让应⽤按照指定类型、指定级别、指定格式字符串打印⽇志内容，帮助开发者了解应用&#x2F;服务的运行状态，更好地调试程序。</li><li>HiLog提供了debug、info、warn、error以及fatal接口，在购物应用中，我们使用hilog打印EntryAbility 、DetailsAbility的⽣命周期。</li></ul></li><li><p>多HAP机制</p><ul><li><p>设计目标</p><ul><li>方便开发者模块化的管理应⽤</li><li>方便开发者将多HAP合理地组合并部署到不同的设备上</li><li>方便开发者按需加载所需模块，减少包大小</li><li>方便应用资源共享，减少程序包大小</li></ul></li><li><p>所有的HAP最终会编译到一个App Pack中</p></li><li><p>多HAP场景下，同一应用的所有HAP的签名证书必须<strong>保持一致</strong></p></li><li><p>开发者可以将⼀个应用的某些HAP配置成按需加载。应用在启动阶段初始用不到的特性，可以配置暂不加载，当用户用到这些特性时，可由应用自动下载这些特性HAP</p></li><li><p>当多HAP如果运行在同一进程，多HAP间组件的通信方式与同一HAP内组件的通信方式<strong>相同</strong></p></li></ul></li><li><p><strong>HAR与HSP</strong> 重要</p><ul><li>OpenHarmony提供了两种共享包，HAR静态共享包和HSP动态共享包，实现代码和资源的共享，包含代码、C++库、资源和配置文件</li><li>HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝</li><li>HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份</li><li>HAR属于编译态复用，HSP属于运行态复用</li></ul></li></ul><h2 id="2-ArkTS"><a href="#2-ArkTS" class="headerlink" title="2. ArkTS"></a>2. ArkTS</h2><ul><li><strong>不考代码，这部分略过</strong></li></ul><h2 id="3-Ark-Compiler-和-Ark-Runtime"><a href="#3-Ark-Compiler-和-Ark-Runtime" class="headerlink" title="3. Ark Compiler 和 Ark Runtime"></a>3. Ark Compiler 和 Ark Runtime</h2><ul><li><strong>类型推导</strong> 重要<ul><li><img src="image-20250103150414765.png" alt="image-20250103150414765" style="zoom:67%;" /></li></ul></li><li><strong>方舟编译运行时</strong> 重要<ul><li><img src="image-20241213175616452.png" alt="image-20241213175616452"></li></ul></li><li>方舟字节码<ul><li>ArkCompiler寄存器要求能够放置对象引用和基本类型，宽度采⽤64位。</li><li>累加寄存器acc，俗称累加器，是⼀个特殊的寄存器，被指令隐含使用。上⼀条指令利用累加器作为结果输出，下⼀条指令将此累加器作为输入，可以有效改善指令密度，减小字节码的尺寸</li><li>ArkCompiler字节码提供对32位（i32）和64位（i64）整型数值的寄存器操作⽀持，8位和16位数值通过扩展到32位来模拟。支持对IEEE-754双精度浮点f64值的寄存器的操作，f32数据类型（IEEE-754单精度）也通过转换为f64值进行模拟。</li><li>ArkCompiler通过特殊的标记值（“Any”）表示动态类型值</li><li>源文件中所有使⽤到的模块命名空间（module namespace）都会被编译进⼀个数组中</li><li>ArkCompiler会把ArkTS&#x2F;TS&#x2F;JS编译为方舟字节码，<strong>运行时直接运行方舟字节码</strong></li><li>方舟字节码中，除<strong>寄存器</strong>和<strong>累加器</strong>之外，还存在4种值存储方式：<strong>全局变量</strong>、<strong>模块命名空间和模块变量</strong>、<strong>词法环境和词法变量</strong>、<strong>补丁变量</strong>。指令可以使用这4种储值位置中的值作为入参</li></ul></li><li><strong>Ark Runtime执行引擎</strong> 重要，看JIT和AOT区别<ul><li>解释器：可直接运行前端编译器输出的字节码</li><li>JIT Compiler（Just-In-Time）：JIT编译器⼀般需要运行时执行代码⼀段时间，Profiler⽣成了profiling数据之后，根据profiling数据即时编译生成高质量的机器码来运行。</li><li>AOT Compiler（Ahead of Time）：AOT编译器则是在运行前根据静态信息直接编译生成高质量的目标机器码在设备上运行，PGO配置文件可以作为AOT Compiler的输入之⼀，给AOT Compiler⼀些指示，比如编译的范围以及编译某个方法时使用哪些优化技术。</li><li><img src="image-20241213180055095.png" alt="image-20241213180055095"></li><li><img src="image-20241213180117663.png" alt="image-20241213180117663" style="zoom:67%;" /></li><li><img src="image-20241213180623319.png" alt="image-20241213180623319"></li></ul></li></ul><h2 id="4-Ark-UI"><a href="#4-Ark-UI" class="headerlink" title="4. Ark UI"></a>4. Ark UI</h2><ul><li><p>基本概念</p><ul><li><strong>装饰器</strong>：用来装饰类、结构体、方法以及变量，赋予其特殊的含义，如上述示例中 @Entry 、 @Component 、 @State 都是装饰器。<ul><li>@Component：装饰struct，结构体在装饰后具有基于组件的能力，需要实现build⽅法来创建UI。</li><li>@Entry： 装饰struct，组件被装饰后作为页面的入口，页面加载时将被渲染显示。</li><li>@Preview：装饰struct， 用@Preview装饰的⾃定义组件可以在DevEco Studio的预览器上进行<strong>实时预览</strong>，加载页面时，将创建并显示@Preview装饰的自定义组件。</li><li><img src="image-20241213185146944.png" alt="image-20241213185146944"></li></ul></li><li>自定义组件：可复用的 UI 单元，可组合其它组件，如上述被 @Component 装饰的 struct Hello。<ul><li>struct：自定义组件可以基于struct实现，不能有继承关系，对于struct的实例化，可以省略new。</li></ul></li><li>UI描述：声明式的方法来描述UI的结构，例如build()方法中的代码块。</li><li>内置组件：ArkTS中默认内置的基本组件和布局组件，开发者可以直接调用，如Column、Text、Divider、Button等。</li><li>属性方法：用于组件属性的配置，统⼀通过属性方法进行设置，如fontSize()、width()、height()、color() 等，可通过链式调用的方式设置多项属性。</li><li>事件方法：用于添加组件对事件的响应逻辑，统⼀通过事件方法进行设置，如跟随在Button后面的onClick()。</li><li><img src="image-20241213181310815.png" alt="image-20241213181310815" style="zoom:70%;" /></li><li><img src="image-20241213181750268.png" alt="image-20241213181750268" style="zoom:67%;" /></li></ul></li><li><p><strong>组件生命周期</strong> 重要</p><ul><li>@Entry装饰的组件才有页面生命周期<ul><li>页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：</li><li>onPageShow：页面每次显示时触发。<ul><li>onPageHide：页面每次隐藏时触发⼀次。</li></ul></li><li>onBackPress：当用户点击返回按钮时触发。</li><li>组件生命周期，即⼀般用@Component装饰的⾃定义组件的生命周期，提供以下生命周期接口：</li><li>aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。<ul><li>aboutToDisappear：在自定义组件即将析构销毁时执行。</li></ul></li><li><img src="image-20241213181849865.png" alt="image-20241213181849865"></li></ul></li></ul></li><li><p><strong>布局结构</strong> 重要</p><ul><li><img src="image-20250103150959721.png" alt="image-20250103150959721" style="zoom:80%;" /></li><li><p>布局元素的组成</p><ul><li><img src="image-20250103151109492.png" alt="image-20250103151109492" style="zoom:80%;" /></li><li><p>组件区域（蓝区⽅块）：组件区域表明组件的大小，width、height属性设置该区域的大小。</p></li><li><p>组件内容区（黄色方块）：组件区域大小减去组件的padding值，组件内容区大小会作为组件内容（或者子组件）进行大小测算时的布局测算限制。</p></li><li><p>组件内容（绿色方块）：组件内容本身占用的大小，比如文本内容占用的大小。组件内容和组件内容区不⼀定匹配，比如设置了固定的width和height，此时组件内容区大小就是设置的width和height减去padding值，但⽂本内容则是通过文本布局引擎测算后得到的大小，可能出现文本真实大小小于设置的组件内容区大小。当组件内容和组件内容区大小不⼀致时，align属性⽣效，定义组件内容在组件内容区的对齐方式，如居中对齐。</p></li><li><p>组件布局边界（虚线部分）：组件通过margin属性设置外边距时，组件布局边界就是组件区域加上margin的大小。</p></li></ul></li></ul></li><li><p><strong>router</strong></p><ul><li>调用router.pushUrl接口，目标页不会替换当前页，而是压入页面栈，保留当前页的状态。此时当前Index页面隐藏，执行页面生命周期Index onPageHide。</li><li>如果调用的是router.replaceUrl，目标页会替换当前页，当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear</li><li>两种实例模式<ul><li>Standard：标准实例模式，也是<strong>默认实例模式</strong>。每次调用都会新建一个目标页并压入栈顶</li><li>Single：单实例模式，如果目标页的url在栈中已经存在，则离栈顶最近的同url页面会被移动到栈顶，并重新加载；如果目标页的url在栈中不存在，则按照标准模式跳转</li></ul></li></ul></li><li><p><strong>For Each</strong></p><ul><li>在ForEach循环渲染过程中，系统会为每个数组元素生成⼀个唯⼀且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建⼀个新的组件</li><li>ForEach必须在容器组件内使用。</li><li>⽣成的子组件应当是允许包含在ForEach父容器组件中的子组件。</li><li>允许子组件生成器函数中包含if&#x2F;else条件渲染，同时也允许ForEach包含在if&#x2F;else条件渲染语句中。</li><li>itemGenerator为数组中的每个元素创建对应的组件，为必选参数；keyGenerator为数据源arr的每个数组项生成唯一且持久的键值，<strong>不是</strong>必选参数</li></ul></li><li><p><strong>Navigation</strong></p><ul><li>⼀般作为页面的根容器，包括<strong>单页面</strong>、<strong>分栏</strong>和<strong>自适应</strong>三种显示模式</li><li><strong>默认显示模式</strong>是自适应模式，自适应模式下，若设备的宽度大于520vp，Navigation组件采用分栏模式，反之采用单页面模式</li></ul></li><li><p><strong>ArkUI框架</strong> 重要</p><ul><li><img src="image-20241213191742663.png" alt="image-20241213191742663" style="zoom: 50%;" /></li><li><p>对于声明式开发范式组件，根据组件从前端到后端的过程，可以将整个框架划分为EtsLoader，JsView, ComPonent,RenderNode四个模块。</p><ul><li>EtsLoader：负责解析ets页面，根据组件的tag标签创建对应的JsView对象，⽣成jsView树。</li><li>JsView：负责处理组件的属性，⽅法和事件。并通过Create函数创建对应的Component树。</li><li>ComPonent：负责将Component树中所有继承自RenderComponent的节点（可绘制节点）创建对应的RenderNode节点，生成对应的RenderNode树</li><li>RenderNode：RenderNode即可绘制的节点，负责组件的最终布局和绘制。</li></ul></li><li><p><strong>Component树、Element树、Render树</strong></p><ul><li><p><strong>Component树</strong>：</p><ul><li><strong>定义</strong>：Component树描述的是应用中所有组件的层级结构。它是由应用中的每一个组件组成的树状结构，每个组件可以包含子组件。</li><li><strong>特点</strong>：它代表了组件的嵌套关系，不包含DOM节点，仅仅是逻辑上的结构，表示组件如何组合和排列。</li><li><strong>作用</strong>：帮助理解组件之间的关系、组件的嵌套结构，以及如何通过父组件和子组件的关系来组织应用。</li></ul><p><strong>Element树</strong>：</p><ul><li><strong>定义</strong>：Element树是从组件的 JSX（React）或模板（Vue）中生成的，包含了组件实例化后的原始元素对象。它是虚拟DOM中的表示，描述了界面中所有的“元素”。</li><li><strong>特点</strong>：Element树是虚拟DOM的一部分，包含每个组件的渲染结果。它的结构和组件树类似，但它是更接近渲染的“表现形式”，也就是说，它包含了实际将会渲染到页面上的元素结构。</li><li><strong>作用</strong>：Element树用于虚拟DOM的比较和更新，帮助决定哪些元素需要更新、添加或删除。</li></ul><p><strong>Render树</strong>：</p><ul><li><strong>定义</strong>：Render树是经过样式计算之后的DOM树的一个表示，包含了所有将要渲染的DOM元素及其样式（包括CSS属性）。</li><li><strong>特点</strong>：它是浏览器内部渲染流程中的一部分，只有经过计算得到的实际渲染样式后，才会被用于渲染最终的页面。它是根据Element树的内容生成的，结合了CSS样式，描述了页面将如何渲染出来。</li><li><strong>作用</strong>：Render树的创建与更新决定了页面的最终视觉展示。浏览器通过它来绘制界面。</li></ul></li></ul></li><li><p>类Web开发范式组件：对于类Web开发范式组件，根据组件从前端到后端的过程，可以将整个框架划分为JsFrameWork，DomNode, ComPonent, RenderNode四个模块。</p><ul><li>JsFrameWork：负责解析前端html和css文件，创建出DomNode树。该树的结构和前端页面是⼀⼀对应的。</li><li>DomNode：负责将Dom树转换为Component树。</li></ul></li><li><p>在开发一款新应用时，推荐采用<strong>声明式开发范式</strong>来构建UI</p></li><li><img src="image-20241213192252463.png" alt="image-20241213192252463" style="zoom:67%;" /></li><li><p>同布局⼀样，绘制也是⼀个深度遍历的过程，遍历调用每个 RenderNode 的 Paint 方法，此时的绘制只是根据布局算出来的大小和位置，在当前绘制的上下文记录每个节点的绘制命令。为了提高性能，这里引入了图层（Layer）的概念。通常绘制会将渲染内容分为多个层进行加速。</p></li><li><p>光栅化合成机制</p><ul><li>UI 线程（UI Thread）在渲染管线中的输出是 LayerTree，它相当于⼀个⽣产者，将⽣产的 LayerTree 添加到渲染队列中。GPU 线程（GPU Thread）的合成器（Compositor）相当于消费者，每个新的渲染周期中，合成器会从渲染队列中获取⼀个 LayerTree 进⾏合成消费。</li><li>对于需要缓存的 Layer,还要执⾏光栅化⽣成 GPU 纹理，所谓光栅化就是将 Layer ⾥⾯记录的命令进⾏回放，⽣成每个实体的像素的过程。像素是存储在纹理的图形内存中。</li><li>合成器会从系统的窗⼝中获取当前的 Surface，将每个 Layer ⽣成的纹理进⾏合成，最终合成到当前 Surface 的图形内存（Graphic Buffer）中。这块内存中存储的就是当前帧的渲染结果内容。最终还需要将渲染结果提交到系统合成器中合成显示。</li></ul></li></ul></li><li><p>大前端框架</p><ul><li><img src="image-20250103151909938.png" alt="image-20250103151909938" style="zoom: 67%;" /></li><li></li></ul></li></ul><h2 id="5-移动互联网应用需求分析"><a href="#5-移动互联网应用需求分析" class="headerlink" title="5. 移动互联网应用需求分析"></a>5. 移动互联网应用需求分析</h2><ul><li><strong>需求分析的层次性</strong> 重要<ul><li>传统信息系统软件需求的分层：业务需求、用户需求、系统需求</li><li>移动互联网领域考虑三个层次<ul><li>战略：起步、发展、成熟、扩展、新业务</li><li>产品：⼀致性的体验、符合战略思路、落实技术功能</li><li>功能</li></ul></li></ul></li><li><strong>涉众分析</strong> 重要<ul><li><img src="image-20241213193655648.png" alt="image-20241213193655648"></li><li>移动互联网应用用户的特点：用户都是大规模，不确定的，易变，更短抉择，随性，常规涉众分析方法不是很有效</li></ul></li><li><strong>需求获取</strong> 重要<ul><li>需求获取的传统方法：面谈、问卷、观察、文档分析、调研、原型、民族志</li><li>移动互联网需求获取<ul><li>“上线”原型法：运营数据分析、数据统计、数据挖掘、用户模拟</li><li>竞品分析：抄袭法</li></ul></li></ul></li><li><strong>移动互联网需求组织方法</strong> 重要：User Story &amp; 技术故事、Behavior Specification</li></ul><h2 id="6-Ability-Kit-Network-Kit-ArkData-ArkWeb"><a href="#6-Ability-Kit-Network-Kit-ArkData-ArkWeb" class="headerlink" title="6. Ability Kit, Network Kit, ArkData, ArkWeb"></a>6. Ability Kit, Network Kit, ArkData, ArkWeb</h2><ul><li>Ability Kit<ul><li>Ability Kit（程序框架服务）提供了应用程序开发和运行的应用模型，是系统为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。</li><li><img src="image-20241214092718741.png" alt="image-20241214092718741"></li><li>UIAbility是系统调度的最小单元。UIAbility的启动分为两种情况：UIAbility<strong>冷启动</strong>和UIAbility<strong>热启动</strong> 重要<ul><li>UIAbility冷启动：指的是UIAbility实例处于完全关闭状态下被启动，这需要完整地加载和初始化UIAbility实例的代码、资源等。</li><li>UIAbility热启动：指的是UIAbility实例已经启动并在前台运行过，由于某些原因切换到后台，再次启动该UIAbility实例，这种情况下可以快速恢复UIAbility实例的状态，只会触发该UIAbility的<strong>onNewWant()</strong> 回调</li></ul></li></ul></li><li>Network Kit<ul><li><img src="image-20241214093451623.png" alt="image-20241214093451623" style="zoom:80%;" /></li><li>使用网络管理模块的相关功能时，需要请求相应的权限：ohos.permission.GET_NETWORK_INFO(允许获取网络连接信息)和ohos.permission.INTERNET(允许程序打开网络套接字进行网络连接)</li><li>request接口开发步骤<ul><li><img src="image-20241214093637938.png" alt="image-20241214093637938" style="zoom:67%;" /></li></ul></li><li><img src="image-20241214093804193.png" alt="image-20241214093804193"  /></li><li>ResponseCode.GONE的值为<strong>410</strong>，表示客户端请求的资源已经不存在</li><li>ResponseCode.NOT_FOUND的值为404，表示服务器无法根据客户端的请求找到资源（网页）</li><li>A : HEAD请求的响应格式与GET请求相同，只是响应主体为空，所以可以用于获取资源的元数据、检查资源是否存在。 B : DELETE请求可以请求服务器删除指定的资源。 C : GET请求可以向服务器获取资源，GET请求<strong>可以携带</strong>参数。 D : POST请求向指定资源提交数据进行处理请求</li><li>A : http请求支持get、post、put等常用的请求方式。 B : 可以使用on(‘headersReceive’)订阅请求响应头。 C : post请求的参数可以在extraData中指定。 D : 执行createHttp成功后，返回一个httpRequest对象，里面包括request、destroy、on和off方法。</li><li>http请求request接口中请求可选参数：A : method B : extraData C : expectDataType D : readTimeout</li></ul></li><li>Ark Data<ul><li>持久化<ul><li><strong>用户首选项（Preferences）</strong> 重要：提供了轻量级配置数据的持久化能力，并支持订阅数据变化的通知能力。<strong>不支持分布式同步</strong>，<strong>不遵循ACID特性</strong>，常用于保存应用配置信息、用户偏好设置等。<ul><li>开发者可以将用户首选项持久化文件的内容加载到Preferences实例，然后使用<strong>flush()方法</strong>写入<strong>持久化文件</strong>中实现数据持久化。<strong>每个文件唯—对应到—个Preferences实例</strong></li><li><strong>使用用户首选项持久化数据的正确流程</strong>：getPreferencesSync()获取用户首选项实例，putSync()方法保存数据到缓存的Preferences实例，flush()持久化数据</li><li>用户首选项Key不可以重复，通过has()方法判断首选项中是否包含指定的key，保证指定的key不会被重复保存</li></ul></li><li>键值型数据管理（KV-Store）：提供了键值型数据库的读写、加密、手动备份以及订阅通知能力。键值型数据库事件回调方法中<strong>不允许进行阻塞操作</strong></li><li>关系型数据管理（RelationalStore）：提供了关系型数据库的增删改查、加密、手动备份以及订阅通知能力。</li></ul></li><li>分布式交互<ul><li>分布式数据对象（DataObject）：独立提供对象型结构数据的分布式能力</li><li>跨应用数据管理（DataShare）：提供了数据提供者provider、数据消费者consumer以及同设备跨应用数据交互的增、删、改、查以及订阅通知等能力。</li><li>统⼀数据管理框架（UDMF）：提供了数据跨应用、跨设备交互标准</li></ul></li><li>数据管理服务（DatamgrService）：提供其它部件的同步及跨应用共享能力</li><li>关系型数据库相关<ul><li>关系型数据库导入的模块是@ohos.data.relationalStore</li><li>RdbStore提供管理关系数据库方法的接口，通过getRdbStore获得一个相关的RdbStore，操作关系型数据库</li><li>ResultSet提供用户调用关系型数据库查询接口之后返回的结果集合</li><li>数据库配置StoreConfig中encrypt指定数据库是否加密，<strong>默认不加密</strong></li></ul></li></ul></li><li>Core File Kit<ul><li>文件类型<ul><li>应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。</li><li>用户文件：文件所有者为登录到该终端设备的用户，包括用户私有的图片、视频、音频、文档等。</li><li>系统文件：与应用和用户⽆关的其它文件，包括公共库、设备文件、系统资源文件等。系统文件及其目录对于应用是只读的</li></ul></li><li>文件系统分类<ul><li>本地文件系统：提供本地设备或外置存储设备（如U盘、移动硬盘）的文件访问能力</li><li>分布式文件系统：提供跨设备的文件访问能力。所谓跨设备，指文件不⼀定存储在本地设备或外置存储设备，而是通过计算机网络与其它分布式设备相连</li></ul></li><li>对于每个应用，系统会在内部存储空间映射出⼀个专属的“应用沙箱目录”，它是“应用文件目录”与⼀部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合，代表应用可见的所有目录范围</li><li>应用之间可以通过分享URI（Uniform Resource Identifier）或文件描述符FD（File Descriptor）的方式，进行文件共享</li><li>用户需要分享文件、保存图片、视频等用户文件时，开发者可以通过系统预置的文件选择器FilePicker，实现该能力。通过Picker访问相关文件，将拉起对应的应用，引导用户完成界面操作，接口本身无需申请权限。picker获取的uri只具有临时权限，获取持久化权限需要通过FilePicker设置永久授权方式获取。包含PhotoViewPicker、DocumentViewPicker、AudioViewPicker</li><li>File Access Framework是一套提供给开发者访问和管理用户文件的基础框架，提供了一套统一访问用户文件的方法和接口</li><li>File Access Helper提供给文件管理器和文件选择器访问用户文件的API接口</li><li>File Access ExtensionAbility提供文件访问框架能力，由<strong>UserFileManager</strong>和<strong>ExternalFileManager</strong>组成</li><li>UserFileManager是<strong>内卡</strong>文件管理服务， ExternalFileManager是<strong>外卡</strong>文件管理服务</li></ul></li><li>Ark Web<ul><li><strong>Web组件生命周期</strong> 重要<ul><li><img src="image-20241214095802013.png" alt="image-20241214095802013" style="zoom:67%;" /></li><li>当Controller成功绑定到Web组件时触发该回调onControllerAttached事件</li><li>当Web组件加载url之前触发onLoadIntercept，默认允许加载</li><li>onInterceptRequest事件用于拦截url并返回响应数据</li><li>onPageEnd事件只在主frame触发</li></ul></li><li>Web组件提供的页面加载方式<ul><li>加载网络页面</li><li>加载本地页面</li><li>加载HTML格式的富文本数据</li></ul></li></ul></li></ul><h2 id="7-移动互联网设计架构"><a href="#7-移动互联网设计架构" class="headerlink" title="7. 移动互联网设计架构"></a>7. 移动互联网设计架构</h2><ul><li><p>架构目标：高可用性、高可扩展性、低成本、多快好省</p></li><li><p>架构组成</p><ul><li><img src="image-20241214100327676.png" alt="image-20241214100327676" style="zoom:67%;" /></li><li><p>业务架构设计原则</p><ul><li>业务平台化</li><li>核心业务、非核心业务分离</li><li>隔离不同类型的业务</li><li>区分主流程、辅流程</li></ul></li><li><p>应用架构设计原则：稳定性原则、解耦&#x2F;拆分、抽象化、松耦合、容错设计</p></li><li><p>数据架构设计原则</p><ul><li><img src="image-20241214100819446.png" alt="image-20241214100819446"></li></ul></li><li><p>技术架构设计原则：</p><ul><li>运行时：可监控；应用可回滚，功能可降级；在线扩容；安全保证；可容错；可故障转移</li><li>部署时</li></ul><img src="image-20241214101039068.png" alt="image-20241214101039068" style="zoom:67%;" /></li></ul></li><li><img src="image-20250103152623253.png" alt="image-20250103152623253" style="zoom:80%;" /></li><li><p><strong>MVC、MVP和MVVM</strong> 重要</p><ul><li><p>MVC模式</p><ul><li>模型：存储内容</li><li>视图：显示内容</li><li>控制器：处理用户输入</li></ul></li><li><p>MVP和MVVM：MVC的改良</p><ul><li><img src="image-20241214104324729.png" alt="image-20241214104324729" style="zoom:67%;" /></li><li><img src="image-20241214104504344.png" alt="image-20241214104504344" style="zoom:67%;" /></li></ul></li><li><p>Functional Reactive Programming （FRP）</p></li></ul></li></ul><h2 id="8-进程与线程"><a href="#8-进程与线程" class="headerlink" title="8. 进程与线程"></a>8. 进程与线程</h2><ul><li><strong>高可用</strong><ul><li>负载均衡与反向代理</li><li>隔离</li><li>限流</li><li>降级</li><li>超时与重试机制</li><li>回滚</li><li>压测和预案</li></ul></li><li><strong>高并发</strong> 和高可用一样，看ppt去吧<ul><li>应用级缓存</li><li>HTTP缓存</li><li>连接池</li><li>异步并发</li><li>扩容</li><li>队列</li></ul></li><li><strong>异步并发</strong> 重要<ul><li>Promise和async&#x2F;await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同⼀时间只有⼀段代码执行，适用于单次I&#x2F;O任务的场景开发</li><li>Promise是⼀种用于处理异步操作的对象，有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）</li></ul></li><li><strong>并发模型</strong> TaskPool和Worker重要<ul><li>并发模型是用来实现不同应用场景中并发任务的编程模型，常见的并发模型分为基于内存共享的并发模型和基于消息通信的并发模型。</li><li>Actor并发模型是基于消息通信并发模型的典型代表</li><li>当前ArkTS提供了<strong>TaskPool和Worker</strong>两种并发能力，TaskPool和Worker都基于Actor并发模型实现<ul><li>运行时间超过3分钟（不包含Promise和async&#x2F;await异步调用的耗时，如网络下载、文件读写）的任务需要使用Worker</li><li>需要设置优先级的任务需要使用TaskPool</li></ul></li></ul></li><li>应用间跳转<ul><li>应用跳转是指从⼀个应用跳转至另外⼀个应用，传递相应的数据、执行特定的功能</li><li>应用跳转的两种类型<ul><li>拉起指定应用：拉起方应用明确指定跳转的目标应用，来实现应用跳转。指向性跳转可以分为指定应用链接、指定Ability两种方式。</li><li>拉起指定类型的应用：拉起方应用通过指定应用类型，拉起垂类应用面板</li></ul></li></ul></li><li><strong>进程模型</strong> 重要<ul><li><img src="image-20250103153557025.png" alt="image-20250103153557025" style="zoom: 80%;" /></li><li><img src="image-20250103153607839.png" alt="image-20250103153607839" style="zoom: 67%;" /></li></ul></li><li>Background Tasks Kit<ul><li>设备返回主界面、锁屏、应用切换等操作会使应用退至后台。系统会对退至后台的应用进行管控，包括进程挂起和进程终止。</li><li>后台任务类型<ul><li>短时任务：适用于实时性要求高、耗时不长的任务，例如状态保存。</li><li>长时任务：适用于长时间运行在后台、用户可感知的任务，例如后台播放音乐、导航、设备连接等，使用长时任务避免应用进程被挂起。</li><li>延迟任务：对于实时性要求不高、可延迟执行的任务，系统提供了延迟任务，即满足条件的应用退至后台后被放入执行队列，系统会根据内存、功耗等统⼀调度。</li><li>代理提醒：代理提醒是指应用退后台或进程终止后，系统会代理应用做相应的提醒。适用于定时提醒类业务，当前支持的提醒类型包括倒计时、日历和闹钟三类。</li></ul></li></ul></li><li>IPC机制<ul><li><img src="image-20250103153720825.png" alt="image-20250103153720825"></li></ul></li></ul><h2 id="9-系统工具库"><a href="#9-系统工具库" class="headerlink" title="9.系统工具库"></a>9.系统工具库</h2><ul><li>Ark UI 的窗口<ul><li>窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。<ul><li>对应用开发者而言，窗口模块提供了界面显示和交互能力。</li><li>对终端用户而言，窗口模块提供了控制应用界面的方式。</li><li>对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。</li></ul></li><li>HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。</li><li><strong>创建应用子窗口后，应先设置子窗口属性，然后加载显示子窗口的具体内容，最后在不需要时销毁子窗口</strong></li><li>实现<strong>沉浸式效果</strong>有两种方式，一是调用 setWindowSystemBarEnable 接口，设置导航栏、状态栏不显示；二是调用 setWindowLayoutFullScreen 接口，设置应用主窗口为全屏布局，再调用 setWindowSystemBarProperties 接口设置相关属性</li></ul></li><li>Basics Service Kit的账号管理<ul><li>应用开发者可以使用应用账号SDK管理本应用的账号数据。</li><li>能力限制：应用卸载场景下，<strong>被卸载应用的账号数据</strong>会被删除；本地账号删除场景下，<strong>被删除本地账号下的所有应用的账号数据</strong>会被删除。</li></ul></li><li>Audio Kit（音频服务）<ul><li>Audio Kit（音频服务）亮点特征包括空间音频、低时延播放、音振协同、低功耗播放等</li><li>音频量化的过程：采样 &gt; 量化 &gt; 编码</li><li>音频播放API<ul><li>AudioRenderer：用于音频输出的ArkTS&#x2F;JS API，<strong>仅支持PCM格式</strong>，需要应用<strong>持续写入音频数据</strong>进行工作。应用可以在输入前添加数据预处理，如设定音频文件的采样率、位宽等，要求开发者具备音频处理的基础知识，<strong>适用于更专业、更多样化的媒体播放应用开发</strong>。</li><li>AudioHaptic：用于音振协同播放的ArkTS&#x2F;JS API，<strong>适用于需要在播放音频时同步发起振动的场景</strong>，如来电铃声随振、键盘按键反馈、消息通知反馈等。</li><li>OpenSL ES：一套跨平台标准化的音频Native API，同样提供音频输出能力，<strong>仅支持PCM格式</strong>，<strong>适用于从其他嵌入式平台移植</strong>，或<strong>依赖在Native层实现音频输出功能</strong>的播放应用使用。</li><li>OHAudio：用于音频输出的Native API，此API在设计上实现归一，同时支持普通音频通路和低时延通路。<strong>仅支持PCM格式</strong>，<strong>适用于依赖Native层实现音频输出功能的场景</strong>。</li><li>AVPlayer：用于音频播放的ArkTS&#x2F;JS API，集成了流媒体和本地资源解析、媒体资源解封装、音频解码和音频输出功能。可用于直接播放mp3、m4a等格式的音频文件，<strong>不支持直接播放PCM格式文件</strong></li><li>SoundPool：低时延的短音播放ArkTS&#x2F;JS API，<strong>适用于播放急促简短的音效</strong>，如相机快门音效、按键音效、游戏射击音效等。</li></ul></li><li><img src="image-20241214153345026.png" alt="image-20241214153345026"></li><li>AudioRenderer 开发步骤，首先应配置音频渲染参数并创建 AudioRenderer 实例，然后调用 on (‘writeData’) 方法订阅监听音频数据写入回调，接着调用 start () 方法开始渲染音频，在需要停止时调用 stop () 方法，最后调用 release () 方法销毁实例</li></ul></li><li><strong>Camera Kit</strong> 重要<ul><li>相机工作流程包括相机<strong>输入设备管理、会话管理和相机输出管理</strong></li><li>拍照模块中，设置拍照参数可以调整闪光灯、变焦、焦距、<strong>照片质量</strong>及旋转角度等信息</li><li>如果开发者仅是需要拉起系统相机拍摄一张照片、录制一段视频，可直接使用<strong>CameraPicker</strong>，无需申请相机权限，直接拉起系统相机完成拍摄。应用可以自行选择媒体类型实现拍照和录制功能。<strong>该类接口需要应用在界面 UIAbility 中调用</strong>。从 <strong>API version 12 开始</strong>，该接口支持在元服务中使用。</li><li><img src="image-20241214153457496.png" alt="image-20241214153457496" style="zoom:67%;" /></li></ul></li><li>Image Kit<ul><li>相关概念<ul><li>图片解码：指将所支持格式的存档图片解码成统一的<strong>PixelMap</strong>，以便在应用或系统中进行图片显示或图片处理。</li><li>PixelMap：指图片解码后无压缩的位图，用于图片显示或图片处理。</li><li>图片编码：指将PixelMap编码成不同格式的存档图片，用于后续处理，如保存、传输等。</li><li>图片处理：指对PixelMap进行相关的操作，如旋转、缩放、设置透明度、获取图片信息、读写像素数据等。</li></ul></li><li>开发过程<ul><li>获取图片：通过应用沙箱等方式获取原始图片。</li><li>创建ImageSource实例：ImageSource是图片解码出来的图片源类，用于获取或修改图片相关信息。</li><li>图片解码：通过ImageSource解码生成PixelMap。</li><li>图片处理：对PixelMap进行处理，更改图片属性实现图片的旋转、缩放、裁剪等效果。然后通过Image组件显示图片。</li><li>图片编码：使用图片打包器类ImagePacker，将PixelMap或ImageSource进行压缩编码，生成一张新的图片。</li></ul></li><li><strong>使用 ImageSource 完成图片解码的步骤</strong>：首先获取 resourceManager 资源管理，然后创建 ImageSource，接着创建 pixelMap，最后释放 pixelMap</li></ul></li><li>ArkGraphics 2D<ul><li>ArkGraphics 2D <strong>能力范围</strong>包括图像处理基本能力、管理色域对象能力、指定帧率能力以及图形绘制与显示相关的 Native 能力。</li><li>使用@ohos.graphics.drawing模块的画布画笔绘制基本的2D图形和文字：<ol><li>创建RenderNode子类。创建RenderNode子类MyRenderNode，并在其中定义绘图函数。RenderNode中包含树结构的操作，以及对绘制属性的操作，其中draw方法会在RenderNode进行绘制时被调用</li><li>构建Path形状。使用path的moveTo，lineTo和close接口构建</li><li>设置画笔和画刷样式。使用Pen接口创建一个画笔实例pen，并设置抗锯齿、颜色、线宽等属性，画笔用于形状边框线的绘制。使用Brush接口创建一个画刷实例brush，并设置填充颜色，画刷用于形状内部的填充。使用canvas中的attachPen和attachBrush接口将画笔画刷的实例<strong>设置到画布实例中</strong></li><li>绘制Path形状。使用canvas中的drawPath接口绘制到画布上</li><li>创建MyRenderNode对象。以上1到4步构建出了MyRenderNode类并在其中定义了绘图的主要函数，接下来创建一个MyRenderNode对象，并设置它的像素格式。</li><li>绘制矩形&#x2F;文字。使用canvas中的drawRect接口绘制矩形，drawTextBlob接口绘制文字</li><li>创建NodeController子类。创建NodeController的子类MyNodeController，并在其中定义创建FrameNode的函数。NodeController定义了节点容器的控制器，控制着容器里在生命周期中的节点。FrameNode定义了节点的基本类型，并包含一个RenderNode。</li><li>创建添加节点的接口。在第7步中创建的MyNodeController类中创建添加RenderNode的接口。</li><li>创建删除节点的接口。在第7步中创建的MyNodeController类中创建删除RenderNode的接口。</li><li>绘制图形和文字。创建MyNodeController实例并将其存入NodeContainer，添加button控件供用户点击，并调用已定义的接口。</li></ol></li></ul></li><li><strong>Sensor Service Kit</strong> 重要<ul><li>Sensor Service Kit（传感器服务）使应用程序能够<strong>从传感器获取原始数据</strong>，并<strong>提供振感控制能力</strong>。包括Sensor（传感器）模块和Vibrator（振动）模块</li><li>传感器运作机制<ul><li><img src="image-20250103154416472.png" alt="image-20250103154416472" style="zoom:67%;" /></li></ul></li></ul></li><li><strong>Form Kit</strong> 重要<ul><li>Form Kit（卡片开发服务）提供一种界面展示形式，可以<strong>将应用的重要信息或操作前置到服务卡片</strong>，以达到<strong>服务直达</strong>、<strong>减少跳转层级</strong>的体验效果。卡片常用于嵌入到其他应用（只支持系统应用，例如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互能力。<strong>支持在卡片中运行逻辑代码</strong>（ArkTS 卡片）</li><li><img src="image-20241214155624545.png" alt="image-20241214155624545"></li><li><strong>卡片使用步骤</strong>：长按 “桌面图标”，弹出操作菜单，点击 “服务卡片” 选项，进入卡片预览界面，再点击 “添加到桌面” 按钮</li></ul></li></ul><h2 id="10-敏捷软件开发"><a href="#10-敏捷软件开发" class="headerlink" title="10. 敏捷软件开发"></a>10. 敏捷软件开发</h2><ul><li>Scrum<ul><li>3个角色<ul><li>产品负责人、Scrum Master、开发团队</li></ul></li><li>三个工件<ul><li>产品Backlog、SprintBacklog、产品增量</li></ul></li><li><h2 id="5个事件"><a href="#5个事件" class="headerlink" title="5个事件  - "></a>5个事件<br>  - <img src="image-20250103155115230.png" alt="image-20250103155115230" style="zoom: 50%;" /></h2></li></ul></li><li>WIP（working in progress）<ul><li>WIP太高，工作闲置</li><li>WIP太低，人员闲置</li></ul></li></ul><h2 id="11-从微服务到云原生"><a href="#11-从微服务到云原生" class="headerlink" title="11. 从微服务到云原生"></a>11. 从微服务到云原生</h2><ul><li>微服务架构的特征<ul><li>通过服务组件化</li><li>围绕业务能力组织：只把业务逻辑强制放在它们会访问的应用程序中</li><li>是产品不是项目：负责产品的整个生命周期，持续关注软件如何帮助用户提升业务能力</li><li>智能端点和哑管道：最常用的两种协议是使用资源API的HTTP请求-响应；在轻量级消息总线上传递消息</li><li>去中心化治理、去中心化数据管理</li><li>基础构建管道</li><li>为失效设计：应用程序需要被设计成能够容忍服务失效</li></ul></li></ul><h2 id="12-高级特性"><a href="#12-高级特性" class="headerlink" title="12. 高级特性"></a>12. 高级特性</h2><ul><li>自动化测试框架<ul><li>自动化测试框架arkxtest，作为工具集的重要组成部分，支持JS&#x2F;TS语言的单元测试框架(JsUnit)及UI测试框架(UiTest)。JsUnit提供单元测试用例执行能力，提供用例编写基础接口，生成对应报告，用于测试系统或应用接口。UiTest通过简洁易用的API提供查找和操作界面控件能力，支持用户开发基于界面操作的自动化测试脚本。</li><li><strong>脚本基础流程运行图</strong><ul><li><img src="image-20250103154658694.png" alt="image-20250103154658694"></li></ul></li></ul></li><li>NDK开发<ul><li>NDK（Native Development Kit）是HarmonyOS SDK提供的Native API、相应编译脚本和编译工具链的集合，方便开发者使用C或C++语言实现应用的关键功能。</li><li>NDK只覆盖了HarmonyOS一些基础的底层能力，如C运行时基础库libc、图形库、窗口系统、多媒体等</li><li><img src="image-20241214192403587.png" alt="image-20241214192403587" style="zoom: 80%;" /></li><li><strong>NAPI对比JNI</strong><ul><li><img src="image-20250103154616244.png" alt="image-20250103154616244"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华为</tag>
      
      <tag>鸿蒙</tag>
      
      <tag>arkts</tag>
      
      <tag>方舟编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式软件系统</title>
    <link href="/2025/01/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/01/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h1><h2 id="1-嵌入式系统概论"><a href="#1-嵌入式系统概论" class="headerlink" title="1. 嵌入式系统概论"></a>1. 嵌入式系统概论</h2><ul><li><strong>嵌入式系统定义</strong><ul><li>“嵌入式系统”实际上是”嵌入式计算机系统”的简称，以下是对嵌入式系统的不同定义。</li><li>IEEE的定义<ul><li>嵌入式系统是用于<strong>控制、监视或者辅助操作机器和设备的装置</strong>。</li><li>此定义是从应用上考虑的，嵌入式系统是软件和硬件的综合体，还可以涵盖机电等附属装置。</li></ul></li><li>国内的定义<ul><li>嵌入式系统是<strong>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</strong>。<ol><li>嵌入式设备是用于特定的设备</li><li>计算机技术为基础，必须要有计算</li><li>软硬件可裁剪:印证了专用设备的特点，将不需要的设备裁剪掉</li></ol></li><li>嵌入式系统就是一个具有特定功能或用途的隐藏在某种设备中的计算机软硬件集合体，没有固定的特征形状。</li><li>嵌入的可以不是设备，而是生产流程，这样的系统也是嵌入式系统</li></ul></li><li>其他的定义<ul><li>看不见的计算机，一般不能被用户编程, 它有一些专用的I&#x2F;O设备, 对用户的接口是应用专用的。</li><li>嵌入式系统是包含在某些较大的设备或产品中的计算机系统，其目的是为该设备提供<strong>监视和控制</strong>服务。</li><li>包括可编程计算机在内但本身<strong>不打算用作通用计算机</strong>的任何设备。</li><li>包含有计算机，但又不是通用计算机的计算机应用系统。</li></ul></li></ul></li></ul><span id="more"></span><ul><li>嵌入式系统示例<ul><li>CPS：信息物理系统，Cyber-Physical System (CPS) ，是计算进程与物理进程的集成</li><li>WSN：无线感知网络，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络。这些装置使用传感器器协作地监控不同位置的物理或环境状况</li><li>传感器:将非电信号转换为电信号，用来感知和度量外部世界，并将其转换为计算机可度量的电信号。比如温湿度、酸碱度传感器等。</li><li>物联网(IoT)是物理设备，车辆(也称为”连接设备”和”智能设备”)，建筑物以及其他嵌入电子设备，软件，传感器，执行器和网络的物品的互连网络 连接性，使这些对象能够收集和交换数据。</li></ul></li><li><img src="image-20241211144341082.png" alt="image-20241211144341082" style="zoom: 67%;" /></li><li><strong>嵌入式系统的组成</strong><ul><li>嵌入式系统一般由<strong>嵌入式硬件和软件</strong>组成</li><li>硬件以<strong>微处理器</strong>为核心集成<strong>存储器</strong>和系统专用的<strong>输入&#x2F;输出设备</strong></li><li>软件包括：<strong>初始化代码及驱动、嵌入式操作系统和应用程序</strong>等，这些软件有机地结合在一起，形成系统特定的一体化软件。</li></ul></li><li><strong>嵌入式系统的特点</strong><ul><li><strong>形式多样、面向特定应用</strong>：一般用于特定的任务，其硬件和软件都必须高效率地设计，可剪裁</li><li><strong>高度制约的环境</strong>：嵌入式系统通常工作在资源高度受限的环境中，这也使得系统设计极具挑战性</li><li><strong>与外部环境的交互，包含传感器和执行器</strong>：与外部环境的交互在很大程度上是无人干预的，需要传感器来接收来自外部环境的数据，通过执行器输出数据到外部环境并控制外部环境</li><li><strong>实时性要求</strong>：一方面大多数实时系统都是嵌入式系统，另一方面嵌入式系统多数有实时性的要求，具有时间约束条件，必须在给定的时间范围内处理完事件</li><li><strong>安全性和可靠性</strong>：某些实时嵌入式系统是安全至上且必须是具有高度的可靠性</li><li><strong>关注成本</strong>：嵌入式系统通常需要注意的成本是系统成本，特别是量大的消费类数字化产品，其成本是产品竞争的关键因素之一</li><li><strong>并发性</strong>：并发性是指在一个系统中将多个计算同时执行并潜在地交互的特性</li></ul></li><li><strong>嵌入式系统的分类</strong><ul><li>按嵌入式处理器的位数来分类：4位、8位、16位、32位、64位</li><li>按应用来分类</li><li>按速度分类：强实时系统、⼀般实时系统、弱实时系统</li><li>按确定性来分类：硬实时、软实时系统</li><li>按嵌入式系统软件复杂程度来分类</li></ul></li></ul><h2 id="2-嵌入式系统设计方法、EMP"><a href="#2-嵌入式系统设计方法、EMP" class="headerlink" title="2. 嵌入式系统设计方法、EMP"></a>2. 嵌入式系统设计方法、EMP</h2><ul><li>设计过程<ul><li><img src="2.png" style="zoom: 50%;" /></li></ul></li><li>硬件组成：CPU、bus、memory、I&#x2F;O devices: 网络，传感器，执行器等。</li><li><strong>嵌入式微处理器(EMP)的分类</strong><ul><li>嵌入式微处理器种类繁多，按位数可分为4位、8位、16位、32位和64位。</li><li>根据功能不同，嵌入式微处理器分为四种：<ol><li>嵌入式微处理单元(MPU)：嵌入式微处理器就是和通用计算机的处理器对应的CPU</li><li>嵌入式微控制器(MCU)：嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM&#x2F;EPROM，RAM，总线，总线逻辑，定时&#x2F;计数器，I&#x2F;O，串行口等各种必要功能和外设</li><li>嵌入式DSP处理器：嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</li><li>嵌入式SoC：系统级芯片，也称为片上系统（System-on-Chip），是追求产品系统最大包容的集成器件，绝大多数系统构件都在一个系统芯片内部</li></ol></li></ul></li><li><strong>嵌入式微处理器特点</strong><ul><li>体积小、重量轻、可靠性高</li><li>功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul></li><li><strong>选择微处理器的准则</strong><ul><li>高效、经济地满足任务的计算需求</li><li>软件开发工具的可用性</li><li>广泛的可用性和可靠的微控制器来源</li></ul></li><li><strong>设备分类</strong><ul><li>根据其能力和性能，物联网设备可以分为三类</li><li>高端设备，车载</li><li>中端物联网设备，包括Rasberry Pi等单板机（SBC）和智能手机</li><li>低端物联网设备，这些设备资源有限，无法运行这些传统的操作系统</li></ul></li></ul><h2 id="3-存储器架构"><a href="#3-存储器架构" class="headerlink" title="3. 存储器架构"></a>3. 存储器架构</h2><ul><li>易失性存储器：随机存取存储器（RAM）<ul><li>SRAM：静态RAM，速度快，面积大</li><li>DRAM：动态RAM，保持数据的时间很短，需要定期刷新，比SRAM更不稳定</li><li><strong>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM</strong></li></ul></li><li>非易失性存储器<ul><li>不需要持续供电来保留存储在计算设备中的数据或程序代码</li><li>只读存储器（ROM），或掩模ROM（Mask ROM）：内容在芯片工厂就已经固定</li><li>电可擦除可编程ROM（Electrically Erasable Programmable ROM，EEPROM）</li><li>快闪存储器（Flash）<ul><li>有比较快的读取时间，但比SRAM和DRAM慢</li><li>写入时间大大超过读取时间，而且写入的次数是有限的</li><li>NOR:(放置固态代码:因为还有XIP)<ol><li>字可读取。</li><li>逐块擦除。</li></ol></li><li>NAND:<ol><li>按页读取(512-4K字节)。</li><li>逐块擦除。</li></ol></li><li>NAND便宜，擦除速度更快，顺序访问时间更短</li></ul></li><li>磁盘存储器</li></ul></li><li><strong>固件和可固化</strong><ul><li>固件（firmware）：一般存储于设备中的电可擦除只读存储器EEPROM 或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级的程序</li><li>可固化（ROMable）：可被编程到ROM芯片中的机器语言</li></ul></li><li><strong>存储器层次结构</strong><ul><li>处理器寄存器</li><li>缓冲存储器：高速缓存Cache、地址转换高速缓存（TLB，也称快表）以及暂存存储器（SPM）。<ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问</li><li>SPM通常和处理器集成在一个芯片上</li></ul></li><li>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在MB到GB之间，并且是易失的</li><li>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案</li></ul></li></ul><h2 id="4-Bus"><a href="#4-Bus" class="headerlink" title="4. Bus"></a>4. Bus</h2><ul><li>可编程I&#x2F;O<ul><li>在通信过程中选择控制寄存器或数据缓冲区的三种方法<ul><li>独立I&#x2F;O端口：I&#x2F;0独立编址，不占用内存空间，但是只能用专门的I&#x2F;0指令，访问端口的方法少</li><li>内存映射I&#x2F;O：在内存映射I&#x2F;O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址</li><li>混合解决方案，混合模型包括内存映射的I&#x2F;O数据缓冲区和用于控制寄存器的独立I&#x2F;O端口</li></ul></li></ul></li><li>I&#x2F;O中断部分：中断向量、中断优先级等内容与OS相同，不再赘述</li><li><strong>可重入</strong><ul><li>定义：一个函数可以同时被多次调用。可重入函数在任何时候都可以被中断，一段时间后继续运行时数据不会丢失。</li><li>在嵌入式世界中，例程必须满足以下条件才能重入:<ul><li>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</li><li>不调用不可重入的函数</li><li>不以非原子的方式使用硬件</li></ul></li></ul></li><li><strong>竞态条件</strong>：设备或系统出现不恰当的执行时序，而得到不正确的结果</li><li>CPU总线<ul><li>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线</li><li>总线协议决定了设备是如何进行通信的</li><li>总线上的设备会经历状态序列：协议是由状态机指定的，协议中的每个参与者都有一个状态机。</li></ul></li><li>分类<ul><li><img src="image-20250104093057527.png" alt="image-20250104093057527" style="zoom: 67%;" /></li><li><img src="image-20250104093134536.png" alt="image-20250104093134536" style="zoom:67%;" /></li></ul></li></ul><h2 id="5-嵌入式软件系统"><a href="#5-嵌入式软件系统" class="headerlink" title="5. 嵌入式软件系统"></a>5. 嵌入式软件系统</h2><ul><li><p>嵌入式软件与桌面软件的对比</p><ul><li><p>内存：有限，影响编程语言的选择以及开发工具的使用(比如编译器优化)</p></li><li><p>CPU处理能力：成本和功耗的考虑，ES不得不采用保守的设计方案，其中的CPU往往只是恰好满足要求。</p></li><li><p>操作系统：OS(Windows&#x2F;Linux)、RTOS、专有OS或裸机</p></li><li><p>实时性</p><ul><li>实时系统不⼀定会运行得很快，但⼀定是可预测的，通常的术语叫做确定性</li><li>实时性的要求对于OS的选择和程序设计都有影响</li></ul></li></ul><ul><li>开发流程<ul><li>ES往往没有足够的资源进行软件开发。交叉开发对于工具的选择有很大影响。<ul><li>开发过程也不同，编辑&#x2F;编译&#x2F;调试的循环是一样的，但执行程序这⼀步却非常复杂，需要把代码转移到目标机上或者在某种环境下运行。</li></ul></li></ul></li><li>执行流程：多数嵌入式设备从开机开始就会运行某个程序，该程序会⼀直运⾏到系统关机。这个程序可能存储在ROM，也可能是从⾮易失性存储器转移到RAM中执行。</li><li>嵌入式软件开发工具<ul><li><img src="image-20241211154237746.png" alt="image-20241211154237746" style="zoom:67%;" /></li></ul></li><li>软件组件<ul><li><img src="image-20241211154350359.png" alt="image-20241211154350359" style="zoom:67%;" /></li></ul></li></ul></li><li><p>嵌入式软件系统层次结构</p><ul><li><img src="image-20250104093329334.png" alt="image-20250104093329334" style="zoom:80%;" /></li></ul></li><li><p>为何要为实时系统建立模型</p><ul><li>辅助测试和完善最终系统</li><li>更重要的是，模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进⼀步研究</li><li>实时工程师使用程序模型来开发软件和硬件，以便能将整个实时系统全盘考虑</li><li>模型使得⼯程师能够预测程序的运行，从而满足系统的性能需求和功能需求</li></ul></li><li><p>嵌入式软件<strong>架构</strong></p><ul><li>分为两部分：业务逻辑、实时依赖硬件的逻辑</li><li><img src="image-20241211154941064.png" alt="image-20241211154941064" style="zoom:50%;" /></li></ul></li><li><p>嵌入式软件<strong>架构模式</strong></p><ul><li>非结构化单体架构：很容易构建，但很难维持规模和移植，与应用层的应用程序紧密耦合</li><li>分层架构<ul><li><img src="image-20241211155159047.png" alt="image-20241211155159047" style="zoom:50%;" /></li></ul></li><li>事件驱动架构<ul><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义</li><li>通常利用中断来立即响应事件</li><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件</li><li>优点：具有相对的可扩展性、软件模块通常具有高内聚性和低耦合性</li><li>缺点：无论何时需要做任何事情，都有额外的开销和复杂性</li></ul></li><li>微服务架构<ul><li>微服务架构将应用程序构建为为业务领域开发的小型自治服务的集合</li><li>微服务本质上是低耦合的，使得微服务易于维护和可测试，开发人员可以快速扩展或移植微服务</li><li>围绕系统的业务逻辑组织，业务逻辑(有时称为业务功能)是系统行为的业务规则和用例</li></ul></li></ul></li><li><p>嵌入式软件<strong>设计模式</strong></p><ul><li>单核、多核、发布和订阅模型、RTOS模式、中断处理和低功耗设计</li><li>轮询<ul><li>从外设收集数据的最直接的设计机制是让应用程序定期轮询外设，以查看是否有任何数据可供管理和处理</li><li><img src="image-20241211155717208.png" alt="image-20241211155717208" style="zoom:50%;" /></li><li>watchdog：<a href="https://blog.csdn.net/shulianghan/article/details/80249185">https://blog.csdn.net/shulianghan/article/details/80249185</a></li></ul></li><li><strong>有限状态机</strong><ul><li>与轮询类似，但只有当前状态被执行.</li><li>每个状态决定下一个状态(非顺序执行)。</li><li>优先级:每个状态确定下一个状态的优先级。</li><li>响应时间:所有任务的总和。</li><li>变更的影响:重大。更改任务的执行时间或添加任务会影响所有其他任务。</li><li>简单性:没有共享数据问题。</li></ul></li><li><strong>中断设计模式</strong><ul><li>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件</li><li>当设计ISR（中断处理服务）时，我们希望中断尽可能快地运行(以最小化中断)</li><li>优先级：中断优先于主循环</li><li>响应时间：所有任务的总和以及中断执行时间</li><li>更改的影响：对于中断服务程序而言意义不大。与轮询作为主循环相同。</li><li>共享数据：必须处理与中断服务程序共享的数据</li><li>是MCU中使用最多的</li></ul></li><li><strong>数据获取&#x2F;存储相关的中断设计模式</strong>：线性数据存储、乒乓缓冲&#x2F;双缓冲、环形&#x2F;循环缓冲区、带有信号量的循环缓冲区、带有事件标志的循环缓冲区、消息队列</li><li>DMA控制器将外设数据传输到循环缓冲区的设计模式<ul><li>DMA，全称Direct Memory Access，即直接存储器访问</li><li>无需CPU的交互情况下在RAM和外设之间以及内部传输数据</li></ul></li><li><strong>RTOS应用程序设计模式</strong><ul><li>在RTOS应用程序中，通常有两种类型的同步</li><li>资源同步：决定了对共享资源的访问是否安全，包括中断锁定（关中断）、抢占锁定（禁用抢占式调度器）和互斥锁</li><li>活动同步：决定执行是否已达到特定状态，用于协调任务执行<ul><li>例如，假设我们正在开发一个获取传感器数据并使用传感器值驱动电机的系统。我们很可能想要向运动任务发出信号，告诉它有新的数据可用，这样任务就不会对陈旧的数据采取行动</li><li>单向同步(任务对任务)：使用二值信号量或事件标志来同步任务</li><li>单向同步(中断到任务)：单向同步还可以在中断和任务之间同步和协调任务执行， 不同之处在于，在ISR给出信号量或事件标志之后，ISR将继续执行，直到完成为止。</li><li>双向同步：两个任务在它们之间的两个方向上进行协调</li><li>同步多个任务之广播设计模式：广播设计模式允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列</li><li>发布和订阅模型：在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题，该设备还可以发布特定的主题</li></ul></li></ul></li><li><img src="image-20241211162121699.png" alt="image-20241211162121699" style="zoom: 67%;" /></li></ul></li></ul><h2 id="6-嵌入式操作系统概述"><a href="#6-嵌入式操作系统概述" class="headerlink" title="6. 嵌入式操作系统概述"></a>6. 嵌入式操作系统概述</h2><ul><li>实时系统：一个实时系统是指计算的正确性不仅取决于程序的逻辑正确性，也取决于结果产生的时间，如果系统的时间约束条件得不到满足，将会发生系统出错<ul><li>确定性（Determinism）：如果一个系统始终会为某个已知输入产生相同的输出，则该系统是确定性的</li><li>截止时限（Deadline）：截止时限就是必须完成某项任务的有限时间窗口，指明计算何时必须结束</li></ul></li><li>实时操作系统（Real-Time Operating System, RTOS）是支持构建实时系统的操作系统</li><li>RTOS与GPOS<ul><li>相似的功能<ul><li>多任务级别</li><li>软件和硬件资源管理</li><li>为应用提供基本的OS服务</li><li>从软件应用抽象硬件</li></ul></li><li>RTOS从GPOS分离出的功能<ul><li>更快的特性</li><li>满足应用需要的剪裁能力</li><li>减少内存需求</li><li>为实时嵌入式系统提供可剪裁的调度策略</li><li>嵌入式应用上下文中具有更好的可靠性</li><li>支持无盘化嵌入式系统，允许从ROM或RAM上引导和运行</li><li>对不同硬件平台具有更好的可移植性</li></ul></li></ul></li><li>为何使用RTOS<ul><li>可被复用的标准软件组件</li><li>灵活性</li><li>响应时间</li></ul></li><li>RTOS关键要求<ul><li>操作系统的时间行为必须是可预测的</li><li>操作系统必须管理线程和进程的调度</li><li>一些系统要求操作系统管理时间</li><li>操作系统必须是快速的</li><li>可靠性</li><li>简洁紧凑</li></ul></li><li>RTOS内核系统服务<ul><li>任务管理</li><li>同步与通信</li><li>内存管理</li><li>时间管理</li><li>IO管理</li><li>异常与中断管理</li></ul></li><li>物联网操作系统的要求<ul><li>内存占用小</li><li>支持异构硬件</li><li>网络连接</li><li>节能</li><li>实时功能</li><li>安全</li></ul></li><li>物联网操作系统分类<ul><li>事件驱动的操作系统<ul><li>该模型的关键思想是，系统上的所有处理都是由(外部)事件触发的，通常由中断发出信号</li><li>这类操作系统包括continki、TinyOS和OpenWSN</li></ul></li><li>多线程OS<ul><li>多线程操作系统通常会引入一些内存开销，这是由于堆栈预留空间造成的，而运行时开销则是由于上下文切换造成的</li><li>属于这一类的操作系统包括RIOT、nuttX、eCos或ChibiOS</li></ul></li><li>纯RTOS<ul><li>在工业&#x2F;商业环境中，RTOS主要关注实现实时保证的目标，正式的验证、认证和标准化通常是至关重要的</li><li>为了允许模型检查和形式化验证，这些操作系统中使用的编程模型通常会对开发人员施加严格的约束</li><li>属于这一类别的物联网设备的操作系统包括FreeRTOS、eCos、RTEMS、ThreadX和一系列其他商业产品(通常是封闭源代码)</li></ul></li></ul></li><li>调度程序分类<ul><li>完全静态调度程序：在系统设计时制定三项决策（分配、排序、定时）</li><li>静态顺序调度程序&#x2F;离线调度程序：在设计时完成任务的分配和排序，但直到任务运行时才确定每个任务的物理执行时间</li><li>在线调度程序<ul><li>静态分配调度程序：在设计时制定任务的分配，其他决策在任务运行时制定</li><li>完全动态调度程序：在任务运行时制定所有的决策</li></ul></li></ul></li><li>任务的周期<ul><li><img src="image-20241212151836995.png" alt="image-20241212151836995" style="zoom:67%;" /></li><li>周期就是一个任务隔这么久会出现一次，同时也是这个任务完成的最晚时间</li></ul></li><li>优先级<ul><li>假设每个任务都有优先级号，调度程序总是执行优先级最高的任务</li><li>固定优先级：任务整个执行过程中其优先级保持不变</li><li>动态优先级：在执行过程中任务的优先级是可变的</li></ul></li><li>非抢占式调度与抢占式调度程序<ul><li>非抢占式优先级调度程序：通过优先级决定当前任务完成之后执行哪个任务，不中断一个正在执行的任务而去执行另外一个</li><li>抢占式优先级调度程序：在任何时刻，支持任务的到达，执行最高优先级的被激活任务。当任何任务改变优先级或激活状态时，内核可以调度一个新任务</li><li>可行调度：所有的任务执行都符合他们的时限</li></ul></li><li><strong>RMS调度算法</strong>：单调速率调度<ul><li>看这篇：<a href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html">https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html</a></li></ul></li><li><strong>EDD调度算法</strong>：最早交货期<ul><li><img src="image-20241212154345902.png" alt="image-20241212154345902" style="zoom:67%;" /></li><li>EDD在最大延迟最小化方面是最优的</li></ul></li><li><strong>EDF调度算法</strong>：最早截止时限优先<ul><li>EDD不支持任务到达，可通过允许任务在任何时刻“到达”(就绪)来扩展EDD</li><li>最早截止时限优先(EDF)：给定n个具有任意到达时间的独立任务集，在<strong>任何时刻</strong>，在<strong>所有到达的任务</strong>中执行<strong>绝对截止时限最早</strong>的任务的算法对于最大延迟最小化上是最优的</li><li>看这篇：<a href="https://blog.csdn.net/Cap220590/article/details/102762190">https://blog.csdn.net/Cap220590/article/details/102762190</a></li></ul></li><li>优先序约束<ul><li><img src="image-20241212155422778.png" alt="image-20241212155422778" style="zoom:67%;" /></li></ul></li><li><strong>LDF调度算法</strong>：最晚时限优先<ul><li><img src="image-20241212160731236.png" alt="image-20241212160731236" style="zoom: 67%;" /></li><li>LDF 在最大延迟最小化方面是最优的</li><li>但是，LDF要求所有任务都是已知的，并且在执行任何任务之前都知道它们的优先序约束</li></ul></li><li>具有优先序的EDF<ul><li><img src="image-20241212160957513.png" alt="image-20241212160957513" style="zoom: 60%;" /></li><li><img src="image-20241212161038698.png" alt="image-20241212161038698" style="zoom:60%;" /></li><li>修改截止时限<ul><li><img src="image-20241212161056264.png" alt="image-20241212161056264" style="zoom:60%;" /></li><li>从叶子往上面算，叶子的<code>di&#39;</code>就等于原来的<code>di</code></li></ul></li></ul></li><li>优先级反转<ul><li><img src="image-20241212161915313.png" alt="image-20241212161915313" style="zoom:67%;" /></li><li>解决方案是优先级继承协议：当任务<code>Ji</code>阻塞一个或多个高优先级任务时，它暂时假定(继承)被阻塞任务的最高优先级</li><li><img src="image-20241212162142431.png" alt="image-20241212162142431" style="zoom:67%;" /></li></ul></li><li>死锁问题的解决<ul><li>优先级上限协议<ul><li>每个锁或信号量都被分配了一个优先级上限，该上限等于可以锁定它的最高优先级任务的优先级</li><li>只有当任务T的优先级严格高于其他任务当前持有的所有锁的优先级上限时，任务T才能获得锁</li></ul></li><li><img src="image-20241212162434797.png" alt="image-20241212162434797" style="zoom:67%;" /></li></ul></li><li>FreeRTOS 支持的调度方法：抢占式、协作式、时间片轮转</li></ul><h2 id="7-实时内核"><a href="#7-实时内核" class="headerlink" title="7. 实时内核"></a>7. 实时内核</h2><ul><li><p>任务和ISR之间的通信方式</p><ul><li>一个任务或ISR可以通过事件控制块ECB（信号量、邮箱或消息队列）向另外的任务发信号</li><li>一个任务还可以等待另一个任务或中断服务子程序给它发送信号，对于处于等待状态的任务，还可以给它指定一个最长等待时间</li><li>多个任务可以同时等待同一个事件的发生，当该事件发生后，在所有等待该事件的任务中，优先级最高的任务得到了该事件并进入就绪状态，准备执行</li></ul></li><li><p>μC&#x2F;OS：一种基于优先级的抢占式多任务实时操作系统，包含了实时内核、任务管理、时间管理、任务间通信同步（信号量，邮箱，消息队列）和内存管理等功能。</p><ul><li>邮箱（MailBox）：一个任务或ISR可以通过邮箱向另一个任务发送一个指针型的变量，该指针指向一个包含了特定“消息”（message）的数据结构；</li><li>消息队列可以使一个任务或ISR向另一个任务发送多个以指针方式定义的变量，实现了任务接收来自其他任务或中断的不固定长度的消息。当队列中的消息是空时， 读取消息的任务将被阻塞</li><li>μC&#x2F;OSII中是实模式存储管理，不划分内核空间和用户空间，整个系统只有一个地址空间，即物理内存空间，应用程序和内核程序都能直接对所有的内存单元进行访问</li><li>μC&#x2F;OS采用的是固定分区的存储管理方法，把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块</li></ul></li><li><img src="image-20241212173144298.png" alt="image-20241212173144298" style="zoom:67%;" /></li><li><p>内存管理方法</p><ul><li><p>静态内存分配（Static Memory Allocation）</p><ul><li>允许用户在编译时为任务和内核对象（如队列、信号量等）分配静态内存</li><li>静态可以保证设备的可靠性但是需要考虑内存上限，内存使用效率低</li></ul></li><li><p>动态内存分配（Dynamic Memory Allocation）</p><ul><li>提供用于动态内存分配的内置函数，允许任务在运行时请求和释放内存</li><li>这种方法对于需要灵活管理内存的应用非常有用，但需要小心避免内存泄漏和碎片化</li></ul></li><li><p>内存池（Memory Pools）</p><ul><li>内存池是在系统初始化时创建的一块内存区域，用于存储固定大小的内存块</li><li>任务可以从内存池中申请内存块，并在使用完毕后将其返回给内存池，这有助于减少内存碎片化</li></ul></li></ul></li><li><img src="image-20241212165513722.png" alt="image-20241212165513722" style="zoom:67%;" /></li></ul><h2 id="8-板级支持包与系统引导"><a href="#8-板级支持包与系统引导" class="headerlink" title="8. 板级支持包与系统引导"></a>8. 板级支持包与系统引导</h2><ul><li>版级支持包 BSP<ul><li>BSP全称“板级支持包”（Board Support Packages），是介于主板硬件和操作系统中驱动层程序之间的一层，一般认为它属于操作系统一部分，主要是实现对操作系统的支持，为上层的驱动程序提供访问硬件设备寄存器的函数包，使之能够更好的运行于硬件主板</li><li>BSP是用于特定硬件平台的一组软件组件，通常包括启动代码、驱动程序和其他与硬件相关的软件库</li><li>组成<ul><li>启动代码：负责系统上电后的硬件初始化，如设置时钟、初始化存储器等</li><li>硬件抽象层（HAL）：介于底层硬件和上层软件之间的一层抽象层，用于隐藏硬件的具体实现细节，提供统一的接口</li><li>设备驱动：针对特定硬件的驱动程序</li></ul></li></ul></li><li>RTOS的引导模式<ul><li>不需要BootLoader的引导模式：时间效率高，系统快速启动，直接在NOR flash或ROM系列非易失性存储介质中运行，但不满足运行速度的要求</li><li>需要BootLoader的引导模式：节省空间，牺牲时间，适用于硬件成本低，运行速度快，但启动速度相对慢</li></ul></li><li>BootLoader：嵌入式系统中的 OS 启动加载程序<ul><li>汇编部分执行简单的硬件初始化</li><li>C语言部分负责复制数据,设置启动参数,串口通信等功能</li></ul></li></ul><h2 id="9-嵌入式系统建模"><a href="#9-嵌入式系统建模" class="headerlink" title="9. 嵌入式系统建模"></a>9. 嵌入式系统建模</h2><ul><li>建模、设计、分析<ul><li>建模是通过模拟加深对系统理解的过程<ul><li>模型是对所研究的系统、过程或概念的一种表达形式</li><li>使用模型的目的是要给出系统的抽象视图，每个模型都表示一组对象以及这些对象之间的相互关系</li><li><img src="image-20241212174232972.png" alt="image-20241212174232972" style="zoom:60%;" /></li></ul></li><li>常见的建模技术<ul><li>面向状态的建模</li><li>面向活动的建模</li><li>面向结构的模型</li><li>面向数据的模型</li><li>异构模型：综合前四种模型特征</li></ul></li></ul></li><li>嵌入式系统模型的用途<ul><li>通过使用现代建模软件工具，可以离线仿真的方式进行设计和执行初始验证</li><li>可以使用模型来作为所有后续开发阶段的基础</li><li>建模（涉及硬件原型设计）将降低出错风险，通过在整个开发过程中执行验证和确认测试来缩短开发周期</li><li>以系统模型为基础，可以更快、更可靠地进行设计评估和预测</li><li>这种迭代方法可以在性能和可靠性方面改进设计</li><li>由于模型的可重用性以及对物理原型的依赖的减少，降低了资源成本</li><li>通过使用代码自动生成技术，可以减少开发错误和开销</li></ul></li><li>建模语言<ul><li><img src="image-20241212174639515.png" alt="image-20241212174639515" style="zoom: 60%;" /></li><li>与编程语言一样，建模语言有明确的定义和标准语法，用于表示结构和功能参与者及其随时间变化的主要关系</li><li>建模语言有多种形式<ul><li>图形、文本</li><li>面向文档、仿真或执行</li><li>专注于体系架构层面内容、实现层面内容</li></ul></li></ul></li><li>何时为嵌入式系统建立模型<ul><li>任务和安全关键型应用</li><li>高度复杂的应用程序和系统</li><li>大型开发团队</li><li>没有其他选择（当没有原型时）</li></ul></li><li><img src="image-20250104102306876.png" alt="image-20250104102306876" style="zoom: 67%;" /></li></ul><h2 id="10-有限状态机FSM"><a href="#10-有限状态机FSM" class="headerlink" title="10. 有限状态机FSM"></a>10. 有限状态机FSM</h2><ul><li>反应式(reactive)系统：指能够持续地与环境进行交互，并且及时地进行响应</li><li>有限状态机：又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型<ul><li>两个重要特性<ul><li>确定性：如果对于每个状态，每个输入值最多可激活一个转移，则称这样的状态机具有确定性，这意味着Φ(S,E)是单一值</li><li>可接受性：如果对于每个状态，每个输入都有至少一个可能的转移，则称这样的状态机为可接受的，定义了每个可能的状态和输入值</li></ul></li><li>Moore状态模型：意味着输出完全由当前状态决定，与输入信号的当前值无关</li><li>Mealy状态模型：意味着输出既依赖于当前状态，也与输入信号的当前值有关</li></ul></li><li>状态表FSM<ul><li><img src="image-20241212202222625.png" alt="image-20241212202222625" style="zoom:67%;" /></li><li><img src="image-20241212202534873.png" alt="image-20241212202534873" style="zoom: 80%;" /></li><li><img src="image-20241212203247392.png" alt="image-20241212203247392"></li></ul></li><li>层次有限状态机<ul><li>是由多个嵌套到层次结构中的有限状态机（fsm）组成的</li><li><img src="image-20241212203533406.png" alt="image-20241212203533406"></li><li><img src="image-20241212203719583.png" alt="image-20241212203719583" style="zoom:60%;" /></li><li><img src="image-20241212203853827.png" alt="image-20241212203853827" style="zoom:67%;" /></li><li><img src="image-20241212203908295.png" alt="image-20241212203908295" style="zoom:67%;" /></li><li><img src="image-20241212204208529.png" alt="image-20241212204208529" style="zoom:67%;" /></li></ul></li><li>行为树BTs<ul><li>行为树是一种分层的决策树，通常用于实现复杂的行为逻辑</li><li>将各种行为组织成节点，并通过条件来控制节点的执行顺序</li><li><img src="image-20241212204525140.png" alt="image-20241212204525140" style="zoom:67%;" /></li><li><img src="image-20241212204744527.png" alt="image-20241212204744527"></li><li><img src="image-20241212205219193.png" alt="image-20241212205219193"></li><li><img src="image-20241212204856981.png" alt="image-20241212204856981"></li><li><img src="image-20241212204840254.png" alt="image-20241212204840254"></li><li><img src="image-20241212204905925.png" alt="image-20241212204905925"></li><li><img src="image-20241212204916227.png" alt="image-20241212204916227"></li></ul></li></ul><h2 id="11-嵌入式系统设计方法"><a href="#11-嵌入式系统设计方法" class="headerlink" title="11. 嵌入式系统设计方法"></a>11. 嵌入式系统设计方法</h2><ul><li>嵌入式系统设计所面临的挑战<ul><li>需要多少硬件？</li><li>如何满足时限要求，如何处理多项功能在时间上的协调一致关系？</li><li>如何降低系统的功耗？</li><li>如何设计以保证系统可升级？</li><li>如何保证系统可靠地工作？</li></ul></li><li>设计目标：成本、性能、功耗、尺寸、可伸缩性和可重用性、容错</li><li>传统的嵌入式系统的设计过程的基本流程<ul><li><img src="image-20250104102652866.png" alt="image-20250104102652866" style="zoom:67%;" /></li></ul></li><li>软硬件的划分<ul><li>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现</li><li>硬件和软件具有双重性</li><li>软硬件变动对系统的决策造成影响</li><li>划分和选择需要考虑多种因素</li><li>硬件和软件的双重性是划分决策的前提</li></ul></li></ul><h2 id="12-物联网"><a href="#12-物联网" class="headerlink" title="12. 物联网"></a>12. 物联网</h2><ul><li>定义<ul><li>物联网，Internet of Things (IoT) ，通过射频识别(RFID)、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念</li><li>物联网是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互</li><li><strong>设备</strong>：在物联网中，具有强制性通信能力和选择性传感、激励、数据捕获、数据存储和数据处理能力的设备</li><li><strong>物</strong>：在物联网中，“物”指物理世界（物理装置）或信息世界（虚拟事物）中的对象，可以被标识并整合入通信网</li></ul></li><li>IOT特征<ul><li>智能：从生成的数据中提取知识</li><li>架构：一个支持许多其他架构的混合架构</li><li>复杂的系统：一组动态变化的对象</li><li>规模：可伸缩性</li><li>时间：数十亿并行和同时发生的事件</li><li>空间：定位</li><li>一切都是服务：将资源作为服务消费</li></ul></li><li>IoT的优势<ul><li>技术优化：物联网技术有助于技术的改进和提高</li><li>改进的数据采集：传统的数据采集有其局限性，设计为被动使用，物联网促进了对数据的即时行动</li><li>减少浪费：物联网提供实时信息可使资源被有效的管理</li><li>提高客户参与度：物联网允许你通过发现问题和改进流程来改善客户体验</li></ul></li><li>IoT的不足<ul><li>安全：物联网技术创造了一个连接设备的生态系统，尽管有足够的安全措施，但系统可能缺乏足够的认证控制</li><li>隐私：物联网的使用，在没有用户积极参与的情况下，暴露大量的个人数据，这就产生了很多隐私问题</li><li>灵活性：主要涉及到与另一个系统的集成，在这个过程中涉及到许多不同的系统</li><li>复杂性：物联网系统的设计也相当复杂，此外部署和维护也不是很容易</li><li>合规性：物联网有自己的一套规则和法规，然而，由于法规遵循的复杂性，其任务是相当具有挑战性的</li></ul></li><li>IoT应用<ul><li>智能家居类：智能灌溉、智能车库门、智能门锁、智能灯、智能恒温器和智能安全系统</li><li>可穿戴设备类：健康和运动跟踪器、智能服装&#x2F;可穿戴设备</li><li>宠物类：宠物定位系统、智能狗狗门</li></ul></li><li>物联网体系结构<ul><li><img src="image-20250104105137310.png" alt="image-20250104105137310" style="zoom: 67%;" /></li></ul></li><li>物联网软件、硬件、连接<ul><li>物联网软件：若干物联网技术已接近成熟，包括边缘人工智能、基于物联网的流分析、监督和非监督机器学习</li><li>物联网硬件：现有物联网技术被归类为相当成熟或主流包括cpu、mcu、gpu、安全芯片、FPGA和边缘网关</li><li>物联网连接：eSIM、mesh网络、5G和Wi-Fi 6，接近成熟</li></ul></li></ul><h2 id="13-IOT平台"><a href="#13-IOT平台" class="headerlink" title="13. IOT平台"></a>13. IOT平台</h2><ul><li>概念<ul><li>物联网平台是一种多层技术，能够在物联网领域中直接提供、管理和自动化连接设备</li><li>对于开发者来说，物联网平台提供了一套随时可用的功能，极大地加快了联网设备应用程序的开发，同时兼顾了可扩展性和跨设备兼容性</li><li>物联网平台起源于物联网<strong>中间件</strong>的形式，其目的是充当硬件层和应用层之间的中介，主要任务包括通过不同的协议和网络拓扑从设备收集数据、远程设备配置和控制、设备管理和空中固件更新</li></ul></li><li>物联网平台覆盖功能领域<ul><li>使设备连接管理简单</li><li>接收、存储和发送数据</li><li>帮助企业可视化设备数据并提供关键的见解</li><li>提供特定于应用程序的支持和数据</li><li>是否有知识渊博、反应灵敏的支持团队‍ 提供健壮的安全</li><li>提供支持物联网解决方案特定需求的定制</li><li>一致的产品交付和平台更新</li></ul></li><li>设备管理<ul><li>设备管理服务, 可以帮助对所有连接的设备, 在全球范围内进行规模化的注册、查看及远程管理</li><li>物模型（Thing Model）是对设备在云端的功能描述，包括设备的属性、数据、服务和事件</li><li>物联网平台提供设备影子功能，用于缓存设备状态，是一个 JSON 文档</li><li>数字孪生，是充分利用物理模型、传感器更新、运行历史等数据，集成多学科、多物理量、多尺度、多概率的仿真过程，在虚拟空间中完成映射，从而反映相对应的实体装备的全生命周期过程</li></ul></li><li>通信协议<ul><li>应用层协议<ul><li><img src="image-20250104152205962.png" alt="image-20250104152205962" style="zoom:67%;" /></li></ul></li><li>多协议接入方案<ul><li>通过协议转换网关实现泛协议设备接入</li><li><img src="image-20250104152301276.png" alt="image-20250104152301276" style="zoom:67%;" /></li></ul></li></ul></li></ul><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><ul><li>Arduino为什么流行<ul><li>跨平台的</li><li>简单，清晰的编程环境</li><li>开放源码和可扩展软件</li><li>开源和可扩展硬件</li><li>便宜</li></ul></li><li>ROS<ul><li>ROS 是一个适用于机器人的开源的元操作系统，提供了操作系统应有的服务，包括硬件抽象、底层设备控制、常用函数的实现、进程间消息传递、以及包管理</li><li>ROS的核心是提供一个消息传递系统，通常称为“中间件”或“管道”</li><li>为什么使用<ul><li>ROS生态系统具有丰富的机器人软件</li><li>ROS项目的目标是不断降低构建机器人应用程序的门槛</li><li>ROS社区是一个庞大、多样和全球性的社区</li></ul></li></ul></li><li>PID<ul><li><strong>反馈控制</strong>是指将系统的输出信息返送到输入端，与输入信息进行比较，并利用二者的偏差进行控制的过程</li><li><strong>开环控制</strong>：open loop control，又称“开环控制系统”，是指在一个控制系统中系统的输入信号不受输出信号影响的控制系统, 也就是，不将控制的结果反馈回来影响当前控制的系统</li><li><strong>闭环控制</strong>：是指作为被控的输出量以一定方式返回到作为控制的输入端，并对输入端施加控制影响的一种控制关系，即带有反馈信息的系统控制方式</li><li><strong>PID</strong>：在过程控制中，按偏差的比例（P）、积分（I）和微分（D）进行控制的PID控制器（亦称PID调节器）是应用最为广泛的一种自动控制器</li></ul></li><li>传感器<ul><li><strong>温度漂移（温漂）</strong>：传感器在不同温度条件下，输出信号发生的变化。由于传感器的材料、结构以及电子元件的温度依赖性，随着环境温度的变化，传感器的灵敏度、零点和其他性能可能发生变化。</li><li><strong>零点漂移（零漂）</strong>：传感器在没有输入信号（例如，温度、压力、加速度等）时，输出信号发生的变化。理想情况下，当输入信号为零时，传感器应该输出零值，但实际情况中，传感器可能会在无输入的情况下产生一个非零的输出，称为零点漂移。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件工程</title>
    <link href="/2025/01/09/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2025/01/09/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务的软件工程"><a href="#面向服务的软件工程" class="headerlink" title="面向服务的软件工程"></a>面向服务的软件工程</h1><h2 id="1-服务和服务系统"><a href="#1-服务和服务系统" class="headerlink" title="1. 服务和服务系统"></a>1. 服务和服务系统</h2><ul><li><p>什么是服务</p><ul><li>服务是一种时间易逝的、无形的体验，为客户提供，客户在其中扮演共同生产者的角色。</li></ul></li><li><p>IT和非IT服务</p><ul><li><p><strong>共同特征</strong></p><ul><li>相同的服务生命周期原则</li><li>相同的一组服务系统元素</li></ul></li><li><p><strong>主要区别</strong></p><ul><li>关键绩效指标（KPI）</li><li>需求管理</li><li>变更的速度</li></ul></li></ul></li></ul><span id="more"></span><ul><li><p>搞清楚服务和制造的区别</p><ul><li><img src="image-20241209203750488.png" alt="image-20241209203750488"></li></ul></li></ul><h2 id="2-服务生态系统与面向服务的计算"><a href="#2-服务生态系统与面向服务的计算" class="headerlink" title="2. 服务生态系统与面向服务的计算"></a>2. 服务生态系统与面向服务的计算</h2><ul><li><p>基于构件的泛型：</p><ul><li>构件：模块化的、可部署、可替换的软件系统组成部分，它封装了内部的具体实现并对外提供统一接口</li><li>以构件的创建、构件的管理以及复用已有构件组装形成应用为基本活动</li></ul></li><li><p>服务组合：由多个装配在一起的服务构成，用以提供对业务任务或过程进行实现的功能</p></li><li><img src="image-20250106101340146.png" alt="image-20250106101340146" style="zoom:67%;" /></li><li><p>服务库存</p><ul><li><img src="image-20241209204405894.png" alt="image-20241209204405894" style="zoom: 67%;" /></li><li><img src="image-20250106101237009.png" alt="image-20250106101237009" style="zoom: 67%;" /></li><li><img src="image-20250106101301206.png" alt="image-20250106101301206" style="zoom:67%;" /></li></ul></li><li><p><strong>服务生态系统</strong></p><ul><li>垂直服务：可以被同时、独立调用的用于满足消费者需求的服务</li><li>水平服务：构成垂直服务的可重用的跨领域的公共服务</li><li>垂直服务与水平服务不互斥</li><li><img src="image-20241209204537993.png" alt="image-20241209204537993" style="zoom:67%;" /></li></ul></li><li><p>面向服务的计算</p><ul><li><img src="image-20241209205310814.png" alt="image-20241209205310814" style="zoom: 67%;" /></li><li><img src="image-20241209205205405.png" alt="image-20241209205205405" style="zoom:67%;" /></li></ul></li><li><p><strong>面向服务和面向对象的差异</strong>（第四张表为设计角度）</p><ul><li><img src="image-20241209205352653.png" alt="image-20241209205352653" style="zoom:67%;" /></li><li><img src="image-20241209205403408.png" alt="image-20241209205403408" style="zoom:67%;" /></li><li><img src="image-20241209205416096.png" alt="image-20241209205416096" style="zoom:67%;" /></li><li><img src="image-20241209205431280.png" alt="image-20241209205431280" style="zoom:67%;" /></li></ul></li></ul><h2 id="3-面向服务的架构和Web-Service"><a href="#3-面向服务的架构和Web-Service" class="headerlink" title="3. 面向服务的架构和Web Service"></a>3. 面向服务的架构和Web Service</h2><ul><li><p>SOA：面向服务的架构</p><ul><li><img src="image-20241209210107082.png" alt="image-20241209210107082" style="zoom: 67%;" /></li></ul></li><li><p>SOA的好处</p><ul><li>IT视角：<ul><li>松耦合，消除假依赖 —— 复用</li><li>服务间接寻址 —— 灵活</li></ul></li><li>企业视角：<ul><li>保护企业投资，提升现有IT资源的作用，促进IT资源的复用</li><li>提高企业灵敏度</li><li>支持企业外包管理模式</li></ul></li></ul></li><li><p>SOA分层：</p><ul><li>业务层、过程层、中间件层、编程层</li><li><img src="image-20241209210907280.png" alt="image-20241209210907280"></li></ul></li><li><p>服务簇</p><ul><li>一类从概念上服务于同一个业务功能的服务集合</li><li>服务簇中的服务可以由不同的服务提供者发布，并在具体特性上有差异</li><li>例如微软和IBM的天气预报服务</li></ul></li><li><p>编排和编导</p><ul><li>编排：存在一个作为中心协调者的复合服务用于组织其他服务</li><li><img src="image-20241209212152725.png" alt="image-20241209212152725" style="zoom: 67%;" /></li><li>编导：每个服务持有自己的脚本来指导自己的运作</li><li><img src="image-20241209212207465.png" alt="image-20241209212207465" style="zoom:67%;" /></li></ul></li><li><p>水平层与垂直层</p><ul><li><img src="image-20250106101936146.png" alt="image-20250106101936146" style="zoom:80%;" /></li><li><p>水平层实现功能性需求</p><ul><li><img src="image-20241209212414535.png" alt="image-20241209212414535" style="zoom: 67%;" /></li></ul></li><li><p>垂直层</p><ul><li><img src="image-20241209212500725.png" alt="image-20241209212500725" style="zoom: 67%;" /></li><li><img src="image-20241209212519820.png" alt="image-20241209212519820" style="zoom:67%;" /></li></ul></li></ul></li><li><p>Web Service内容</p><ul><li><img src="image-20241209212804179.png" alt="image-20241209212804179" style="zoom: 67%;" /></li><li><img src="image-20241209212929307.png" alt="image-20241209212929307" style="zoom: 67%;" /></li></ul></li><li><p>Web Service协议栈</p><ul><li><img src="image-20241209205941119.png" alt="image-20241209205941119" style="zoom:80%;" /></li></ul></li></ul><h2 id="4-XML及相关协议"><a href="#4-XML及相关协议" class="headerlink" title="4. XML及相关协议"></a>4. XML及相关协议</h2><ul><li><p>什么是信息交换</p><ul><li>在执行领域（业务）相关功能时，各式各样采用电子信息方式编码的信息，在软件单元间的移动</li></ul></li><li><p>为什么用XML</p><ul><li>平台中立</li><li>语言中立</li><li>基于文本结构</li><li>能够表达复杂数据结构</li></ul></li><li><p>服务合约</p><ul><li>建立了与服务交互有关的术语</li><li>提供了技术限制和需求，及服务的拥有者希望对外公布的所有语义信息</li><li><img src="image-20241209213316284.png" alt="image-20241209213316284"></li></ul></li><li><img src="image-20241210091936034.png" alt="image-20241210091936034" style="zoom: 67%;" /></li><li><p><strong>XML声明规则</strong>（符合5+1原则为<strong>格式良好</strong>的XML文档，<strong>合法</strong>的XML文档还需要基于一个词汇表用DTD或XML schema定义结构）</p><ul><li>单根元素：所有XML文档只能有一个根元素</li><li>元素标签规则：元素以一个开始标签和一个结束标签进行包装</li><li>元素嵌套规则：在元素的以开始标签和结束标签之间可以嵌套任意数量的子元素或数据</li><li>元素规则：包括命名规则、元素内容（PCDATA和CDATA）</li><li>元素属性：属性是一个键值对，必须有值</li><li>[可选]XML声明：出现在第一行，version为必选属性</li></ul></li><li><p>名称空间</p><ul><li>为避免冲突，将元素或属性名用URI + 名称表示</li><li><img src="image-20241210094427956.png" alt="image-20241210094427956" style="zoom: 67%;" /></li><li>QNames：包含前缀部分和本地部分（如<a href="books:title">books:title</a>）</li></ul></li><li><p>XML Schema</p><ul><li><img src="image-20250106103144223.png" alt="image-20250106103144223" style="zoom:80%;" /></li></ul></li><li><p>DOM Parser、SAX Parser、XSL、XPath、XSLT的选择</p><ul><li><p><strong>DOM Parser</strong>:</p><ul><li>适用于需要完整加载和操作 XML 文档的情况。</li><li>优点：支持随机访问和修改 XML 树结构，适合处理小型 XML 文件。</li><li>缺点：内存消耗大，处理大型文档性能较差。</li><li><strong>场景</strong>：需要反复读取、修改 XML 数据时使用。</li></ul></li><li><p><strong>SAX Parser</strong>:</p><ul><li>适用于逐行解析 XML 文档的情况，不需要加载完整文档。</li><li>优点：占用内存少，处理速度快，适合处理大型文档。</li><li>缺点：仅支持顺序读取，无法随机访问或修改数据。</li><li><strong>场景</strong>：只需一次性读取或过滤部分数据时使用。</li></ul></li><li><p><strong>XSL (Extensible Stylesheet Language)</strong>:</p><ul><li>适用于通过样式定义 XML 数据的展示方式。</li><li>包括 <strong>XSLT</strong>（转换部分）和 <strong>XSL-FO</strong>（格式化部分）。</li><li><strong>场景</strong>：需要定义复杂的 XML 文档样式或转换文档为不同的输出格式时使用。</li></ul></li><li><p><strong>XSLT (XSL Transformations)</strong>:</p><ul><li>专注于将 XML 文档转换为其他格式（如 HTML、XML、JSON 等）。</li><li>基于模板的转换语言，可通过规则匹配实现结构变换。</li><li><strong>场景</strong>：需要从一个 XML 文档生成另一种格式的输出时使用。</li></ul></li><li><p><strong>XPath (XML Path Language)</strong>:</p><ul><li>用于从 XML 文档中提取节点和数据。</li><li>适合精确定位或过滤特定数据。</li><li><strong>场景</strong>：需要从 XML 数据中快速提取某些字段或执行条件查询时使用。</li></ul></li><li><p>宏观选择的依据</p><p>| <strong>工具&#x2F;技术</strong> | <strong>适用场景</strong>                                        |<br>| ————- | ————————————————— |<br>| DOM Parser    | 操作整个 XML 树，支持随机访问和修改，适合小型文档。 |<br>| SAX Parser    | 顺序读取 XML，适合大型文档和高效处理需求。          |<br>| XSL           | 定义 XML 的展示样式或格式化输出。                   |<br>| XSLT          | 转换 XML 为其他格式（HTML、JSON 等）。              |<br>| XPath         | 查询、提取 XML 中的特定节点或数据。                 |</p></li></ul></li></ul><h2 id="5-Web-Service核心"><a href="#5-Web-Service核心" class="headerlink" title="5. Web Service核心"></a>5. Web Service核心</h2><h3 id="5-1-SOAP"><a href="#5-1-SOAP" class="headerlink" title="5.1 SOAP"></a>5.1 SOAP</h3><ul><li><p>什么是SOAP</p><ul><li><img src="image-20241210101319810.png" alt="image-20241210101319810" style="zoom:67%;" /></li></ul></li><li><p>SOAP的结构</p><ul><li><img src="image-20241210101633042.png" alt="image-20241210101633042" style="zoom:67%;" /></li><li><img src="image-20250106103832269.png" alt="image-20250106103832269" style="zoom:80%;" /></li><li>Envelope 元素：必须元素，根元素，标识此 XML 文档为一条 SOAP 消息；可以包含命名空间和声明额外的属性。如果出现额外属性，则必须使用命名空间修饰。</li><li>Header 元素：可选元素，有关 SOAP 消息的应用程序专用信息（比如认证、支付等）。</li><li>Body 元素：必须元素，包含所有的调用和响应信息。</li><li>Fault 元素：可选元素，提供有关在处理此消息所发生的错误的信息</li></ul></li><li><p>SOAP处理模型</p><ul><li>用 XML 打包请求：<ol><li>将接口名作为根节点</li><li>方法和参数作为节点</li></ol></li><li>将请求发给服务器：<ol><li>不创建自己的 TCP&#x2F;IP 信息，利用 HTTP</li><li>将请求封装成 HTTP POST 请求格式发出</li></ol></li><li>服务器收到请求，解码 XML，处理请求，以 XML 格式返回响应<ol><li>与请求比较，方法的节点名字变为请求的方法名后缀 <code>Response</code>（例如，<code>find-&gt;findResponse</code>）</li><li>客户程序自己调用了哪个方法，根据方法名后缀 <code>Response</code> 寻找调用方法的返回值</li></ol></li></ul></li><li><p>SOAP 通信的两种典型模型：</p><ol><li><strong>点对点通信</strong>：直接从发送方到接收方的简单模型。</li><li><strong>多跳通信</strong>：消息在多个中间节点间传递，最后到达目标接收者的复杂模型。过程中能够在不同网络协议（如 HTTP、SMTP、JMS 等）上进行</li></ol></li><li><p>文档导向和远程调用的区别</p><ul><li><strong>文档导向模式</strong></li></ul></li></ul><ul><li>一种<strong>异步</strong>交互方式<ul><li>发送一个完整的 XML 文档，并等待通知。结果会在处理完成后发送回来。</li><li>适用于复杂业务流程（如订单处理、报表生成），结果不要求实时返回。</li><li><strong>远程过程调用模式</strong><ul><li>一种<strong>同步</strong>的请求&#x2F;响应交互方式</li><li>发送具体的函数调用及其参数，请求并等待响应。</li><li>适用于简单任务或需要实时响应的场景（如查询某个数据）。</li></ul></li></ul></li></ul><ul><li>SOAP Fault机制<ul><li>SOAP 提供了一种模型，用于处理消息处理过程中出现的错误情况。</li><li>SOAP 区分了导致错误的条件和向错误消息的发起者或其他节点通知该错误的能力。</li><li>通知错误的能力取决于所使用的消息传输机制，而 SOAP 在绑定到底层协议的规范中，其中一个方面就是规定如何通知错误（如果支持的话）。</li><li>SOAP 的错误模型要求所有与 SOAP 相关的错误和与应用程序相关的错误都必须通过一个特殊的元素 <strong>Fault</strong> 来报告，并且该元素包含在 <strong>Body</strong> 元素中。</li><li>env:Fault元素包含两个子元素：env:code和env:reason</li></ul></li><li>NotUnderstood Message<ul><li>在处理 SOAP 消息的过程中，如果某个必需的头部元素无法被理解，或者其中包含的信息无法被处理，则可能会产生一个错误。<br>处理头部块时的错误同样会通过 <strong>env:Fault</strong> 元素在 <strong>env:Body</strong> 中进行通知，但不会使用 <strong>Detail</strong> 子元素。<br>相反，SOAP 错误命名空间中一个特殊的头部元素 <strong>Misunderstood</strong> 会被用来标识引发错误的头部。</li></ul></li></ul><h3 id="5-2-Web-Service接口定义语言WSDL"><a href="#5-2-Web-Service接口定义语言WSDL" class="headerlink" title="5.2 Web Service接口定义语言WSDL"></a>5.2 Web Service接口定义语言WSDL</h3><ul><li><p>WSDL的概念</p><ul><li><strong>功能</strong>：WSDL 对服务能力、服务中使用的数据结构以及传输绑定给出定义和描述；提供了一种基于 XML 的标准接口定义语言&#x2F;服务能力定义语言，用以在服务的提供者&#x2F;调用者&#x2F;服务注册之间，交换必要的有关的 web service 的信息。<strong>WSDL 的核心是描述 Web 服务的接口和操作，以及如何访问这些操作的消息格式和传输协议。</strong></li><li><img src="image-20241210103612279.png" alt="image-20241210103612279" style="zoom:67%;" /></li></ul></li><li><p><strong>WSDL结构</strong></p><ul><li><img src="image-20241210104015754.png" alt="image-20241210104015754" style="zoom:67%;" /></li><li><p>以 description 元素为根节点。</p></li><li><p>import、include：拼装不同部门&#x2F;组织定义的文档，形成完整的 WSDL 语义</p><p>| 特性         | import                                 | include                               |<br>| ———— | ————————————– | ————————————- |<br>| <strong>命名空间</strong> | 用于导入<strong>不同命名空间</strong>的定义         | 用于包含<strong>相同命名空间</strong>的定义        |<br>| <strong>用途</strong>     | 重用其他命名空间的 WSDL 或 XSD 定义    | 拆分当前命名空间内的 WSDL 或 XSD 文件 |<br>| <strong>属性</strong>     | 必须包含 <code>namespace</code> 和 <code>location</code>     | 只需包含 <code>location</code>                   |<br>| <strong>常见场景</strong> | 引入外部服务接口或跨命名空间的数据结构 | 拆分 WSDL 定义以简化管理              |</p></li><li><p>抽象部分：</p><ol><li>Types：使用到的数据结构或者叫数据格式范式，独立于语言和平台</li><li>Interface : operation 的集合，即服务能力的集合，描述服务能力。operation : input、output、infault、outfault</li></ol></li><li><p>具体部分：</p><ol><li>Binding：特定端口类型的具体协议和数据格式规范的绑定，即把抽象消息格式转化为具体的消息格式（Interface关注服务具体内容，Binding关注如何转换）</li><li>Service：对服务整体的抽象，包含若干个 endpoint。endpoint：在binding和interface间创建映射</li></ol></li></ul></li><li><p><strong>MEP：消息交换模式</strong></p><ul><li>8种预定义，四种基本</li><li><img src="image-20241210105203594.png" alt="image-20241210105203594" style="zoom:67%;" /></li><li><img src="image-20250106110600885.png" alt="image-20250106110600885" style="zoom:80%;" /></li></ul></li><li><p><strong>Message Dispatch</strong>：是一种与 SOAP 消息交换模式相关的机制，用于根据消息内容或格式将请求路由到正确的服务端处理逻辑。它本质上描述了 Web 服务如何根据消息的结构和类型来分发和处理请求。</p></li><li><img src="image-20241210105902896.png" alt="image-20241210105902896" style="zoom:67%;" /></li></ul><h2 id="6-Web-Service-扩展"><a href="#6-Web-Service-扩展" class="headerlink" title="6. Web Service 扩展"></a>6. Web Service 扩展</h2><h3 id="6-1-UDDI"><a href="#6-1-UDDI" class="headerlink" title="6.1 UDDI"></a>6.1 UDDI</h3><ul><li>概念<ul><li>UDDI被用来提供发布和查找Web Service的元服务。它可以用来针对丰富的元信息进行查找</li><li>UDDI采用XML格式，来存放注册Web Service的描述信息</li></ul></li><li><strong>UDDI结构</strong><ul><li><img src="image-20241210110514067.png" alt="image-20241210110514067" style="zoom:67%;" /></li><li><img src="image-20241210110625890.png" alt="image-20241210110625890" style="zoom:67%;" /></li></ul></li><li><strong>WSDL与UDDI的对应关系</strong><ul><li><img src="image-20241210110753583.png" alt="image-20241210110753583" style="zoom:67%;" /></li></ul></li><li>UDDI的使用<ul><li>对于分类、编目和管理Web服务，UDDI注册库提供了一个标准方式，以便于能够发现和使用这些Web服务<ul><li>业务和提供者可以按标准方式使用UDDI来表示Web服务信息</li><li>UDDI使用SOAP作为它的传输层</li></ul></li><li>UDDI API是一个接口，可以接受封装在SOAP信封中的XML消息<ul><li>所有的UDDI交互都使用请求&#x2F;响应模式</li><li>可以使用出查询API来搜索和读取UDDI注册库中的数据，并可使用发布API来添加、更新和删除UDDI注册库中的数据</li></ul></li><li>UDDI发布API<ul><li><img src="image-20241210111134770.png" alt="image-20241210111134770" style="zoom: 50%;" /></li></ul></li><li>UDDI查询API<ul><li><img src="image-20241210111338423.png" alt="image-20241210111338423" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h3 id="6-2-WS-协议"><a href="#6-2-WS-协议" class="headerlink" title="6.2 WS-*协议"></a>6.2 WS-*协议</h3><ul><li><strong>BPEL</strong>：采用标准协议的XML脚本描述服务组合方式</li><li><strong>Web-Addressing</strong>：用于消息分发<ul><li>请求消息<ul><li><img src="image-20241210122420047.png" alt="image-20241210122420047" style="zoom:67%;" /></li><li>元数据中包含WSDL，WSDL包含action以确定要调用的服务，SOAP消息中包含一个全局唯一的会话标记ID和FROM&#x2F;TO信息</li></ul></li><li>响应消息（右下）与请求消息（左上）对应关系<ul><li><img src="image-20241210122647438.png" alt="image-20241210122647438" style="zoom:67%;" /></li></ul></li></ul></li><li>WSRF : Web Service 资源框架，用于实现带状态的服务</li><li>WS-Sercurity：通过在SOAP头块中进行相关定义来实现安全性需求<ul><li><img src="image-20241210123713915.png" alt="image-20241210123713915" style="zoom:67%;" /></li></ul></li><li>WS-Coordination：主要包括WSAT（原子事务）和WSBA（商业活动）<ul><li><img src="image-20241210123805065.png" alt="image-20241210123805065" style="zoom: 80%;" /></li><li><img src="image-20241210123831641.png" alt="image-20241210123831641" style="zoom: 80%;" /></li></ul></li></ul><h2 id="7-服务生态系统的构建"><a href="#7-服务生态系统的构建" class="headerlink" title="7. 服务生态系统的构建"></a>7. 服务生态系统的构建</h2><ul><li><p>服务生命周期的基本阶段：面向服务的分析、设计，服务的开发、测试、部署、管理</p></li><li><p>业务逻辑：源于企业业务领域，业务需求的文档化实现</p></li><li><p>应用逻辑：组织成不同技术解决方案的业务逻辑的自动化实现</p></li><li><p>服务的层次</p><ul><li>最上层：编排层</li><li>中层：服务接口层<ul><li>应用服务：对底层的应用逻辑进行封装的服务</li><li>业务服务：用于满足服务调用者的业务需求的服务<ul><li>以任务为核心的（业务）服务</li><li>实体服务</li><li><img src="image-20241210200635130.png" alt="image-20241210200635130" style="zoom:67%;" /></li></ul></li><li>编排服务（可选）：对业务服务进行组合形成的新服务</li></ul></li><li><img src="image-20241210195306037.png" alt="image-20241210195306037" style="zoom: 80%;" /></li><li><img src="image-20241210195538392.png" alt="image-20241210195538392" style="zoom:67%;" /></li></ul></li><li><p><strong>业务服务与编排</strong></p><ul><li>编排能够组合以任务为核心的业务服务及以实体为核心的业务服务</li><li>基本的业务模型由以实体为核心的服务来表示</li><li>与业务逻辑相关的任务由以任务为核心的服务来表示</li><li>在不影响业务服务和应用服务的前提下进行业务规则和业务逻辑的变更</li></ul></li><li><p><strong>面向服务的交付策略</strong></p><ul><li>自顶向下：分析优先<ul><li>定义企业范围的相关本体（领域知识的概念及其关联）</li><li>将相关的业务模型（包括实体模型）与新的或修订后的本体匹配</li><li>进行面向服务的分析</li><li>进行面向服务的设计</li><li>开发所需服务</li><li>测试和部署服务</li></ul></li><li>自底向上：按需交付，封装并集成遗留系统优先<ul><li>对所需的应用服务进行建模，多为混合（应用）服务，即合并业务服务与应用服务。</li><li>设计所需的应用服务</li><li>开发所需的应用服务</li><li>测试和部署服务</li></ul></li><li><img src="image-20241210200118926.png" alt="image-20241210200118926" style="zoom: 67%;" /></li><li><img src="image-20241210200134384.png" alt="image-20241210200134384" style="zoom:67%;" /></li></ul></li><li><p>面向服务的设计</p><ul><li><p>在面向服务设计的过程中，通过从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中</p></li><li><p>设计过程</p><ul><li><p>组合SOA</p><ul><li>选择服务层</li><li>定位核心的SOA 标准</li><li>选择SOA 扩展</li></ul></li><li><p>设计服务</p></li></ul></li></ul></li></ul><ul><li>设计以实体为核心的业务服务<ul><li>设计应用服务</li></ul></li><li>设计以任务为核心的业务服务<ul><li>设计面向服务业务过程</li></ul></li></ul><h2 id="8-服务设计原则"><a href="#8-服务设计原则" class="headerlink" title="8. 服务设计原则"></a>8. 服务设计原则</h2><h4 id="标准化服务合约"><a href="#标准化服务合约" class="headerlink" title="标准化服务合约"></a>标准化服务合约</h4><ul><li>概念：使用形式化或者标准化的合约</li><li>服务合约设计的相关风险<ul><li>版本化：底层逻辑越是可复用，那些需要消费它的程序的数量和消费频率就会越大，拓展难度大，从而导致发布新的服务版本的要求</li><li>技术依赖：操作性系统层（编程语言和开发平台）的技术性变化导致服务合约变化</li><li>开发工具缺陷：使用开发工具自动生成合约可能产生非标准化的服务合约</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>标准化服务合约与服务松散耦合<ul><li>消费者和服务之间存在对服务合约中技术接口的依赖<ul><li>技术服务合约越详细，越内容丰富，消费者和服务之间的依赖关系越强</li><li>两个服务之间所达到的松散耦合程度直接与在服务合约中的依赖关系数量相关</li></ul></li><li>标准化的合约将会有助于提高服务之间的一致性和耦合质量</li></ul></li><li>标准化服务合约与服务抽象<ul><li>服务抽象原则要求简化合约：非核心信息都被隐藏</li><li>服务合约的设计决定了抽象的程度：在合约中的内容越仔细，服务中被抽象的信息就越少</li></ul></li><li>标准化服务合约与服务可复用性<ul><li>服务可复用性原则常常侧重于服务封装的逻辑是否足够一般和通用</li><li>可复用方案逻辑与数据交换之间的关系最终要由服务合约是如何设计的来决定</li><li>服务合约越是通用、灵活和可扩展，服务的长远复用潜力就越大</li></ul></li><li>标准化服务合约与服务可发现性<ul><li>服务合约越是得到一致的标注和结构化，对于那些需要使用它们的人来说就越是可以预测的</li><li>服务合约越是标准化，元信息的技术接口细节提供得越是充分，服务的可发现性就越高</li></ul></li><li>标准化服务合约与服务可组合性<ul><li>服务的可组合性需求常常与服务合约表达其能力的粒度有关</li><li>粗粒度的操作拥有更高的效率，但常常不适应于需要参与到更大规模组合中的服务</li></ul></li></ul><h4 id="服务松散耦合"><a href="#服务松散耦合" class="headerlink" title="服务松散耦合"></a>服务松散耦合</h4><ul><li>概念：调节技术合约内容的数量和复杂度，从而最小化消费者依赖需求</li><li>服务合约耦合类型<ul><li>“逻辑-合约”耦合(积极)：首先设计合约，然后再设计底层的方案逻辑。允许对底层逻辑进行微调以支持服务合约</li><li>“合约-逻辑”耦合(消极)：从现有的方案逻辑当中生成Web Services</li><li>“合约-技术”耦合(消极)：有的时候服务是作为传统专用组件存在的，这就需要服务合约与服务相关的通信技术紧密地耦合</li><li>“合约-实现”耦合(消极)：实现相关的特性和细节在服务合约的内容中体现出来</li><li>“合约-功能”耦合(消极)：由一个服务所封装的逻辑被专门设计为支持服边界之外的功能体</li></ul></li><li>服务消费者耦合的类型<ul><li>“消费者-实现”耦合(消极)：绕过服务合约，直接使用其他入口访问服务</li><li>“消费者-合约”耦合(积极)：采用合约集中化，将对服务的访问控制在合约内</li></ul></li><li>可能的风险<ul><li>“逻辑-合约”耦合的限制<ul><li>同一底层逻辑对应两个或者多个合约，从而建立多个入口，每一入口向不同类型的消费者暴露不同的服务能力</li></ul></li><li>Schema 耦合太“松散”：<ul><li>为了强调服务的兼容性演化能力，通过过分简化服务合约，追求减少消费者依赖，仅确定了一些非常通用的数据类型（弱类型）</li><li>验证并处理弱类型，增加服务所需的性能要求</li><li>服务合约发布的信息越少，消费者程序就需要知道越多关于服务实现逻辑的信息，从而产生消极耦合</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务松散耦合与标准化服务合约<ul><li>松散耦合鼓励调节技术合约内容的数量和复杂度，从而最小化消费者依赖需求、最大化服务所有者的自由度，在不影响现有消费者的情况下随着时间演化和改变服务</li></ul></li><li>服务松散耦合与服务抽象<ul><li>创建更低耦合的消费者关系，明确地要求应用良好定义的功能和技术抽象级别</li></ul></li><li>服务松散耦合与服务可复用性<ul><li>减少依赖关系可以使服务更容易被组合、演化甚至扩充以支持不断变化的业务需求和方向</li></ul></li><li>服务松散耦合与服务自治<ul><li>减少消极耦合类型的程度，会为运行时和设计时的更高自治级别提供支持</li><li>服务消费者具有越多的跨服务依赖，它所具有的自主权就越少（服务消费者可能同时担任复合服务中的服务协调者）</li></ul></li><li>服务松散耦合与服务可发现性<ul><li>服务松散耦合有助于元数据的调节</li></ul></li><li>服务松散耦合与服务可组合性<ul><li>在服务组合中，避免消极形式的耦合<ul><li>“合约-逻辑”耦合 如果服务合约是自动生成的，就很有可能在被其他服务使用时不符合标准。因此需要在它和其他组成成员之间进行转换</li><li>“合约-技术”耦合 如果同一个组合中的不同部分同时使用开放与专用服务技术，就会需要在本地实现技术转化层</li><li>“合约-实现”耦合 当一个服务合约与底层实现特性之间产生耦合时，就会最终把这些性质强加到作为一个整体的组合之上</li></ul></li></ul></li></ul><h4 id="服务抽象"><a href="#服务抽象" class="headerlink" title="服务抽象"></a>服务抽象</h4><ul><li>概念：获得信息隐藏的正确平衡点，即对哪一部分服务信息进行隐藏，哪一部分公开</li><li>可能的风险<ul><li>多消费者耦合的需求：不同消费者可能需要不同的技术接口细节，所需的抽象程度也不尽相同</li><li>人为误判<ul><li>过于抽象的服务合约导致曲解或不能充分理解一个服务。从而丧失潜在的复用机会</li><li>过于具体的服务合约导致对服务的行为作出与服务实现相关的假设，从而导致实现耦合</li></ul></li><li>安全和隐私的考虑：服务合约可能暴露私有或者敏感信息</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务抽象与标准化服务合约<ul><li>服务抽象出来并对外界可用的信息就是服务合约，服务抽象原则的应用影响到服务合约</li><li>服务合约的设计标准也会影响到功能、技术和逻辑抽象的等级</li></ul></li><li>服务抽象与服务松散耦合<ul><li>抽象的程度对可能耦合的程度有直接的关系</li><li>少量的高度详细的技术接口约束会导致比大量含糊或开放的数据约束更多的紧密耦合需求<ul><li>耦合的程度一般由被抽象的信息数量和信息本身的属性的组合来决定</li><li>最终由服务合约的粒度加以体现</li></ul></li></ul></li><li>服务抽象与其他原则<ul><li>其他的服务设计原则，如服务可复用性、服务可组合性和服务可发现性等原则都鼓励创建更多的、关于服务的元信息</li><li>而服务的抽象原则要求在发布这些元信息前评估其必要程度</li></ul></li></ul><h4 id="服务可复用性"><a href="#服务可复用性" class="headerlink" title="服务可复用性"></a>服务可复用性</h4><ul><li>概念：尽可能让服务被更多地复用</li><li><strong>可能的风险</strong><ul><li>文化上的考虑<ul><li>当项目团队被要求遵守特定可重用服务的逻辑集中化时，会出现常见的文化问题</li></ul></li><li>治理上的考虑<ul><li>面向服务将相互无关的逻辑单元抽象为服务，与业务流程、应用程序或用户基础都没有任何直接联系</li></ul></li><li>可靠性上的考虑<ul><li>可复用服务的单点失效会导致多个业务流程的失</li><li>通过对关键服务的多重复用来解决</li></ul></li><li>安全上的考虑<ul><li>在不同应用场景中的安全性要求不同</li><li>安全级别可能和信息交换的方式直接相关，甚至可能和服务合约所暴露的功能类型相关</li></ul></li><li>商业设计需求上的考虑<ul><li>领域专家在进行服务分析和建模阶段中引入的风险和问题</li></ul></li><li>敏捷交付上的考虑<ul><li>在需要以敏捷开发方法来解决短期和战术上的业务目标时，提倡服务的可复用性是非常困难的</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可复用性与标准化服务合约<ul><li>可复用的服务需要足够的灵活性来支持带有不同交互需求的消费者</li><li>导致降低合约验证约束（尤其是那些易变的）的设计标准</li></ul></li><li>服务可复用性与服务抽象<ul><li>合约的自描述性与简洁之间的平衡</li><li>元信息的抽象程度反映这一平衡</li></ul></li><li>服务可复用性与服务松散耦合<ul><li>一个服务的依赖需求越小，复用它就越简单</li><li>当追求服务逻辑的可复用性时，总是有一种减少服务合约约束的趋势</li></ul></li><li>服务可复用性与其他原则<ul><li>服务自治<ul><li>自治是对可复用服务潜在高性能和并行使用的保证</li></ul></li><li>服务无状态<ul><li>通过最小化状态管理责任，提高一个服务的可用性，从而提高有效扩展的能力</li></ul></li><li>服务可发现性<ul><li>可复用服务必需可发现、可解释</li></ul></li><li>服务可组合性<ul><li>可组合是复用的一种形式，可复用潜能越大，服务被反复组装的机会就越大</li></ul></li></ul></li></ul><h4 id="服务自治"><a href="#服务自治" class="headerlink" title="服务自治"></a>服务自治</h4><ul><li>概念：服务的自治，表现了它可以独立执行自身核心服务逻辑的能力</li><li>分类<ul><li>共享自治</li><li>部分隔离服务：只共享数据库、目录等资源</li><li>完全自治<ul><li>功能隔离：服务构件和物理数据模型是专用的，但是服务位于一个与其他服务共享的服务器上</li><li>绝对隔离：服务构件和相关的数据模型都位于专用服务器上</li><li>设计时隔离：从设计开始，就对服务设计、数据模型和宿主环境等，拥有完全的管理权</li></ul></li></ul></li><li>可能的风险<ul><li>错误地判断服务的范围</li><li>包装服务和遗留逻辑封装：无法改变的自动化系统无法回避自治问题</li><li>对服务需求的过高估计：过于追求高自治</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务自治与标准化服务合约<ul><li>服务合约自治直接与服务合约紧密相连</li><li>规范化的考虑会影响到合约如何形成，以及如何与其他服务协调</li><li>在服务合约上有越大的控制权，服务合约能被更好地定制和标准化，越能够确保底层实现可以在遵循既定自治级别的前提下，被独立设计</li></ul></li><li>服务自治与服务松散耦合<ul><li>由于同样期望将服务之间的依赖最小化，服务自治在很大程度上支持服务松散耦合原则<ul><li>积极耦合会直接导致设计时自治的增加；设计时自治的增加，又能更好地增强和优化服务的实现，从而持运行时的自治</li></ul></li></ul></li><li>服务自治与服务抽象<ul><li>将一个服务的自治级别作为整个服务合约的一部分来发布</li><li>服务自治的信息是服务质量信息抽象的一个例子</li></ul></li><li>服务自治与服务可复用性<ul><li>自治的增加提高了一个服务的复用潜力</li><li>通过增强服务的可靠性和提高服务行为的可预测性，其逻辑可以更加容易地适应多个服务消费者的需求</li><li>更好地支持服务运行环境的演化，从而应对复用所带来的并发要求</li></ul></li><li>服务自治与服务无状态性<ul><li>实现高级别的服务自治可以直接支持服务无状态性程度的增加</li></ul></li><li>服务自治与服务可组合性<ul><li>服务组合的整体自治性取决于它的所有组成成员自身的自治性</li><li>服务有越好的可靠性和可预侧性就越能组成更高效的大型服务组合</li></ul></li></ul><h4 id="服务无状态性"><a href="#服务无状态性" class="headerlink" title="服务无状态性"></a>服务无状态性</h4><ul><li>概念：服务要尽量减少对状态信息的保存，从而减少资源消耗，满足尽可能多的消费者程序的需要</li><li><strong>可能的风险</strong><ul><li>对于架构的依赖<ul><li>要建立服务设计和一个外部状态延迟选项的相互依赖关系</li><li>需要权衡这种依赖关系和延迟状态所带来的好处</li></ul></li><li>增加的运行时性能需求<ul><li>在从无状态到有状态进行切换时，可能会需要找回、解析然后再在服务中执行状态数据，引入额外的性能开销</li></ul></li><li>低估交付代价<ul><li>特定于活动的数据需要在运行过程中被接收、解析、处理和延迟，包含复杂的算法和例程。这不仅会带来额外的设计考虑，还伴随着确保该服务能够处理大量可能的情况和大量的活动数据所需要的编程和测试的代价</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务无状态性与服务可复用性<ul><li>减少活动相关逻辑使一个服务变得更加无关（而无关服务具有更好的可复用性）</li><li>提高服务的可扩展性和可用性使得它们可以在更多的服务组合中被更多的服务消费者复用</li></ul></li><li>服务无状态性与服务自治<ul><li>状态信息的本质通常是特定于一个给定的活动或者业务流程的，通过在服务边界外改变状态管理机制和流程的职责，就可以降低服务逻辑依赖于更大的业务任务的可能性。这使得服务能够更加自给自足，并且能够被定位成技术环境的一个独立部分，因而直接增加其整体自治性</li><li>另一方面，由环境架构所提供的状态管理延迟选项可要求服务形成在其边界外的一个直接依赖。这种类型的外部实现耦合会影响到一个服务的整体自治</li></ul></li></ul><h4 id="服务可发现性"><a href="#服务可发现性" class="headerlink" title="服务可发现性"></a>服务可发现性</h4><ul><li>概念：帮助调用方确定得要完成的自动化需求是否已经存在于服务库存中</li><li>可能的风险<ul><li>可发现性在实施后的应用<ul><li>在服务定义完毕后，再记录元数据，甚至由其他人员来加以记录，从而导致发现性和可解释性元数据的质量的损失</li><li>应当在设计阶段，早于服务最初发布时，就把那些元信息添加到文档中</li></ul></li><li>由不擅交流的人员来应用本原则<ul><li>如果可发现性信息仅仅是由业务或者技术专家创建的，那么它很可能不足以应付其他的项目组成员的使用</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可发现性与标准化服务合约<ul><li>使服务更加容易可发现和可解释会影响服务合约的内容</li><li>服务可发现性会直接地影响功能表达设计标准的确定</li></ul></li><li>服务可发现性与服务抽象<ul><li>服务抽象的原则需要减少合约当中所发布的信息数量；服务可发现性则要求提供更多的信息；两者之间需要取得平衡</li><li>一旦实现了可发现性和抽象之间的适当的平衡，那么随后实现的服务的可发现性将基于那些已发布的（而不是被抽象的）元信息</li></ul></li><li>服务可发现性与服务可复用性<ul><li>强调服务可发现性的主要目的是支持服务可复用性</li><li>当表述可复用功能时，应当应用可发现性相关的设计标准，以保证能通过实际的技术合约把服务的目的和能力尽可能清楚地表述出来</li></ul></li><li>服务可发现性与服务可组合性<ul><li>潜在的组合成员应当容易定位和识别，以避免在无意间创建冗余的服务逻辑</li><li>当服务组合为了适应上层业务流程的变化或者为了增加整体的业务需求实现而发生演变时，需要查找从组合的原始版本创建以来，新加入的服务和功能</li></ul></li></ul><h4 id="服务可组合性"><a href="#服务可组合性" class="headerlink" title="服务可组合性"></a>服务可组合性</h4><ul><li>概念：让服务可以被其他服务组合，或通过组合其他服务来实现设计需求</li><li>可能的风险<ul><li>组合成员成为单点失效的源头</li><li>组合成员成为性能瓶颈</li><li>对于组合中“过度复用”所带来的治理强度</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可组合性与标准化服务合约<ul><li>服务可组合性的应用强调服务间需要一致的合约标准</li><li>由服务可组合性原则引起的考虑可以用来帮助形成服务合约设计标准，以便支持特定于组合（尤其是复杂的组合）的需求。</li></ul></li><li>服务可组合性与服务松散耦合<ul><li>服务所具有的依赖关系会造成一些根本性的约束，直接制约服务能够达到的可组合性级别</li></ul></li><li>服务可组合性与服务抽象<ul><li>当抽象被应用到复杂组合被隐藏的程度时，对这些组合高效可靠地执行的要求被大大放大。作为回报，组合所有者可以更好地控制如何改进组合配置。</li></ul></li><li>服务可组合性与服务可复用性<ul><li>当一个成熟的服务库存建立起来的时候，服务组合就成为最常用的服务复用方式<ul><li>可复用但不可组合（参与多个点对点活动）</li><li>可组合但不可复用（很高的“服务-消费者”耦合）</li></ul></li></ul></li><li>服务可组合性与服务自治<ul><li>这两个原则之间是“整体-部分”的关系</li><li>控制器服务在组合其他服务时需要牺牲其自治性（等价于对所有涉及的服务组合成员的自治性的综合度量结果）</li><li>服务自治性的提高有助于产生高效的组合成员</li></ul></li><li>服务可组合性与服务无状态性<ul><li>尽可能地减轻每个组合成员在状态管理方面的责任，可以更精细、更优化地执行整体的组合实例</li><li>为了能够在同一个服务库存中重复地装配出高效的服务组合，服务之间需要能够通过一致并且有效的方式共享状态数据</li></ul></li><li>服务可组合性与服务可发现性<ul><li>作为组合控制器的服务能力可以负责描述它所封装的整个组合逻辑，并达到服务抽象原则所允许的任意程度</li></ul></li></ul><h2 id="9-Web开发部分"><a href="#9-Web开发部分" class="headerlink" title="9. Web开发部分"></a>9. Web开发部分</h2><ul><li><img src="image-20250106151751982.png" alt="image-20250106151751982" style="zoom:80%;" /></li><li><p><img src="image-20250106152417263.png" alt="image-20250106152417263"></p></li><li><p>JAXB如何做类型映射和操作XML？</p><ul><li>JAXB是 Java 提供的一个框架，用于将 Java 对象与 XML 数据相互转换（即序列化和反序列化）。它通过自动生成的映射类和注解来简化操作 XML 的过程。</li><li>Java到XML的映射<ul><li>使用 <strong>JAXB 注解</strong> 来控制映射细节</li><li><img src="image-20250106151941714.png" alt="image-20250106151941714" style="zoom:80%;" /></li></ul></li></ul></li><li><p>JAX-WS的三种开发模式</p><ul><li>Start from Java<ul><li>这是最简单的开发方式，先编写 Java 类，然后通过工具生成 Web Service 和 WSDL 文件。</li></ul></li><li>Start from WSDL</li><li>这种模式是先定义服务契约（WSDL 文件），然后生成 Java 代码。</li><li>Start from WSDL and Java<ul><li>从 WSDL 和 Java 混合开发</li><li>需要在服务契约和业务逻辑之间找到平衡，既要对 WSDL 进行自定义，又希望减少开发工作量。</li></ul></li></ul></li><li><p>CLient端和Server端的exception</p><ul><li><p>客户端（Client）端的两种异常</p><ol><li><strong><code>SOAPFaultException</code></strong><ul><li>这是客户端在调用服务端时收到的 SOAP 错误响应。</li><li>发生场景：当服务端返回的响应中包含了 SOAP 的 <code>Fault</code> 元素时，会在客户端抛出该异常。</li><li>特点：<ul><li>表示服务端处理请求时发生的逻辑或应用级错误。</li><li>客户端通过 <code>getFaultCode()</code> 和 <code>getFaultString()</code> 方法可以获取错误的详细信息。</li></ul></li></ul></li><li><strong><code>WebServiceException</code></strong><ul><li>是 JAX-WS 中的通用异常，表示客户端无法成功调用 Web 服务。</li><li>发生场景：<ul><li>通信错误（例如无法连接服务端、超时等）。</li><li>SOAP 消息格式错误。</li><li>客户端处理响应时遇到错误。</li></ul></li><li>特点：<ul><li>是一个运行时异常（RuntimeException）。</li><li>可以通过 <code>getMessage()</code> 方法查看异常的描述信息。</li></ul></li></ul></li></ol></li><li><p>服务端（Server）端的三种异常</p><ol><li><strong><code>SOAPFaultException</code></strong><ul><li>服务端主动创建并返回给客户端的异常，表示服务端在逻辑处理时遇到了问题。</li><li>发生场景：服务端检测到业务逻辑问题或其他错误，需要向客户端返回详细的 SOAP 错误信息。</li><li>特点：<ul><li>服务端在代码中可以主动抛出 <code>SOAPFaultException</code>。</li><li>在响应中以 SOAP 的 <code>Fault</code> 元素返回。</li></ul></li></ul></li><li><strong><code>ProtocolException</code></strong><ul><li>表示通信协议（如 HTTP 或 HTTPS）层出现问题。</li><li>发生场景：<ul><li>服务端接收到的请求在传输层有问题（例如 HTTP 头错误）。</li><li>服务端响应消息的协议部分不符合规范。</li></ul></li><li>特点：<ul><li>这种异常可能不会明确反馈给客户端，而是在服务端日志中捕获。</li></ul></li></ul></li><li><strong><code>WebServiceException</code></strong><ul><li>服务端的通用异常，表示服务端处理请求时遇到了不可恢复的错误。</li><li>发生场景：<ul><li>内部逻辑错误（例如数据库连接失败）。</li><li>服务端无法解析客户端的请求。</li><li>服务端配置错误。</li></ul></li><li>特点：<ul><li>也是一个运行时异常。</li><li>通常会被框架捕获，或者通过 SOAP <code>Fault</code> 元素反馈给客户端。</li></ul></li></ul></li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XML</tag>
      
      <tag>面向服务架构</tag>
      
      <tag>Web Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础</title>
    <link href="/2024/07/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据管理基础"><a href="#数据管理基础" class="headerlink" title="数据管理基础"></a>数据管理基础</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li><p>数据(Data)</p><ul><li>是数据库中存储的基本对象</li><li>定义：描述事物的符号记录</li><li>数据的含义称为数据的语义，数据与其语义是不可分的。</li></ul></li><li><p>数据库</p><ul><li>定义：是<strong>长期</strong>储存在计算机内、有<strong>组织</strong>的、可<strong>共享</strong>的<strong>大量</strong>数据的集合</li></ul></li><li><p>数据库管理系统（Database Management System ，简称 DBMS）</p><ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul></li></ul><span id="more"></span><ul><li><p>数据库系统（Database System ，简称 DBS）</p><ul><li><p>在计算机系统中引入数据库后的系统构成</p></li><li><p>构成</p><img src="image-20240309103511321.png" alt="image-20240309103511321" style="zoom:50%;" /></li></ul></li></ul><h3 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h3><ul><li><p>数据模型：对现实世界数据特征的抽象，用以抽象、表示和处理</p><ul><li>概念模型&#x2F;信息模型：按用户的观点来对数据和信息建模，用于数据库设计</li><li>逻辑模型：按计算机系统的观点对数据建模，用于 DBMS 实现</li><li>物理模型：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。</li><li>数据模型的组成：数据结构、数据操作、数据的完整性约束条件</li></ul></li><li><p>概念模型</p><ul><li>实体(Entity)：客观存在并可相互区别的事物</li><li>属性(Attribute)：实体所具有的某一特性</li><li>码(Key)：唯一标识实体的属性集</li><li>实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li><li>实体集(Entity Set)：同一类型实体的集合称为实体集</li><li>联系(Relationship)：界中反映为实体(型)内部的联系和实体(型)之间的联系。</li></ul></li><li><p>逻辑模型</p><ul><li><img src="image-20240309105048278.png" alt="image-20240309105048278" style="zoom:50%;" /></li><li>关系模型<img src="image-20240309105243092.png" alt="image-20240309105243092" style="zoom:50%;" /></li><li>关系的完整性约束条件<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul></li><li><p>数据库系统结构</p><ul><li>模式(Schema)：数据库逻辑结构和特征的描述，是型的描述，不涉及具体值，相对稳定</li><li>实例(Instance)：反映数据库某一时刻的状态，同一个模式可以有很多实例，随数据库中的数据的更新而变动</li></ul></li><li><p>三级模式结构</p><ul><li><img src="image-20240309105725766.png" alt="image-20240309105725766" style="zoom: 50%;" /></li><li>模式(也称逻辑模式)<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>与数据的物理存储细节和硬件环境无关</li><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li></ul></li><li>外模式(也称子模式或用户模式)<ul><li>数据库用户(包括应用程序员和最终用户)使用的<strong>局部</strong>数据的逻辑结构和特征的描述</li><li>模式与外模式的关系：一对多</li><li>外模式通常是模式的子集，反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li><li>内模式(也称存储模式)<ul><li>是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式</li><li>一个数据库只有一个内模式</li></ul></li><li>二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换：外模式／模式映像、模式／内模式映像</li></ul></li><li><p>数据库系统人员</p><ul><li>最终用户(交互式用户)<ul><li>临时用户(用SQL语句访问DBMS的用户)</li><li>缺乏经验的用户(通过菜单访问DBMS的用户)</li></ul></li><li>应用管理员(编写菜单程序的程序员)</li><li>数据库管理员(DBA):在数据库系统中，负责数据库的设计、建立、日常管理和运行维护的人员。</li></ul></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-关系模型"><a href="#1-关系模型" class="headerlink" title="1.关系模型"></a>1.关系模型</h3><table><thead><tr><th>关系数据库管理系统</th><th>关系模型</th><th>文件系统</th></tr></thead><tbody><tr><td>表</td><td>关系</td><td>记录文件</td></tr><tr><td>列</td><td>属性</td><td>域</td></tr><tr><td>行</td><td>元组</td><td>记录</td></tr><tr><td>表头</td><td>模式</td><td>记录类型</td></tr></tbody></table><ul><li><p>关系规则</p><ul><li>关系模型不允许有多值属性</li><li>只能基于内容存取行规则</li><li>行唯一性规则</li><li>实体完整性规则</li></ul></li><li><p>域：一组具有相同数据类型的值的集合</p></li><li><p>笛卡尔积：<img src="image-20240309150243038.png" alt="image-20240309150243038" style="zoom:50%;" /></p></li><li><p>元组(Tuple)：笛卡尔积中每一个元素叫作一个n元组或简称元组，每个值叫做一个分量</p><img src="image-20240309150407183.png" alt="image-20240309150407183" style="zoom: 67%;" /></li><li><p>基数：笛卡尔积的基数为每个子域基数的乘积</p></li><li><p>笛卡尔积的表示方法</p><ul><li><p>笛卡尔积可表示为一张二维表</p></li><li><p>表中的每行对应一个元组，表中的每列对应一个域</p></li></ul></li><li><p>关系：</p><ul><li><img src="image-20240309151216804.png" alt="image-20240309151216804" style="zoom:50%;" /></li></ul></li></ul><ul><li>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域<ul><li>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li><li>不同的列可出自同一个域，行列顺序无所谓</li></ul></li></ul><ul><li><p>码</p><ul><li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</li><li>主码：若一个关系有多个候选码，则选定其中一个为主码</li><li>主属性：候选码的诸属性称为主属性，不包含在任何侯选码中的属性称为非主属性或非码属性</li><li>任意两个元组的候选码不能相同</li></ul></li><li><p>关系模式是型，关系是值，关系模式是对关系的描述</p><ul><li><img src="image-20240309152157704.png" alt="image-20240309152157704" style="zoom:50%;" /></li><li>关系模式和关系往往笼统称为关系</li></ul></li></ul><h3 id="2-关系的完整性"><a href="#2-关系的完整性" class="headerlink" title="2.关系的完整性"></a>2.关系的完整性</h3><ul><li><p>实体完整性</p><ul><li>若属性A是基本关系R的主属性，则属性 A 不能取空值</li><li>空值就是<strong>不知道</strong>或<strong>不存在</strong>或<strong>无意义</strong>的值</li></ul></li><li><p>关系间的引用</p><ul><li><p>在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用</p></li><li><img src="image-20240309154348254.png" alt="image-20240309154348254" style="zoom:50%;" /></li><li><img src="image-20240309154400798.png" alt="image-20240309154400798" style="zoom:50%;" /></li><li><img src="image-20240309154421325.png" alt="image-20240309154421325" style="zoom:50%;" /></li><li><p>外码</p><ul><li><p>引用的其他关系的码，引用其他关系码的关系叫参照关系，被引用的码对应的关系叫被参照关系</p></li><li><p>外码并不一定要与相应的主码同名</p></li><li><p>目标关系S的主码Ks和参照关系的外码F必须定义在同一个（或一组）域上</p></li><li><img src="image-20240309154814760.png" alt="image-20240309154814760" style="zoom:50%;" /></li><li><img src="image-20240309154825229.png" alt="image-20240309154825229" style="zoom:50%;" /></li><li><img src="image-20240309154839012.png" alt="image-20240309154839012" style="zoom:50%;" /></li></ul></li></ul></li><li><p>参照完整性</p><ul><li><img src="image-20240309155511079.png" alt="image-20240309155511079" style="zoom:50%;" /></li><li><img src="image-20240309155609399.png" alt="image-20240309155609399" style="zoom:50%;" /></li></ul></li><li><p>用户定义的完整性</p><ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li><li><img src="image-20240309160436720.png" alt="image-20240309160436720" style="zoom: 50%;" /></li></ul></li></ul><h3 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3.关系代数"></a>3.关系代数</h3><ul><li>常用的关系操作<ul><li>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</li><li>数据更新：插入、删除、修改</li><li>选择、投影、并、差、笛卡尔积是 5 种基本操作</li></ul></li><li><img src="image-20240309160909071.png" alt="image-20240309160909071" style="zoom:50%;" /></li><li>交、并、差<ul><li>具有相同的目n，即两个关系都有n个属性</li><li>相应的属性取自同一个域</li><li><img src="image-20240309161025335.png" alt="image-20240309161025335" style="zoom:50%;" /></li><li><img src="image-20240309161629768.png" alt="image-20240309161629768" style="zoom:50%;" /></li><li><img src="image-20240309161721956.png" alt="image-20240309161721956" style="zoom:50%;" /></li></ul></li><li>笛卡尔积<ul><li><img src="image-20240309161837485.png" alt="image-20240309161837485" style="zoom:50%;" /></li><li>相当于把元组当作集合元素的笛卡尔积</li></ul></li><li>使用的符号<ul><li>t∈R： 元组t是关系R的一个元组</li><li>t[Ai]：表示元组t中相应于属性Ai的一个分量</li><li>若A&#x3D;{Ai1, Ai2, … Aik}}，则 A 称为属性列或属性组。</li><li>t[A]表示元组t在属性列A上诸分量的集合。</li><li>A上加一横表示{A1，A2，An}中去掉 {Ai1，Ai2，Aik}后剩余的属性组。</li><li><img src="image-20240309163005502.png" alt="image-20240309163005502" style="zoom:50%;" /></li></ul></li><li>象集Zx<ul><li>给定一个关系R(X, Z)，X和Z为属性组</li><li><img src="image-20240309163337725.png" alt="image-20240309163337725" style="zoom:50%;" /></li><li>它表示R中属性组X上值为x的诸元组在Z上分量的集合</li><li><img src="image-20240309163429087.png" alt="image-20240309163429087" style="zoom:50%;" /></li></ul></li><li>选择<ul><li><img src="image-20240309163557761.png" alt="image-20240309163557761" style="zoom:50%;" /></li><li>例：<strong>σ</strong>Sage&lt;20(student)，查找年龄小于20的学生</li></ul></li><li>投影<ul><li>从R中选择出若干属性列组成新的关系</li><li><img src="image-20240309164614781.png" alt="image-20240309164614781" style="zoom: 50%;" /></li><li>投影之后不仅取消了原关系中的某些列 而且还可能取消某些元组，避免重复行</li><li>从列的角度运算</li></ul></li><li>连接<ul><li>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</li><li><img src="image-20240309164810532.png" alt="image-20240309164810532" style="zoom:50%;" /></li><li>等值连接：θ 为 的连接运算称为等值连接</li><li>自然连接：一种特殊的等值连接<ul><li>两个关系中进行比较的分量必须是相同的属性组</li><li>在结果中把重复的属性列去掉</li></ul></li><li>从行的角度运算</li></ul></li><li>悬浮元组<ul><li>两个关系 R 和 S 在做自然连接时，关系 R 中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为<strong>悬浮元组</strong></li><li>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值 (Null)，就叫做外连接</li><li>左外连接：只保留左边关系R中的悬浮元组</li><li>右外连接：只保留右边关系S中的悬浮元组</li><li><img src="image-20240309165611271.png" alt="image-20240309165611271" style="zoom:50%;" /></li><li><img src="image-20240309165555485.png" alt="image-20240309165555485" style="zoom:50%;" /></li></ul></li><li>除<ul><li><img src="image-20240309193501435.png" alt="image-20240309193501435" style="zoom:50%;" /></li><li><img src="image-20240309193528303.png" alt="image-20240309193528303" style="zoom:50%;" /></li><li><img src="image-20240309194107688.png" alt="image-20240309194107688" style="zoom:50%;" /></li><li>可以简记为只留下公共属性相同或包含的（能除尽）</li></ul></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="1-SQL简述"><a href="#1-SQL简述" class="headerlink" title="1. SQL简述"></a>1. SQL简述</h3><ul><li>SQL特点<ul><li>综合统一：可以独立完成数据库生命周期中的全部活动</li><li>高度非过程化：存取路径的选择以及 SQL 的操作过程由系统自动完成。</li><li>面向集合的操作方式：非关系数据模型采用面向记录操作方式，操作对象是一条记录，采用集合操作方式</li><li>以同一种语法结构提供两种使用方法：既是独立的语言，能够独立地用于联机交互的使用方式，又是嵌入式语言，能够嵌入到高级语言中</li><li>语言简洁，易学易用</li></ul></li><li>SQL与关系数据库三级模式<ul><li><img src="image-20240312193355315.png" alt="image-20240312193355315" style="zoom: 50%;" /></li><li><img src="image-20240312193427315.png" alt="image-20240312193427315" style="zoom:50%;" /></li></ul></li><li>层次化的数据库对象命名机制<ul><li>一个关系数据库管理系统的实例（ Instance ）中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul></li></ul><h3 id="2-SQL数据定义"><a href="#2-SQL数据定义" class="headerlink" title="2. SQL数据定义"></a>2. SQL数据定义</h3><ul><li>SQL 的数据定义功能 :<ul><li>模式定义</li><li>表定义</li><li>视图和索引的定义</li><li><img src="image-20240312194043087.png" alt="image-20240312194043087" style="zoom: 50%;" /></li></ul></li><li>定义模式<ul><li>定义模式实际上定义了一个命名空间，在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</li><li>在 CREATE SCHEMA 中可以接受 CREATE TABLE，CREATE VIEW 和 GRANT 子句。</li><li><img src="image-20240312194212360.png" alt="image-20240312194212360" style="zoom:50%;" /></li><li><img src="image-20240312194629532.png" alt="image-20240312194629532" style="zoom:50%;" /></li></ul></li><li>删除模式<ul><li>DROP SCHEMA &lt; 模式名 &gt; &lt;CASCADE|RESTRICT&gt;</li><li>CASCADE：级联<ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul></li><li>RESTRICT 限制<ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</li><li>仅当该模式中没有任何下属的对象时才能执行。</li></ul></li><li>例： DROP SCHEMA ZHANG CASCADE</li></ul></li></ul><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h3><ul><li>定义基本表<ul><li><img src="image-20240312194913028.png" alt="image-20240312194913028" style="zoom:50%;" /></li><li>&lt;列级完整性约束条件 &gt;：涉及相应属性列的完整性约束条件，例如某列为主码</li><li>&lt;表级完整性约束条件 &gt;：涉及一个或多个属性列的完整性约束条件，例如有多列组合起来作为主码</li><li>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则列级和表级都可</li><li><img src="image-20240312195151400.png" alt="image-20240312195151400" style="zoom: 40%;" /></li></ul></li><li>数据类型<ul><li><img src="image-20240321193939685.png" alt="image-20240321193939685"></li></ul></li><li>修改数据类型<ul><li><img src="image-20240321194346149.png" alt="image-20240321194346149" style="zoom: 50%;" /></li><li>ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</li><li>DROP COLUMN 子句用于删除表中的列</li><li>DROP CONSTRAINT 子句用于删除指定的完整性约束条件</li><li>ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型</li><li><img src="image-20240321194522455.png" alt="image-20240321194522455" style="zoom:50%;" /></li></ul></li><li>删除基本表<ul><li>DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]</li><li>RESTRICT：欲删除的基本表不能被其他表的约束所引用</li><li>CASCADE ：删除该表没有限制，在删除基本表的同时，相关的依赖对象一起删除</li></ul></li><li>建立索引<ul><li>CREATE [UNIQUE] [INDEX] &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;&lt;次序&gt;, &lt;列名&gt;&lt;次序&gt;···)</li><li>索引：可以建立在该表的一 列或多列上，各列名之间用逗号分隔</li><li>次序 指定索引值的排列次序。升序：ASC；降序：DESC。缺省值：ASC。</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li><li><img src="image-20240321195529416.png" alt="image-20240321195529416" style="zoom:50%;" /></li></ul></li><li>修改&#x2F;删除索引<ul><li><img src="image-20240321195513699.png" alt="image-20240321195513699" style="zoom:50%;" /></li></ul></li></ul><h3 id="4-查询"><a href="#4-查询" class="headerlink" title="4.查询"></a>4.查询</h3><h4 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h4><ul><li>基本语法<ul><li><img src="image-20240321195644829.png" alt="image-20240321195644829" style="zoom:50%;" /></li></ul></li><li>查询经过计算的值<ul><li>SELECT * FROM [表名]：查询所有列</li><li>SELECT 子句的目标列表达式不仅可以为表中的属性列，也可以是表达式，如2014-Sage</li><li>LOWER()：表示转换成小写</li><li>SELECT和列名之间默认为ALL，可使用DISTINCT去掉重复行</li><li><img src="image-20240321200124811.png" alt="image-20240321200124811" style="zoom:50%;" /></li></ul></li><li>条件查询<ul><li><img src="image-20240321200604266.png" alt="image-20240321200604266" style="zoom:50%;" /></li><li>比较大小：WHERE Sdept &#x3D;‘ CS’；WHERE Sage &lt; 20；</li><li>确定范围：[NOT] BETWEEN … AND</li><li>确定集合：IN &lt;值表&gt;, NOT IN &lt;值表&gt;，例如 WHERE Sdept IN ((‘CS’,’MA’,’IS’）</li><li>字符匹配<ul><li>谓词：[NOT] LIKE ‘&lt;匹配串&gt;’ [ ESCAPE ‘换码字符‘ ]</li><li>匹配串 可以是一个完整的字符串，也可以含有通配符%(（)任意长度且长度可以为0的字符串)和 _ (任意单个字符)</li><li><img src="image-20240321201139317.png" alt="image-20240321201139317" style="zoom:50%;" /></li><li><img src="image-20240321201156766.png" alt="image-20240321201156766" style="zoom:50%;" /></li></ul></li><li>涉及空值的查询：IS NULL 或 IS NOT NULL，IS不能用 ’&#x3D;‘代替</li><li>多重条件查询：用AND和OR，且AND优先级更高，可用括号改变优先级</li></ul></li><li>对查询结果排序<ul><li>ORDER BY 子句<ul><li>可以按一个或多个属性列排序</li><li>升序：ASC；降序：DESC；缺省值为升序</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul></li><li><img src="image-20240321201836656.png" alt="image-20240321201836656" style="zoom:50%;" /></li></ul></li><li>聚集函数<ul><li>统计元组个数：COUNT(*)</li><li>统计一列中值的个数：COUNT( [DISTINCT | ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）：SUM( [DISTINCT | ALL] &lt;列名&gt;)</li><li>计算一列值的平均值（此列必须为数值型）：AVG( [DISTINCT | ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值：MAX( [DISTINCT | ALL] &lt;列名&gt;)      MIN( [DISTINCT | ALL] &lt;列名&gt;)</li><li><img src="image-20240321202208049.png" alt="image-20240321202208049" style="zoom:50%;" /></li></ul></li><li>对查询结果分组<ul><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li><li><img src="image-20240321202346616.png" alt="image-20240321202346616" style="zoom:50%;" /></li></ul></li></ul><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><ul><li><p>连接</p><ul><li><p>连接查询：同时涉及两个以上的表的查询</p></li><li><p>连接条件或连接谓词：用来连接两个表的条件</p></li><li><img src="image-20240325164121305.png" alt="image-20240325164121305" style="zoom:50%;" /></li><li><p>连接字段：连接谓词中的列名称，连接条件中的各连接字段类型必须是可比的，但名字不<br>必相同</p></li><li><img src="image-20240325164426187.png" alt="image-20240325164426187" style="zoom:50%;" /></li><li><p>连接操作执行过程</p><ul><li>嵌套循环法：首先在表1中找到第一个元组，然后从头开始扫描表 2 ，逐一查找满足连接件的元<br>组，找到后拼接起来形成结果表中一个元组。</li><li>排序合并法（常用于&#x3D;连接）：先按连接属性进行排序，当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</li><li>索引连接：对表2按连接字段建立索引，对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组后将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</li></ul></li><li><p>同时进行选择和连接</p><ul><li><img src="image-20240325165907620.png" alt="image-20240325165907620" style="zoom:50%;" /></li><li>过程：先选择，再连接</li></ul></li><li><p>自身连接</p><ul><li><p>一个表与其自己进行连接</p></li><li><p>需要给表起别名以示区别</p></li><li><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p></li><li><img src="image-20240325170019101.png" alt="image-20240325170019101" style="zoom:50%;" /></li></ul></li><li><p>外连接</p><ul><li><img src="image-20240325170445001.png" alt="image-20240325170445001" style="zoom:50%;" /></li></ul></li><li><p>多表连接：用AND组合连接条件</p></li></ul></li></ul><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ul><li><p>定义</p><ul><li>一个 SELECT FROM WHERE 语句称为一个查询块</li><li>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</li><li>上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询</li><li>允许多层嵌套查询</li></ul></li><li><p>相关子查询</p><ul><li>不相关子查询：子查询的查询条件不依赖于父查询</li><li>相关子查询：子查询的查询条件依赖于父查询<ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若 WHERE 子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组，重复这一过程，直至外层表全部检查完为止</li></ul></li></ul></li><li><p>嵌套查询的转化</p><ul><li><p>带有IN谓词的：可用连接查询转化</p><img src="image-20240325191322025.png" alt="image-20240325191322025" style="zoom:50%;" /></li><li><p>带有比较运算符的</p><img src="image-20240325191505302.png" alt="image-20240325191505302" style="zoom:50%;" /></li><li><p>带有ANY、SOME或 ALL谓词的子查询</p><ul><li><img src="image-20240325191545636.png" alt="image-20240325191545636" style="zoom:50%;" /></li><li><img src="image-20240325191728446.png" alt="image-20240325191728446" style="zoom:50%;" /></li><li><img src="image-20240325191750839.png" alt="image-20240325191750839" style="zoom:50%;" /></li></ul></li><li><p>带有EXISTS谓词的查询</p><ul><li>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false</li><li>由 EXISTS 引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS 的子查询只返回真值或假值，给出列名无实际意义</li><li>一些带 EXISTS 或 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换</li><li>所有带 IN 谓词、比较运算符、 ANY 和 ALL 谓词的子查询都能用带 EXISTS 谓词的子查询等价替换</li><li><img src="image-20240325193002970.png" alt="image-20240325193002970" style="zoom:50%;" /></li><li><img src="image-20240325193511253.png" alt="image-20240325193511253" style="zoom:50%;" /></li><li><img src="image-20240325193041283.png" alt="image-20240325193041283" style="zoom:50%;" /></li></ul></li></ul></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>并<ul><li>UNION：将多个查询结果合并起来时，系统自动去掉重复元组</li><li>UNION ALL ：将多个查询结果合并起来时，保留重复元组</li></ul></li><li>交<ul><li>INTERSECT：对多个查询结果求交集</li></ul></li><li>差<ul><li>EXCEPT：对多个查询结果求差集</li></ul></li></ul><h4 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h4><ul><li>子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM子句中，这时子查询生成的临时派生表（ Derived Table ）成为主查询的查询对象</li><li><img src="image-20240325195306327.png" alt="image-20240325195306327" style="zoom:50%;" /></li><li>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询 SELECT 子句后面的列名为其缺省属性。</li></ul><h3 id="5-插入"><a href="#5-插入" class="headerlink" title="5.插入"></a>5.插入</h3><ul><li>语法<ul><li><img src="image-20240325195347713.png" alt="image-20240325195347713" style="zoom: 67%;" /></li><li>INTO子句中属性列的顺序可与表定义中的顺序不一致；若没有指定属性列，则表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致；若指定部分属性列，则插入的元组在其余属性列上取空值</li><li>VALUE子句提供的值必须与 INTO 子句匹配</li></ul></li><li>插入子查询结果<ul><li><img src="image-20240325195754200.png" alt="image-20240325195754200" style="zoom:50%;" /></li><li>SELECT 子句目标列必须与 INTO 子句匹配</li><li><img src="image-20240325195812803.png" alt="image-20240325195812803" style="zoom:50%;" /></li></ul></li></ul><h3 id="6-修改"><a href="#6-修改" class="headerlink" title="6.修改"></a>6.修改</h3><ul><li>语法<ul><li><img src="image-20240326160952560.png" alt="image-20240326160952560" style="zoom:50%;" /></li><li>修改指定表中满足 WHERE 子句条件的元组</li><li>SET 子句给出 表达式 的值用于取代相应的属性列</li><li>如果省略 WHERE 子句，表示要修改表中的所有元组</li><li>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则</li><li><img src="image-20240326161546782.png" alt="image-20240326161546782" style="zoom:50%;" /></li></ul></li></ul><h3 id="7-删除"><a href="#7-删除" class="headerlink" title="7.删除"></a>7.删除</h3><ul><li><p>语法</p><ul><li><img src="image-20240326161447700.png" alt="image-20240326161447700" style="zoom:50%;" /></li><li>删除指定表中满足 WHERE 子句条件的元组</li><li>WHERE子句指定要删除的元组，缺省表示要删除表中的全部元组，表的定义仍在字典中</li><li><img src="image-20240326161559709.png" alt="image-20240326161559709" style="zoom:50%;" /></li></ul></li></ul><h3 id="8-空值"><a href="#8-空值" class="headerlink" title="8.空值"></a>8.空值</h3><ul><li>空值的情形<ul><li><img src="image-20240326161655973.png" alt="image-20240326161655973" style="zoom:50%;" /></li><li>有 NOT NULL 约束条件的不能取空值</li><li>加了 UNIQUE 限制的属性不能取空值</li><li>码属性不能取空值</li></ul></li><li>空值的运算<ul><li>判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示</li><li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li><li>空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN</li><li><img src="image-20240326162106406.png" alt="image-20240326162106406" style="zoom:50%;" /></li></ul></li></ul><h3 id="9-视图"><a href="#9-视图" class="headerlink" title="9.视图"></a>9.视图</h3><ul><li><p>特点</p><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li><strong>基表</strong>中的数据发生变化，从<strong>视图</strong>中查询出的数据也随之改变</li></ul></li><li><p>定义视图</p><ul><li><img src="image-20240326162300009.png" alt="image-20240326162300009" style="zoom:50%;" /></li><li><p>组成视图的属性列名：全部省略或全部指定</p><ul><li><p>全部省略：由子查询中 SELECT 目标列中的诸字段组成</p></li><li><p>需要指定的情况：</p><img src="image-20240326162401519.png" alt="image-20240326162401519" style="zoom:50%;" /></li></ul></li><li><p>关系数据库管理系统执行 CREATE VIEW 语句时只是把视图<strong>定义</strong>存入数据字典，并不执行其中的 SELECT 语句。（即不将视图作为表存储，与创建基本表对比）</p></li><li><img src="image-20240326162523957.png" alt="image-20240326162523957" style="zoom:50%;" /></li><li><p>视图可以作为子查询对象再次创建视图</p></li></ul></li><li><p>删除视图</p><ul><li>DROP VIEW &lt;视图名 &gt; [CASCADE]</li><li>该语句从数据字典中删除指定的视图定义</li><li>如果该视图上还导出了其他视图，使用CASCADE 级联删除语句，把该视图和由它导出的视图一起删除</li><li>删除<strong>基表</strong>时，由该基表导出的所有视图定义都必须<strong>显式</strong>地使用 DROP VIEW 语句删除</li></ul></li><li><p>查询视图</p><ul><li>用户角度：查询视图与查询基本表相同</li><li>关系数据库管理系统实现视图查询的方法：<strong>视图消解法</strong></li><li><img src="image-20240326163020522.png" alt="image-20240326163020522" style="zoom:50%;" /></li><li>有些情况下，视图消解法不能生成正确的查询</li></ul></li><li><p>更新视图</p><ul><li><img src="image-20240326191436608.png" alt="image-20240326191436608" style="zoom:50%;" /></li><li>允许对行列子集视图进行更新</li><li>对其他类型视图的更新不同系统有不同限制</li><li>一个不允许更新的视图上定义的视图也不允许更新</li></ul></li><li><p>视图的作用</p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul></li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="1-数据库安全性"><a href="#1-数据库安全性" class="headerlink" title="1.数据库安全性"></a>1.数据库安全性</h3><ul><li>数据库安全性<ul><li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li><li>系统安全保护措施是否有效是数据库系统主要的性能指标之一</li><li><img src="image-20240326194009321.png" alt="image-20240326194009321" style="zoom:50%;" /></li><li><img src="image-20240326194023731.png" alt="image-20240326194023731" style="zoom:50%;" /></li></ul></li><li>计算机系统的安全模型<ul><li>计算机系统中，安全措施是一级一级层层设置</li><li>系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统</li><li>数据库管理系统还要进行存取控制，只允许用户执行合法操作</li><li>操作系统有自己的保护措施</li><li>数据以密码形式存储到数据库中</li><li><img src="image-20240326194126976.png" alt="image-20240326194126976" style="zoom: 67%;" /></li></ul></li></ul><h3 id="2-存取控制"><a href="#2-存取控制" class="headerlink" title="2.存取控制"></a>2.存取控制</h3><ul><li><p>概念</p><ul><li>定义用户权限， 并将用户权限登记到数据字典中</li><li>合法权限检查</li><li>用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</li></ul></li><li><p>自主存取控制</p><ul><li>C2 级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li><li>通过 SQL 的 GRANT 语句和 REVOKE 语句实现</li><li>用户权限组成：数据库对象、操作类型</li><li><img src="image-20240326194456443.png" alt="image-20240326194456443" style="zoom:50%;" /></li></ul></li><li><p>GRANT语句</p><ul><li><img src="image-20240326194525154.png" alt="image-20240326194525154" style="zoom:67%;" /></li><li>语义：将对指定操作对象的指定操作权限授予指定的用户</li><li>发出 GRANT：数据库管理员、数据库对象创建者、拥有该权限的用户</li><li>按受权限的用户：一个或多个具体用户、PUBLIC（全体用户）</li><li>WITH GRANT OPTION 子句：指定则可以再授予，没有指定则不能传播</li><li><img src="image-20240326194721666.png" alt="image-20240326194721666" style="zoom:50%;" /></li></ul></li><li><p>REVOKE语句</p><ul><li><img src="image-20240326194802843.png" alt="image-20240326194802843" style="zoom:50%;" /></li><li><img src="image-20240326194815389.png" alt="image-20240326194815389" style="zoom:50%;" /></li></ul></li><li><p>创建用户</p><ul><li><img src="image-20240326195740507.png" alt="image-20240326195740507" style="zoom:67%;" /></li><li>CREATE USER 不是 SQL标准，各个系统的实现相差甚远</li><li>新创建的数据库用户有三种权限：CONNECT 、 RESOURCE 和 DBA</li><li><img src="image-20240326195810621.png" alt="image-20240326195810621" style="zoom:50%;" /></li></ul></li><li><p>数据库角色</p><ul><li>被命名的一组与数据库操作相关的权限</li><li>角色是权限的集合，可以为一组具有相同权限的用户创建一个角色</li><li>语法：CREATE ROLE &lt;角色名&gt;</li><li>给角色授权：GRANT &lt;权限&gt; [&lt;权限&gt;]…<br>ON &lt;对象类型&gt; 对象名<br>TO &lt;角色&gt; [&lt;角色&gt;]…</li><li><img src="image-20240407161503630.png" alt="image-20240407161503630" style="zoom:67%;" /></li><li><img src="image-20240407161517661.png" alt="image-20240407161517661" style="zoom:50%;" /></li><li>只有角色的创建者和拥有ADMIN OPTION的角色可以revoke</li><li><img src="image-20240407161621046.png" alt="image-20240407161621046" style="zoom: 67%;" /></li></ul></li><li><p>强制存取控制 MAC</p><ul><li>每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li><li>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</li><li>主体：系统中的活动实体，如数据库管理系统所管理的实际用户、代表用户的各进程</li><li>客体：系统中的被动实体，受主体操纵，如文件、基本表、索引、视图</li><li>对于主体和客体， DBMS 为它们每个实例（值）指派一个敏感度标记（ Label）</li><li><img src="image-20240407162315453.png" alt="image-20240407162315453" style="zoom:50%;" /></li><li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时，该主体才能<strong>读取</strong>相应的客体；仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</li></ul></li></ul><h3 id="3-审计"><a href="#3-审计" class="headerlink" title="3.审计"></a>3.审计</h3><ul><li>概念<ul><li>启用一个专用的审计日志将用户对数据库的<strong>所有操作</strong>记录在上面</li><li>审计员利用审计日志 监控数据库中的各种行为 ，找出非法存取数据的人、时间和内容</li></ul></li><li>审计事件<ul><li>服务器事件：审计数据库服务器发生的事件<ul><li>系统权限：对系统拥有的结构或模式对象进行操作的审计</li><li>要求该操作的权限是通过系统权限获得的</li></ul></li><li>语句事件<ul><li>对 SQL 语句，如 DDL 、 DML 、 DQL 及 DCL 语句的审计</li></ul></li><li>模式对象事件<ul><li>对特定模式对象上进行的 SELECT 或 DML 操作的审计</li></ul></li></ul></li><li>审计功能<ul><li>提供多种审计查阅方式，审计分析和报表功能</li><li>多套审计规则：一般在初始化设定</li><li>审计日志管理功能：<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录 不允许任何用户新增和修改审计记录等</li></ul></li><li>提供查询审计设置及审计记录信息的专门视图</li></ul></li><li>审计级别<ul><li>用户级审计：任何用户可设置的审计，主要是用户针对自己创建的数据库表和视图进行审计</li><li>系统级审计：只能由数据库管理员设置，监测成功或失败的登录要求、监测授权和收回操作，以及其他数据库级权限下的操作</li></ul></li><li>语法<ul><li><img src="image-20240407164222082.png" alt="image-20240407164222082" style="zoom: 50%;" /></li></ul></li></ul><h3 id="4-数据加密"><a href="#4-数据加密" class="headerlink" title="4.数据加密"></a>4.数据加密</h3><ul><li><p>概念</p><ul><li>防止数据库中数据在存储和传输中失密的有效手段</li><li>根据一定的算法将原始数据(明文)变换为不可直接识别的格式( 密文)</li><li>加密方法：存储加密、传输加密</li></ul></li><li><p>存储加密分类</p><ul><li><p>透明存储加密</p><ul><li>内核级加密保护方式，对用户完全透明</li><li>将数据在写到磁盘时对数据进行加密 授权用户读取数据时再对其进行解密</li><li>内核级加密方法：性能较好，安全完备性较高</li></ul></li><li><p>非透明存储加密：通过多个加密函数实现</p></li></ul></li><li><p>传输加密</p><ul><li>链路加密：传输信息由报头和报文两部分组成，报文和报头均加密</li><li>端到端加密：在发送端加密，接收端解密，只加密报文不加密报头</li></ul></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="1-数据库完整性"><a href="#1-数据库完整性" class="headerlink" title="1.数据库完整性"></a>1.数据库完整性</h3><ul><li>概念<ul><li>数据的正确性：数据符合现实世界语义，反映了当前实际状况</li><li>数据的相容性：数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul></li><li>完整性机制<ul><li>提供定义完整性约束条件的机制<ul><li>完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件</li><li>SQL标准使用了一系列概念描述完整性，包括关系模型的实体完整性、参照完整性、用户定义完整性</li><li>这些完整性一般由 SQL 的数据定义语言语句来实现</li></ul></li><li>提供完整性检查的方法<ul><li>数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。</li><li>一般在 INSERT 、 UPDATE 、 DELETE 语句执行后开始检查，也可以在事务提交时检查</li></ul></li><li>违约处理<ul><li>数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作</li><li>拒绝执行该操作</li><li>级连执行其他操作</li></ul></li></ul></li><li>实体完整性<ul><li>定义<ul><li>关系模型的实体完整性：用码表示，单属性构成的码可以用列级或表级约束条件说明，多属性必须用表级</li><li><img src="image-20240407165743929.png" alt="image-20240407165743929" style="zoom:50%;" /></li></ul></li><li>检查与处理<ul><li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括检查主码值是否唯一和检查主码的各个属性是否为空，不满足则拒绝插入和修改</li><li>检查时为了避免全局扫描，一般会建立索引</li></ul></li></ul></li><li>参照完整性<ul><li>定义<ul><li>在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码</li><li>用 REFERENCES 短语指明这些外码参照哪些表的主码</li><li><img src="image-20240407170035297.png" alt="image-20240407170035297" style="zoom:60%;" /></li></ul></li><li>参照完整性检查<ul><li>一个参照完整性将两个表中的相应元组联系起来，对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</li><li><img src="image-20240407170136140.png" alt="image-20240407170136140" style="zoom: 50%;" /></li></ul></li><li>违约处理<ul><li>拒绝执行</li><li>级联操作</li><li>设置为空值</li><li><img src="image-20240407170245921.png" alt="image-20240407170245921" style="zoom:57%;" /></li></ul></li></ul></li><li>用户定义的完整性<ul><li>定义<ul><li>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求，包括属性上的和元组上的关系</li><li>数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</li><li><img src="image-20240407170427707.png" alt="image-20240407170427707" style="zoom: 50%;" /></li><li><img src="image-20240407170447271.png" alt="image-20240407170447271" style="zoom:50%;" /></li></ul></li><li>完整性约束创建子句<ul><li>CONSTRAINT &lt; 完整性约束条件名&gt; &lt;完整性约束条件&gt;</li><li>完整性约束条件 包括 NOT NULL 、 UNIQUE 、PRIMARY KEY 短语、 FOREIGN KEY 短语、 CHECK 短语等</li><li>修改完整性约束:使用 ALTER TABLE 语句修改表中的完整性限制，如：ALTER TABLE Student  DROP CONSTRAINT C4;</li><li><img src="image-20240407170639819.png" alt="image-20240407170639819" style="zoom:60%;" /></li></ul></li></ul></li></ul><h3 id="2-断言"><a href="#2-断言" class="headerlink" title="2.断言"></a>2.断言</h3><ul><li>定义<ul><li>用于指定更具有一般性的约束</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言<strong>不为真值</strong>的操作都会被<strong>拒绝执行</strong></li></ul></li><li>语法<ul><li>创建断言：CREATE ASSERTION&lt; 断言名 &gt;&lt;CHECK&gt; 子句</li><li>删除断言：DROP ASSERTION &lt;断言名&gt;</li><li><img src="image-20240407171225042.png" alt="image-20240407171225042" style="zoom:40%;" /></li></ul></li></ul><h3 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3.触发器"></a>3.触发器</h3><ul><li>定义<ul><li>触发器是用户定义在关系表上的一类由事件驱动的特殊过程</li><li>触发器保存在数据库服务器中，任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</li><li>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</li></ul></li><li>语法<ul><li>定义触发器：<img src="image-20240407171731071.png" alt="image-20240407171731071" style="zoom:50%;" /></li><li>删除触发器：DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</li><li>当特定的系统事件发生时，对规则条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作</li></ul></li><li>触发器类型<ul><li>语句级触发器：只针对一整条SQL语句</li><li>行级触发器：执行SQL语句过程中每查询一行元组都会检查触发器</li><li><img src="image-20240407172322105.png" alt="image-20240407172322105" style="zoom:50%;" /></li></ul></li><li>激活触发器<ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序：<ul><li>执行该表上的 BEFORE 触发器</li><li>激活触发器的 SQL 语句</li><li>执行该表上的 AFTER 触发器</li></ul></li></ul></li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="1-关系模式及范式"><a href="#1-关系模式及范式" class="headerlink" title="1.关系模式及范式"></a>1.关系模式及范式</h3><ul><li>关系模式由五部分组成，是一个五元组：(R, U, D, DOM, F)<ul><li>关系名 R 是符号化的元组语义</li><li>U 为一组属性</li><li>D 为属性组 U 中的属性所来自的域</li><li>DOM 为属性到域的映射</li><li>F 为属性组 U 上的一组数据依赖</li><li>由于D、DOM与模式设计关系不大，因此可以把关系模式看作一个三元组： R&lt;U, F&gt;</li></ul></li><li>数据依赖<ul><li>内涵：是一个关系内部属性与属性之间的一种约束关系，现实世界属性间相互联系的抽象，数据内在的性质，语义的体现</li><li>分类：函数依赖、多值依赖</li><li>函数依赖<ul><li>普遍存在于现实生活中</li><li>一个属性可由一个函数被另一个属性唯一确定</li><li><img src="image-20240416195138006.png" alt="image-20240416195138006" style="zoom:50%;" /></li></ul></li><li>多值依赖见第五小节</li></ul></li><li>范式<ul><li>范式是符合某一种级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式</li><li><img src="image-20240416195545966.png" alt="image-20240416195545966" style="zoom:50%;" /></li><li>高等级的范式包含于低等级的，例如2NF ∈ 1NF</li><li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></li></ul></li></ul><h3 id="2-函数依赖与码"><a href="#2-函数依赖与码" class="headerlink" title="2.函数依赖与码"></a>2.函数依赖与码</h3><ul><li><p>函数依赖</p><ul><li><p>定义</p><img src="image-20240416195934292.png" alt="image-20240416195934292" style="zoom: 67%;" /></li><li><img src="image-20240416195955459.png" alt="image-20240416195955459" style="zoom: 60%;" /></li><li><p>函数依赖不是指关系模式 R 的某个或某些关系实例满足的约束条件，而是指 R 的<strong>所有</strong>关系实例均要满足的约束条件。</p></li><li><p>数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。</p></li></ul></li><li><p>平凡函数依赖与非平凡函数依赖</p><ul><li>如果 X→Y ，但 Y不∈X ，则称 X→Y 是非平凡的函数依赖</li><li>如果 X→Y ，且Y∈X ，则称 X→Y 是平凡的函数依赖</li></ul></li><li><p>完全函数依赖与部分函数依赖</p><ul><li><img src="image-20240416202632255.png" alt="image-20240416202632255" style="zoom: 50%;" /></li></ul></li><li><p>传递函数依赖</p><ul><li><img src="image-20240416202747822.png" alt="image-20240416202747822" style="zoom:55%;" /></li><li><img src="image-20240416202832055.png" alt="image-20240416202832055" style="zoom: 50%;" /></li></ul></li><li><p>码</p><ul><li><img src="image-20240416203026034.png" alt="image-20240416203026034" style="zoom:50%;" /></li><li>若关系模式 R 有多个候选码，则选定其中的一个作为主码</li><li>主属性与非主属性<ul><li>包含在任何一个候选码中的属性 ，称为主属性</li><li>不包含在任何码中的属性称为非主属性或非码属性</li><li>全码：整个属性组是码，称为全码</li></ul></li><li>外码：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码或外码</li></ul></li></ul><h3 id="3-1NF，2NF，3NF"><a href="#3-1NF，2NF，3NF" class="headerlink" title="3. 1NF，2NF，3NF"></a>3. 1NF，2NF，3NF</h3><ul><li>1NF<ul><li>如果一个关系模式 R 的所有属性都是不可分的基本数据项，则 R∈1NF 。</li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</li><li>1NF的缺点<ul><li>数据冗余：每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。</li><li>更新异常：某系更换系主任后，必须修改与该系学生有关的每一个元组。</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。</li><li>删除异常：如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</li><li>解决方案：将其分解为多个关系</li></ul></li><li><img src="image-20240416203642322.png" alt="image-20240416203642322" style="zoom:50%;" /></li></ul></li><li>2NF<ul><li>若关系模式 R∈1NF ，并且每一个非主属性都完全函数依赖于任何一个候选码，则 R∈2NF</li><li>如果不是2NF，会引发插入异常、删除异常、修改复杂</li><li>解决方法：将关于候选码完全函数依赖的非主属性和部分函数依赖的非主属性分成两类，分别与它对应的候选码成为一张新表</li></ul></li><li>3NF<ul><li><img src="image-20240416204023800.png" alt="image-20240416204023800" style="zoom:50%;" /></li><li>非3NF修改方法：将每个传递依赖的每一环节拆分成新的表</li></ul></li></ul><h3 id="4-BNF"><a href="#4-BNF" class="headerlink" title="4. BNF"></a>4. BNF</h3><ul><li>BCNF<ul><li>定义<ul><li><img src="image-20240420101602827.png" alt="image-20240420101602827" style="zoom: 50%;" /></li></ul></li><li>性质<ul><li>所有非主属性都完全函数依赖于每个候选码</li><li>所有主属性都完全函数依赖于每个不包含它的候选码</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li><li><img src="image-20240420101811662.png" alt="image-20240420101811662" style="zoom: 50%;" /></li></ul></li></ul><h3 id="5-多值依赖与4NF"><a href="#5-多值依赖与4NF" class="headerlink" title="5. 多值依赖与4NF"></a>5. 多值依赖与4NF</h3><ul><li>多值依赖<ul><li>定义<ul><li><img src="image-20240420102125572.png" alt="image-20240420102125572" style="zoom:50%;" /></li><li><img src="image-20240420102140744.png" alt="image-20240420102140744" style="zoom:50%;" /></li></ul></li><li>平凡与非平凡多值依赖<ul><li><img src="image-20240420102221888.png" alt="image-20240420102221888" style="zoom:50%;" /></li></ul></li><li><img src="image-20240420102244697.png" alt="image-20240420102244697" style="zoom:50%;" /></li></ul></li><li>多值依赖的对称性<ul><li>按照语义对于 W 的每一个值 Wi，S 有一个完整的集合与之对应而不问C 取何值。所以 W-&gt;-&gt;S</li><li>而相对的，对于 W 的每一个值 Wi，C也有一个完整的集合与之对应，它与S对称</li><li><img src="image-20240420102507629.png" alt="image-20240420102507629" style="zoom:60%;" /></li><li>多值依赖具有对称性，即若X-&gt;-&gt;Y ，则 X-&gt;-&gt;Z ，其中 Z&#x3D;U-X-Y</li><li>函数依赖是多值依赖的特殊情况。即若 X-&gt;Y ，则X-&gt;-&gt;Y</li><li>多值依赖在当前属性集的子集上一定成立，但超集不一定</li><li><img src="image-20240420103110238.png" alt="image-20240420103110238" style="zoom:50%;" /></li></ul></li><li>4NF<ul><li>定义<ul><li><img src="image-20240420103131532.png" alt="image-20240420103131532" style="zoom:50%;" /></li></ul></li><li>4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。 4NF 所允许的非平凡多值依赖实际上是函数依赖。</li></ul></li></ul><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1.数据库设计概述"></a>1.数据库设计概述</h3><ul><li>概念<ul><li>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li><li><img src="image-20240408102211841.png" alt="image-20240408102211841" style="zoom:50%;" /></li></ul></li><li>数据库设计方法<ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良（ New Orleans ）方法</li><li>基于 E-R 模型的数据库设计方法</li><li>3NF （第三范式）的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（ UML ）方法</li></ul></li></ul></li><li>数据库设计阶段<ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li><li><img src="image-20240408102648166.png" alt="image-20240408102648166" style="zoom:50%;" /></li><li>需求分析和概念设计独立于任何数据库管理系统</li><li>逻辑设计和物理设计与选用的数据库管理系统密切相关</li></ul></li><li>参与数据库设计的人员<ul><li>系统分析人员和数据库设计人员</li><li>数据库管理员和用户代表</li><li>应用开发人员</li></ul></li></ul><h3 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h3><ul><li>需求分析任务<ul><li>详细调查现实世界要处理的对象</li><li>充分了解原系统（手工系统或计算机系统）工作概况</li><li>明确用户的各种需求</li><li>在此基础上确定新系统的功能</li><li>新系统必须充分考虑今后可能的扩充和改变</li><li>调查的重点是数据和处理 ，获得用户对数据库的要求<ul><li>信息要求</li><li>处理要求</li><li>安全性与完整性要求</li></ul></li><li>第一阶段收集的基础数据（用数据字典来表达）是下一步进行概念设计的基础。</li></ul></li><li>需求分析方法<ul><li>调查清楚用户的实际需求并进行初步分析</li><li>与用户达成共识</li><li>分析与表达这些需求</li></ul></li><li><img src="image-20240408104024219.png" alt="image-20240408104024219" style="zoom: 67%;" /></li><li>数据字典<ul><li>概念<ul><li>数据字典是关于数据库中数据的描述，即元数据，不是数据本身</li><li>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善</li><li>数据字典是进行详细的数据收集和数据分析所获得的主要结果</li><li>注意和关系数据库管理系统中数据字典的区别和联系</li></ul></li><li>内容<ul><li>数据项、数据结构、数据流、数据存储、处理过程</li><li>数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构</li><li>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</li></ul></li><li>数据项<ul><li><img src="image-20240408104538786.png" alt="image-20240408104538786" style="zoom:50%;" /></li></ul></li><li>数据结构<ul><li>数据结构反映了数据之间的组合关系</li><li>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</li><li><img src="image-20240408104615628.png" alt="image-20240408104615628" style="zoom:50%;" /></li></ul></li><li>数据流<ul><li><img src="image-20240408104632175.png" alt="image-20240408104632175" style="zoom:50%;" /></li></ul></li><li>数据存储<ul><li><img src="image-20240408104649695.png" alt="image-20240408104649695" style="zoom:50%;" /></li></ul></li><li>处理过程<ul><li><img src="image-20240408104707751.png" alt="image-20240408104707751" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="3-概念模型和E-R模型"><a href="#3-概念模型和E-R模型" class="headerlink" title="3.概念模型和E-R模型"></a>3.概念模型和E-R模型</h3><ul><li><p>概念模型</p><ul><li>定义：将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计</li><li>描述概念模型的工具：E-R模型</li></ul></li><li><p>实体型之间的联系</p><ul><li>两个实体型间联系<ul><li>一对一联系(1 : 1)</li><li>一对多联系(1 : n)</li><li>多对多联系(m : n)</li><li><img src="image-20240408105949171.png" alt="image-20240408105949171" style="zoom:50%;" /></li></ul></li><li>两个以上的实体型之间的联系<ul><li>一般地，两个以上的实体型之间也存在着一对一、一对多、多对多联系</li><li>同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系</li><li><img src="image-20240408110105704.png" alt="image-20240408110105704" style="zoom: 25%;" /></li><li><img src="image-20240408110118388.png" alt="image-20240408110118388" style="zoom:33%;" /></li></ul></li></ul></li><li><p>E-R模型</p><ul><li>概念<ul><li>联系的度：参与联系的实体型的数目</li><li>2 个实体型之间的联系度为 2 ，也称为二元联系</li><li>3 个实体型之间的联系度为 3 ，称为三元联系</li><li>N 个实体型之间的联系度为 N ，也称为 N 元联系</li></ul></li><li>图例<ul><li>实体型：用矩形表示，矩形框内写明实体名</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（联系可以具有属性）</li><li><img src="image-20240408110344356.png" alt="image-20240408110344356" style="zoom: 25%;" /></li></ul></li></ul></li><li><p>ISA联系</p><ul><li><p>有的实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系</p><img src="image-20240412195628567.png" alt="image-20240412195628567" style="zoom: 60%;" /></li><li><p>分类属性：分类属性是父实体型的一个属性，它的值把父实体型中的实体分派到子实体型中</p><img src="image-20240412195732030.png" alt="image-20240412195732030" style="zoom:67%;" /></li><li><p>不相交约束：描述父类中的一个实体不能同时属于多个子类中的实体集。即一个父类中的实体最多属于一个子类实体集。</p><p><img src="image-20240412195759245.png" alt="image-20240412195759245"></p></li><li><p>描述父类中的一个实体是否必须是某一个子类中的实体。如果是，则叫做完全特化，用父类到子类的双线连接来表示；否则叫做部分特化，用父类到子类的单线连接来表示。</p><p><img src="image-20240412195910036.png" alt="image-20240412195910036"></p></li><li><p>基数约束</p><ul><li>min&#x3D;1 的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系</li><li>min&#x3D;0 的约束叫做非强制参与约束，被施加基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系</li></ul><p><img src="image-20240412195952226.png" alt="image-20240412195952226"></p></li><li><p>弱实体型和独占联系</p><ul><li>如果一个实体型的存在依赖于其它实体型的存在，则这个实体型叫做弱实体型否则叫做强实体型。</li><li>用弱实体类型和识别联系来表示独占联系双矩形表示弱实体型，用双菱型表示识别联系。</li><li><img src="image-20240412200428721.png" alt="image-20240412200428721" style="zoom: 67%;" /></li></ul></li><li><p>Part-of 联系</p><ul><li>描述某个实体型是另外一个实体型的一部分</li><li>非独占的Part-of联系，简称非独占联系：整体实体如果被破坏，另一部分实体仍然可以独立存在</li><li>独占的Part-of联系，简称独占联系：整体实体如果被破坏，另一部分实体不可以独立存在</li><li>用非强制参与联系表示非独占的 Part of 联系</li><li>用弱实体类型和识别联系来表示独占联系编号编号</li></ul></li></ul></li></ul><h3 id="4-概念结构设计"><a href="#4-概念结构设计" class="headerlink" title="4.概念结构设计"></a>4.概念结构设计</h3><ul><li><p>方法</p><ul><li>自顶向下：首先定义全局概念结构的框架，然后逐步细化</li><li>自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构</li><li>逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构</li><li>混合策略：将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构<ul><li>自顶向下地进行需求分析</li><li>自底向上地设计概念结构</li><li><img src="image-20240412200949513.png" alt="image-20240412200949513" style="zoom:50%;" /></li></ul></li></ul></li><li><p>概念结构设计的步骤</p><ul><li><img src="image-20240412201846050.png" alt="image-20240412201846050" style="zoom: 60%;" /></li></ul></li><li><p>实体与属性的划分</p><ul><li>为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待</li><li>两条准则：<ol><li>作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。</li><li>属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。</li></ol></li><li><img src="image-20240412202047285.png" alt="image-20240412202047285" style="zoom:50%;" /></li></ul></li><li><p>E-R图的集成</p><ul><li><p>步骤</p><ul><li>合并。解决各分E-R 图之间的冲突，将分E-R图合并起来生成初步E-R图。</li><li>修改和重构。消除不必要的冗余，生成基本E-R图。</li></ul></li><li><p>子系统E-R图之间的冲突主要有三类：属性冲突、命名冲突、结构冲突</p></li><li><p>属性冲突</p><ul><li>属性域冲突，即属性值的类型、取值范围或取值集合不同</li><li>属性取值单位冲突</li></ul></li><li><p>命名冲突</p><ul><li>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字</li><li>异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字</li></ul></li><li><p>结构冲突</p><img src="image-20240412202452411.png" alt="image-20240412202452411" style="zoom: 67%;" /></li><li><p>第二步：消除不必要的冗余，设计基本E-R图</p><ul><li>所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。</li><li>消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。</li><li><img src="image-20240412202612581.png" alt="image-20240412202612581" style="zoom:50%;" /><img src="image-20240412202936024.png" alt="image-20240412202936024"></li><li><img src="image-20240412202936024.png" alt="image-20240412202936024" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="5-逻辑结构设计"><a href="#5-逻辑结构设计" class="headerlink" title="5.逻辑结构设计"></a>5.逻辑结构设计</h3><ul><li>概念<ul><li>任务：把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构</li><li>内容：<ul><li>E-R图由实体型、实体的属性和实体型之间的联系三个要素组成</li><li>关系模型的逻辑结构是一组关系模式的集合</li><li>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</li></ul></li></ul></li><li>实体型<ul><li>一个实体型转换为一个关系模式</li><li>关系的属性：实体的属性</li><li>关系的码：实体的码</li></ul></li><li>1:1联系<ul><li>一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</li><li>转换为一个独立的关系模式：<ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的候选码：每个实体的码均是该关系的候选码</li></ul></li><li>与某一端实体对应的关系模式合并<ul><li>合并后关系的属性：加入对应关系的码和联系本身的属性</li><li>合并后关系的码：不变</li></ul></li></ul></li><li>1:n联系<ul><li>一个 1:n 联系可以转换为一个独立的关系模式，也可以与<strong>n端</strong>对应的关系模式合并。</li><li>转换为一个独立的关系模式<ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：n端实体的码</li></ul></li><li>与n端对应的关系模式合并<ul><li>合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性</li><li>合并后关系的码：不变</li><li>可以减少系统中的关系个数</li></ul></li></ul></li><li>m:n联系<ul><li>一个 m:n 联系转换为一个关系模式</li><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合</li><li><img src="image-20240416193525525.png" alt="image-20240416193525525" style="zoom: 40%;" /></li></ul></li><li>多元联系<ul><li>三个或三个以上实体间的一个多元联系转换为一个关系模式。</li><li>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合</li></ul></li><li>关系模式的合并<ul><li>具有相同码的关系模式可合并</li><li>目的：减少系统中的关系个数</li><li>合并方法：<ul><li>将其中一个关系模式的全部属性加入到另一个关系模式中</li><li>然后去掉其中的同义属性（可能同名也可能不同名）</li><li>适当调整属性的次序</li></ul></li></ul></li><li>E-R图的转换<ul><li><img src="image-20240416193843520.png" alt="image-20240416193843520" style="zoom: 60%;" /></li></ul></li><li>数据模型的优化<ul><li>得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。</li><li>关系数据模型的优化通常以<strong>规范化理论</strong>为指导</li><li><img src="image-20240416194242050.png" alt="image-20240416194242050" style="zoom: 50%;" /></li><li>并不是规范化程度越高的关系就越优：当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算，而连接运算代价高，因此在这种情况下，第二范式甚至第一范式也许是适合的。对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定</li></ul></li><li>关系模式的分解<ul><li>水平分解<ul><li>把基本关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</li><li>对符合80&#x2F;20原则 的，把经常被使用的数据（约20%）水平分解出来，形成一个子关系。</li></ul></li><li>垂直分解<ul><li>把关系模式 R 的属性分解为若干子集合，形成若干子关系模式。</li><li>垂直分解的原则：经常在一起使用的属性从 R 中分解出来形成一个子关系模式</li><li>垂直分解的适用范围：取决于分解后 R 上的所有事务的总效率是否得到了提高</li></ul></li></ul></li><li>设计用户子模式<ul><li>定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：<ul><li>使用更符合用户习惯的别名</li><li>针对不同级别的用户定义不同的视图，以保证系统的安全性</li><li>简化用户对系统的使用</li></ul></li></ul></li></ul><h3 id="6-物理结构设计"><a href="#6-物理结构设计" class="headerlink" title="6.物理结构设计"></a>6.物理结构设计</h3><ul><li>设计步骤<ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li><li>若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ul></li><li>设计内容<ul><li>为关系模式选择存取方法</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul></li><li>数据库管理系统常用存取方法<ul><li>B+ 树索引存取方法</li><li>Hash 索引存取方法</li><li>聚簇存取方法</li></ul></li><li>B+树索引存取方法<ul><li>选择索引存取方法的一般规则<ul><li>如果一个（组）属性经常在查询条件中出现，则考虑在这个（组）属性上建立索引（或组合索引）</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个（组）属性经常在连接操作的连接条件中出现，则考虑在这个（组）属性上建立索引</li></ul></li><li>关系上定义的索引数过多会带来较多的额外开销（维护、查找）</li></ul></li><li>Hash 存取方法<ul><li>如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一<ul><li>该关系的大小可预知，而且不变</li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态 Hash存取方法</li></ul></li></ul></li><li>聚簇<ul><li>定义：为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。</li><li>聚簇的用途：大大提高按聚簇属性进行查询的效率</li><li>聚簇存储方法的选择<ul><li>选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系</li><li>一个数据库可以建立<strong>多个</strong>聚簇，一个关系只能加入<strong>一个</strong>聚簇。</li><li><img src="image-20240420105643741.png" alt="image-20240420105643741"></li></ul></li><li>聚簇的局限性<ul><li>聚簇只能提高某些特定应用的性能</li><li>建立与维护聚簇的开销相当大</li><li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时可以使用聚簇</li></ul></li></ul></li><li>确定数据库的存储结构<ul><li>确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等</li><li>确定数据的存放位置基本原则：根据应用情况将易变部分与稳定部分分开存放，经常存取部分与存取频率较低部分分开存放</li><li>确定系统配置<ul><li><img src="image-20240420105904442.png" alt="image-20240420105904442" style="zoom:50%;" /></li></ul></li></ul></li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="1-数据库的实施和维护"><a href="#1-数据库的实施和维护" class="headerlink" title="1. 数据库的实施和维护"></a>1. 数据库的实施和维护</h3><ul><li>数据的载入和应用程序的调试<ul><li>数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。</li><li>数据装载方法：人工方法、计算机辅助数据入库</li><li>在组织数据入库的同时还要调试应用程序</li></ul></li><li>数据库的试运行<ul><li>应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。</li><li>主要工作：功能测试、性能测试</li><li>数据库的试运行的注意事项：<ul><li>数据的分期入库</li><li>数据库的转储和恢复</li></ul></li></ul></li><li>数据库的运行和维护<ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改进</li><li>数据库的重组织与重构造</li></ul></li><li>数据库的转储和恢复<ul><li>数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。</li><li>一旦发生故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。并尽可能减少对数据库的破坏。</li></ul></li><li>数据库的安全性、完整性控制<ul><li>初始定义：数据库管理员根据用户的实际需要授予不同的操作权限，根据应用环境定义不同的完整性约束条件</li><li>修改定义：当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制；由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求</li></ul></li><li>数据库性能的监督、分析和改进<ul><li>在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进性能的方法。</li><li>利用监测工具获取系统运行过程中一系列性能参数的值</li><li>通过仔细分析这些数据，判断当前系统是否处于最佳运行状态</li><li>如果不是，则需要调整参数或对数据库进行重组织或重构造</li></ul></li><li>数据库的重组织<ul><li>原因：数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。</li><li>重组织的形式：全部重组织、部分重组织（只对频繁增删的表）</li><li>重组织的工作：重新安排存储位置、回收垃圾、减少指针链</li></ul></li><li>数据库的重构造<ul><li>原因：数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求</li><li>重构造的主要工作：根据新环境调整数据库的模式和内模式<ul><li>增加或删除某些数据项</li><li>改变数据项的类型</li><li>增加或删除某个表</li><li>改变数据库的容量</li><li>增加或删除某些索引</li></ul></li><li>重构造数据库的程度是有限的，若变化太大或重构代价太高，则需要重新设计新数据库</li></ul></li></ul><h3 id="2-面向驱动的数据库编程"><a href="#2-面向驱动的数据库编程" class="headerlink" title="2. 面向驱动的数据库编程"></a>2. 面向驱动的数据库编程</h3><ul><li>考试不考，见PPT</li></ul><h3 id="3-过程化SQL"><a href="#3-过程化SQL" class="headerlink" title="3. 过程化SQL"></a>3. 过程化SQL</h3><ul><li>概念<ul><li>SQL的扩展</li><li>增加了过程化语句功能</li><li>基本结构是块</li></ul></li><li>过程化SQL的块结构<ul><li>定义<ul><li><img src="image-20240426124403855.png" alt="image-20240426124403855" style="zoom:67%;" /></li></ul></li><li>执行部分<ul><li><img src="image-20240426124436809.png" alt="image-20240426124436809" style="zoom:67%;" /></li></ul></li></ul></li><li>变量和常量的定义<ul><li><img src="image-20240426124638813.png" alt="image-20240426124638813" style="zoom: 60%;" /></li></ul></li><li>流程控制<ul><li>条件控制<ul><li><img src="image-20240426124742104.png" alt="image-20240426124742104" style="zoom:50%;" /></li></ul></li><li>循环控制<ul><li><img src="image-20240426124804628.png" alt="image-20240426124804628" style="zoom: 50%;" /></li></ul></li><li>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</li></ul></li></ul><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><ul><li>过程化SQL块类型<ul><li>命名块：编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li><li>匿名块：每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li><li>存储过程<ul><li>定义：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只需要调用</li><li>优点：运行效率高，降低了客户机与服务器的通信量，方便实施企业规则</li></ul></li><li>存储过程的用户接口<ul><li>创建存储过程<ul><li><img src="image-20240426125312310.png" alt="image-20240426125312310" style="zoom:50%;" /></li></ul></li><li>执行存储过程<ul><li><img src="image-20240426125409322.png" alt="image-20240426125409322" style="zoom:50%;" /></li></ul></li><li>修改和删除<ul><li><img src="image-20240426125428974.png" alt="image-20240426125428974" style="zoom:50%;" /></li></ul></li></ul></li><li>函数<ul><li><img src="image-20240426125452183.png" alt="image-20240426125452183" style="zoom:50%;" /></li></ul></li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h3><ul><li>概念<ul><li>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事务是恢复和并发控制的基本单位</li></ul></li><li>定义事务<ul><li><img src="image-20240430140603082.png" alt="image-20240430140603082"></li><li>隐式方式：当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务</li><li><img src="image-20240430140732623.png" alt="image-20240430140732623"></li></ul></li><li>事务的ACID特性<ul><li>原子性<ul><li>事务是数据库的逻辑工作单位</li><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li><li>一致性<ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>一致性状态：数据库中只包含成功事务提交的结果</li></ul></li><li>隔离性<ul><li>一个事务的执行不能被其他事务干扰</li><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul></li><li>持续性（永久性）<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响</li></ul></li><li>保证事务ACID特性是事务处理的任务</li><li>破坏事务ACID特性的因素<ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul></li></ul></li></ul><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="1-故障和数据库恢复"><a href="#1-故障和数据库恢复" class="headerlink" title="1. 故障和数据库恢复"></a>1. 故障和数据库恢复</h3><ul><li>故障<ul><li>分类<ul><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li><li>各类故障，对数据库的影响有两种可能性：<ul><li>一是数据库本身被破坏</li><li>二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。</li></ul></li></ul></li><li>事务故障<ul><li>分类<ul><li>运算溢出</li><li>并发事务发生死锁而被选中撤销该事务</li><li>违反了某些完整性限制而被终止等</li></ul></li><li><strong>事务故障仅指这类非预期的故障</strong></li><li>事务故障意味着：<ul><li>事务没有达到预期的终点 (COMMIT 或者显式的ROLLBACK)</li><li>数据库可能处于不正确状态。</li></ul></li><li>事务故障的恢复：事务撤消<ul><li>强行回滚（ ROLLBACK ）该事务</li><li>撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样</li></ul></li></ul></li><li>系统故障<ul><li>系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如 CPU 故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。</li><li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<ul><li>恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（ UNDO ）所有未完成事务</li></ul></li><li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失<ul><li>恢复策略：系统重新启动时，恢复程序需要重做所有已提交的事务</li></ul></li></ul></li><li>介质故障<ul><li>介质故障，称为硬故障，指外存故障</li><li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务</li></ul></li><li>计算机病毒<ul><li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li><li>数据库一旦被破坏仍要用恢复技术把数据库加以恢复</li></ul></li><li>恢复<ul><li><img src="image-20240430144104099.png" alt="image-20240430144104099"></li></ul></li></ul><h3 id="2-数据转储和日志文件"><a href="#2-数据转储和日志文件" class="headerlink" title="2. 数据转储和日志文件"></a>2. 数据转储和日志文件</h3><ul><li>数据转储<ul><li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本（后援副本）</li><li>数据库遭到破坏后可以将后备副本重新装入</li><li>重装后备副本只能将数据库恢复到转储时的状态</li><li>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</li></ul></li><li>转储方法<ul><li>静态转储<ul><li>在系统中无运行事务时进行的转储操作</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>优点：实现简单</li><li>缺点：降低了数据库的可用性</li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存取或修改</li><li>利用动态转储得到的副本进行故障恢复：需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件，后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态</li></ul></li><li>海量转储：每次转储全部数据库</li><li>增量转储 : 只转储上次转储后更新过的数据</li></ul></li><li>日志文件<ul><li>日志文件是用来记录事务对数据库的更新操作的文件</li><li>日志文件的格式：<ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul></li><li>以记录为单位的日志文件内容<ul><li>各个事务的开始标记 (BEGIN）</li><li>各个事务的结束标记 (COMMIT 或 ROLLBACK)</li><li>各个事务的所有更新操作</li></ul></li><li>以记录为单位的日志文件，每条日志记录的内容<ul><li>事务标识（标明是哪个事务）</li><li>操作类型（插入、删除或修改）</li><li>操作对象（记录内部标识）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言 , 此项为空值）</li></ul></li><li>以数据块为单位的日志文件，每条日志记录的内容<ul><li>事务标识</li><li>被更新的数据块</li></ul></li><li>日志文件的作用<ul><li><img src="image-20240430152027383.png" alt="image-20240430152027383"></li></ul></li><li>登记日志文件原则<ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul></li></ul></li></ul><h3 id="3-恢复策略"><a href="#3-恢复策略" class="headerlink" title="3. 恢复策略"></a>3. 恢复策略</h3><ul><li><p>事务故障的恢复</p><ul><li>恢复方法：由恢复子系统利用日志文件撤消此事务已对数据库进行的修改</li><li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li><li>步骤<ul><li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中更新前的值写入数据库。</li><li>重复前两步，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ul></li></ul></li><li><p>系统故障的恢复</p><ul><li>恢复方法<ul><li>Undo 故障发生时未完成的事务（反向扫描日志）</li><li>Redo 已完成的事务（正向扫描日志）</li></ul></li><li>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li></ul></li><li><p>介质故障的恢复</p><ul><li><p>介质故障的恢复的工作</p><ul><li>重装数据库</li><li>重做已完成的事务</li></ul></li><li><p>介质故障的恢复需要数据库管理员介入，但具体的恢复操作仍由数据库管理系统完成</p></li><li><p>数据库管理员的工作</p><ul><li>重装最近转储的数据库副本和有关的各日志文件副本</li><li>执行系统提供的恢复命令</li></ul></li></ul></li></ul><h3 id="4-具有检查点的恢复步骤"><a href="#4-具有检查点的恢复步骤" class="headerlink" title="4. 具有检查点的恢复步骤"></a>4. 具有检查点的恢复步骤</h3><ul><li>概念<ul><li>恢复的两个问题：<ul><li>搜索整个日志将耗费大量的时间</li><li>重做处理：重新执行，浪费了大量时间</li></ul></li><li>具有检查点的恢复技术<ul><li>在日志文件中增加<strong>检查点记录</strong>(checkpoint)</li><li>增加<strong>重新开始文件</strong></li><li>恢复子系统在登录日志文件期间动态地维护日志</li></ul></li><li>检查点记录的内容<ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul></li><li>重新开始文件的内容：记录各个检查点记录在日志文件中的地址</li></ul></li><li>动态维护日志文件的方法<ul><li>周期性地执行如下操作：建立检查点，保存数据库状态。</li><li><img src="image-20240430153706620.png" alt="image-20240430153706620"></li></ul></li><li>建立检查点<ul><li>恢复子系统可以定期或不定期地建立检查点，保存数据库状态</li><li>定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点</li><li>不定期：按照某种规则，如日志文件已写满一半建立一个检查点</li></ul></li><li>利用检查点的恢复策略<ul><li>使用检查点方法可以改善恢复效率<ul><li>当事务T在一个检查点之前提交， T对数据库所做的修改已写入数据库</li><li>写入时间是在这个检查点建立之前或在这个检查点建立之时</li><li>在进行恢复处理时，没有必要对事务T执行重做操作</li></ul></li><li><img src="image-20240430153944163.png" alt="image-20240430153944163"></li><li>恢复步骤<ul><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li><li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单(ACTIVE LIST)<ul><li><img src="image-20240430154130957.png" alt="image-20240430154130957" style="zoom: 67%;" /></li></ul></li><li>从检查点开始<strong>正向</strong>扫描日志文件，直到日志文件结束<ul><li><img src="image-20240430154145401.png" alt="image-20240430154145401" style="zoom:67%;" /></li></ul></li><li>对UNDO LIST中的每个事务执行UNDO操作；对REDO LIST中的每个事务执行REDO操作</li></ul></li></ul></li></ul><h3 id="5-数据库镜像"><a href="#5-数据库镜像" class="headerlink" title="5. 数据库镜像"></a>5. 数据库镜像</h3><ul><li>概念<ul><li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li><li>数据库管理系统自动保证镜像数据与主数据的一致性</li><li>每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li><li>在实际应用中用户往往只选择对关键数据和日志文件镜像</li></ul></li><li>用途<ul><li>出现介质故障时<ul><li>可由镜像磁盘继续提供使用</li><li>同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复</li><li>不需要关闭系统和重装数据库副本</li></ul></li><li>没有出现故障时<ul><li>可用于并发操作</li><li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁</li></ul></li></ul></li></ul><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="1-并发控制"><a href="#1-并发控制" class="headerlink" title="1. 并发控制"></a>1. 并发控制</h3><ul><li>事务并发<ul><li>多用户数据库系统，允许多个用户同时使用的数据库系统</li><li>特点：在同一时刻并发运行的事务数可达数百上千个</li><li>事务并发执行带来的问题<ul><li>会产生多个事务同时存取同一数据的情况</li><li>可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性</li></ul></li><li>数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一</li></ul></li><li>多事务执行方式<ul><li>串行执行<ul><li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li><li>不能充分利用系统资源，发挥数据库共享资源的特点</li></ul></li><li>交叉并发<ul><li>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</li><li>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率</li></ul></li><li>同时并发<ul><li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li><li>最理想的并发方式，但受制于硬件环境</li><li>更复杂的并发方式机制</li></ul></li></ul></li><li>并发控制<ul><li>事务是并发控制的基本单位</li><li>并发控制机制的任务<ul><li>对并发操作进行正确调度</li><li>保证事务的隔离性</li><li>保证数据库的一致性</li></ul></li><li>并发操作带来的数据不一致性<ul><li>丢失修改</li><li>不可重复读</li><li>读脏数据</li></ul></li></ul></li><li>丢失修改<ul><li>两个事务 T1 和 T2 读入同一数据并修改， T2的提交结果破坏了 T1提交的结果，导致 T1的修改被丢失</li><li><img src="image-20240507163437064.png" alt="image-20240507163437064" style="zoom:50%;" /></li></ul></li><li>不可重复读<ul><li>不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使T1 无法再现前一次读取结果</li><li><img src="image-20240507163512940.png" alt="image-20240507163512940" style="zoom: 50%;" /></li><li><img src="image-20240507163528614.png" alt="image-20240507163528614" style="zoom:50%;" /></li></ul></li><li>读脏数据<ul><li>概念<ul><li>事务 T1 修改某一数据，并将其写回磁盘</li><li>事务 T2 读取同一数据后， T1 由于某种原因被撤销</li><li>这时 T1 已修改过的数据恢复原值， T2 读到的数据就与数据库中的数据不一致</li><li>T2 读到的数据就为 脏 数据，即不正确的数据</li></ul></li><li><img src="image-20240507165156396.png" alt="image-20240507165156396" style="zoom:50%;" /></li></ul></li><li>并发控制方式<ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul></li></ul><h3 id="2-封锁"><a href="#2-封锁" class="headerlink" title="2. 封锁"></a>2. 封锁</h3><ul><li>概念<ul><li>封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象</li><li>基本封锁类型<ul><li>排它锁&#x2F;写锁（简记为X锁或W锁）</li><li>共享锁&#x2F;读锁（简记为S锁或R锁）</li></ul></li></ul></li><li>排他锁与共享锁<ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</li><li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到 T 释放A上的S锁</li></ul></li><li>封锁协议<ul><li>在运用 X 锁和 S 锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议<ul><li>何时申请 X 锁或 S 锁</li><li>持锁时间</li><li>何时释放</li></ul></li><li>一级封锁协议<ul><li>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放</li><li>一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。</li><li>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读脏数据。</li></ul></li><li>二级封锁协议<ul><li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁</li><li>二级封锁协议可以防止丢失修改和读脏数据</li><li>在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它不能保证可重复读</li></ul></li><li>三级封锁协议<ul><li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li><li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。</li><li><img src="image-20240507170014737.png" alt="image-20240507170014737" style="zoom:50%;" /></li></ul></li></ul></li><li>活锁与死锁<ul><li>活锁<ul><li><img src="image-20240507170258593.png" alt="image-20240507170258593" style="zoom:50%;" /></li><li>避免活锁：采用先来先服务的策略</li></ul></li><li>死锁<ul><li><img src="image-20240507170338505.png" alt="image-20240507170338505" style="zoom:50%;" /></li><li>简单来说就是等待形成闭环</li></ul></li><li>死锁的预防<ul><li>一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li>顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li></ul></li><li>死锁的诊断<ul><li>超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li><li>等待图法， 并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</li><li><img src="image-20240507170526998.png" alt="image-20240507170526998" style="zoom:50%;" /></li></ul></li><li>死锁的解除<ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul></li></ul></li></ul><h3 id="3-事务调度"><a href="#3-事务调度" class="headerlink" title="3. 事务调度"></a>3. 事务调度</h3><ul><li><p>并发调度的可串行性</p><ul><li>概念：执行结果等价于串行调度的调度是正确的，称为可串行化调度</li><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul></li><li><p>冲突可串行化</p><ul><li>冲突操作：是指不同的事务对同一数据的读写操作和写写操作</li><li>其他操作是不冲突操作</li><li>不能交换的动作<ul><li>同一事务的两个操作</li><li>不同事务的冲突操作</li></ul></li><li><img src="image-20240512101532738.png" alt="image-20240512101532738" style="zoom:50%;" /></li><li>冲突可串行化调度是可串行化调度的<strong>充分条件</strong>，<strong>不是必要条件</strong>。还有不满足冲突可串行化条件的可串行化调度。</li></ul></li><li><p>两段锁协议</p><ul><li>概念：所有事务必须分两个阶段对数据项加锁和解锁</li><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li><li>两段锁协议中事务分为两个阶段：第一阶段是获得封锁，也称为扩展阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁；第二阶段是释放封锁，也称为收缩阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li><li>事务遵守两段锁协议是可串行化调度的<strong>充分条件</strong>，而<strong>不是必要条件</strong>。</li><li><img src="image-20240512102104179.png" alt="image-20240512102104179" style="zoom:50%;" /></li></ul></li></ul><h3 id="4-封锁粒度"><a href="#4-封锁粒度" class="headerlink" title="4. 封锁粒度"></a>4. 封锁粒度</h3><ul><li><p>封锁粒度</p><ul><li>封锁对象的大小称为封锁粒度</li><li>封锁的对象：逻辑单元，物理单元<ul><li>逻辑单元 : 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li><li>物理单元：页（数据页或索引页）、物理记录等</li></ul></li><li>封锁粒度与系统的并发度和并发控制的开销密切相关<ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li><li>封锁的粒度越小，并发度较高，但系统开销也就越大</li></ul></li><li>多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择<ul><li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li><li>需要处理大量元组的用户事务：以关系为封锁单元</li><li>只处理少量元组的用户事务：以元组为封锁单位</li></ul></li></ul></li><li><p>多粒度树</p><ul><li>以树形结构来表示多级封锁粒度</li><li>根结点是整个数据库，表示最大的数据粒度</li><li>叶结点表示最小的数据粒度</li><li><img src="image-20240512103213720.png" alt="image-20240512103213720" style="zoom:50%;" /></li></ul></li><li><p>多粒度封锁协议</p><ul><li>允许多粒度树中的每个结点被独立地加锁</li><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li><li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul><li>显式封锁 : 直接加到数据对象上的封锁</li><li>隐式封锁 是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li></ul></li><li>系统检查封锁冲突时，既要检查显式封锁，还要检查隐式封锁</li><li>对某个数据对象加锁，系统要检查：<ul><li>该数据对象有无显式封锁与之冲突</li><li>所有上级结点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突</li><li>所有下级结点：看上面的显式封锁是否与本事务的隐式封锁</li></ul></li></ul></li><li><p>意向锁</p><ul><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li><li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li><li>例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</li></ul></li><li><p>常用意向锁</p><ul><li><img src="image-20240512103701784.png" alt="image-20240512103701784" style="zoom:50%;" /></li><li><img src="image-20240512103715836.png" alt="image-20240512103715836" style="zoom:50%;" /></li><li><img src="image-20240512103812734.png" alt="image-20240512103812734" style="zoom:50%;" /></li><li><img src="image-20240512104014765.png" alt="image-20240512104014765" style="zoom:50%;" /></li></ul></li><li><p>具有意向锁的多粒度封锁方法</p><ul><li>申请封锁时应该按自上而下的次序进行</li><li>释放封锁时则应该按自下而上的次序进行</li><li><img src="image-20240512104306067.png" alt="image-20240512104306067" style="zoom: 50%;" /></li></ul></li></ul><h3 id="5-查询处理"><a href="#5-查询处理" class="headerlink" title="5. 查询处理"></a>5. 查询处理</h3><ul><li><img src="image-20240512104658699.png" alt="image-20240512104658699" style="zoom:50%;" /></li><li>查询分析<ul><li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析</li><li>词法分析：从查询语句中识别出正确的语言符号</li><li>语法分析：进行语法检查</li></ul></li><li>查询检查<ul><li>根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效</li><li>如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作</li><li>根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查</li><li>检查通过后把 SQL 查询语句转换成内部表示，即等价的关系代数表达式。</li></ul></li><li>查询优化<ul><li>查询优化：选择一个高效执行的查询处理策略</li><li>查询优化分类<ul><li>代数优化&#x2F;逻辑优化：指关系代数表达式的优化</li><li>物理优化：指存取路径和底层操作算法的选择</li></ul></li><li>查询优化的选择依据<ul><li>基于规则</li><li>基于代价</li><li>基于语义</li></ul></li></ul></li><li>查询执行<ul><li>依据优化器得到的执行策略生成查询执行计划</li><li>两种执行方法<ul><li>自顶向下</li><li>自底向上</li></ul></li></ul></li><li>各种操作的实现<ul><li>选择操作<ul><li>全表扫描方法（适合小表）：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出</li><li>索引扫描方法(适合于选择条件中的属性上有索引，例如B+树索引或Hash索引)：通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li></ul></li><li>连接操作<ul><li><img src="image-20240512105946194.png" alt="image-20240512105946194" style="zoom:50%;" /></li><li><img src="image-20240512110042019.png" alt="image-20240512110042019" style="zoom:50%;" /></li><li><img src="image-20240512110054804.png" alt="image-20240512110054804" style="zoom:50%;" /></li><li><img src="image-20240512110112932.png" alt="image-20240512110112932" style="zoom:50%;" /></li><li><img src="image-20240512110123324.png" alt="image-20240512110123324" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="6-查询优化"><a href="#6-查询优化" class="headerlink" title="6. 查询优化"></a>6. 查询优化</h3><ul><li><p>概述</p><ul><li>关系查询优化是影响关系数据库管理系统性能的关键因素</li><li>非关系系统中用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的</li><li>目标：关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案</li><li><img src="image-20240514162847443.png" alt="image-20240514162847443" style="zoom: 67%;" /></li><li>分为代数优化和物理优化</li></ul></li><li><p>代数优化</p><ul><li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率，E1 ≡ E2表示两个表达式等价</li><li>常用的等价变换规则<ul><li><img src="image-20240514163149780.png" alt="image-20240514163149780" style="zoom: 50%;" /></li><li><img src="image-20240514163200443.png" alt="image-20240514163200443" style="zoom:50%;" /></li><li><img src="image-20240514163210003.png" alt="image-20240514163210003" style="zoom:50%;" /></li><li><img src="image-20240514163300627.png" alt="image-20240514163300627" style="zoom:50%;" /></li></ul></li><li>典型的启发式规则<ul><li>选择运算应尽可能先做</li><li>把投影运算和选择运算同时进行</li><li>把投影同其前或其后的双目运算结合起来</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算</li><li>找出公共子表达式</li></ul></li><li>查询树的启发式优化算法见PPT</li></ul></li><li><p>物理优化</p><ul><li><p>概述</p><ul><li>代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</li><li>对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的</li><li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</li></ul></li><li><p>物理优化方法</p><ul><li>基于规则的启发式优化</li><li>基于代价估算的优化</li><li>两者结合的优化方法</li></ul></li><li><p>选择操作的启发式规则</p><ul><li><p>对于小关系，使用全表顺序扫描，即使选择列上有索引</p></li><li><p>对于大关系，启发式规则有：</p><img src="image-20240514172111501.png" alt="image-20240514172111501" style="zoom: 67%;" /></li><li><p>连接操作的启发式规则</p><ol><li>如果 2 个表都已经按照连接属性排序：选用排序-合并算法</li><li>如果一个表在连接属性上有索引：选用索引连接算法</li><li>如果上面 2 个规则都不适用，其中一个表较小：选用 hash join 算法</li><li>可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数 (较少的表，作为外表 外循环的表 )</li></ol></li></ul></li><li><p>基于代价估算的优化</p><ul><li>启发式规则优化是定性的选择，适合解释执行的系统</li><li>编译执行的系统中查询优化和查询执行是分开的</li><li>基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关</li><li><img src="image-20240514173200353.png" alt="image-20240514173200353" style="zoom: 60%;" /></li><li>代价估算方法<ol><li><img src="image-20240514173238431.png" alt="image-20240514173238431"></li><li><img src="image-20240514173248991.png" alt="image-20240514173248991"></li></ol></li></ul></li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><span id="more"></span><h2 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h2><ul><li>Thompson算法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110195743">编译原理: Thompson 构造法（正则表达式 转 NFA）_thompson构造法-CSDN博客</a></li><li><img src="image-20240611150213632.png" alt="image-20240611150213632"></li><li><img src="image-20240611150228916.png" alt="image-20240611150228916"></li><li><img src="image-20240611150236987.png" alt="image-20240611150236987"></li><li><img src="image-20240611150247191.png" alt="image-20240611150247191" style="zoom:50%;" /></li><li><img src="image-20240611150257922.png" alt="image-20240611150257922" style="zoom:67%;" /></li><li><img src="image-20240611150306204.png" alt="image-20240611150306204" style="zoom:67%;" /></li><li><img src="41.png"></li></ul></li><li>子集构造法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110213913">编译原理: Subset Construction 子集构造法(幂集构造)(NFA转DFA)_编译原理nfa转dfa-CSDN博客</a></li><li><img src="image-20240611150549771.png" alt="image-20240611150549771"></li><li><img src="image-20240611150602989.png" alt="image-20240611150602989" style="zoom:67%;" /></li><li>解释：先把初始状态和它通过无条件转移能到达的并为一个状态，然后一步步根据不同输入扩展，知道所有状态在所有输入情况下的目标状态都已定义</li></ul></li><li>DFA最小化算法<ul><li><img src="image-20240611152632268.png" alt="image-20240611152632268"></li><li><img src="image-20240611152648720.png" alt="image-20240611152648720" style="zoom:50%;" /></li><li>解释：先把非接受状态和接受状态分成两类，再在每个等价类内部判断每个成员是否会转移到其他等价类，如果是就把它拎出去单独成一个等价类，直到最后只剩最小闭包。</li><li>合并等价状态时注意只把它们之间的状态转移去掉，但它们自己到自己的边和与外界相连的边要保留</li></ul></li></ul><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><ul><li>上下文无关文法<ul><li><img src="image-20240611154021569.png" alt="image-20240611154021569"></li><li><img src="image-20240611155045696.png" alt="image-20240611155045696" style="zoom:67%;" /></li><li>在最左推导中，每一步总是替换字符串中最左边的非终结符。具体过程如下（最右推导相反）：<ol><li>从起始符号（开始符号）S开始。</li><li>在每一步推导中，选择当前字符串中最左边的非终结符，并使用某个产生式规则进行替换。</li><li>重复步骤2，直到得到仅由终结符组成的字符串。</li></ol></li><li><img src="image-20240611155322088.png" alt="image-20240611155322088"></li><li>文法G 的语言L(G) 是它能推导出的所有句子构成的集合</li></ul></li></ul><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><ul><li><p>FIRST与FOLLOW求解</p><ul><li><p><a href="https://blog.csdn.net/jianbai_/article/details/106367466">编译原理：LL(1)文法-构造预测分析表_ll(1)分析表-CSDN博客</a></p></li><li><p>示例看这篇：<a href="https://blog.csdn.net/qq_40741513/article/details/106036849">编译原理LL(1)预测分析表的构造_构造文法l(1)l预测分析表-CSDN博客</a></p></li><li><p>First(α) 是可从α 推导得到的句型的首终结符号的集合，Follow(A) 是可能在某些句型中紧跟在A 右边的终结符的集合</p></li><li><p>注意，FIRST和FOLLOW都是针对单个非终结符的，预测分析表的行也是单个非终结符，也就是说不存在类似FIRST(ABC)</p></li><li><img src="28.png" style="zoom: 50%;" /></li><li><img src="29.png" style="zoom:50%;" /></li><li><p>对文法G的每个产生式A-&gt;α 执行如下步骤：</p></li></ul><p>  （1）对每个a∈First(α)，把 A-&gt;α 加入M[A,a]</p><p>  （2）若 ε∈First(α)，则对任何b∈Follow(A) ,把 A-&gt; ε加至M[A,b]中</p></li><li><p>判断某文法是否为LL(1)</p><ul><li><a href="https://blog.csdn.net/weixin_44162921/article/details/103482452">编译原理——判断是否为LL（1）文法及构造分析表_请写出ll(1)文法应满足的条件。-CSDN博客</a></li><li><img src="image-20240611193206421.png" alt="image-20240611193206421" style="zoom:80%;" /></li><li>另一种方式：检查预测分析表是否无冲突，即检查是否有一个单元格中是否有有超过一个表达式，如果有则不是LL(1)</li></ul></li></ul><h3 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a>LR(0)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105554383">编译原理学习笔记（七）~LR(0)分析-CSDN博客</a></li><li>画自动机<ul><li>先对文法增广</li><li>通过初始状态得到I0</li><li>一步步对每个点不在最右边的情况生成新的状态，计算项集时注意每一条点不在最右边的要把点后非终结符的规则加进来</li><li>直到最后不再有新的状态出现</li></ul></li><li>画分析表<ul><li>根据自动机填表</li><li>非终结符部分有三种（移入s，规约r，接受acc），终结符部分直接写数字表示状态跳转</li><li>注意需要规约的状态无论看到什么输入都进行规约</li></ul></li><li>关注栈的状态<ul><li>移入动作代表入栈</li><li>入栈的同时也带来新的状态</li><li>出栈时状态回到该句柄入栈前的状态</li></ul></li></ul><h3 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a>SLR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105596980">编译原理学习笔记（九）~SLR分析-CSDN博客</a></li><li>如果文法G 的SLR(1) 分析表是无冲突的, 则G 是SLR(1) 文法。</li><li><img src="image-20240612154526804.png" alt="image-20240612154526804"></li><li>新的自动机：在规约项后加上FOLLOW集中的元素，表示只有下一个输入符号为这些之一才规约，否则移入</li><li><img src="image-20240612155521083.png" alt="image-20240612155521083"></li></ul><h3 id="LALR-1"><a href="#LALR-1" class="headerlink" title="LALR(1)"></a>LALR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105599118">编译原理学习笔记（十一）~LALR分析法-CSDN博客</a></li><li>LALR(1) : 合并具有相同核心LR(0)项的状态(忽略不同的向前看符号)</li><li><img src="image-20240612160005965.png" alt="image-20240612160005965"></li></ul><h2 id="ANTLR优先级上升算法"><a href="#ANTLR优先级上升算法" class="headerlink" title="ANTLR优先级上升算法"></a>ANTLR优先级上升算法</h2><ul><li>优先级确定：根据原文法从下往上每条规则优先级从1递增</li><li>非左递归规则改写：<ul><li>放在开头，用( )包裹，两条规则中间用|隔开</li><li>若包含递归规则，分为含运算符和不含运算符两种</li><li>不含运算符（如<code>( expr )</code>）则传参数0</li><li>若含右结合单操作数运算符（如<code>&#39;-&#39; expr</code>），则传参等于此条规则优先级</li></ul></li><li>左递归规则改写：<ul><li>用( )包裹，最后有*</li><li>每条规则前有优先级判断（如<code>(5 &gt;= $_P)?</code>）</li><li>非终结符调用递归规则，若运算符为左结合（包括单操作数，如阶乘 !）则传参为该规则优先级+1，若运算符为右结合（如指数运算2^5，规则前要加一条<code>&lt;assoc = right&gt;</code>）则传参为该规则优先级</li><li>优先级升高原因：使优先级等于或高于当前节点的能在当前节点下展开，小于的回到上一级展开</li></ul></li><li>示例<ul><li><img src="image-20240621092049848.png" alt="image-20240621092049848"></li><li><img src="image-20240621092105593.png" alt="image-20240621092105593" style="zoom: 50%;" /></li><li><img src="image-20240621092118737.png" alt="image-20240621092118737"></li><li><img src="image-20240621092141481.png" alt="image-20240621092141481"></li><li><img src="80a9dcf969d7026c3dda87a88cb61c40-1718933855431.png" alt="img" style="zoom:50%;" /></li></ul></li></ul><h2 id="语法制导翻译SDT"><a href="#语法制导翻译SDT" class="headerlink" title="语法制导翻译SDT"></a>语法制导翻译SDT</h2><ul><li><img src="image-20240611195505703.png" alt="image-20240611195505703" style="zoom:50%;" /></li><li>综合属性<ul><li><img src="image-20240611195633623.png" alt="image-20240611195633623" style="zoom:50%;" /></li><li>在LL 语法分析器中, 递归下降函数A 返回时,计算相应节点A 的综合属性值</li><li>综合属性用returns定义！</li></ul></li><li>继承属性<ul><li><img src="image-20240611195804291.png" alt="image-20240611195804291" style="zoom:50%;" /></li><li><img src="image-20240611200431868.png" alt="image-20240611200431868" style="zoom:50%;" /></li><li>继承属性用参数定义！</li></ul></li><li>L属性<ul><li><img src="image-20240611195917546.png" alt="image-20240611195917546" style="zoom:50%;" /></li><li>直观来说就是继承属性只能从上往下、从左往右传递</li><li><img src="image-20240611200751148.png" alt="image-20240611200751148" style="zoom:50%;" /></li></ul></li><li><img src="image-20240611200549503.png" alt="image-20240611200549503" style="zoom:50%;" /></li><li>例子<ul><li><img src="image-20240621094922672.png" alt="image-20240621094922672"></li><li><img src="image-20240621095154487.png" alt="image-20240621095154487"></li><li><img src="image-20240621095217714.png" alt="image-20240621095217714"></li><li><img src="image-20240621095309194.png" alt="image-20240621095309194"></li><li><img src="image-20240621101202137.png" alt="image-20240621101202137"></li></ul></li></ul><h2 id="中间代码翻译"><a href="#中间代码翻译" class="headerlink" title="中间代码翻译"></a>中间代码翻译</h2><ul><li>表达式<ul><li><img src="image-20240612141832786.png" alt="image-20240612141832786" style="zoom:50%;" /></li></ul></li><li>数组引用<ul><li><img src="image-20240612143015988.png" alt="image-20240612143015988" style="zoom:67%;" /></li></ul></li><li>控制流语句翻译中的地址回填技术<ul><li><img src="image-20240612143619019.png" alt="image-20240612143619019" style="zoom: 50%;" /></li><li>祖先节点通过综合属性收集子节点中具有相同目标的跳转指令</li><li>综合属性B.truelist 保存需要跳转到B.true 标签的指令</li><li>综合属性B.falselist 保存需要跳转到B.false 标签的指令</li><li>综合属性S&#x2F;L.nextlist 保存需要跳转到S&#x2F;L.next 标签的指令</li><li><img src="image-20240612144545716.png" alt="image-20240612144545716"></li></ul></li><li>控制流语句<ul><li>简单模式：只使用综合属性，为布尔表达式B 计算逻辑值(假设保存在临时变量t1 中)，if、while 等语句根据 B 的结果改变控制流</li><li>困难模式：父节点为子节点准备跳转指令的目标标签，子节点通过继承属性确定跳转目标</li><li><img src="image-20240612145711859.png" alt="image-20240612145711859"></li><li><img src="image-20240612145745468.png" alt="image-20240612145745468"></li></ul></li></ul><h2 id="RISC-V指令集"><a href="#RISC-V指令集" class="headerlink" title="RISC-V指令集"></a>RISC-V指令集</h2><ul><li>寄存器<ul><li>ra：返回地址</li><li>t0 - t6：临时寄存器</li><li>pc：程序计数器</li></ul></li><li>指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>one: .word 1 # int one = 1; 32位下word4字节，byte1字节，doubleword8字节<br>result: .word 0<br>msg: .string &quot;hello&quot; # 自带\0的字符串，.ascii是不带\0的<br>array: .word 10, 20, 30, 40 # 每个数字占一个word<br><br>.text<br>li t0, 200 # 立即数加载，伪指令<br>addi t0, zero, 200 # 立即数加法，实现li<br>add t2, t0, t1 # t2 = t0 + t1<br>sub t2, t0, t1 # t2 = t0 - t1<br>mul t2, t0, t1 # t2 = t0 * t1<br>slli t2, t0, 2 # t2 = t0 &lt;&lt; 2<br><br># 系统调用<br>li a7, 1 # 系统调用号存入a7, 1是输出单字，4输出字符串<br>add a0, t0, zero # 传参到a0 - a6<br>mv a0, t0 # 伪指令，a0 &lt;- t0<br>ecall # 触发系统调用<br><br># 从内存中存取数据<br>la t0, one<br>lw t0, 0(t0) # load word，加载一个字节(也有lb)，0是offset，t0是基址<br><br>la t1, result<br>sw t0, 0(t1) # save word，与lw对应，但是注意方向相反：t0 -&gt; 0(t1)<br># 等价于lw t0, one和sw t0, result, t2伪指令<br><br># 访问数组<br>la t0, array<br>lw t1, 12(t0) # 访问array[3]<br><br># 条件判断<br>bge t0, t1, label1 # branch if t0 &gt;= t1<br>bltz t0, label1 # branch if t0 &lt; 0<br>beqz t0, label1 # branch if t0 = 0<br>j label1 # jump<br><br># 函数调用<br>jal ra, max # 调用max函数，把max首条指令地址存入pc，并把下条指令地址存入ra<br># 可以缩写成jal max或call max，默认用ra存<br><br>jalr zero, 0(ra) # 被调用方用，返回0(ra)的地址，并将当前下一条指令存入第一个参数(用zero表示丢弃)<br># 可以缩写成jr ra或ret<br><br>#栈操作<br>addi sp, sp, -8 # 腾出8字节栈空间<br>sw a0, 4(sp) # 将需要保存的寄存器值存入栈空间<br>sw ra, 0(sp) # 注意，ra在多层调用时一定要保存<br># 此处省略函数调用，如递归<br>mv t0, a0 # 把返回值存入t0，防止丢失<br>lw a0, 4(sp)<br>lw ra, 0(sp)<br>addi sp, sp, 8<br></code></pre></td></tr></table></figure><h2 id="寄存器分配算法"><a href="#寄存器分配算法" class="headerlink" title="寄存器分配算法"></a>寄存器分配算法</h2><ul><li><img src="image-20240621110136179.png" alt="image-20240621110136179" style="zoom: 50%;" /></li><li><img src="image-20240621110531657.png" alt="image-20240621110531657" style="zoom: 67%;" /></li><li><img src="image-20240621110653715.png" alt="image-20240621110653715" style="zoom:50%;" /></li><li>线性扫描分配算法<ul><li>三大关键操作: 占用、释放、溢出</li><li><img src="image-20240621110903961.png" alt="image-20240621110903961" style="zoom:50%;" /></li><li>发生溢出时，比较右端点，把最远的放入内存，腾出来的寄存器给新变量</li><li><img src="image-20240621111514563.png" alt="image-20240621111514563" style="zoom:50%;" /></li><li>解决方案一：生成代码时, 使用临时物理寄存器实现临时变量</li><li>解决方案二: 预留若干物理寄存器, 作为溢出处理时所需的临时寄存器</li><li>分支指令问题<ul><li><img src="image-20240621111658512.png" alt="image-20240621111658512" style="zoom:50%;" /></li><li><img src="image-20240621111710530.png" alt="image-20240621111710530" style="zoom:50%;" /></li><li><img src="image-20240621111722291.png" alt="image-20240621111722291"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II</title>
    <link href="/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/"/>
    <url>/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="软工II整理"><a href="#软工II整理" class="headerlink" title="软工II整理"></a>软工II整理</h1><h2 id="01-软件工程基础"><a href="#01-软件工程基础" class="headerlink" title="01.软件工程基础"></a>01.软件工程基础</h2><ul><li><p>软件的特性</p><ul><li>软件与现实世界关系更加密切，对需求的规格化更加困难</li><li>软件⽐硬件容易修改的多，并且不需要昂贵的⽣产线复制产品</li><li>软件没有损耗</li><li>软件不可见</li></ul></li></ul><span id="more"></span><ul><li><p>云原生</p><ul><li><img src="image-20240311210317505.png" alt="image-20240311210317505" style="zoom: 67%;" /></li></ul></li><li><p>软件类别</p><ul><li>系统软件：操作系统、数据库、数据仓库、嵌⼊式设备、安全</li><li>编程软件：IDE、测试、持续集成、建模、度量</li><li>应用软件：商业、政府、休闲、医疗、教育、国防、 个⼈、专业、科学</li></ul></li><li><p>应⽤软件</p><ul><li>应⽤软件被开发的⽬的和意图来源于现实世界的问题。</li><li>应⽤软件必须基于现实才能解决问题。</li><li>软件最终要被⽤于现实并改进现实。</li><li><img src="image-20240311210345790.png" alt="image-20240311210345790" style="zoom:67%;" /></li></ul></li><li><p>工程</p><ul><li>定义：创造性地应用科学原理，设计或开发结构、机器、仪器或制造工艺，或单独或组合使用它们的工程；或在充分了解它们的设计的情况下建造或操作它们；或在特定操作条件下预测它们的行为；就预期功能、运行的经济性或生命财产安全而言</li><li><strong>CCSE - About Engineer 关于工程师的介绍</strong><ul><li>工程师通过⼀系列的<strong>讨论决策</strong>，仔细评估项⽬的可选活动，并在每个决策点选择⼀种在当前环境中适合工当前任务的⽅法进⾏工作。可以通过对成本和收益进⾏折衷分析调整相应策略。</li><li>工程师需要对某些对象进⾏度量，有时需要定量的工作；他们要校准和确认度量⽅法，并根据经验和实验数据进⾏估算。</li><li>软件工程师强调<strong>项目设计过程的纪律性</strong>，这是团队⾼效工作的条件。</li><li>工程师可胜任研究、开发、设计、⽣产、测试、构造、操作、管理，以及销售、咨询和培训等<strong>多种角色</strong>。</li><li>工程师们需要在某些过程中使⽤工具，选择和使用合适的工具是工程的关键要素。</li><li>工程师们通过专业协会发展和确认原理、标准和最佳实践⽅法，并提⾼个⼈能⼒。</li><li>工程师们能够重用设计和设计制品。</li></ul></li><li><img src="image-20240311210400691.png" alt="image-20240311210400691" style="zoom:50%;" /></li></ul></li><li><p>工程的要素</p><ul><li>具有解决实际问题的动机</li><li>应⽤科学知识指导⼯程活动</li><li>以成本效益比有效为基本条件</li><li>构建机器或事物</li><li>以服务⼈类为最终⽬的</li></ul></li><li><p>软件工程定义</p><ol><li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</li><li>对(1)中各种方法的研究。</li></ol></li><li><p>软件工程特点</p><ul><li>软件⼯程是⼀种⼯程活动</li><li>软件⼯程的动机是解决实际问题</li><li>软件⼯程是科学性、实践性和⼯艺性并重的</li><li>软件⼯程追求⾜够好，不是最好</li><li>软件⼯程真正的产品是基于虚拟计算机的软件⽅案</li><li>软件⼯程的最终⽬的是要促进整个社会的进步</li></ul></li><li><p>软件工程技术域</p><ul><li><img src="image-20240311210414779.png" alt="image-20240311210414779" style="zoom:67%;" /></li><li><img src="image-20240311210434034.png" alt="image-20240311210434034" style="zoom:67%;" /></li><li>软件工程管理知识域：<img src="image-20240311210446065.png" alt="image-20240311210446065"></li></ul></li><li><p>角色分工</p><ul><li>需求工程师，⼜被称为需求分析师：承担需求开发任务。软件产品的需求开发⼯作通常由多个需求工程师来完成，他们共同组成⼀个需求工程师⼩组，在⾸席需求工程师的领导下开展⼯作。通常⼀个团队只有⼀个需求工程师⼩组。</li><li>软件体系结构师：承担软件体系结构设计任务。通常也是由多⼈组成⼀个小组，并在首席软件体系结构师的领导下开展⼯作。通常⼀个团队只有⼀个软件体系结构师小组。</li><li>软件设计师：承担详细设计任务。在软件体系结构设计完成之后，可以将其部件分配给不同的开发小组。开发小组中负责所分配部件详细设计工作的⼈员就是软件设计师。⼀个团队可能有⼀个或多个开发小组。 ⼀个小组可能有⼀个或多个软件设计师。</li><li>程序员：承担软件构造任务。程序员与软件设计师通常是同⼀批⼈，也是根据其所分配到的任务开展⼯作。</li><li>⼈机交互设计师：承担⼈机交互设计任务。⼈机交互设计师与软件设计师可以是同⼀批⼈，也可以是不同⼈员。在有多个小组的软件工程团队中，可以有⼀个单独的人机交互设计师小组，也可以将⼈机交互设计师分配到各个小组。</li><li>软件测试⼈员：承担软件测试任务。软件测试⼈员通常需要独⽴于其他的开发⼈员⻆⾊。⼀个团队可能有⼀个或多个测试⼩组。⼀个⼩组可能有⼀个或多个软件测试⼈员。</li><li>项⽬管理⼈员：负责计划、组织、领导、协调和控制软件开发的各项⼯作。相⽐于传统意义上的管理者，他们不完全是监控者和控制者，更多得是协调者。通常⼀个团队只有⼀个项⽬管理⼈员。</li><li>软件配置管理⼈员：管理软件开发中产⽣的各种制品，具体⼯作是对重要制品进⾏标识、变更控制、状态报告等。通常⼀个团队只有⼀个软件配置管理⼈员。</li><li>质量保障⼈员：在⽣产过程中监督和控制软件产品质量的⼈员。通常⼀个团队有⼀个质量保障⼩组，由⼀个或多个⼈员组成。</li><li>培训和⽀持⼈员：负责软件移交与维护任务。他们可以是其他开发⼈员的⼀部分，也可以是独立的⼈员。</li><li>⽂档编写⼈员：专⻔负责写作软件开发各种⽂档的⼈员。他们的存在是为了充分利⽤部分宝贵的⼈⼒资源(例如需求工程师和软件体系结构师)，让这些⼈⼒资源从繁杂的⽂档化⼯作中解放出来。</li></ul></li></ul><h2 id="02-项目启动"><a href="#02-项目启动" class="headerlink" title="02.项目启动"></a>02.项目启动</h2><h3 id="项目和项目管理"><a href="#项目和项目管理" class="headerlink" title="项目和项目管理"></a>项目和项目管理</h3><ul><li>项目的定义<ul><li>具有⼀个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul></li><li>项目管理的目标<ul><li>在限定时间内</li><li>在⼀定的成本内</li><li>在要求的质量水平上</li><li>高效使用资源</li><li>获得客户认可</li></ul></li><li>过程组：项目启动、项目计划、项目执⾏，项目跟踪与控制和项目收尾</li><li>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</li></ul><h3 id="团队组织与管理"><a href="#团队组织与管理" class="headerlink" title="团队组织与管理"></a>团队组织与管理</h3><ul><li>团队定义：为了⼀致的目的、绩效标准、⽅法⽽共担责任并且技能互补的少数⼈。</li><li>团队结构<ul><li><strong>主程序员团队</strong>：决策需要由主程序员进行制定<ul><li>效率高，如果完成把握大，并且需要时间紧迫，可以优先考虑</li><li>一个人的决断容易影响整个团队，如果项目复杂，主程序员会成为瓶颈。</li><li>适用于把握性大，时间要求紧的情况</li></ul></li><li><strong>民主团队</strong>：没有集中的瓶颈，成员发挥能动性，工作效率降低，冲突解决。敏捷+较有挑战性的项目</li><li><strong>开放团队</strong><ul><li>为了创新而存在的。黑箱管理，问题在于项目进展没有可视度。</li><li>相对于前两个团队的需求明确，团队的需求并不明确</li><li>管理者主要负责清除出现的障碍。</li><li>开放团队是为了<strong>创新</strong>而存在</li></ul></li></ul></li><li>团队建设(高凝聚力的团队被称为胶冻团队)<ul><li><strong>建立团队章程</strong>：建立明确的团队章程，统一团队成员的目标，对团队成员进行一定的约束。经验：有必要指定一定的章程，约束团队成员之间的行为，比如开会请假必须得到其他三人的同意，又如一旦某项决策做出，不同意者不能再后续阶段违反等</li><li><strong>持续成功</strong>：设置小里程碑，每隔一段时间让团队体验成功。每次作业的检查结果一定程度上肯定了每个小阶段的工作。</li><li><strong>和谐沟通</strong>：和谐沟通：建立持续有效的沟通机制，相互尊重，管道畅通，开放透明，坦诚真实。开会频率保持在每周一次左右为宜，在工作量大的时候，需要集体工作，当面沟通，另外吵架可以，但是需要达成一致。</li><li><strong>不断总结</strong>：不断总结上一阶段的工作成果，运用项目评审等手段，进行反思回顾，指导后续阶段的开发。每个阶段都会有启动会议对上个阶段进行回顾，评审会议对此阶段进行评审。</li><li><strong>避免团队杀手</strong>：需要对别人的工作全心全意的信任，尽管评审是必要的。产品质量的降低会使凝聚力下降</li></ul></li></ul><h3 id="软件质量保障"><a href="#软件质量保障" class="headerlink" title="软件质量保障"></a>软件质量保障</h3><ul><li><p>质量属性</p><ul><li>⼈们通常会选⽤系统的某些质量要素进行量化处理，建⽴质量特征，这些特征被称为<strong>质量属性</strong></li><li>为了根据质量属性描述和评价系统的整体质量，⼈们从很多质量属性的定义当中选择了⼀些能够相互配合、相互联系的特征集，它们被称为<strong>质量模型</strong></li></ul></li><li><p>质量模型</p><ul><li>因素</li><li>功能性</li><li>可靠性</li><li>易用性:人机交互</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li><p>质量保障</p><ul><li><img src="3.png" style="zoom:50%;" /></li><li><img src="image-20240312201645433.png" alt="image-20240312201645433" style="zoom:50%;" /></li><li><p>度量产生自统计控制思想。</p></li><li><p>测度就是为了描述软件产品而提供的定量指标，如代码行数</p></li><li><p>进行测度的活动被称为测量</p></li><li><p>度量是软件产品在特定属性上的量化测度程度</p></li></ul></li><li><p>评审</p><ul><li><img src="5.png" style="zoom:50%;" /></li><li>在<strong>规划</strong>阶段，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与⼈员、审查内容等等。</li><li>在<strong>总体部署</strong>阶段，向所有参与审查会议的⼈员描述待审查材料的内容、审查的⽬标以及⼀些假设，并分发⽂档。</li><li>在<strong>准备</strong>阶段，审查⼈员各⾃独⽴执⾏检查任务。在检查的过程当中，他们可能会被要求使⽤检查清单、场景等检查⽅法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集 ⼈员。</li><li>在<strong>审查会议</strong>阶段，通过会议讨论，识别、确认、分类发现的错误。</li><li>在**返⼯**阶段，修改发现的缺陷。</li><li>在<strong>跟踪</strong>阶段，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</li></ul></li><li><p>软件配置管理的动机</p><ul><li>在软件开发活动中，除了最终产品之外，还会产⽣很多<strong>中间制品</strong>，例如需求规格说明、需求分析模型、软件体系结构设计模型、详细设计模型等。这些制品是不同阶段、不同角色、不同软件开发活动进行协同的基础。</li><li>在复杂软件系统开发中，产⽣的制品数量众多，以⾄于开发者需要维护⼀个清单才能清楚项目所处的状态，理解已经完成的⼯作和将要进行的⼯作。</li><li>某个制品发⽣变化带来的最大挑战是如何确保其使用者能够得到最新的制品，避免开发协同出现问题</li></ul></li><li><p>配置管理</p><ul><li>IEEE定义：用技术的和管理的指导和监督方法，来标识和说明<strong>配置项</strong>的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的⼀致性</li><li><strong>配置项</strong>：置于软件配置管理之下的软件配置的各种有关项⽬，包括各类管理文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等</li><li><strong>基线</strong>：基线是指通过了评审和验证，可以作为后续开发工作基础而进入协同工作过程，需要纳入配置管理和执行变更控制的制品</li><li><strong>配置管理活动</strong>：<ul><li>标识配置项版本管理：确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单</li><li>配置审计：验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告：反映当前的配置状态。</li><li>软件发布管理：将配置项发布到开发活动之外，例如发布给客户。</li><li><img src="image-20240312203602358.png" alt="image-20240312203602358" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h3 id="管理实践"><a href="#管理实践" class="headerlink" title="管理实践"></a>管理实践</h3><ul><li>投入<ul><li>⼈员的成本：这是最重要的一部分投⼊。 除了开发⼈员外，还要计算项目管理⼈员和其他相应⽀持⼈员的费用</li><li>工具的购买：包括计算机及其周围配套设备等硬件，也包括开发⼯具、办公套件等软件。</li><li>培训的费用：开发⼈员接受培训，获得开发项⽬所需技能的费⽤。</li><li>差旅费：拜访客户，参加会议等的费⽤。</li><li>维护的费用：定时的数据备份、系统监控、系统维修和升级等引起的费⽤。</li><li>生产停顿的损失：因为项⽬调试引起正常⼯作业务停顿的损失。</li><li>市场和服务的费用：推⼴软件产品所要的⼴告费用、参加展览会的费用等。</li><li>机会成本：因为投资该项目，而不能投资别的项目或者放银行收取利息的机会成本。</li></ul></li><li>产出<ul><li>节约商业活动成本：只要是和无新软件系统时候比较，将节省的时间和原材料折算成量化的数字。例如，开发了新的库存管理系统后，加快了流通并减少了库存浪费。</li><li>创新商机增加销售：指由于使用新软件带来的盈利，可能是软件产品本身的销售，也可能是软件项目带来的营业成⻓。</li><li>提高品牌含金量： 提高质量和客户满意度，可以带来品牌含金量的提高。这比较虚⼀点，但也可以像企业的无形资产⼀样估算。</li></ul></li></ul><h3 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h3><ul><li><p>为实践项目组建你的团队：</p><ul><li>选择技能互补的成员组成团队，明确分工；</li><li>根据成员特点，选择团队结构；(建议使用民主团队)</li><li>建立团队章程；</li><li>明确团队的交流沟通⼿段。</li><li>需要保留开发过程，用来确保可查</li></ul></li><li><p>配置管理</p><ul><li>所有产物都通过Gitlab来管理</li><li>建立Group</li><li>⽂档采用MD文件</li></ul></li></ul><h2 id="03-需求基础"><a href="#03-需求基础" class="headerlink" title="03.需求基础"></a>03.需求基础</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><ul><li><p>需求工程的概念：所有需求处理活动的总和。它<strong>收集</strong>信息、<strong>分析</strong>问题、<strong>整合</strong>观点、记录需求并<strong>验证</strong>其正确性，最终描述出软件被应用后与其环境互动形成的<strong>期望效应</strong>。</p></li><li><p>三个主要任务：</p><ul><li>需求工程必须说明软件系统将被应用的应用环境及其<strong>目标</strong>，说明用来达成这些目标的软件功能，也即要同时说明软件”需要<strong>做什么</strong>“和”<strong>为什么</strong>需要做”。</li><li>需求⼯程必须将⽬标和功能反映到软件系统当中，映射为<strong>可行的软件行为</strong>，并对软件⾏为进行准确的<strong>规格说明</strong>。</li><li>现实世界是<strong>不断变化</strong>的世界，因此需求⼯程还需要妥善处理⽬标和功能随着时间演化的变动情况。</li></ul></li><li><p>需求工程活动</p><ul><li><img src="image-20240313121004338.png" alt="image-20240313121004338" style="zoom:50%;" /></li></ul></li><li><p>需求开发</p><ul><li><img src="image-20240313121025278.png" alt="image-20240313121025278" style="zoom:50%;" /></li><li><p>需求获取</p><ul><li>从<strong>人、文档或者环境</strong>当中获取需求的过程</li><li>要利⽤各种方法和技术来<strong>发现</strong>需求</li><li>目标分析：1. 根据问题确定目标:发现用户的期望和现实之间的差距 2. 通过分析利害关系人确定目标</li><li>需求获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型、民族志、竞品分析</li><li>问题与解决方案<ol><li>用户和开发⼈员的背景不同，⽴场不同：消除默认知识</li><li>普通用户缺乏概括性、综合性的表述能力：专业的需求人员</li><li>⽤户存在认知困境：原型(做一个原型帮助用户理解的草图模型)</li><li>⽤户越俎代庖：需求是开发人员开发出来的，不是⽤户提出来的；协商</li><li>缺乏用户参与：为用户参与提供⽅便</li></ol></li></ul></li><li><p>需求分析</p><ul><li>通过<strong>建模</strong>来整合各种信息，以使得人们更好的理解问题。</li><li>为问题定义出⼀个需求集合，这个集合能够为问题界定⼀个有效的<strong>解决方案</strong>。</li><li><strong>检查</strong>需求当中存在的错误、遗漏、不⼀致等各种缺陷，并加以修正</li><li>边界分析<ol><li>定义项目的范围。系统边界之内定义的是系统需要对外提供的功能</li><li>系统边界的定义要保证系统能够和周围环境形成有效的互动</li><li>系统用例图、上下文图通常被用来定义系统的边界</li></ol></li></ul></li><li><p>需求规格说明</p><ul><li>在系统用户之间<strong>交流需求信息</strong></li><li>要简洁、精确、⼀致和易于理解</li><li>需求工程师在这个阶段的重要工作包括:<ol><li>定制文档模版，提高效率</li><li>编写文档(模型语言和自然语言两种)</li></ol></li></ul></li><li><p>需求验证</p><ul><li>需求规格说明文档至少要满足下面几个标准:<ol><li>文档内每条需求都<strong>正确、准确</strong>的反映了用户的意图；</li><li>文档记录的需求集在整体上具有<strong>完整性和⼀致性</strong>；</li><li>文档的组织方式和需求的书写方式具有<strong>可读性</strong>和<strong>可修改性(方便保证版本简化)</strong>。</li></ol></li><li>需求验证的方法：同级评审、原型、模拟等</li></ul></li></ul></li><li><p>需求管理</p><ul><li>保证需求作用的持续、稳定和有效发挥：在需求开发活动之后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展⼯作</li><li>进行变更控制：纳入和实现合理的变更请求，拒绝不合理的变更请求，控制变更的成本和影响范围</li></ul></li></ul><h3 id="需求基础"><a href="#需求基础" class="headerlink" title="需求基础"></a>需求基础</h3><ul><li>IEEE对需求的定义：<ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对1或2中的一个条件或一种能力的一种文档化表述。</li></ol></li><li>需求开发的目标<ul><li><img src="4.png" style="zoom: 67%;" /></li></ul></li><li>问题域<ul><li>现实世界运行规律的一种反映</li><li>需求的<strong>产生域</strong>，也是需求的<strong>解决地</strong>。</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄⾃修改现实世界的实际情况。</li></ul></li></ul></li><li>规格说明<ul><li>软件产品的方案描述，它以软件产品的运行机制为主要内容。</li><li>它不是需求但实现需求，不是问题域但需要与问题域互动。</li><li>规格说明要以关注<strong>对外交互</strong>的⽅式描述软件解决⽅案，它既需要从软件产品的⻆度⽽不是⽤户的⻆度进⾏描述，⼜不能太多地涉及软件产品的内部构造机制。</li><li>为什么描述的是交互？因为交互对我们而言是一个对外的重要展示。</li></ul></li><li>需求、问题域、规格说明三者要进行区分<ul><li><img src="image-20240313122311441.png" alt="image-20240313122311441" style="zoom: 60%;" /></li></ul></li><li>需求层次性<ul><li>三种需求层次:业务需求、用户需求、系统级需求</li><li>业务需求(目标，解决方案与系统特性)<ul><li>业务需求是<strong>高层次</strong>的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。</li><li>为什么是系统特性？因为还没有到细节的部分</li><li>特性说明了系统为用户提供的各项功能，它限定了系统的<strong>范围</strong>(Scope)</li><li>例：在系统使用3个月后，销售额度应该提⾼20%</li></ul></li><li>用户需求(任务，问题域知识)<ul><li>问题域知识：执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么<ol><li>直接用户</li><li>间接用户(<strong>通用软件的销售人员和售后支持人员</strong>)</li></ol></li><li>问题域知识：是需要了解到期望所来源的背景知识。</li><li><strong>特性</strong><ol><li>模糊、不清晰(允许适度的用形容词和副词)</li><li>多特性混杂 (功能和⾮功能的混杂)</li><li>多逻辑混杂 (⼀个任务需要多次系统交互才能完成)</li></ol></li><li>例：系统应该允许客户经理添加、修改或者删除会员个⼈信息</li></ul></li><li>系统级需求<ul><li>需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的⼀个实现细节</strong>(和用户需求有着很大的区别)</li><li>描述了开发人员<strong>需要实现什么</strong></li><li>将用户需求转化为系统需求的过程是⼀个复杂的过程<ol><li>首先需要分析<strong>问题领域</strong>及其特性，从中发现问题域和计算机系统的共享知识，建⽴系统的知识模型；</li><li>然后将⽤户需求<strong>部署到系统模型</strong>当中，即定义系列的系统⾏为，让它们联合起来实现⽤户需求，每⼀个系统⾏为即为⼀个系统需求。</li><li>该过程就是需求⼯程当中最为重要的需求分析活动，⼜称<strong>建模与分析活动</strong>。</li></ol></li><li>系统级需求还可能会补充一些与软件实现相关的细节</li><li>例：在客户经理输⼊会员的客户编号时，系统要提供该会员的个⼈信息</li></ul></li><li><img src="image-20240313122823522.png" alt="image-20240313122823522" style="zoom: 67%;" /></li></ul></li></ul><h3 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h3><ul><li><p>需求图谱</p><ul><li><img src="image-20240313163053020.png" alt="image-20240313163053020" style="zoom:50%;" /></li><li>项目需求(<strong>人的数量、计划成本、时间</strong>)：项目的成本要控制在60万元⼈⺠币以下、项目要在6个月内完成</li><li>过程需求(<strong>人的分工、合作、方法、工具</strong>)：如在开发中，开发者要提交软件需求规格说明文档、设计描述⽂档和测试报告；项目要使用持续集成⽅法进行开发</li></ul></li><li><p>需求的分类（IEEE）</p><ul><li><strong>功能需求</strong>：和系统主要共作相关的需求，即在不考虑物理约束的情况下，⽤户希望系统所能够执行的活动，这些活动可以帮助⽤户完成任务。<strong>功能需求主要表现为系统和环境之间的⾏为交互</strong>。</li><li><strong>性能需求</strong>：系统整体或系统组成部分应该拥有的性能特征，包括速度、容量、吞吐量、负载、实时性</li><li><strong>质量属性</strong>：系统完成工作的质量，即系统需要在⼀个”好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。</li><li><strong>对外接口</strong>：系统和环境中其他系统之间需要建⽴的接口，包括硬件接口、软件接口、数据库接口等等。</li><li><strong>约束</strong>：进行系统构造时需要遵守的约束，例如<strong>编程语言、硬件设施</strong>等</li></ul></li><li><p>功能需求</p><ul><li>功能需求是最常见、最主要和最重要的需求，是能够为用户带来业务价值的系统⾏为</li><li><strong>最需要按照三个抽象层次进行展开</strong>，说明了关系</li><li>软件产品产生价值的基础，需求检查最重要的部分</li><li>比如:在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息</li></ul></li><li><p>数据需求</p><ul><li><strong>功能需求</strong>的补充：如果在功能需求部分明确定义了<strong>相关的数据结构</strong>，那么就不需要再行定义数据需求</li><li>数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：<ul><li>各个功能使⽤的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li></ul></li></ul></li><li><p>性能需求</p><ul><li><img src="image-20240313165138780.png" alt="image-20240313165138780" style="zoom: 67%;" /></li></ul></li><li><p>质量属性</p><ul><li>系统为了满足<strong>规定的及隐含</strong>的所有要求而需要具备的要素称为质量</li><li>质量属性是为了度量质量要素而选用的特征</li><li>质量模型就是能够为质量需求的描述和评价提供工作基础的特征集及特征之间的联系</li></ul></li><li><p>常见质量属性</p><ol><li><strong>可靠性</strong>(Reliability)：在规格时间间隔内和规定条件下，系统或部件执⾏所要求能⼒的能⼒。<ul><li>在进⾏数据的下载和上传中，如果⽹络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复。</li></ul></li><li><strong>可用性</strong>(Availability)：软件系统在投⼊使⽤时可操作和可访问的程度或能实现其指定系统功能的概率。<ul><li>系统的可⽤性要达到98%。</li></ul></li><li><strong>安全性</strong>(Security)：软件阻止对其程序和数据进行未授权访问的能力，未授权的访问可能是有意，也可能是无意的。<ul><li>VIP顾客只能查看自己的个人信息和购买记录；</li><li>收银员只能查看，不能修改、删除VIP顾客的信息。</li></ul></li><li><strong>可维护性</strong>(Maintainability)：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。<ul><li>如果系统要增加新的特价类型，要能够在2个⼈⽉内完成。</li></ul></li><li><strong>可移植性</strong>(Portability)：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。<ul><li>集中服务器要能够在1⼈⽉内从Window 7操作系统更换到Solaris 10操作系统。</li></ul></li><li><strong>易用性</strong>(Usability)：与⽤户使⽤软件所花费的努⼒及其对使⽤的评价相关的特性。<ul><li>使用系统1个⽉的收银员进⾏销售处理的效率要达到10件商品&#x2F;分钟。</li></ul></li></ol></li><li><p>对外接口</p><ul><li><strong>解系统和其他系统</strong>之间的软硬件接⼝:包括硬件接口、软件接口、数据库接口等<ul><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li></ul></li><li>用户界面</li></ul></li><li><p>约束</p><ul><li>总体上限制了开发⼈员设计和构建系统时的选择范围</li><li><strong>系统开发及运行的环境</strong><ul><li>包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等</li><li>例：系统要使用Java语言进行开发。</li></ul></li><li><strong>问题域内的相关标准</strong><ul><li>包括法律法规、⾏业协定、企业规章等。</li></ul></li><li><strong>商业规则</strong><ul><li>⽤户在任务执⾏中的⼀些潜在规则也会限制开发⼈员设计和构建系统的选择范围</li></ul></li></ul></li></ul><h2 id="04-需求分析基础"><a href="#04-需求分析基础" class="headerlink" title="04.需求分析基础"></a>04.需求分析基础</h2><h3 id="需求分析基础"><a href="#需求分析基础" class="headerlink" title="需求分析基础"></a>需求分析基础</h3><ul><li>需求分析的任务<ul><li>建立<strong>分析模型</strong>，达成开发者和用户对需求信息的共同理解:分析将复杂的系统分解为简单的部分以及它们之间的联系，确定本质特征，抛弃次要特征。</li><li>依据共同的理解，<strong>发挥创造性</strong>，创建软件系统解决方案:分析可以将一个问题分解为独立的、更简单的和易于管理的子问题来帮助寻找解决方案</li></ul></li><li>模型<ul><li>模型是对事物的抽象，帮助⼈们在创建一个事物之前可以有更好的理解</li><li>为了更好地理解需求获取所得到的复杂信息，需要集中关注问题的计算特性(数据、功能、规则等)，建立相关的软件模型</li></ul></li><li>建模<ul><li>建模的目标是建立系统的一个表示，这个表示以精确⼀致的方式描述系统，使得系统的使用更加容易</li><li><strong>抽象</strong>和<strong>分解</strong>是建模最为常用的两种手段</li></ul></li><li>需求分析模型<ul><li><img src="image-20240314102113872.png" alt="image-20240314102113872" style="zoom:50%;" /></li></ul></li></ul><h3 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h3><ul><li><p>面向对象分析过程</p><ul><li><img src="image-20240314102240131.png" alt="image-20240314102240131" style="zoom:67%;" /></li></ul></li></ul><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><ul><li><p>用例</p><ul><li>定义：在系统(或者子系统或者类)和外部对象的交互当中所执行的行为序列的描述,包括各种不同的序列和错误的序列,它们能够联合提供⼀种有价值的服务</li><li>用例描述了在不同条件下系统对某一用户的请求的响应。根据用户的请求和请求时的系统条件,系统将执行不同的行为序列, 每⼀ 个行为序列被称为⼀个场景。⼀个用例是多个场景的集合。</li><li>用例图的建立：目标分析与解决方向的确定、寻找参与者、寻找用例、细化用例</li></ul></li><li><p>用例图基本元素：用例、参与者、关系、系统边界</p><ul><li>用例：椭圆<ul><li>以用例的形式表达需求。</li><li>用例表示有助于构建、关联和理解基本需求的典型场景集。</li><li>场景是对系统在实践中如何使用的描述：用户与计算机系统之间的典型交互</li><li>一般会用动宾短语，加上actor作为主语就是句子了</li></ul></li><li>参与者：小人<ul><li>参与者是用户或其他系统对要开发的系统所扮演的角色。</li><li>用例图中的单个参与者可以表示多个用户(或系统)。</li><li>单个用户(或系统)也可以扮演多个角色。</li><li>参与者不需要是人，例如，需要来自当前系统的某些信息的外部系统也是参与者。</li></ul></li><li>关系：简单的就是一条直线<ul><li>有关</li><li>泛化关系，指向的是被泛化的。</li><li>包含关系</li><li>继承关系</li></ul></li><li>系统边界：是一个框<ul><li>强调重点是什么是要详细的，什么不是。</li><li>系统边界隐式存在于没有显式表示的系统边界的图中</li><li>参与者总是在边界之外，用例总是在边界之内。</li><li>系统边界是指一个系统所包含的系统成分与系统外事务的分界线</li></ul></li></ul></li><li><p>目标分析</p><ul><li>问题目标的解决方案</li><li>×××连锁商店是一家刚刚发展起来的小型连锁商店，其前身是⼀家独立的小百货门面店。<ul><li>首先是随着商店规模的扩大，顾客量大幅增长，手工作业销售迟缓，顾客购物排队现象严重，导致流失客源。</li><li>其次是商店的商品品种增多，无法准确掌握库存，商品积压、缺货和报废的现象上升明显。</li><li>再次是商店面临的竞争比以前更⼤，希望在降低成本，吸引顾客，增强竞争力的同时，保持盈利水平</li></ul></li><li>业务需求<ol><li>BR1：在系统使⽤6个月后，商品积压、缺货和报废的现象要减少50%</li><li>BR2：在系统使⽤3个月后，销售⼈员⼯作效率提⾼50%</li><li>BR3：在系统使⽤6个月后，运营成本要降低15%<ul><li>范围：⼈力成本和库存成本</li><li>度量：检查平均员工数量和平均每10,000元销售额的库存成本</li></ul></li><li>BR4：在系统使⽤6个月后，销售额度要提高20%</li></ol></li><li>系统功能<ol><li>SF1：分析商品库存，发现可能的商品积压、缺货和报废现象</li><li>SF2：根据市场变化调整销售的商品</li><li>SF3：制定促销手段，处理积压商品</li><li>SF4：与生产厂家联合进行商品促销</li><li>SF5：制定促销手段进行销售竞争</li><li>SF6：掌握员工变动和授权情况</li><li>SF7：处理商品入库与出库</li><li>SF8：发展会员，提高顾客回头率</li><li>SF9：允许积分兑换商品和赠送吸引会员的礼品，提高会员满意度</li><li>SF10：帮助收银员处理销售与退货任务</li></ol></li></ul></li><li><p>寻找参与者与用例</p><ul><li>每个用户的任务(目标)都是⼀个独立用例</li><li><img src="image-20240314104447968.png" alt="image-20240314104447968" style="zoom: 67%;" /></li><li><img src="image-20240314104544180.png" alt="image-20240314104544180" style="zoom: 67%;" /></li></ul></li><li><p>细化用例</p><ul><li>如果用例的粒度不合适就需要进⾏细化和调整。</li><li>判断标准是：⽤例描述了为应对<strong>一个业务事件</strong>，由<strong>一个用户</strong>发起，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务</li><li>产品具体的细化（例子）<ol><li>特价策略制定、赠送策略制定两个用例的业务目的、发起源和过程基本相同，仅仅是业务数据不同，所以可以合并为⼀个用例销售策略制定。</li><li>会员管理用例有两个明显不同的业务事件，可以被细化为发展会员和礼品赠送2个更细粒度的用例。</li><li>客户经理的库存管理用例也有三个不同的业务⽬标：出库、⼊库和库存分析，所以也应该细化为三个用例商品出库、商品⼊库和库存分析，其中库存分析⽤例与总经理的库存分析⽤例相同。</li></ol></li><li><img src="image-20240314105045573.png" alt="image-20240314105045573" style="zoom:67%;" /></li></ul></li><li><img src="13.png" style="zoom: 80%;" /></li></ul><h4 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h4><ul><li><p>概念</p><ul><li>概念类图又被称为”领域模型”(Domain Model)</li><li>类图是面向对象分析方法的核心：类图描述类(对象)和这些类(对象)之间的关系</li><li>概念类图和<strong>设计类图</strong>的不同点：关注系统与外界的交互，⽽不是软件系统的内部构造机制</li><li><strong>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</strong></li><li>类图只有类和类名，没有包含方法。</li><li>用例不是概念类，同一个用例可能产生多个概念类</li></ul></li><li><p>概念类图基本元素</p><ul><li>对象<ul><li>标识符：对象自治、对象请求写作</li><li>状态：存储数据，如密码、名称</li><li>行为：利用数据做什么</li></ul></li><li>类:对象集合的抽象</li><li>链接<ul><li>对象之间的互相协作的关系</li><li>描述了对象之间的物理或业务联系</li></ul></li><li>关联<ul><li>对象之间链接的抽象</li><li>聚合(空心菱形)与组合(实心菱形)</li></ul></li><li>继承：泛化关系</li><li><img src="image-20240428112931962.png" alt="image-20240428112931962"></li></ul></li><li><p>建立概念类图的步骤</p><ul><li>对每个用例文本描述，尤其是场景描述，建立<strong>局部</strong>的概念类图<ul><li>识别候选类(名词分析法)</li><li><strong>确定概念类</strong> (看是否满足既有状态又有行为)<ol><li>既需要维持一定的状态，又需要依据状态表现一定的行为：确定为一个概念类</li><li>如只需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，却需要表现行为：首先重新审视需求是否有遗漏，因为没有状态支持的对象无法表现行为；如果确定没有需求的遗漏，就需要剔除该候选类，并将行为转交给具备状态支持能力的其他概念类</li><li>既不需要维护状态，又不需要表现行为：应该被完全剔除</li></ol></li><li>识别关联(文本中提取出”名词＋动词＋名词”的结构)：第一标准是满足需求的要求，第二标准是现实状况</li><li>识别重要属性：协作的必要信息，通过分析用例的描述，补充问题域信息发现。</li></ul></li><li>将所有用例产⽣的局部概念类图进行合并，建⽴软件系统的整体概念类图</li><li>自己注:先画关联关系，再添加类的属性</li><li><img src="image-20240410205025063.png" alt="image-20240410205025063" style="zoom: 60%;" /></li><li><img src="image-20240410205400576.png" alt="image-20240410205400576"></li></ul></li></ul><h4 id="顺序图（交互图）"><a href="#顺序图（交互图）" class="headerlink" title="顺序图（交互图）"></a>顺序图（交互图）</h4><ul><li>概念<ul><li>行为模型显示了对象之间的交互，以产生一些特定的系统行为，这些行为被指定为一个用例</li><li>UML中的序列图(或协作图)用于<strong>建模对象之间的交互</strong></li><li>分析阶段，主要是利用<strong>系统顺序图</strong>，表达系统和外部参与者之间的交互行为：务必要严格谨慎的界定系统</li></ul></li><li>图例<ul><li><img src="image-20240421171223317.png" alt="image-20240421171223317" style="zoom:67%;" /></li></ul></li><li>系统顺序图<ul><li><img src="image-20240421171303355.png" alt="image-20240421171303355" style="zoom: 80%;" /></li><li>画外部和内部之间的交互应当仔细辨别系统和系统(也就是系统边界)</li><li>不同框的含义:<ol><li>alt一定要选(多选一):<strong>注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[ ]里面。</strong></li><li>opt一定要选(选择0或者1)</li><li>loop:表示循环，在旁边使用[]书写循环条件</li></ol></li><li>步骤:<ol><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加消息</li></ol></li></ul></li></ul><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><ul><li>概念<ul><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ul></li><li><img src="31.png" style="zoom:50%;" /></li><li><img src="image-20240428223753527.png" alt="image-20240428223753527"></li><li><strong>创建状态图的步骤</strong><ul><li>确定上下文环境<ul><li>状态图是立足于状态快照进行行为描述的，因此建立状态图时首先要搞清楚<strong>状态的主体</strong>，确定状态的上下文环境。常见的状态主体有：类、用例、多个用例和整个系统。</li><li>状态应该是相对较多，比较复杂的。</li></ul></li><li>识别<strong>状态</strong><ul><li>状态主体会表现出⼀些稳定的状态，它们需要被识别出来，并且标记出其中的初始状态和结束状态集。在有些情况下，可能会不存在确定的初始状态和结束状态。</li></ul></li><li>建立<strong>状态转换</strong><ul><li>根据需求所描述的系统行为，建⽴各个稳定状态之间可能存在的转换。</li></ul></li><li>补充<strong>详细信息</strong>，完善状态图<ul><li>添加转换的触发事件、转换行为和监护条件等详细信息</li></ul></li></ul></li></ul><h3 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h3><ul><li>方法<ul><li>自顶向下分解</li><li>各种图<ul><li>数据流图</li><li>实体关系图</li><li>状态转移图</li></ul></li></ul></li><li>结构图<ul><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li></ul></li></ul><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><ul><li>数据流图<ul><li>数据流图将系统看做是过程的集合，其中一些由人来执行，另一些由软件系统来执行。</li><li><strong>过程的执行就是对数据的处理：它接收输入，进行数据转换，输出结果。</strong></li><li>数据流图主要是展示了数据在通过系统如何进行了变化。</li><li>可能需要和软件系统外的实体尤其是<strong>人</strong>进行交互</li><li>数据的变化包括：<strong>被转换、被存储、或者被分布</strong></li><li><img src="41.png" style="zoom: 80%;" /></li><li>外部实体：数据的产生或者消耗者，是待构建软件系统之外的人、组织、设备或者其他软件系统，它们不受系统控制，开发者不能以任何方式操纵它们</li><li>过程：<ul><li>将数据从输入转换到输出：示例：计算税金，确定面积，格式报告，显示图形必须始终以某种方式处理数据以实现系统功能</li><li>过程是指施加于数据的动作或者行为，它使得数据发生变化，包括被转换、被存储或者被分布</li></ul></li><li>数据流：数据流是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。</li><li>数据存储：软件系统需要在内部手机、保存，以供日后使用的数据集合。</li><li>数据流图分为三种图：上下文图、0层图和N层图<ul><li>上下文图是DFD的最高层次的图，是系统功能的最高抽象。上下文将整个系统看做一个过程，这个过程实现系统的所有功能</li><li>0层图通常被用作整个系统的功能概图为了概述整个系统的功能，建立0层图时需要分析需求获取的信息，归纳出系统的主要功能</li><li>N层图：父过程为被分解的过程，子图为分解后产生的揭示更多细节的图</li><li>具体见ppt</li></ul></li></ul></li></ul><h4 id="实体关系图"><a href="#实体关系图" class="headerlink" title="实体关系图"></a>实体关系图</h4><ul><li><p>实体关系图</p><ul><li><p>传统实体</p><ul><li>实体并不是孤立存在的，相互交互相互影响</li><li>参与关系的每个实体都针对关系拥有最大基数和最小基数</li><li>最大基数:对关系中任意的其他实体实例，该实体可能参与关系的最大数量。最大基数为1，表示为One，否则为Many</li><li>最小基数:对关系中任意的其他实体实例，该实体可能参与关系的最小数量。实体在关系中的最小基数被标记为Optional,最小基数为1时，实体在关系中的最小基数被标记为mandatory</li></ul></li></ul></li></ul><ul><li><p>关系</p><ul><li>系统必须记住的事实，不能或不能计算或推导出来<ul><li>关系的几个实例可以存在</li><li>实体可以以多种方式关联</li><li><img src="37.png" style="zoom: 67%;" /></li></ul></li><li>键：实体的⼀个或者多个属性能够唯⼀确定和标示每个实例，这些属性或者属性组合就被称为实体的标示符，或者键</li></ul></li><li><p>建立实体关系图的步骤</p><ul><li>第1级-对所有数据对象(实体)及其相互之间的”连接”建模</li><li>第2级-对所有实体和关系建模<ul><li>第3级-对所有实体、关系和属性建模，以提供进一步的深度</li></ul></li><li><img src="38.png" style="zoom: 67%;" /></li></ul></li></ul><h3 id="使用需求分析方法细化和明确需求"><a href="#使用需求分析方法细化和明确需求" class="headerlink" title="使用需求分析方法细化和明确需求"></a>使用需求分析方法细化和明确需求</h3><ul><li><p>为什么要细化</p><ul><li>用户需求的描述的模糊性和系统设计所需要的严谨性之间的矛盾</li></ul></li><li><p>如何细化</p><ul><li>需求分析建模</li><li>发现其中的遗漏、冲突、冗余和错误</li><li>迭代(获取、分析、获取、分析······)</li></ul></li><li><p>系统顺序图有助于发现交互性的缺失</p><ul><li><img src="image-20240327204341393.png" alt="image-20240327204341393" style="zoom: 80%;" /></li></ul></li><li><p>概念类图有助于发现</p><ul><li><p>部分信息的使用不准确</p></li><li><p>部分信息不明确</p></li><li><p>遗漏了重要内容</p></li><li><img src="image-20240327204359767.png" alt="image-20240327204359767" style="zoom:80%;" /></li></ul></li><li><p>状态图有助于发现页面的跳转</p><ul><li><img src="image-20240327204629398.png" alt="image-20240327204629398" style="zoom: 67%;" /></li></ul></li><li><p>建立系统需求</p><ul><li>8种规格说明：<ul><li>by mode 功能需求分类</li><li>by user class</li><li>by object</li><li>by feature</li><li>by stimulus</li><li>by functional hierarchy</li><li>multiple organization</li></ul></li><li>不同的分析⽅法适合不同的规格说明</li></ul></li></ul><h2 id="05-需求文档化与验证"><a href="#05-需求文档化与验证" class="headerlink" title="05.需求文档化与验证"></a>05.需求文档化与验证</h2><h3 id="用例文档"><a href="#用例文档" class="headerlink" title="用例文档"></a>用例文档</h3><ul><li>为什么文档化需求<ul><li>方便团队工作和沟通</li><li>方便项目管理</li><li>更加明确的体系架构</li><li>方便软件设计</li><li>方便编码</li><li>方便维护</li></ul></li><li>为什么建立需求规格说明？结合试验说明（<strong>重要</strong>）<ul><li>方便交流，软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以在软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li>需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li>在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化。</li></ul></li><li>用例文档<ul><li>在用户的角度以用例文本为主描述软件系统与外界的交互</li><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li><li><img src="image-20240331164631718.png" alt="image-20240331164631718" style="zoom:67%;" /></li><li>用例图等描述图可以更加直观的了解这部分</li></ul></li></ul><h3 id="软件需求规格说明文档（SRS）"><a href="#软件需求规格说明文档（SRS）" class="headerlink" title="软件需求规格说明文档（SRS）"></a>软件需求规格说明文档（SRS）</h3><ul><li>概念<ul><li>在软件产品的⻆度以系统级需求列表的⽅式描述软件系统解决方案</li><li><img src="image-20240331172611622.png" alt="image-20240331172611622" style="zoom: 67%;" /></li></ul></li><li>模板<ul><li><img src="3-1746703874907.png" style="zoom:67%;" /></li></ul></li></ul><h3 id="文档化需求"><a href="#文档化需求" class="headerlink" title="文档化需求"></a>文档化需求</h3><ul><li><p>注意事项</p><ul><li>简洁:动词名词+辅助词，不要使用复杂长句、形容词和副词。</li><li>精确:不能产生起义或无法理解。</li><li>易读(查询)：有效使用引言、目录、索引等能够增强文档易读性的方法；使用系统化的方式组织内容信息，提供文档内容的可读性。</li><li>易修改：使用相同的语句格式组织相关联或相似的信息；使用列表组织独立、并列的信息；使用编号表达繁杂信息之间的关系。引用而不是重复</li></ul></li><li><p>系统化的方式</p><ul><li>使用<strong>相同</strong>的语句格式来描述相似、关联的信息。</li><li>使用<strong>列表或者表格</strong>来组织独立、并列的信息。</li><li>使用<strong>编号</strong>来表达繁杂信息之间的关系,包括顺序关系、嵌套关系和层次关系。<ul><li>对图、表进行编号</li><li>对⽂档的章节进行编号</li><li>对信息内容进行标识和编号</li></ul></li></ul></li><li><p>需求书写要点</p><ul><li>需求书写要点<ul><li>使用用户术语:不要使用计算机术语(导致用户无法理解)</li><li>可验证：不可验证的需求一般是因为描述模糊或者过于抽象</li><li>可行性：需求必须能够在系统及其运行环境的已知条件和约束下实现。要考虑在限定成本、时间和人力约束内，实现需求的可能性</li></ul></li><li>需求规格说明文档书写要点<ul><li>充分利用标准的文档模版，保持所有内容位置得当</li><li>保持⽂档内的需求集具有完备性和⼀致性。</li><li>为需求划分优先级(可以分为高中低、也可以分为1-10等分)</li></ul></li></ul></li><li><p>验证需求文档</p><ul><li>评审<ul><li>评审的人员不能仅由技术人员组成，必须包括客户和用户</li><li>在评审中使用线索，⽤户对场景与线索表现出了最⼤的兴趣</li><li>使用需求检查列表</li></ul></li><li>开发系统测试用例<ul><li>基于用例描述，可以为销售处理确定测试用例套件</li><li>测试用例套件是测试用例的集合，将有关测试用例集合在一起</li></ul></li><li>建立测试用例<ul><li>主要是基于规格的技术，设计测试场景的输⼊与输出数据</li><li>不断地添加测试用例来完成测试</li></ul></li></ul></li><li><p>度量需求功能点</p><ul><li><p>度量需求</p><ul><li>用例的数量<ul><li>平均每个用例中的场景数量</li><li>平均用例行数</li><li>在一个尺度下进行分析</li></ul></li><li>软件需求数量</li><li>非功能需求数量</li><li>功能点数量</li></ul></li><li><p>度量的意义</p><ul><li>如果平均的用例场景<strong>数量过低</strong>，那么就可能存在对<strong>异常流程考虑不周</strong>的可能。</li><li>如果<strong>平均用例行数过大或者过小</strong>，那么可能对⽤例的细分粒度过⼤或者过小。</li><li>用例数量、软件需求数量和功能点数量应该是相对比例均衡的，如果三者之间有着**⾮常大的差距**，那么可能会有需求的遗漏。</li></ul></li><li><p>功能点度量</p><ul><li><p>用于估算和度量软件系统规模与复杂度的抽象单位</p></li><li><img src="image-20240331191831646.png" alt="image-20240331191831646" style="zoom:67%;" /></li><li><p>功能点测度总数：</p><img src="8.png" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="08-软件设计基础"><a href="#08-软件设计基础" class="headerlink" title="08.软件设计基础"></a>08.软件设计基础</h2><h3 id="什么是软件设计"><a href="#什么是软件设计" class="headerlink" title="什么是软件设计"></a>什么是软件设计</h3><ul><li>概念<ul><li>软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。</li><li>软件设计活动以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。</li><li>软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性。</li></ul></li><li>软件设计的核心思想<ul><li>软件设计方法的核心问题：控制系统复杂度</li><li>分解与抽象是软件设计的核心思想，两者都是由层次性的，彼此之间可以嵌套使用。<ol><li>分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象:在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度。</li></ol></li><li><img src="image-20240408111022715.png" alt="image-20240408111022715" style="zoom:50%;" /></li><li><img src="1.png" style="zoom: 67%;" /></li></ul></li><li>设计<ul><li>定义<ul><li>设计(名词):⼀个对象的规格说明。它由⼈创造,有明确的⽬标,适⽤于特殊的环境,由⼀些基础类型构件组成,满⾜⼀个需求集合,受⼀定的限制条件约束。</li><li>设计(动词):在⼀个环境中创建对象的规格说明</li></ul></li><li>设计经常需要⼀个设计师考虑⼀个对象或过程的<strong>审美、功能以及其他方面</strong>，这通常需要进⾏相当的研究、思考、建模、交互调整和重新设计。</li><li>分类<ul><li>工程设计和艺术设计</li><li>理性主义和经验主义</li><li>具体见PPT</li></ul></li></ul></li><li>软件设计的演化性<ul><li>需求是外部表现，需求和内部结构是有鸿沟的。</li><li>非功能需求(质量需求)</li><li>始终进行迭代</li><li><img src="6.png" style="zoom:50%;" /></li></ul></li><li>设计的决策<ul><li><img src="image-20240408111756337.png" alt="image-20240408111756337" style="zoom:50%;" /></li><li>决策的约束性<ul><li>需求；环境；资源；技术 …</li><li>最初的需求确定了对设计情况的最基本的约束和要求。</li><li>通常，在设计工作本身中最终会发现更多的约束。</li><li>约束既适用于设计的工件，也适用于设计活动中涉及的流程和参与者</li></ul></li><li><img src="7.png" style="zoom:60%;" /></li></ul></li></ul><h3 id="软件设计的分层（重要）"><a href="#软件设计的分层（重要）" class="headerlink" title="软件设计的分层（重要）"></a>软件设计的分层（重要）</h3><ul><li><img src="image-20240408112055301.png" alt="image-20240408112055301" style="zoom:50%;" /></li><li>低层设计<ul><li>将基本的语言单位(类型与语句)，组织起来，建立高质量的数据结构+算法</li><li>常见设计场景：<ul><li>数组的使用，链表的使用，内存的使用，遍历算法，递归算法…</li><li>一次问相对比较大的内存，然后我们自己在进行的内存的分配</li></ul></li><li>经典场景：<ul><li>堆栈，队列，树，排序算法，查找算法…</li></ul></li><li>数据结构与算法审美：简洁、结构清晰，坚固(可靠、高效、易读)</li><li>低层设计本质：屏蔽程序中复杂数据结构与算法的实现细节</li><li><img src="image-20240408120816682.png" alt="image-20240408120816682" style="zoom:50%;" /></li><li>模块划分<ul><li>1970s：函数的成熟与模块的出现</li><li>模块划分：将系统分成简单片段：⽚段有名字，可以被反复使用</li><li>名字和使⽤⽅法称为<strong>模块的抽象与接⼝</strong></li><li>模块内部的程序⽚段为精化与实现</li></ul></li></ul></li><li>中层设计<ul><li>开始：模块划分<strong>隐藏</strong>⼀些程序片段(数据结构+算法)的细节，暴露接口于外界</li><li><img src="image-20240408121107687.png" alt="image-20240408121107687" style="zoom:67%;" /></li><li>模块化的目标：完全独立性</li><li>方法：模块化、信息隐藏、抽象数据类型、封装</li></ul></li><li>高层设计：体系结构<ul><li><strong>部件</strong>承载了系统主要的<strong>计算与状态</strong></li><li><strong>连接件</strong>承载部件之间的<strong>交互</strong></li><li>部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，配置将它们的实例连接起来</li><li><img src="image-20240408122354610.png" alt="image-20240408122354610" style="zoom:50%;" /></li></ul></li></ul><h3 id="软件设计过程、方法和模型、描述"><a href="#软件设计过程、方法和模型、描述" class="headerlink" title="软件设计过程、方法和模型、描述"></a>软件设计过程、方法和模型、描述</h3><ul><li>软件设计过程的主要活动<ul><li><img src="image-20240408122621390.png" alt="image-20240408122621390" style="zoom: 80%;" /></li></ul></li><li>软件设计的模型和方法<ul><li>结构化设计方法</li><li>面向对象设计</li><li>数据为中心设计:有一些项目是做数据仓库等的，数据爬取操作和读取。</li><li>基于构件的设计:调用构件和库</li><li>形式化方法设计</li></ul></li><li>描述软件设计的模型，通常可以分为两类:<ul><li>静态模型<ul><li>静态模型是通过快照 的方式对系统中时间不变的属性进行描述。通常描述的是状态,而不<br>是行为。</li></ul></li><li>动态模型：动态模型通常描述的是系统行为和状态转移。</li><li><img src="image-20240408123041801.png" alt="image-20240408123041801" style="zoom: 67%;" /></li></ul></li><li>软件设计描述<ul><li><img src="image-20240408123255930.png" alt="image-20240408123255930" style="zoom:45%;" /></li><li><img src="image-20240408123336074.png" alt="image-20240408123336074" style="zoom:50%;" /></li></ul></li></ul><h2 id="09-软件体系结构基础"><a href="#09-软件体系结构基础" class="headerlink" title="09.软件体系结构基础"></a>09.软件体系结构基础</h2><ul><li>软件体系结构发展历史略</li></ul><h3 id="理解软件体系结构"><a href="#理解软件体系结构" class="headerlink" title="理解软件体系结构"></a>理解软件体系结构</h3><ul><li><p>概念</p><ul><li>软件体系结构：现代系统组件和子系统相互作用形成系统的结构和组织，以及最好在系统级别设计和分析的系统属性。</li><li>软件体系结构包含有关以下方面的重要决策<ul><li>软件系统的<strong>组织</strong></li><li>选择组成系统的<strong>结构元素及其接口</strong>，以及这些元素之间的协作所指定的<strong>行为</strong>，</li><li>将这些元素组成越来越大的<strong>子系统</strong>，</li><li>指导该组织，这些元素及其界面，协作和组成的结构元素及其接口。</li></ul></li><li>软件体系结构&#x3D;{部件(Component),连接件(Connector),配置(Configuration)}<ul><li><strong>部件</strong>是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;</li><li><strong>连接件</strong>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;</li><li><strong>配置</strong>是对”形式”的发展,定义了”部件”以及”连接件”之间的关联方式,将它们组织成系统的总体结构。</li></ul></li></ul></li><li><p>物理与逻辑</p><ul><li>模块<ul><li>逻辑：⼀个模块调用另⼀个模块</li><li>物理实现<ol><li>基本：接口调用</li><li>需要传递数据对象怎么办？</li></ol></li><li>逻辑：⼀个模块给另⼀个模块传递数据流</li><li>物理实现：读写共享数据、pipe…</li></ul></li><li>物理实现的载体<ul><li>低层：基本类型+基本控制结构</li><li>中层：OO编程语言机制<ol><li>类声明、实例创建与撤销、实例⽣命期管理</li><li>类权限控制机制</li><li>复杂机制：继承…</li></ol></li><li>高层：导⼊导出和名称匹配</li></ul></li></ul></li><li><p>高层抽象(体系结构 &#x3D; 部件 + 连接件 + 配置) <strong>重要</strong></p><ul><li><p>概念</p><ul><li><strong>组件</strong>是计算和状态的聚合</li><li><strong>连接件</strong>是组件之间的关系的聚合</li><li><img src="8-1746703902687.png"></li><li>连接件是⼀个与部件平等的单位。</li><li>部件与连接件是比类、模块等软件单位更高层次的抽象</li></ul></li><li><p>部件</p><ul><li>封装系统架构中的处理和数据的元素称为软件组件</li><li>件通常提供特定于应用程序的服务</li></ul><p><img src="9.png"></p><ul><li>部件承载系统主要功能，包括处理和数据</li></ul></li><li><p>原始部件和复合部件</p><ul><li><p>部件可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。</p></li><li><p>原始类型的部件可以直接被实现为相应的软件实现机制。</p></li><li><p>复合部件则由<strong>更细粒度</strong>的<strong>部件和连接件</strong>组成,复合部件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</p></li><li><img src="11.png" style="zoom:67%;" /></li></ul></li><li><p>连接件</p><ul><li>在复杂的系统中，交互可能比单个组件的功能更重要和更具挑战性</li><li>连接件定义了部件间的交互，是连接的抽象表示</li><li>与部件相似,在实现上连接件也可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。原始类型的连接件可以直接被实现为相应的软件实现机制。</li><li>复合连接件则由更细粒度的<strong>部件和连接件</strong>组成,复合连接件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</li><li><img src="image-20240410120546268.png" alt="image-20240410120546268" style="zoom: 67%;" /></li></ul></li><li><p>配置</p><ul><li>组件和连接器以给定系统体系结构中的特定方式构成，以实现该系统的目标</li><li>为了对软件体系结构进行更严格、准确的描述，人们建立了体系结构描述语言(ADL)，用于描述软件体系结构的形式化模型语言。</li><li>配置定义了部件和连接件之间的关联方式，将他们组织成系统的总体结构。</li></ul></li><li><p>高层抽象优点</p><ul><li>直观，便于理解</li><li>验证正确性</li><li>关注度分离，降低复杂度</li></ul></li></ul></li></ul><h3 id="体系结构风格初步"><a href="#体系结构风格初步" class="headerlink" title="体系结构风格初步"></a>体系结构风格初步</h3><ul><li><p>这部分需要重要掌握每一种风格的优点缺点和画图</p></li><li><p>分类</p><ul><li><img src="image-20240417154959514.png" alt="image-20240417154959514"></li></ul></li><li><p>主程序子进程风格</p><ul><li>组件：程序、函数和模块</li><li>连接件：在上述三个组件之间相互调用</li><li><img src="12.png" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>基于声明–使用(程序调用)关系建立连接件,以层次分解的方式建立系统部件, 共同组成层次结构。</li><li>每⼀个上层部件可以”使用”下层部件，但下层部件不能”使用”上层部件，即不允许逆方向调用。(层次性分解，基于定义使用关系)</li><li>系统<strong>单线程</strong>执行。主程序部件拥有初的执⾏控制权，并在”使用”中将控制权转移给下层子程序。</li><li>子程序只能够通过上层转移来获得控制权,可以在执⾏中将控制权转交给下层的子程序,并在自身执行完成之后必须将控制权还交给上层部件。</li><li>隐含子系统结构。</li></ul></li><li>实现<ul><li>主要实现机制:模块实现。</li><li>功能分解</li><li>集中控制</li><li>每个构件⼀个模块实现：主要是<strong>单向依赖</strong></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li>优点：流程清晰,易于理解；强控制性</li><li>缺点：程序调用是⼀种<strong>强耦合</strong>的连接方式,非常依赖交互方的接口规格,这会使得系统难以修改和复用；程序调用的连接方式限制了各部件之间的数据交互,可能会使得不同部件使用隐含的共享数据交流,产⽣不必要的公共耦合</li></ul></li></ul></li><li><p>面向对象风格</p><ul><li>组件：对象或模块(调用方法)</li><li>连接件：函数或者调用</li><li><img src="image-20240417165216134.png" alt="image-20240417165216134" style="zoom:67%;" /></li><li>设计决策及约束<ul><li>依照对数据的用情况,用<strong>信息内聚</strong>的标准,为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口,并隐藏内部数据的表示。</li><li>基于方法调用(Method Invocation)机制建立连接件,将对象部件连接起来。</li><li>每个对象负责维护其自身数据的⼀致性与完整性,并以此为基础对外提供”正确”的服务。</li><li>每个对象都是⼀个自治单位,不同对象之间是平级的,没有主次、从属、层次、分解等关系。</li></ul></li><li>实现<ul><li>主要实现机制：模块实现</li><li>任务分解</li><li>(委托式)分散式控制</li><li>每个构件⼀个模块实现<ol><li>使用接口将双向依赖转换为单向依赖</li><li>将每个构件分割为多个模块，以保证单向依赖</li><li>每个模块内部可以是基于面向对象方法，也可以基于结构化</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>面向对象式风格的优点有：<ul><li>内部实现的可修改性。</li><li>易开发、易理解、易复用的结构组织。</li></ul></li><li>面向对象式风格的缺点有:<ul><li>接口的耦合性。</li><li>标识的耦合性。</li><li>副作用</li></ul></li></ul></li><li><p>分层风格</p><ul><li>组件：通常是过程或对象的集合。</li><li>连接件：通常在受限可见性下进行过程调用或方法调用。</li><li><img src="image-20240417165555108.png" alt="image-20240417165555108" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>从低层到高层,部件的抽象层次逐渐提升。每个下层为邻接上层提供服务, 每个上层将邻接下层作为基础设施使用。也就是说,在程序调用机制中上层调用下层。</li><li>两个层次之间的连接要遵守特定的交互协议,该交互协议应该是<strong>成熟、稳定和标准化</strong>的。也就是说,只要遵守交互协议,不同部件实例之间是可以互相替换的。</li><li>跨层次的连接是禁止的，不允许第 I 层直接调用 I+N(N&gt;1)层的服务。(也就是必须逐层进行调用)</li><li>逆向的连接是禁止的，不允许第 I 层调⽤第 J(J &lt; I)层的服务</li></ul></li><li>实现<ul><li>关注点分离(每层逐次抽象)</li><li>层间接口使用固定协议(固定控制)</li><li>每层⼀或多个模块实现<ol><li>单向依赖</li><li>层间数据传递建立专门模块</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li><img src="image-20240417170546313.png" alt="image-20240417170546313" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>Model-View-Controller Style MVC风格</p><ul><li><p>子系统模型被设计的不用依赖任何一种视图或者控制子系统</p></li><li><p>任何他们状态的修改都会被传播给显示子系统</p></li><li><p><img src="22.png"></p></li><li><p>组件</p><ol><li>模型组件负责保持问题域知识和确认视图层的修改</li><li>视图组件负责显示信息给用户并且将用户的行为传递给控制器</li><li>控制器<ol><li>修改模型的状态：将用户的行为和模型的更新映射起来</li><li>选择用来反映的视图</li></ol></li></ol></li><li><p>连接件：方法调用，信息，事件</p></li><li><p>设计决策和约束</p><ul><li>模型、视图、控制是分别是关于<strong>业务逻辑</strong>、<strong>表现</strong>和<strong>控制</strong>的三种不同内容抽象。</li><li>如果视图需要持续地显示某个数据的状态,那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更,模型会主动通知视图,然后再由视图查询数据的更新情况。</li><li>视图只能使用模型的数据查询服务,只有控制部件可以调用可能修改模型状态的程序。</li><li>用户行为虽然由视图发起,但是必须转交给控制部件处理。对接收到的用户行为, 控制部件可能会执行两种处理中的⼀种或两种：调用模型的服务,执行业务逻辑;提供下⼀个业务展现。</li><li>模型部件相对独立,既不依赖于视图,也不依赖于控制。虽然模型与视图之间存在⼀个”通知变更”的连接,但该连接的交互协议是⾮常稳定的,可以认为是非常弱的依赖。</li></ul></li><li><p>实现</p><ul><li>模型-视图-控制风格需要为模型、视图和控制的每个部件实例建立模块实现,各模块间存在导⼊&#x2F;导出关系,程序调用连接件不需要显式的实现。</li><li>特定技术实现，通常专用于WEB<ol><li>Model与Controller单向</li><li>Controller与View双向</li><li>Model与View双向</li></ol></li><li>典型实现<ol><li>View： JSP，HTML</li><li>Controller： Servlet</li><li>Model： JavaBean</li></ol></li></ul></li><li><p>效果</p><ul><li><img src="image-20240417171043461.png" alt="image-20240417171043461"></li></ul></li><li><p>分层与MVC</p><ul><li><img src="image-20240417171101444.png" alt="image-20240417171101444"></li></ul></li></ul></li><li><p>判断题：</p><ul><li>按照功能分解的方式进行模块分割能够实现高内聚的软件设计：<strong>√</strong></li><li>体系结构设计是软件非功能性的实现，而详细设计主要是软件功能性的实现。：<strong>√</strong></li></ul></li></ul><h2 id="10-软件体系结构设计与构建"><a href="#10-软件体系结构设计与构建" class="headerlink" title="10.软件体系结构设计与构建"></a>10.软件体系结构设计与构建</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><ul><li><p>步骤（重要）</p><ul><li>分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。</li><li>通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。</li><li>进行软件体系结构逻辑(抽象)设计：产生逻辑包图</li><li>依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图</li><li>完善体系结构设计：关键类图，持久化数据格式的定义等</li><li>添加构件接口：包、重要文件的创建，定义接口</li><li>迭代过程3-6</li></ul><blockquote><ol><li>步骤1-3是逻辑设计，步骤4-7是物理设计</li><li>接下来的部分将要按照这个思路进行下去</li></ol></blockquote></li><li><p>第一步：分析关键需求和项目约束</p><ul><li><p>一般来说，体系结构设计的输入要素主要由两个来源：</p><ol><li>软件需求规格说明</li><li>项目约束</li></ol></li><li><p>体系结构设计必须落实所有的功能性需求和非功能性需求</p></li></ul></li><li><p>第二步：通过选择体系结构风格</p><ul><li>例：分层风格<ul><li>协议不变情况下易于修改</li><li>能够促进并行开发</li></ul></li></ul></li><li><p>第三步：进行软件体系结构逻辑(抽象)设计</p><ul><li>将需求分配到子系统和模块<ol><li>考虑功能的相同性：不同任务，但是相同功能</li><li>考虑可复用性：结构、数据、行为的可复用性</li></ol></li><li>使⽤非功能性需求与项⽬约束评价和改进初始设计<ul><li>能够满足项目约束</li><li>无法满足安全需求和网络分布约束，所以需要改进</li></ul></li></ul></li><li><p>包设计原则</p><ul><li>复用发布等价原则(REP)：复用的粒度就是发布的粒度</li><li>共同封闭原则(CCP)：包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。</li><li>共同重用原理(CRP)：一个包中的所有类应该是能够共同重用的。</li><li>无环依赖原则(ADP)：在包的依赖关系图中不能存在环。</li><li>稳定依赖原则(SDP)：朝着稳定的方向进行依赖<ul><li>包的稳定性度量</li><li><img src="image-20240417194311104.png" alt="image-20240417194311104" style="zoom:50%;" /></li><li><img src="image-20240417194328157.png" alt="image-20240417194328157" style="zoom:50%;" /></li></ul></li><li>稳定抽象原则(SAP)：包的抽象程度应该和其稳定程度一致</li><li>前三条描述的是依赖性，后三条描述的是耦合性</li></ul></li><li><p>包设计过程</p><ul><li>迭代的过程:先用 CCP 原则对把可能⼀同变化的类组织成包进行发布</li><li>随着系统的不断增长,我们开始关注创建可重用的元素,于是开始使⽤ CRP 和 REP 来指导包的组合。</li><li>后使用 ADP、SDP、SAP 对包图进行度量，去掉不好的依赖。(修改设计)</li></ul></li><li><p>第四步：依赖逻辑设计进行软件体系结构(实现)设计</p><ul><li>内容<ul><li>开发包(构件)设计</li><li>运行时的进程</li><li>物理部署</li></ul></li><li>具体细节见PPT</li></ul></li><li><p>第五步：完善体系结构设计</p><ul><li>完善启动和网络链接<ul><li>失败业务的现场保护问题</li><li>网络连接断开的恢复问题</li><li>除了细化职责建立关键类图之后，模块传递的数据对象也需要被明确定义，因为他们是模块建接口的重要部分，必须严格、准确。</li></ul></li><li>细化模块</li><li>数据定义<ul><li>接口的数据对象、关键类的重要数据结构、Value Object (VO)、Persistent Object(PO)</li><li>Java 实体<ul><li>实体是一个可以代表一个临时的业务实体的对象，比如一个账单或者用户</li><li>没有逻辑业务方法(行为)</li><li>实体必须在使用它们的会话或事务之间持久存在。</li><li>实体是存储在文件或者数据库中的</li><li>实体是一个Beans</li></ul></li><li>Value Objects(逻辑层向展示层传递数据)<ul><li>价值对象(VO)包含一个或多个公共领域中实体的属性。</li><li>在层之间传递值对象，而不是实体。</li><li><strong>应该考虑实现Serializable</strong></li><li>值对象可以更新和创建实体。</li><li>实体可以创建价值对象。</li></ul></li></ul></li></ul></li><li><p>第六步：添加构件接口</p><ul><li>构件初步设计<ul><li>根据分配的需求确定模块对外接口</li><li>初步设计关键类</li><li>编写接口规范</li></ul></li></ul></li><li><p>体系结构的原型构建</p><ul><li>包的创建</li><li>重要文件的创建</li><li>定义构件之间的接口</li><li>关键需求的实现</li></ul></li><li><p>体系结构集成与测试</p><ul><li>当体系结构中原型各个模块的代码都编写完成并经过单元测试之后,需要将所有模块组合起来形成整个软件原型系统, 这就是集成。</li><li>集成的<strong>目的</strong>是为了逐步让各个模块合成为⼀个系统来⼯作,从而验证整个系统的功能、性能、可靠性等需 求。对于被集成起来的系统，⼀般主要通过其暴露出来的接口，伪装⼀定的参数和输入，进行黑盒测试。</li><li>Stub 桩程序：为了完成程序的编译和连接而使用的暂时代码</li><li>根据从模块之间集成的先后顺序,⼀般有下列几种常见的集成策略：<ul><li>大爆炸式(所有放在一起，看能不能过)</li><li>增量式：自顶向下式、自底向上式、三明治式、持续集成</li></ul></li><li>大爆炸式：将所有模块一次性组合在一起，可以在短时间内迅速完成集成，但一次运行成功可能性不高，不容易发现bug</li><li>自顶向下：先集成和测试上层的测模块，下层的模块用伪装的具体接口的桩程序</li><li>自底向上集成：先底层组件，对底层组件较早进行验证，桩的工作量少，但高层设计的错误不会被很快的发现</li><li>持续集成：一种增量集成方法,但它提倡尽早集成和频繁集成。尽早集成是指不需要总是等待⼀个模块开发完成才把它集成起来；频繁集成是指开发者每次完成⼀些开发任务之后,就可以用开发结果替换 Stub 中的相应组件,进行集成与测试</li></ul></li><li><p>体系结构评审</p><ul><li><p>评审的角度</p><ul><li>设计方案正确性、先进性、可行性;</li><li>系统组成、系统要求及接口协调的合理性;</li><li>对于功能模块的输⼊参数、输出参数的定义是否明确;</li><li>系统性能、可靠性、安全性要求是否合理;</li><li>⽂档的描述是否清晰、明确。</li></ul></li><li><p>体系结构评审的方法</p><ul><li>对结果的评审：Checklist(动态更新的)</li><li>对设计决策的评审</li></ul></li><li><p>软件体系结构设计文档的Checklist</p><p><img src="image-20240418164336573.png" alt="image-20240418164336573"></p></li></ul></li></ul><h2 id="11-人机交互设计"><a href="#11-人机交互设计" class="headerlink" title="11.人机交互设计"></a>11.人机交互设计</h2><h3 id="什么是人机交互"><a href="#什么是人机交互" class="headerlink" title="什么是人机交互"></a>什么是人机交互</h3><ul><li>概念<ul><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li><li>良好的HCI界面设计可鼓励用户与系统之间轻松，自然且引人入胜的交互</li></ul></li><li>HCI的重要组成：可用性<ul><li>可用性不是用户界面单一的一维属性，它包含以下维度：<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验</li></ol></li></ul></li></ul><h3 id="人机交互的三个要素"><a href="#人机交互的三个要素" class="headerlink" title="人机交互的三个要素"></a>人机交互的三个要素</h3><ul><li><p>人</p><ul><li>概念<ul><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ul></li><li>特性<ul><li>短期记忆有限</li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ul></li><li>精神模型 <strong>重要</strong><ul><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ul></li><li>发现精神模型<ul><li>找到用户在尝试去做什么——目标</li><li>用户，目标，结果任务的需求</li><li><strong>仅在确定有助于解决任务的功能时才应添加功能</strong></li><li>与用户个人资料相关的任务的频率</li></ul></li><li>差异性<ul><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进行业务导航，尽量避免出错。如果⼀个系统的⼤多数用户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是长时间使用软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家用户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计人机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新手用户提供易学性高的⼈机交互机制(图形界面)</li><li>又为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ul></li></ul></li><li><p>计算机</p><ul><li>⼈机交互设备<ul><li>输入设备</li><li>输出设备</li></ul></li><li>常见界面类型<ul><li><img src="image-20240418195946335.png" alt="image-20240418195946335"></li></ul></li><li>交互方式<ul><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ul></li></ul></li><li><p>交互</p><ul><li>导航 <strong>重要</strong><ul><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉用户，这个就是导航。</li><li>导航的目的就是为用户提供⼀个很好的完成任务的入口，好的导航会让这个入口非常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给不同的用户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给用户提供导航</li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据</li></ul></li><li>反馈 <strong>重要</strong><ul><li>一定要有反馈，避免进行错误的操作</li><li>用户喜欢较短的响应时间；</li><li>较长的响应时间(&gt;15秒)具有破坏性；</li><li>用户会根据响应时间的变化调整自己的工作方式；</li><li>较短的响应时间导致了较短的用户思考时间；</li><li>较快的节奏可能会提高效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间</li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间</li></ul></li><li>协作式设计 <strong>重要</strong><ul><li>人和计算机是人机交互的两方，其中人的因素比较固定，⼀定时期内不会发生大的变化，所以要让⼆者交互顺畅，就需要让计算机更多地适应人的因素，这也是人机交互设计以用户为中心的根本原因</li><li>这种调整计算机因素以更好地适应并帮助用户的设计方式被称为协作式设计</li></ul></li><li>人机交互设计原则<ul><li>简洁设计(7±2原则)</li><li>一致性设计</li><li>低出错率设计</li><li>易记性设计<ul><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ul></li><li>可视化设计要点</li></ul></li></ul></li></ul><h3 id="人机交互设计流程"><a href="#人机交互设计流程" class="headerlink" title="人机交互设计流程"></a>人机交互设计流程</h3><ul><li>设计过程<ul><li><img src="image-20240418204112209.png" alt="image-20240418204112209"></li><li>导航设计：建立多次交互之间的逻辑衔接结构</li><li>页面设计：设计交互中的具体界面的细节</li><li>页面原型化：使用界面原型工具</li><li>页面的评估与修改：用户进行评估</li></ul></li><li>页面设计<ul><li><img src="17.png"></li></ul></li></ul><h3 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h3><ul><li>内容<ul><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ul></li><li>关键点<ul><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ul></li><li>常见的GUI元素<ul><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ul></li><li>Check List<ul><li>数据输入界面</li><li>可定制的视觉设计</li><li>搜索和检索界面</li><li>附加的用户功能</li><li>控制用户访问</li><li>与其他集合的互操作性</li></ul></li><li>评估GUI<ul><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如”可用性检查”或”启发式评估”)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ul></li></ul><h2 id="12-详细设计"><a href="#12-详细设计" class="headerlink" title="12. 详细设计"></a>12. 详细设计</h2><h3 id="详细设计基础"><a href="#详细设计基础" class="headerlink" title="详细设计基础"></a>详细设计基础</h3><ul><li><p>概念</p><ul><li><p><img src="1-1746703946905.png"></p><blockquote><ol><li>高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。</li><li>中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。</li><li>低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。</li></ol></blockquote></li><li><p>软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息</p></li><li><p>细节设计通过细节设计机制实现模块</p><ol><li>中级：(子调制)-&gt; OO-&gt;类指定</li><li>低级：DS. + ALG. -&gt;实现类</li></ol></li><li><p>细节设计要求设计者考虑模块的美观，功能和许多其他方面</p><ol><li>详细设计中的质量要求：修改，维护，性能……</li></ol></li><li><img src="3-1746703948594.png" style="zoom: 80%;" /></li></ul></li><li><p>详细设计的出发点</p><ul><li>上下文<ul><li>模块的规格：导出&#x2F;导入接口</li><li>职责分配：<ol><li>有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图</li><li>其他一些来自实施决策</li></ol></li><li>在详细设计文档中需要明确定义:<ol><li>模块结构及其接口(如果有更细的模块分解)</li><li>类结构、类协作、类接口(面向对象分析方法)</li><li>控制结构与函数接口(结构化分析方法)</li><li>重要的数据结构和算法逻辑(如果必要的话)</li></ol></li></ul></li><li><img src="image-20240428111557004.png" alt="image-20240428111557004" style="zoom:67%;" /></li></ul></li></ul><h3 id="面向对象详细设计"><a href="#面向对象详细设计" class="headerlink" title="面向对象详细设计"></a>面向对象详细设计</h3><h4 id="设计模型建立"><a href="#设计模型建立" class="headerlink" title="设计模型建立"></a>设计模型建立</h4><ul><li>面向对象设计的思想：职责<ul><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ul><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作</li></ul></li><li>职责驱动的分解<ul><li>职责可以在不同的抽象层次上陈述。</li><li>职责可以分解。</li><li>可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ul></li><li>职责启发法<ul><li>很好地分配职责有助于实现高凝聚力和低耦合。(高内聚)</li><li>确保模块职责不重叠。</li><li><strong>仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。</strong></li></ul></li><li>委托：其中一个模块将职责交给另一个模块</li></ul></li><li>面向对象设计的思想：协作<ul><li>概念<ul><li>一个应用程序可以分解为许多不同的行为。</li><li>每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践</li><li>每次协作，无论大小，都保证实现应用程序的行为</li><li>将面向对象的应用程序想象成通过关系连接的对象网络。</li><li>协作是通过网络追求特定行为的<strong>消息模式</strong></li><li>协作分布在对象网络中，因此在任何地方都不存在</li></ul></li></ul></li><li>面向对象详细设计的过程<ul><li><img src="image-20240428112704867.png" alt="image-20240428112704867"></li></ul></li></ul><h4 id="通过职责建立静态设计模型"><a href="#通过职责建立静态设计模型" class="headerlink" title="通过职责建立静态设计模型"></a>通过职责建立静态设计模型</h4><ul><li>抽象类的职责<ul><li>类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图</li><li>职责分类<ol><li>属性职责:对象的状态</li><li>行为职责:对象的行为</li></ol></li></ul></li><li>类之间的关系<ul><li><img src="image-20240428112903745.png" alt="image-20240428112903745"></li></ul></li><li>GRASP原则<ul><li>General Responsibility Assignment Software Patterns（一般职责分配软件模式）</li><li>不是”设计模式”，而是对象设计的基本原理</li><li>专注于对象设计的最重要方面之一：为类分配职责</li><li>强调适用性：并不是一个普适的</li><li>常见的一些特点:<ol><li>低耦合：分配一个职责要保证低耦合度</li><li>高内聚：分配一个职责的时候要保持类的高聚合度</li><li>信息专家：将一个职责分配给专家-履行职责所必须的信息的类</li><li>创建者：创建规则在后面</li><li>控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一)</li></ol></li></ul></li><li>拇指原则：当存在替代设计选择时，请仔细研究替代方案的<strong>凝聚力和耦合含义</strong>，并可能对替代方案的未来发展压力。选择具有良好内聚性，耦合性和稳定性的替代方案。</li><li>信息专家<ul><li>问题：在面向对象设计中分配职责的最基本原则是什么？</li><li>解决方案：将职责分配给具有完成任务所必需的信息的类。</li><li>维护信息封装</li><li>促进低耦合</li><li>促进高内聚类</li><li>例子见PPT</li></ul></li><li>添加辅助类<ul><li>分类：接口类、记录类(数据类)、启动类、控制器类、实现数据类型的类、容器类</li></ul></li></ul><h4 id="通过协作创建动态设计模型"><a href="#通过协作创建动态设计模型" class="headerlink" title="通过协作创建动态设计模型"></a>通过协作创建动态设计模型</h4><ul><li><p>抽象对象之间协作</p><ul><li>从小到大,将对象的小职责聚合形成大职责;</li><li>从大到小,将大职责分配给各个小对象。</li><li>这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。</li><li>可以用顺序图表示对象之间的协作</li><li>除了顺序图，我们还可以通过状态图来表达软件的动态模型</li></ul></li><li><p>创建者（creator）</p><ul><li>如果有以下情况，则由创建者分配B类创建A类实例的职责：<ol><li>B 聚集了 A 对象</li><li>B 包含了 A 对象</li><li>B 记录了 A 的实例</li><li>B 要经常使用 A 对象</li></ol></li><li><img src="image-20240428224003187.png" alt="image-20240428224003187"></li></ul></li><li><p>控制器（controller）</p><ul><li><p>如果程序从图形界面以外的来源接收事件，添加事件类以将事件源与实际处理事件的对象分离</p></li><li><p>Controller本身不是面向对象的，它包含很多复杂的逻辑</p></li><li><p>使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为</p></li><li><p>控制器对象可能变得高耦合和职责上低内聚</p></li><li><p>将处理系统事件消息的职责分配给代表以下选项之一的类：</p><ol><li>整个组织的业务(立面控制器)。</li><li>整个系统(外观控制器)。</li><li>在问题域中真实操作解决问题的人(角色控制器)。</li><li>自动化解决用例的模块(用例控制器)。</li></ol></li></ul></li><li><p>选择合适的控制风格</p><ul><li>控制风格：系统行为的逻辑在对象(组件)网络之间分布的方式</li><li><img src="image-20240428224338297.png" alt="image-20240428224338297"></li><li>集中式控制风格<ul><li>几个控制器记录所有系统行为的逻辑</li><li>优点：容易找到做出决定的地方，易于查看如何制定决策以及如何更改决策流程</li><li>缺点：控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库（增加耦合、破坏信息隐藏）</li></ul></li><li>委托式控制风格<ul><li>通过对象网络分配决策，由几个控制器进行主要决策</li><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ul></li><li>分散式控制风格<ul><li>所有系统行为都通过对象网络广泛传播</li><li>其特点是拥有许多组件，几乎没有数据，职责也很少。</li><li>缺点：很难理解控制流；组件无法独自完成很多工作，从而增加了耦合；隐藏信息是很难的；内聚性通常很差；很少有模块化原则可以满足。</li><li>完全靠对象自治的方式来实现自己的职责</li></ul></li><li>控制器设计启发<ul><li>避免大多数消息都来自单个组件的交互设计</li><li>保持组件较小</li><li>确保并非仅将全部职责分配给几个组件</li><li><strong>确保操作职责与数据职责一致</strong></li><li>避免要求每个组件发送许多消息的交互</li></ul></li></ul></li></ul><h3 id="为类间协作开发集成测试用例"><a href="#为类间协作开发集成测试用例" class="headerlink" title="为类间协作开发集成测试用例"></a>为类间协作开发集成测试用例</h3><ul><li>详细设计的集成测试<ul><li>类间协作的集成测试<ul><li>重点针对复杂逻辑(交互比较多)</li><li>自顶向下或者自底向上的集成</li><li><img src="image-20240429093620217.png" alt="image-20240429093620217"></li></ul></li><li>Mock Object（不是stub）<ul><li><img src="image-20240429093541455.png" alt="image-20240429093541455" style="zoom:50%;" /></li></ul></li><li>测试用例</li></ul></li></ul><h3 id="结构化详细设计"><a href="#结构化详细设计" class="headerlink" title="结构化详细设计"></a>结构化详细设计</h3><ul><li>结构化设计的思想<ul><li>分解是降低复杂度的一种方法</li><li>按算法的分解：自然的分解想法，分而治之</li><li>从数据流图向结构图的转换</li></ul></li><li>降低复杂度的方法<ul><li>分解：同一层次</li><li>抽象：从低层次抽象出高层次</li></ul></li><li>结构化设计<ul><li>结构化设计的重心：从数据流图到结构图</li><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li><li>转化过程:<ul><li>寻找到输入的最高抽象点和输出的最高抽象点</li><li>根据输入、输出的最高抽象点，对模块进行划分</li><li>然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图</li></ul></li><li>详细参考课本(201页)</li><li>例子<ul><li><img src="image-20240429094505931.png" alt="image-20240429094505931"></li><li><img src="image-20240429094516376.png" alt="image-20240429094516376"></li></ul></li></ul></li></ul><h3 id="详细设计文档描述和评审"><a href="#详细设计文档描述和评审" class="headerlink" title="详细设计文档描述和评审"></a>详细设计文档描述和评审</h3><ul><li>评审<ul><li><img src="image-20240429094834998.png" alt="image-20240429094834998"></li></ul></li><li>度量<ul><li>模块化度量</li></ul></li><li>测试<ul><li>协作测试</li></ul></li></ul><h2 id="13-模块化与信息隐藏"><a href="#13-模块化与信息隐藏" class="headerlink" title="13. 模块化与信息隐藏"></a>13. 模块化与信息隐藏</h2><h3 id="模块化与信息隐藏思想"><a href="#模块化与信息隐藏思想" class="headerlink" title="模块化与信息隐藏思想"></a>模块化与信息隐藏思想</h3><ul><li><strong>内聚和耦合</strong><ul><li>内聚（越高越好）：内聚表达的是一个模块内部的联系的紧密型：包括信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。</li><li><img src="image-20240429103022348.png" alt="image-20240429103022348"></li><li>耦合（越低越好）：耦合描述的是两个模块之间关系的复杂程度，包括内容耦合，公共耦合，重复耦合，控制耦合，印记耦合，数据耦合</li><li><img src="15.png"></li></ul></li><li>模块化<ul><li>模块定义：模块是一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标识符。</li><li>为什么要将系统进行模块化<ul><li>管理：分而治之</li><li>演进：分离系统的各个部分，以便将一个部分的更改与其他部分的更改隔离开<ol><li>直接性原则(将需求明确分配到模块，理想情况下一个或多个需求映射到一个模块)</li><li>连续性&#x2F;局部性原则(需求的微小变化仅触发对一个模块的更改)</li></ol></li><li>理解：促使我们的系统更加容易被理解<ol><li>作为思维大小的块的组成，例如7±2规则</li><li>一部分只有一个问题，例如本地性原则，封装，关注点分离</li></ol></li><li>关键问题：模块化使用什么标准？-&gt;<strong>信息隐藏</strong></li></ul></li><li>最有可能被改变的设计域<ul><li>硬件依赖</li><li>输入输出格式</li><li>非标准语言特点和库路径</li><li>复杂设计和实现</li><li>复杂数据结构</li><li>复杂逻辑</li><li>全局变量</li><li>数据规模限制</li></ul></li></ul></li><li>信息隐藏<ul><li>目的：为了使可能的改动本地化</li><li>过程<ul><li>最常见的隐藏是您认为可能会更改的设计决策。</li><li>然后，您可以通过将每个设计秘密分配给自己的类，子例程或其他设计单元来分离它们。</li><li>接下来，您隔离(封装)每个机密，这样，如果它确实发生了更改，则更改不会影响程序的其余部分。</li></ul></li><li>接口与实现<ul><li>接口：用户对模块的看法，仅描述用户使用模块需要知道的内容</li><li>原则<ol><li>显式接口：使模块之间的所有依赖关系明确(无隐藏的耦合)</li><li>低耦合-接口少：最小化模块之间的依赖性</li><li>接口规模小：将大型接口分为几个接口</li><li>高内聚：一个模块应该封装一些定义良好的，连贯的功能(稍后会详细介绍)</li></ol></li><li>耦合与内聚<ol><li>内聚力是模块之间的一致性的度量。</li><li>耦合是模块之间的交互程度。</li><li>需要高内聚和低耦合</li></ol></li></ul></li></ul></li><li>KWIC例子<ul><li>具体见PPT</li><li>第一种模块化：处理过程中的每个主要步骤都是一个模块</li><li>第二种模块化：<ol><li>信息隐藏：每个模块都有一个或多个”隐藏”<ol><li>行：字符&#x2F;行的存储方式</li><li>循环位移：旋转算法，旋转存储</li><li>字符表化：alpha的算法，alpha的惰性</li><li>每个模块都以其对设计决策的了解为特征，而对其他所有决策则都不了解。</li></ol></li></ol></li></ul></li></ul><h3 id="结构化的模块化"><a href="#结构化的模块化" class="headerlink" title="结构化的模块化"></a>结构化的模块化</h3><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><ul><li>概念<ul><li>耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。<ul><li>连接有多复杂：全局变量，范围；与其他模块的连接</li><li>连接是指模块本身还是模块内部的东西</li><li>应该对外提供什么和接收什么</li></ul></li></ul></li><li>耦合强度1——连接有多复杂<ul><li>原则1：全局变量是被认为是有害的<ul><li>封装减少耦合：抽象和分解<ul><li>将潜在的共享元素细分成组</li><li>将每个组的访问权限限制为最小的模块子集</li></ul></li></ul></li><li>原则二：如果没有特殊要求，让代码清晰一点</li><li>原则三：不要重复</li></ul></li><li>耦合强度2——连接是指模块本身还是模块内部的东西<ul><li>以其名称寻址或整体引用一个模块的连接产生的耦合，比引用另一个模块内部元素的连接产生的耦合低(整体连接的耦合程度低于模块内部元素连接的耦合)</li><li>原则四：面向接口编程</li></ul></li><li>耦合强度3——应该对外提供什么和接收什么<ul><li>数据耦合：发送必要数据的耦合</li><li>印记耦合：发送数据比刚好需要的多</li><li>控制耦合：除了数据还有控制信号</li><li>内容耦合：数据和控制元素的耦合</li><li>显然，印记耦合可以实现更多的数据耦合</li><li>控制耦合比数据耦合还耦合更多：信息隐藏</li></ul></li></ul><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><ul><li>概念<ul><li>实现独立模块的方式<ul><li>减少不在同一模块中的元素之间的关系</li><li>增加同一模块中元素之间的关系</li><li>内聚程度的度量：绑定</li></ul></li><li>内聚度(绑定的类型)<ul><li>偶然内聚 &lt; 逻辑内聚 &lt; 临时内聚 &lt; 交流内聚 &lt; 功能内聚 &lt; 信息内聚</li></ul></li></ul></li></ul><h3 id="模块化思想的应用"><a href="#模块化思想的应用" class="headerlink" title="模块化思想的应用"></a>模块化思想的应用</h3><ul><li>低耦合处理<ul><li>软件体系结构的分层设计中<ul><li>不同层的模块之间仅能通过程序调用与数据传递实现交互，不能共享数据(例如 Model 层建立⼀个数据对象并将引用传递给 Logic 层使用)否则会导致公共耦合。</li></ul></li><li>软件体系结构的逻辑包设计中<ul><li>依据功能的特点将三个层次进⼀步划分为更小的包，而不是只使用 Presentation、Logic和 Model 三个包，可以通过包分割实现接口最小化，这能去除不必要的耦合。</li></ul></li><li>软件体系结构的物理包设计中<ul><li>将不同包的重复内容独立为单独的包以消除重复，避免产生隐式的重复耦合</li></ul></li><li>详细设计中对象创建者的选择<ul><li>如果两个对象 A、B 间已有比较高的耦合度了, 那么使用 A 创建 B 或者反之就不会带来额外的耦合度</li></ul></li></ul></li><li>高内聚处理<ul><li>软件体系结构的分层设计中:<ul><li>三个层次都是高内聚的,⼀个处理交互任务, ⼀个处理业务逻辑,⼀个处理数据持久化。</li></ul></li><li>软件体系结构的逻辑包设计中:<ul><li>将三个层次进⼀步划分为更小的包,可以实现每个更小的包都是高内聚的。</li></ul></li><li>详细设计中抽象类的职责:<ul><li>要求状态与方法紧密联系就是为了达到高内聚 (信息内聚)。</li></ul></li><li>详细设计中使用控制风格:<ul><li>控制风格分离了控制逻辑，可以实现业务逻辑对象的高内聚(功能内聚)。因为封装了控制逻辑，所以控制器对象承载了不可避免的顺序内聚、通信内聚和逻辑内聚，这就要求控制器对象必须是受控的，也是它们为什么倾向于对外委托而不是自己进行业务计算的原因。</li></ul></li></ul></li></ul><h3 id="结构化的信息隐藏"><a href="#结构化的信息隐藏" class="headerlink" title="结构化的信息隐藏"></a>结构化的信息隐藏</h3><ul><li>Module Guide<ul><li>模块的主要秘密：主要秘密描述的是这个模块所要实现的<strong>用户需求</strong>。是设计者对用户需求的实现的⼀次职责分配。有了这个描述以后，我们可以利⽤它检查我们是否完成所有的⽤户需求，还可以利⽤它和需求优先级来决定开发的次序。</li><li>模块的次要秘密：次要秘密描述的是这个模块在实现职责时候所涉及的具体的<strong>实现细节</strong>。包括数据结构，算法，硬件平台等信息。</li><li>模块的角色：描述了独立的模块在整个系统中所承担的角色，所起的作用以及与哪些模块有相关联的关系</li><li>模块的对外接口：模块提供给别的模块的接口</li></ul></li><li>信息隐藏思想的应用<ul><li><img src="image-20240429183633558.png" alt="image-20240429183633558"></li><li><img src="image-20240429183643021.png" alt="image-20240429183643021"></li></ul></li></ul><h2 id="14-面向对象的模块化"><a href="#14-面向对象的模块化" class="headerlink" title="14. 面向对象的模块化"></a>14. 面向对象的模块化</h2><ul><li>模块化的原则(总结)<ul><li><img src="1-1746703986798.png" style="zoom: 67%;" /></li><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ul></li></ul><h3 id="面向对象中的模块和耦合"><a href="#面向对象中的模块和耦合" class="headerlink" title="面向对象中的模块和耦合"></a>面向对象中的模块和耦合</h3><ul><li>耦合中的结构方法与面向对象方法<ul><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ul></li><li>降低耦合的设计原则<ul><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ul></li></ul><h3 id="访问耦合"><a href="#访问耦合" class="headerlink" title="访问耦合"></a>访问耦合</h3><ul><li><img src="image-20240508093021579.png" alt="image-20240508093021579"></li><li>隐式耦合：Cascading Message 级联调用问题<ul><li>解决方案<ol><li>引入局部变量，避免隐式耦合，变为显式耦合，降低耦合度</li><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ol></li></ul></li><li>组件耦合原理<ul><li>原则四：面向接口编程<ul><li>编写所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块&#x2F;类约定：所需方法&#x2F;提供的方法</li><li>方法约定：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li></ul></li><li>原则五：迪米特法则<ul><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li></ul></li><li>原则六：接口隔离原则(ISP)&#x2F;也叫接口最小化原则<ul><li>面向更简单的接口编程</li><li>许多客户端专用接口比一个通用接口要好</li><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li></ul></li></ul></li></ul><h3 id="继承耦合"><a href="#继承耦合" class="headerlink" title="继承耦合"></a>继承耦合</h3><ul><li><p><img src="image-20240508093924254.png" alt="image-20240508093924254"></p></li><li><p>修改继承耦合</p><ul><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ul></li><li><p>精化继承耦合</p><ul><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母的引用，则需要整个父母和子女的修饰</li></ul></li><li><p>扩展继承耦合</p><ul><li>最好的继承耦合</li><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ul></li><li><p>降低继承耦合的方法</p><ul><li><p>原则七：里氏替换原则</p><ul><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。”</li><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ul></li><li><p>原则八：组合代替继承</p><ul><li><p>组合优于继承</p></li><li><p>使用继承实现多态</p></li><li><p>使用委托时不要继承复用代码</p></li><li><p>例子：</p><ul><li><img src="16.png" style="zoom: 67%;" /><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><img src="17-1746703995843.png" style="zoom: 67%;" /><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li><li><img src="18.png" style="zoom:50%;" />- Person持有Role，Passenger和Agent实现抽象接口PersonRole- Role可以是一个List</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="内聚-1"><a href="#内聚-1" class="headerlink" title="内聚"></a>内聚</h3><ul><li>衡量标准<ul><li>方法和属性保持一致<ul><li><img src="image-20240508101030667.png" alt="image-20240508101030667" style="zoom:67%;" /></li></ul></li><li>属性之间是否体现一个职责<ul><li><img src="image-20240508101047791.png" alt="image-20240508101047791"></li></ul></li><li>属性间是否可以抽象<ul><li><img src="image-20240508101511363.png" alt="image-20240508101511363"></li></ul></li></ul></li><li>方法内聚<ul><li>一个类中的方法是普通耦合</li><li>所有方法服务于一个职责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ul></li><li>原则九：单一责任原则(SRP)<ul><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的</li></ul></li></ul><h3 id="耦合和内聚的度量"><a href="#耦合和内聚的度量" class="headerlink" title="耦合和内聚的度量"></a>耦合和内聚的度量</h3><ul><li><p>类之间的耦合度量</p><ul><li>第一种度量:CBO(方法调用耦合)<ul><li>对象类之间的耦合(CBO)</li><li>CBO &#x3D; 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ul></li><li>第二种度量:DAC(数据抽象耦合)<ul><li>DAC &#x3D; 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ul></li><li>第三种度量:Ca和Ce(有效和)<ul><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ul></li><li>第四种度量:DIT 继承树的深度<ul><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性。</li></ul></li><li>第五种度量 Number of children (NOC) 子类的数量<ul><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ul></li></ul></li><li><p>类内聚程度衡量</p><ul><li><p>Lack of cohesion in methods (LCOM)</p></li><li><p><img src="28.png"></p><ul><li><p>交集为空则在P中，交集不为空则在Q中</p></li><li><p>值越低越好</p></li><li><p>还定义了许多其他版本的LCOM</p></li><li><p>如果LCOM&gt;&#x3D; 1，则应将类划分</p></li></ul></li></ul></li><li><p>Summary:Principles from Modularization 模块化的原则</p><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol></li></ul><h2 id="15-面向对象的信息隐藏"><a href="#15-面向对象的信息隐藏" class="headerlink" title="15. 面向对象的信息隐藏"></a>15. 面向对象的信息隐藏</h2><h3 id="封装类的职责"><a href="#封装类的职责" class="headerlink" title="封装类的职责"></a>封装类的职责</h3><ul><li><p>结构化中的信息隐藏</p><ul><li>每一个模块都隐藏了这个模块中关于重要设计决策的实现，以至于只有这个模块的每一个组成部分才能知道具体的细节</li><li>最重要的细节：职责的变更</li><li>次要的细节：实现的变更</li></ul></li><li><p>类的职责</p><ul><li><p>职责是类或对象维护一定的状态信息，并基于状态履行行为职能的能力</p></li><li><p>职责的体现：封装</p></li></ul></li><li><p>类的封装</p><ul><li>封装：一个模块应该通过稳定的接口对外体现其所承载的要求，而隐藏它对需求的内部实现细节</li><li>封装将数据和行为同时包含在类中，分离对外接口与内部实现</li><li>接口是模块的可见部分：描述了一个类中的暴露到外界的可见特征</li><li>实现被隐藏在模块之中：隐藏实现意味着只能在类内操作，更新数据，而不意味着隐藏接口数据</li><li>面向对象中的接口通常包含的部分<ul><li>对象之间交互的消息(方法名)</li><li>消息中的所有参数</li><li>消息返回结果的类型</li><li>与状态无关的不变量(前置条件和后置条件)</li><li>需要处理的异常</li></ul></li><li>封装实现的细节<ul><li>封装数据和行为</li><li>封装内部结构</li><li>封装其他对象的引用</li><li>封装类型信息</li><li>封装隐藏变更</li></ul></li><li>原则十：最小化类和成员的可访问性<ul><li>抽象化：抽象集中于对象的外部视图，并将对象的行为与其实现分开</li><li>封装形式：类不应公开其内部实现细节</li><li>权限最小化原则</li></ul></li></ul></li></ul><h3 id="为变更而设计"><a href="#为变更而设计" class="headerlink" title="为变更而设计"></a>为变更而设计</h3><ul><li><p>OCP (开闭原则，Open&#x2F;Close Principle) <strong>重要</strong></p><ul><li><p>修改很复杂，修改后需要重新编译，有一定代价</p></li><li><p>解决方案：使用多态依赖完成</p></li><li><p>例子（图一为修改前，图二为修改后）：</p><ul><li><img src="1-1746704008602.png" style="zoom:67%;" /></li><li><img src="17-1746704010148.png" style="zoom: 67%;" /></li></ul></li><li><p>开闭原则(OCP)：软件实体应该开放进行扩展，而封闭以进行修改</p><ul><li>对<strong>扩展</strong>开放：模块的行为可以被扩展，比如新添加一个子类</li><li>对<strong>修改</strong>关闭：模块中的源代码不应该被修改</li></ul></li><li><p>RTTI：运行时类型信息是丑陋并且危险的</p><ul><li><p>RTTI &#x3D; Run-Time Type Information RTTI &#x3D; 运行时类型信息</p></li><li><p>如果模块尝试将基类指针动态转换为多个派生类，则每次扩展继承层次结构时，都需要更改模块</p></li><li><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSquare</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        <span class="hljs-comment">//这里写法不合适</span><br>        <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Square) &#123;<br>            ((Square) shape).drawSquare();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Circle) &#123;<br>            ((Circle) shape).drawCircle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>都有draw方法，应该将draw放到shape里面</p></li></ul></li></ul></li><li><p>多态</p><ul><li>多态是指针对类型的语言限定，指的是不同类型的值能够通过统一的接口来操纵</li><li><img src="image-20240514200706623.png" alt="image-20240514200706623" style="zoom:67%;" /></li><li>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        shape.draw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>原则十二：DIP (Dependency Inversion Principle) 依赖倒置原则</p><ul><li>高级模块不应依赖于低级模块，两者都应依赖抽象；抽象不应该依赖细节，详细信息应取决于抽象</li><li>将接口从实现中分离出来 —— 抽象<ul><li>设计接口，而不是实现！</li><li>使用继承来避免直接绑定到类</li><li>实现依赖于接口</li></ul></li><li>例子：<ul><li><img src="23.png"></li><li>抽象：Writer，扩展的时候只需要被扩展类实现Writer</li></ul></li><li>抽象类&#x2F;接口：<ol><li>倾向于不经常改变</li><li>抽象是”铰接点”，在此更易于扩展&#x2F;修改</li><li>不必修改代表抽象(OCP)的类&#x2F;接口</li></ol></li><li>例外情况<ol><li>有些类很不可能修改<ol><li>因此对插入抽象层没有什么好处</li><li>示例：字符串类</li></ol></li><li>在这种情况下可以直接使用具体的类：在这种情况下可以直接使用具体的类…</li></ol></li><li>符合DIP的分层设计图参考课本256页</li></ul></li></ul><h2 id="16-设计模式"><a href="#16-设计模式" class="headerlink" title="16. 设计模式"></a>16. 设计模式</h2><h3 id="可修改性及其基本实现机制"><a href="#可修改性及其基本实现机制" class="headerlink" title="可修改性及其基本实现机制"></a>可修改性及其基本实现机制</h3><ul><li><p>可修改性</p><ul><li>实现的<strong>可修改性</strong>：涉及到大的场景的修改<ol><li>对已有实现的修改</li><li>例如：修改现有促销策略</li></ol></li><li>实现的<strong>可扩展性</strong>(DIP &amp; OCP)<ol><li>对新的实现的扩展</li><li>例如：增加一条新的促销策略(策略模式)</li></ol></li><li>实现的<strong>灵活性</strong><ol><li>对实现的动态配置</li><li>例如：动态修改更改某商品对应促销策略</li></ol></li></ul></li><li><p>可修改性的实现</p><ul><li><p>接口与实现的分离</p><ul><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。</li></ul></li><li><p>继承的优点</p><ul><li>虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。</li><li>子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。</li></ul></li><li><p>继承的缺点</p><ul><li>继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。</li><li>而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改。</li></ul></li><li><p>组合</p><ul><li><p>利用接口的组成关系，能在实现接口和实现的前提下，体现更好的灵活性。</p></li><li><p>优点</p><ol><li>前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。</li><li>后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。</li></ol></li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>概念<ul><li>设计模式：抽象一个重复的设计结构</li><li>包含类和&#x2F;或对象</li><li>提炼设计经验</li><li><strong>设计模式重点掌握类图</strong></li></ul></li><li>分类<ul><li>策略模式：减少耦合、依赖倒置。</li><li>抽象工厂模式：职责抽象、接口重用。</li><li>单件模式：信息隐藏、职责抽象。</li><li>迭代器模式：减少耦合、依赖倒置。</li></ul></li><li>策略模式<ul><li>策略模式：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li><li>参与者<ul><li>上下文（Context）:<ol><li>被配置了具体策略Concrete Strategy</li><li>拥有Strategy对象的一个引用</li><li>实现了一些方法以供Strategy访问其数据</li></ol></li><li>策略（Strategy）: 声明了所支持策略的接口。Context利用这些被Concrete Strategy定义的接口。</li><li>具体策略（Concrete Strategy）: 实现了Strategy声明的接口，给出了具体的实现。</li></ul></li><li>应用场景<ul><li>当很多相关类只在它们的行为的实现上不一样。策略模式提供了一个很好的方式来配置某个类，让其具有上述多种实现之一。</li><li>当我们需要同一个行为的不同实现（变体）的时候。策略模式可以用作实现这些变体。</li><li>算法需要用到一些数据，而这些数据不应该被客户知道。我们可以通过策略模式隐藏复杂的算法和数据接口。</li><li>一个类定义了很多行为，这些行为作为一个switch选择语句的分支执行部分。策略模式可以消除这些分支选择。</li></ul></li><li>类图<ul><li><img src="image-20240516152505556.png" alt="image-20240516152505556"></li></ul></li></ul></li><li>抽象工厂模式<ul><li>工厂模式就是为对象的创建提供一个接口，将具体创建的实现封装在接口之下，这样具体创建的实现的改变就不会对客户代码Client类产生影响。从而降低了Client类和多个具体类的耦合。</li><li><img src="image-20240516152625441.png" alt="image-20240516152625441" style="zoom:50%;" /></li><li>应用场景<ul><li>抽象工厂模式可以帮助系统独立于如何对产品的创建、构成、表现。</li><li>抽象工厂模式可以让系统灵活配置拥有某多个产品族中的某一个。</li><li>一个产品族的产品应该被一起使用，抽象工厂模式可以强调这个限制。</li><li>如果你想提供一个产品的库，抽象工厂模式可以帮助暴露该库的接口，而不是实现。</li></ul></li><li><img src="image-20240516152357093.png" alt="image-20240516152357093" style="zoom:67%;" /></li><li>类图<ul><li><img src="image-20240516152522467.png" alt="image-20240516152522467" style="zoom: 50%;" /></li></ul></li><li>工厂接口可以通过抽象工厂模式的专门的接口来实现，另外也可以通过父类的工厂方法，来让子类继承相应的工厂接口，这就是工厂方法模式</li></ul></li><li>单件模式<ul><li>在有些场景中，对于某个类，在内存中只希望有唯一一个对象存在。每次想得到这个类的一个对象的引用的时候，都指向唯一的那个对象。无论我创建多少次这个类的对象，其实总共还是只创建了一个对象。</li><li>类图<ul><li><img src="image-20240516152916693.png" alt="image-20240516152916693" style="zoom:50%;" /></li></ul></li><li>设计分析<ul><li><img src="image-20240516153424625.png" alt="image-20240516153424625"></li></ul></li></ul></li><li>迭代器模式<ul><li>当需要接受某个参数（如链表、散敛表）并对其进行迭代，将参数类型设为Collection</li><li>类图<ul><li><img src="image-20240516153154670.png" alt="image-20240516153154670" style="zoom:50%;" /></li></ul></li><li>参与者：<ul><li>迭代器（Iterator）： 迭代器定义访问和遍历元素的接口</li><li>具体迭代器（ConcreteIterator）：具体迭代器实现迭代器接口。对该聚合遍历时跟踪当前位置。</li><li>聚合（Aggregate）：聚合定义创建相应迭代器对象的接口。</li><li>具体聚合(ConcreteAggregate)：具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</li></ul></li><li>应用场景：<ul><li>访问一个聚合对象的内容而无需暴露它的内部实现。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ul></li></ul></li></ul><h2 id="17-软件构造"><a href="#17-软件构造" class="headerlink" title="17. 软件构造"></a>17. 软件构造</h2><ul><li>概述<ul><li>定义：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，⽣产可⼯作的、有意义的软件的详细创建过程。</li><li>软件构造是设计的延续<ul><li>设计是<strong>规划软件构造方法</strong>的过程，实现是依据<strong>规划的软件构造方案建造真正产品</strong>的过程</li><li>源程序是软件构建方案的<strong>最后一个规划</strong>，不是产品本身，真正的产品是运行于计算机上的由二进制代码组成的可执行程序。</li><li>源程序的生产过程-编程，属于设计活动，编译器完成的编译和链接才是依据规划建造软件产品的实现活动。</li><li><strong>编程不是一个简单的活动，核心是编码的设计</strong>。</li></ul></li><li>软件构造活动包含详细设计、编程、测试、调试、代码评审、集成与构建、构造与管理</li></ul></li></ul><h3 id="软件构造活动"><a href="#软件构造活动" class="headerlink" title="软件构造活动"></a>软件构造活动</h3><ul><li>详细设计<ul><li>概述<ul><li>有些项目会将主要的详细设计工作分配在软件构造阶段完成。</li><li>无论是哪种项目，在软件构造阶段都不可避免的会设计到详细设计的调整工作。因为编程语言是软件设计的一个重要约束，随着编程工作的进行和约束，人们可能会发现与预想不一致的情况和更多的约束，这个时候就需要在软件构造阶段修改详细设计方案。</li><li>软件构造阶段详细设计使用的方法与技术与软件设计阶段是一样的，只是应用在<strong>更小</strong>的规模上。</li><li>详细设计已经包含实际的代码实现了，不同编程语言的代码行数不同。</li></ul></li><li>程序代码的典型质量<ul><li>易读性：让软件更容易开发，尤其是易于调试；可以使的程序更加容易维护，减少理解代码的难度和成本：降低交流的成本，自己写完之后要修正代码使其易读。</li><li>易维护性:要求代码易读、易修改，增量开发，关键业务流程应该是易于扩展的</li><li>可靠性：执行正确，并能妥善处理故障。</li><li>性能：高性能，包括时间性能和空间性能，需要设计数据结构和算法设计。</li><li>安全性：不留系统漏洞，不出现重要信息的泄露(内存数据区泄露)</li></ul></li></ul></li><li>编程的主要技术<ul><li><img src="1-1746704036532.png" style="zoom:80%;" /></li></ul></li><li>测试、调试<ul><li>通常来说，程序员每修改⼀次程序就会进行最少⼀次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到了要求，没有程序错误。集成测试⼀般在单元测试之后，用来测试多个单元之间的接口是否编程正确。</li><li>调试过程可以分为三个部分：重现问题、诊断缺陷和修复缺陷。</li><li>重现问题的方法<ul><li><img src="4-1746704038583.png" style="zoom:80%;" /></li></ul></li><li>寻找和定位缺陷的方法<ul><li>灵活使用编译器提示。</li><li>持续缩小嫌疑代码的范围。</li><li>检查刚刚修改过的部分。</li><li>警惕已出现缺陷和常见缺陷。</li><li>利用工具。</li></ul></li><li><img src="6-1746704040318.png" style="zoom: 67%;" /></li><li>修复缺陷注意点<ul><li>⼀次只修复⼀个缺陷。</li><li>修改前保留旧版本的备份，如果项目使用了配置管理系统，这个工作会由配置管理工具完成，否则就需要由程序员手动完成。</li><li>使用测试和评审验证修复的有效性。</li><li>检查和修复类似的缺陷，这可以在代码搜索、程序切片等工具的帮助下进行。</li></ul></li></ul></li><li>代码评审<ul><li>代码评审对代码的系统检查，通常是通过同行专家评审来完成的。通过评审会议可以发现并修正之前忽略的代码错误，从而同时提高软件的质量和开发者的技巧。</li><li>代码评审⼀般分为正式评审、轻量级评审和结对编程。</li></ul></li><li>集成与构建<ul><li><img src="10.png" style="zoom: 80%;" /></li></ul></li><li>构造与管理<ul><li><img src="11-1746704043879.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="实践方法"><a href="#实践方法" class="headerlink" title="实践方法"></a>实践方法</h3><ul><li>重构<ul><li>概念：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。</li><li>重构的时机：<ul><li>增加新的功能时</li><li>发现了缺陷进行修复时</li><li>进行代码评审时</li></ul></li><li>代码的“坏味道”<ul><li><img src="image-20240528210426534.png" alt="image-20240528210426534"></li></ul></li><li>详见课本290页</li></ul></li><li>测试驱动开发<ul><li>测试驱动开发又被称为测试优先（Test First）的开发，随着极限编程方法的普遍应用而得到普及。</li><li>测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。测试代码通常由测试工具自动装载执行，也可以由程序员手工执行。完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性。</li><li><img src="image-20240528210620336.png" alt="image-20240528210620336" style="zoom: 67%;" /></li></ul></li><li>结对编程<ul><li>概念<ul><li>两位程序员并排工作，在相同的设计，算法，代码或测试上进行协作</li><li>一个程序员(驱动程序)可以控制键盘&#x2F;鼠标并主动执行程序</li><li>另一个程序员(观察员)不断观察驾驶员的工作，以发现战术上的(语法上的，拼写的等)缺陷，并从战略上考虑工作的方向</li><li>根据需要，两位程序员可以集思广益解决任何难题</li><li>两位程序员定期切换角色，他们平等地合作开发软件</li></ul></li><li>为什么结对编程有效？<ul><li>双压力：彼此保持专注并专注于任务</li><li>配对思考：为任务带来不同的先前经验</li><li>配对中继：每个人依次为自己的知识和能力做出最大贡献，然后坐下来思考，而他们的伴侣继续奋斗</li><li>配对审查<ol><li>持续的设计和代码审查</li><li>极高的缺陷去除效率</li><li>消除程序员对评论的厌恶</li><li>在所有(单独)程序员中，有80％都不定期或根本不这样做</li><li>预防缺陷总是比消除缺陷更有效</li></ol></li><li>配对调试：成对谈论问题可能会导致解决方案变得显而易见</li><li>配对学习：持续审核-&gt;向合作伙伴学习技术，语言知识，领域等。</li></ul></li></ul></li><li>有建设性的想法（具体见PPT）<ul><li>十年的软件建设进展</li><li>现代软件建设的十个现实情况</li><li>1990年代和2000年代最糟糕的建筑思想</li></ul></li></ul><h2 id="18-代码设计"><a href="#18-代码设计" class="headerlink" title="18. 代码设计"></a>18. 代码设计</h2><ul><li><p>设计易读的代码</p><ul><li>布局格式<ul><li>用缩进与对齐表达逻辑结构</li><li>将相关逻辑组织在一起（成员变量声明、构造方法和析构方法、public方法……）</li><li>将空行分隔逻辑(将大规模的逻辑划分的片段进行分隔)</li><li>将语句进行分隔(将过长的语句分隔到几行中进行显示)</li></ul></li><li>命名<ul><li>使用有意义的名称进行命名</li><li>名称要与实际内容相符</li><li>如果存在惯例，命名时要遵守惯例</li><li>临时变量命名要符合常规</li><li>不要使用太长的名称</li><li>不要使用易混字符进行命名</li><li>不要仅仅使用不易区分的多个名称（例如Sales与Sale）</li><li>不要使用没有任何逻辑的字母缩写进行命名</li></ul></li><li>注释<ul><li>语句注释（&#x2F;&#x2F;）</li><li>标准注释(&#x2F;* *&#x2F;)</li><li>文档注释(&#x2F;** *&#x2F;)</li><li>注释要有意义，不要简单重复代码的含义</li><li>重视对数据类型的注释</li><li>重视对复杂控制结构的注释</li></ul></li><li>javadoc<ul><li><img src="image-20240530104046105.png" alt="image-20240530104046105" style="zoom: 60%;" /></li><li><img src="image-20240530104115367.png" alt="image-20240530104115367" style="zoom:50%;" /></li></ul></li></ul></li><li><p>设计易维护的代码</p><ul><li><p>小型任务</p><ul><li>要让程序代码可修改，就要控制代码的复杂度。这首先要求每个函数或⽅法的代码应该是内聚的，恰好完成⼀个功能与⽬标。</li><li>如果内聚的代码本身比较简单，复杂性可控，那么它就具有比较好的可维护性。反之，内聚的代码也可以比较复杂，典型表现是完成⼀个功能需要多个步骤、代码比较长，那么就需要将其进⼀步分解为多个高内聚、低耦合的小型任务。</li></ul></li><li><p>复杂决策</p><ul><li><p>使用新的布尔变量简化复杂决策</p><img src="image-20240530104850436.png" alt="image-20240530104850436" style="zoom:50%;" /></li><li><p>使用有意义的名称封装复杂决策</p><img src="image-20240530104804574.png" alt="image-20240530104804574" style="zoom:50%;" /></li><li><p>表驱动编程</p><ul><li><img src="image-20240530105007694.png" alt="image-20240530105007694" style="zoom: 67%;" /></li><li><img src="image-20240530105028512.png" alt="image-20240530105028512"></li></ul></li></ul></li><li><p>数据使用</p><ul><li><img src="image-20240530105101590.png" alt="image-20240530105101590"></li></ul></li><li><p>明确依赖关系</p><ul><li>类之间模糊的依赖关系会影响到代码的理解与修改，非常容易导致修改时产生未预期的连锁反应</li></ul></li></ul></li><li><p>设计可靠的代码</p><ul><li>契约式设计——异常方式<ul><li><img src="image-20240530105257449.png" alt="image-20240530105257449" style="zoom:67%;" /></li></ul></li><li>契约式设计——断言方式<ul><li><img src="image-20240530105323619.png" alt="image-20240530105323619"></li><li><img src="image-20240530105351501.png" alt="image-20240530105351501" style="zoom: 50%;" /></li></ul></li><li>防御式编程<ul><li>防御式编程的基本思想是：在⼀个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害。</li><li>异常和断言都可以⽤来实现防御式编程，两种实现方式的差异与契约式设计的实现⼀样</li></ul></li></ul></li><li><p>使用模型辅助设计复杂代码</p><ul><li>决策表<ul><li><img src="image-20240530105808943.png" alt="image-20240530105808943" style="zoom:50%;" /></li><li><img src="image-20240530105821325.png" alt="image-20240530105821325"></li></ul></li><li>伪代码<ul><li><img src="image-20240530105846470.png" alt="image-20240530105846470"></li></ul></li><li>程序流程图<ul><li><img src="image-20240530105908073.png" alt="image-20240530105908073"></li></ul></li></ul></li><li><p>为代码开发单元测试用例</p><ul><li>为方法开发测试用例<ul><li><img src="image-20240530112339238.png" alt="image-20240530112339238" style="zoom: 50%;" /></li><li><img src="image-20240530112541314.png" alt="image-20240530112541314"></li></ul></li><li>为类开发测试用例<ul><li>在复杂类中，常常有着多变的状态，每次⼀个方法的执行改变了类状态时，都会给其他方法带来影响，也就是说复杂类的多个方法间是互相依赖的。</li><li>所以，除了测试类的每⼀个方法之外，还要测试类不同方法之间的互相影响情况。</li><li><img src="image-20240530112523161.png" alt="image-20240530112523161"></li></ul></li></ul></li><li><p>代码复杂度度量</p><ul><li>程序复杂度是造成各种编程困难的主要原因。为了帮助程序员处理程序复杂度，人们提出了<br>很多程序复杂度的度量手段，其中McCabe的圈复杂度[McCabe1976]得到了比较大的关注</li><li><img src="image-20240530113030652.png" alt="image-20240530113030652" style="zoom:50%;" /></li><li><img src="image-20240530113043738.png" alt="image-20240530113043738" style="zoom:50%;" /></li><li><img src="image-20240530113136053.png" alt="image-20240530113136053" style="zoom: 50%;" /></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>关闭隐式声明</li><li>声明全部的变量</li><li>遵循某种命名规则</li><li>检查变量名</li></ul></li><li>变量初始化<ul><li><img src="image-20240530192031434.png" alt="image-20240530192031434" style="zoom: 50%;" /></li></ul></li><li>作用域<ul><li>使变量应用局部化（空间）</li><li>尽可能缩短变量的存活时间（时间）</li></ul></li><li>持续性<ul><li>在程序中加⼊调试代码或者断言来检查那些关键变量的合理取值</li><li>编写代码时要假设数据并没有持续性</li></ul></li><li>数值理论<ul><li>避免使用“神秘数值”</li><li>如果需要，可以使用硬编码的0和1</li><li>预防除0的错误</li><li>避免混合类型的比较</li><li>使类型转换变得明显</li></ul></li></ul></li><li><p>⼀般控制问题</p><ul><li>布尔表达式<ul><li>用true和false做布尔判断</li><li>简化复杂的表达式</li><li>编写肯定形式的布尔表达式（isEmpty）</li><li><img src="image-20240530192745794.png" alt="image-20240530192745794" style="zoom:50%;" /></li></ul></li><li>复合语句<ul><li>把括号对⼀起写出</li><li>y6括号被条件表达清楚</li></ul></li><li>空语句<ul><li><img src="image-20240530193054565.png" alt="image-20240530193054565" style="zoom:50%;" /></li></ul></li><li>驯服危险的深层嵌套<ul><li><img src="image-20240530193149087.png" alt="image-20240530193149087" style="zoom:50%;" /></li></ul></li></ul></li></ul><h2 id="19-软件测试"><a href="#19-软件测试" class="headerlink" title="19. 软件测试"></a>19. 软件测试</h2><ul><li>概念<ul><li>软件正确性：在且仅在以下情况下，才根据规范S考虑程序P：对于每个有效输入，P的输出均符合规范S</li></ul></li><li>V&amp;V<ul><li>Verification: 验证，检查开发者是否正确地使用技术建立系统，确保系统能够在于其的环境中按照技术要求正确地运行。例如：“检查需求文档中的书写错误”，“发现设计思路的不完善”</li><li>Validation: 确认，检查开发者是否建立了正确的系统，确保最终产品符合规格。例如：“需求文档能否反应用户真实意图”，“代码是否按照需求与设计要求编写”</li><li>V＆V通常是指试图确保软件按要求运行的任何活动，差异无关紧要。(见课本320页,重要，会考V&amp;V)</li><li>软件开发的验证与确认主要有两种手段：<strong>静态分析</strong>与<strong>动态测试</strong></li><li><img src="image-20240611161053160.png" alt="image-20240611161053160" style="zoom: 50%;" /></li></ul></li><li>静态分析<ul><li>仅基于(手动或自动)检查软件模型和代码的项目文档以及有关需求和设计的其他相关信息，通常会产生有效的结果，但精度可能较弱。容易产生误报，因为多态的存在导致很多只能在运行的时候才报错。</li><li>评审是最常用的静态分析手段</li><li>传统静态技术–大量手动操作，容易出错，耗时<ol><li>软件检查–根据已编译的常见和历史缺陷清单，对生成的文档(可交付成果)进行逐步分析</li><li>软件评审–将工作产品的不同方面呈现给项目人员(经理，用户，客户等)和其他感兴趣的涉众以征求意见或批准的过程</li><li>阅读代码–对生成的代码进行桌面分析，以发现不违反样式或语法的键入错误</li><li>算法分析和跟踪–可以得出所用算法的复杂性以及最坏情况，平均情况和概率分析评估的过程</li></ol></li></ul></li><li>动态测试<ul><li>在软件运行时考察软件运行时的表现，完成验证与确认</li><li>动态分析技术<ul><li>测试：基于对有价输入的代码执行(必要时必须包括表征系统状态的参数和环境条件的定义)</li><li>性能分析：程序配置文件记录了一组受控执行过程中某些感兴趣的实体出现的次数</li></ul></li></ul></li><li>软件测试<ul><li>目的<ul><li>向开发者和用户展示软件满足了需求，表明软件产品是一个合格的产品</li><li>找出软件中的缺陷和不足</li></ul></li><li>测试用例<ul><li><img src="image-20240611161633280.png" alt="image-20240611161633280" style="zoom: 33%;" /></li></ul></li><li>桩与驱动<ul><li>桩程序是被测试部件的交互环境，他扮演被测试部件需要调用的其他系统部件。桩程序对其他系统部件的扮演仅限于规格相同，内部代码要简单的多，通常是直接返回固定数据或者按照固定规则返回数据。</li><li>驱动程序负责创建被测试部件的执行环境，并驱动和监控被测试部件执行测试用例的过程，判定测试用例的执行结果。</li><li><img src="image-20240611161721076.png" alt="image-20240611161721076" style="zoom: 33%;" /></li></ul></li><li>测试层次<ul><li><img src="image-20240611162004576.png" alt="image-20240611162004576" style="zoom: 80%;" /></li><li>开发者主要是进行单元测试，可以进行一定程度上的集成测试和系统测试</li><li>看一下α和β测试</li></ul></li><li>单元测试<ul><li><img src="image-20240611162115903.png" alt="image-20240611162115903" style="zoom: 33%;" /></li><li>在过程化编程中，一个单元就是一个函数与过程。</li><li>在面向对象编程中，一个单元就是类的一个方法。</li><li>发现技术缺陷和代码缺陷</li></ul></li><li>集成测试<ul><li><img src="image-20240611162205907.png" alt="image-20240611162205907" style="zoom: 60%;" /></li><li><img src="image-20240611162226820.png" alt="image-20240611162226820" style="zoom:60%;" /></li></ul></li><li>系统测试：关注不符合需求的缺陷和需求自身的内在缺陷。根据测试目标的不同，有很多不同类型的系统测试：功能测试、非功能性测试、验收测试、安装测试等等。</li></ul></li><li>软件测试技术<ul><li>随机测试：根据软件工程师的技能、直觉和对类似程序的经验，从所有可能的输入值中选择输⼊子集，建立测试用例。</li><li>黑盒测试：将测试对象作为一个黑盒子，完全基于输入和输出数据来判断测试对象的正确性。<ul><li>把所有可能的输入数据，即程序的输入域划分为若干部分(子集)，从每个子集中选取少量具有代表性的数据作为测试用例。</li><li>等价类划分：将输入域分为有效等价类和无效等价类。有效等价类指对系统规格说明来说合理的输入，无效等价类与之相反。设计测试用例时要同时考虑两种等价类。</li><li>边界值分析：对定价类划分的补充，错误容易发生在各个等价类的边界上，而不是等价类的内部，因此针对边界情况设计测试用例，可以发现更多的缺陷。</li><li>决策表是为复杂逻辑判断设计测试用例的技术。决策表是由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。（具体见18代码设计或者书P311）</li><li>状态转换是针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定。状态转换包含有效转换和无效转换，只有在复杂情况和可靠性要求较高的情况下才会为无效转换设计测试用例。</li></ul></li><li>白盒测试：将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。<ul><li>语句覆盖：设计测试用例的标准是确保被测试对象的每⼀行程序代码都⾄少执行⼀次。</li><li>条件覆盖：设计测试用例的标准是确保程序中每个判断的每个结果都⾄少满足⼀次</li><li>路径覆盖：测试用例的标准是确保程序中每条独立执行路径都⾄少执行⼀次</li></ul></li><li>特定测试技术和面向对象的测试技术略</li></ul></li><li>测试活动（P332）<ul><li>测试计划:在开始具体的软件测试活动之前，必须首先进行测试计划，以明确测试的工作范围、资源与成本、基本策略、进度安排等。</li><li>测试设计:测试的成功取决于有效设计的测试用例</li><li>测试执行:执行测试前需要选择好测试工具</li><li>测试评价:在测试完成后，必须评价测试结果</li></ul></li><li>测试度量<ul><li>缺陷数据：分类汇总测试过程中发现的缺陷</li><li>测试覆盖率<ul><li>需求覆盖率&#x3D;被测试的需求数量&#x2F;需求总数</li><li>模块覆盖率&#x3D;被测试的模块数量&#x2F;模块总数</li><li>代码覆盖率&#x3D;被测试的代码行&#x2F;代码行数</li></ul></li></ul></li></ul><h2 id="20-软件交付"><a href="#20-软件交付" class="headerlink" title="20. 软件交付"></a>20. 软件交付</h2><ul><li>概念<ul><li>软件交付是软件项目的结束阶段，标志着软件开发任务的完成</li><li>软件交付是软件开发与软件维护两个既连续又不同的软件产品生存状态的分水岭。</li><li>只有做好软件交付工作，才是真正地完成整个项目。</li></ul></li><li>安装<ul><li>概念：安装是软件交付的最常见形式，现在大多数产品都通过安装的形式交付，它要求开发团队创建一个安装包，用户可以通过的执行将软件产品部署到工作环境。</li><li>创建安装包的步骤<ul><li>确定安装环境<ol><li>确定安装包需要<strong>支持的操作系统</strong>，这既需要考虑当前用户的工作环境，又需要考虑产品未来的市场规划；</li><li>确定软件产品的语言支撑环境，例如使用Java语言开发的软件产品就需要安装JDK；</li><li>确定软件产品需要的软件支持，例如数据库系统、网络系统等；</li><li>确定硬件等其他要求，例如有些软件产品可能会要求扫描仪、视频卡、通信设备等特殊硬件。</li></ol></li><li>列举安装清单<ol><li>要根据软件产品的实现情况，结合所需的环境支撑，列举需要安装的文件、初始化数据、注册表等清单信息，要清楚<strong>标明它们在安装后将会出现的位置</strong>。</li><li>在考虑安装位置时要遵守一致性，标记名称的使用要意义清楚，让用户能便利地找出相应文件。</li></ol></li><li>设计和建立安装包：要对安装包进行详细的设计，包括一个渐进的安装步骤，各步骤的人机交互方式等等。完成设计后就可以使用安装工具创建安装包。</li><li>测试安装包：安装包需要在目标环境中进行安装测试，以发现可能的问题。必须以用户的工作环境为<strong>目标环境</strong>进行测试，因为用户使用的机器环境与开发者的机器环境有很大的不同</li></ul></li></ul></li><li>部署<ul><li>背景：在软件产品比较复杂时，仅仅通过一个安装包无法完成软件交付任务，这时可以使用另一种常见的软件交付方式——部署。</li><li>概念：部署通常是由开发人员直接操纵软件产品的目标环境，使得软件产品能够在目标环境中正常运行。</li><li>部署的步骤<ul><li>确定部署环境：需要对目标环境进行调查分析，搞清楚部署前的环境细节，然后才能与软件产品需要的环境细节进行比较，明确需要执行的部署任务。具体来说，软件部署需要了解服务器与网络拓扑、安全控制与权限管理、软硬件系统的配置信息等。</li><li>确定部署任务：将软件产品需要的目标环境与部署前的环境进行比较，分析二者之间的差距，并将其确立为部署的任务。确定任务之后，还需要以渐进的方式安排任务之间的执行次序。</li><li>完成部署准备：有些部署工作可以完全依靠现场执行，但多数的部署任务需要进行一定的事前准备，尤其是要综合考虑部署工作可能出现的各种情况，制定完备的应对方案。</li><li>执行部署任务</li></ul></li></ul></li><li>培训与文档支持<ul><li>培训<ul><li>培训主要是教会用户使用软件产品的功能来完成其工作和任务。依据任务的不同，要为不同的用户进行不同类型的培训。</li><li>尤其不能忽略的是对<strong>系统管理员</strong>进行培训。要培训系统管理员如何启动和运行新系统、如何配置系统、如何授权或拒绝对系统的访问、如何支持用户、如何处理异常等。</li><li>只介绍能够帮助用户完成主要工作和任务的功能。对于一些很少会被使用并且<strong>不太重要</strong>的功能，即使培训也会很快被用户忘记，可以让用户使用<strong>文档支持</strong>来学会使用。</li><li>培训时，要关注用户的工作和任务，不必涉及系统的内部操作，不必知道系统的存储方式、访问方式和权限控制方式。</li></ul></li><li>文档支持<ul><li>用户文档：用户文档是指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。</li><li><img src="image-20240611202441645.png" alt="image-20240611202441645" style="zoom:50%;" /></li><li>系统管理员文档：与用户文档注重系统使用细节不同，系统管理员文档更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。</li></ul></li></ul></li><li>项目评价<ul><li>常见的项目评价针对四个方面：<ol><li>项目管理：可以帮助建立对项目的更准确认知，例如常见的管理问题与偏差、时间与成本耗费分布等。</li><li>产品：可以帮助开发者建立对产品的更准确认知，提高产品的开发经验。</li><li>团队：可以帮助开发者更好地组织分工，也可以帮助团队建立更好的沟通与交流途径。</li><li>个人：可以帮助开发者更准确认知自己的生产力，学习常见问题及其处理方法，了解自己的长处和不足并持续提高。</li></ol></li><li>项目评价方法<ul><li>评审：项目评审通过评审重要项目制品的方法来评价项目，这些重要制品包括项目计划、管理文档、会议记录、历史数据等。</li><li>度量数据分析：度量数据可以提供丰富的信息，通过分析这些信息，开发团队可以获取正确和深入的结论。</li></ul></li></ul></li></ul><h2 id="21-软件的维护与演化"><a href="#21-软件的维护与演化" class="headerlink" title="21. 软件的维护与演化"></a>21. 软件的维护与演化</h2><ul><li>概念<ul><li>软件维护只需要完成少量的使用帮助、故障解决和磨损处理等工作</li><li>修改软件的代价非常高，软件维护的重点在于软件修改和变更上。</li><li>软件变更的常见场景<ul><li>问题发生了改变</li><li>环境发生了改变</li><li>软件产品中存在缺陷</li></ul></li></ul></li><li>软件维护类型划分<ul><li>完善性维护：为了满足用户新的需求、增加软件功能而进行的软件修改活动。</li><li>适应性维护：为了使软件能适应新的环境而进行的软件修改活动。</li><li>修正性维护：为了排除软件产品中遗留缺陷而进行的软件修改活动。</li><li>预防性维护：为了让软件产品在将来可维护，提升可维护性的软件修改活动。<ol><li>随着持续的修改，软件的复杂度会上升，质量会下降。预防性修改是为了解决上述问题而进行的软件调整，是一种特殊类型的”修改”</li><li>只有这一种维护是根源于软件维护中的规律性。</li></ol></li></ul></li><li>前期(开发阶段)更充分的准备可以减轻后期维护的压力和困难<ul><li>考虑软件的可变更性：预测变更并将其独立封装，便于修改时的程序定义与理解，防止修改时的连锁反应</li><li>为降低维护困难而开发<ul><li>编写详细的技术文档并保持及时更新。</li><li>保证代码的可读性。</li><li>维护需求跟踪链。<ol><li>需求跟踪链从正反两个方向纪录”需求、设计、编码、测试”之间的跟踪与回溯关系</li></ol></li><li>维护回归测试基线。<ol><li>回归测试基线包含了系统修改之前的有效测试用例集合， 因此只需要根据修改情况对回归测试基线进行简单的修正</li></ol></li></ul></li></ul></li><li>软件维护过程<ul><li><img src="2.png" style="zoom:67%;" /></li></ul></li><li>软件演化生命周期<ul><li><img src="4-1746704106380.png" style="zoom: 67%;" /></li><li>初始开发<ul><li>初始开发阶段按照传统的软件开发方式完成第一个版本的软件产品开发。第一版的软件产品可以实现全部需求，也可以(通常是)只包含部分需求——对用户来说非常重要和紧急的最高优先级需求。</li><li>初始阶段的一个极其重要的工作是建立一个好的软件体系结构</li></ul></li><li>演化<ul><li>在完成初始开发之后，软件产品就进入演化阶段。该阶段可能会有预先安排的需求增量，也可能完全是对变更请求的处理，它们的共同点都是保持软件产品的持续增值，让软件产品能够满足用户越来越多的需要，实现更大的业务价值</li><li>演化阶段的软件产品要具备两个特征：<ol><li>软件产品具有<strong>较好的可演化性</strong>。一个软件产品在演化过程中复杂性会逐渐增高，可演化性会逐渐降低直至无法继续演化。</li><li>软件产品能够帮助用户实现较好的<strong>业务价值</strong>。只有这样，用户才会继续需要该产品，并持续提供资金支持。</li></ol></li><li>如果在演化过程中，一个软件产品开始不满足第(2)条特征，那么该产品就会提前进入停止阶段。如果软件产品满足第(2)条的同时不满足第(1)条特征，那么该产品就会进入服务阶段。</li></ul></li><li>服务<ul><li>服务阶段的软件产品不再持续的增加自己的价值，而只是周期性的修正已有的缺陷。</li></ul></li></ul></li><li>软件维护与演化的技术<ul><li>遗留软件<ul><li>如果遗留软件已经没有使用价值，就直接丢弃该软件。</li><li>如果遗留软件还有使用价值，但是其维护的成本效益比低于新开发一个软件系统的成本效益比，那么冻结遗留软件，将其作为一个新的更大系统的组成部分进行使用。</li><li>如果遗留软件的成本效益比低于新开发一个软件系统的成本效益比，而且该遗留软件仍然具备较好的可维护性，那么就逆向工程遗留软件并继续维护一段时间；</li><li>如果遗留软件的成本效益比高于新开发一个软件系统的成本效益比，而且该遗留软件已经不具备可维护性，那么就修改系统使其获得新生(即再工程该系统)，然后继续维护再造后的系统。</li></ul></li><li>逆向工程<ul><li>处理遗留软件时，维护人员接受的维护对象可能是一个没有任何文档也没有程序源代码的软件程序，此时，维护人员需要使用逆向工程技术</li><li>逆向工程技术是指：”分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程</li><li>逆向工程的基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li></ul></li><li>再工程<ul><li>再工程的目的是对遗留软件系统进行分析和重新开发，以便进一步利用新技术来改善系统或促进现存系统的再利用。</li><li><img src="7-1746704109456.png" style="zoom: 50%;" /></li><li>常见的具体活动有<ol><li>重新文档化</li><li>重组系统的结构</li><li>将系统转换为更新的编程语言</li><li>修改数据的结构组织。</li></ol></li></ul></li></ul></li></ul><h2 id="22-软件开发过程模型"><a href="#22-软件开发过程模型" class="headerlink" title="22. 软件开发过程模型"></a>22. 软件开发过程模型</h2><ul><li>概念<ul><li>软件过程模型在生命周期模型的基础则进一步详细说明各个阶段的任务、活动、对象及其组织、控制过程</li><li>与简略的软件生命周期模型不同，软件过程模型可以被看作是网络化的活动组织</li><li>不同的生命周期模型有不同的软件过程模型：阶段划分不一样</li><li>同一个生命周期模型也会有多个不同的软件过程模型</li></ul></li><li>构建-修复模型<ul><li><img src="image-20240613123828381.png" alt="image-20240613123828381" style="zoom: 67%;" /></li><li>缺点<ul><li>在这种模型中，没有对开发工作进行规范和组织，所以随着软件系统的<strong>复杂度提升</strong>，开发活动会超出个人的直接控制能力，构建-修复模型就会导致开发活动无法有效进行而失败；</li><li>没有分析<strong>需求的真实性</strong>，给软件开发带来很大的风险；</li><li>没有考虑<strong>软件结构的质量</strong>，使得软件结构在不断的修改中变得质量越来越糟，直至无法修改；</li><li>没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难。</li></ul></li><li>适用范围<ul><li>软件规模很小，只需要几百行程序，其开发复杂度是个人能力能够胜任的；</li><li>软件对质量的要求不高，即使出错也无所谓；</li><li>只关注开发活动，对后期维护的要求不高，甚至不需要进行维护</li></ul></li></ul></li><li>瀑布模型<ul><li><img src="image-20240613123952041.png" alt="image-20240613123952041" style="zoom: 50%;" /></li><li>优点：为软件开发活动定义了清晰的阶段划分(包括输入&#x2F;输出、主要工作及其关注点)，这让开发者能够以关注点分离的方式更好地进行那些复杂度超越个人能力的软件项目的开发活动</li><li>缺点<ul><li>对文档的过高期望具有局限性。<ul><li>一方面会耗费很大的工作量和成本</li><li>另一方面很难为经常变化的需求建立完备可靠的文档。</li></ul></li><li>对开发活动的线性顺序假设具有局限性。<ol><li>要求一个阶段的工作经过验证后才能进入后续阶段是不切实际的。在实际开发中，常常需要进行一定的后续工作才能验证当前的工作是否正确、可靠。</li></ol></li><li>客户、用户参与具有局限性。<ol><li>成功的项目开发需要客户、用户从始至终的参与，而不仅仅是一个阶段。</li></ol></li><li>里程碑粒度具有局限性：里程碑粒度过粗，基本丧失了”早发现缺陷早修复”这一思想</li></ul></li><li>适用范围<ul><li>需求非常成熟、稳定，没有不确定的内容，也不会发生变化；</li><li>所需的技术成熟、可靠，没有不确定的技术难点，也没有开发人员不熟悉的技术问题；</li><li>复杂度适中，不至于产生太大的文档负担和过粗的里程碑。</li></ul></li></ul></li><li>增量迭代模型<ul><li><img src="image-20240613125033159.png" alt="image-20240613125033159"></li><li>优点<ul><li>迭代式开发更加符合软件开发的实践情况，具有更好的适用性；</li><li>并行开发可以帮助缩短软件产品的开发时间；</li><li>渐进交付可以加强用户反馈，降低开发风险。</li></ul></li><li>缺点<ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。</li><li>增量交付模型需要<strong>一个完备、清晰的项目前景和范围</strong>以进行并发开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围。</li></ul></li><li>适用范围：因为能够很好地适用于大规模软件系统开发，所以增量迭代模型在实践中有着广泛的应用，尤其是比较成熟和稳定的领域。</li></ul></li><li>演化模型<ul><li><img src="image-20240613125157881.png" alt="image-20240613125157881"></li><li>优点<ul><li><strong>使用了迭代式开发，具有更好的适用性</strong>，尤其是其演化式迭代安排能够适用于那些需求变更比较频繁或不确定性较多的软件系统的开发；</li><li>并行开发可以帮助<strong>缩短</strong>软件产品的开发时间；</li><li>渐进交付可以<strong>加强用户反馈</strong>，降低开发风险。</li></ul></li><li>缺点<ul><li>无法在项目早期阶段建立项目范围，所以项目的整体计划、进度调度、尤其是商务协商事宜无法准确把握；</li><li>后续迭代的开发活动是在前导迭代基础上进行修改和扩展的，这容易让后续迭代忽略设分析与设计工作，蜕变为构建-修复方式。</li><li>容易退化为构建修复方式</li></ul></li><li>适用范围：在实践中，<strong>不稳定领域的大规模软件系统</strong>开发适合使用<strong>演化模型</strong>进行组织。</li></ul></li><li>原型模型<ul><li><img src="image-20240613125236672.png" alt="image-20240613125236672"></li><li>抛弃式原型<ol><li>它通过模拟”未来”的产品，将”未来”的知识置于”现在” 进行推敲，解决不确定性。</li><li>存在的原因是”不确定的”，这一类原型在后续的开发过程中会被抛弃</li></ol></li><li>演化式原型<ol><li>在迭代中构建，是系统的核心，并不断扩充，最终成为真正的软件产品。</li><li>它将作为真正产品的一部分，所以必须有很好的质量。在迭代式开发中，通常会在第一个迭代中构建一个核心的体系结构演化式原型，并且在后续迭代中不断扩充，成为真正的软件产品。</li></ol></li><li>优点<ul><li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度；</li><li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性。</li></ul></li><li>缺点<ul><li>原型方法能够解决风险，但是自身也能带来新的风险，例如原型开发的成本较高，可能会耗尽项目的费用和时间；</li><li>实践中，很多项目负责人不舍得抛弃”抛弃式原型”，使得质量较差的代码进入了最终产品，导致了最终产品的低质量。</li></ul></li></ul></li><li>螺旋模型<ul><li><img src="image-20240613125349691.png" alt="image-20240613125349691"></li><li>原型模型 vs 螺旋模型<ol><li>原型模型：使用原型解决需求的不确定性</li><li>螺旋模型：实用原型解决项目开发中常见的各种类型的技术风险，包括系统需求开发、软件需求开发、软件体系结构设计、详细设计等各个阶段</li></ol></li><li>自内向外，螺旋模型有4次风险解决迭代，分别解决了几个高风险的阶段的问题<ol><li>解决系统需求开发中的风险，尤其是产品概念设计风险，得到一个确定的产品前景和范围。</li><li>解决软件需求开发中的风险，得到清晰的软件需求</li><li>解决软件体系结构设计中的技术风险，构建高质量的核心体系结构原型。</li><li>解决详细设计和实现中的关键技术风险，建立一个可实现的高质量软件结构。</li></ol></li><li>优点：可以降低风险，减少项目因风险造成的损失</li><li>缺点<ul><li>风险解决需要使用原型手段，也就会存在原型自身带来的风险，这一点与原型模型相同；</li><li>模型过于复杂，不利于管理者依据其组织软件开发活动；</li></ul></li><li>适用性：在实践中，螺旋模型在高风险的大规模软件系统开发中有着较多的应用。</li></ul></li><li>Rational 统一过程<ul><li>总结和借鉴传统上的各种有效经验，建立最佳实践方法的集合，并提供有效的过程定制手段，允许开发者根据特定的需要定制一个有效的过程模型。</li><li><img src="11-1746704120722.png" style="zoom:67%;" /></li><li>RUP裁剪：确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。</li><li>核心思想<ul><li>迭代式开发，这是过去被反复证明的最佳实践方法；</li><li>管理需求，重视需求工程中除了需求开发之外的需求管理活动；</li><li>使用基于组件的体系结构，它帮助建立一个可维护、易开发、易复用的软件体系结构；</li><li>可视化建模，利用UML进行建模；</li><li>验证软件质量，尽早和持续地开展验证，以尽早发现缺陷，降低风险和成本；</li><li>控制软件变更，适应1990s以后需求变更越来越重要的事实</li></ul></li><li>适用性：RUP是重量级过程，能够胜任大型软件团队开发大型项目时的活动组织。但RUP经过裁剪和定制，也可以变为轻量级过程，也能够胜任小团队的开发活动组织。</li></ul></li><li>敏捷过程：略</li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程与计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2024/01/19/COA/"/>
    <url>/2024/01/19/COA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理整理"><a href="#计算机组成原理整理" class="headerlink" title="计算机组成原理整理"></a>计算机组成原理整理</h1><h2 id="第一讲：计算机概述"><a href="#第一讲：计算机概述" class="headerlink" title="第一讲：计算机概述"></a>第一讲：计算机概述</h2><ul><li>冯诺依曼结构<ul><li>计算机由运算器、存储器、控制器、输入设备、输出设备组成<ul><li>主存储器：地址和存储的内容</li><li>算术逻辑单元 &#x2F; 处理单元：执行信息的实际处理</li><li>程序控制单元 &#x2F; 控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li><li>指令和数据以同等地位存放在存储器内，并可按地址访问</li><li>指令和数据均用二进制表示</li></ul></li><li>计算机性能标准<ul><li>CPU ：速度</li><li>存储器：速度，容量</li><li>I&#x2F;O ：速度，容量</li></ul></li></ul><span id="more"></span><ul><li>CPU性能<ul><li>时钟频率 &#x2F; 时钟速度（单位：Hz） ：计算机在单位时间内执行最基本操作的次数</li><li>时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间</li><li>CPI：执行程序时平均每条指令所需的时钟周期数</li><li><img src="image-20231205151251333.png" alt="image-20231205151251333"></li></ul></li><li>字长<ul><li>机器字长：计算机能直接处理的二进制数据的位数。机器字长通常与主存单元的位数一致。计算机中运算器进行算术运算和逻辑运算，机器字长也就是进行定点数运算的字长，通常也是CPU内部数据通路的宽度。</li><li>指令字长：一个指令字中包含二进制代码的总位数。指令字长取决于操作码的长度、操作码地址的长度和操作码地址的个数。</li><li>存储字长：一个存储单元存储二进制代码的位数。</li></ul></li></ul><h2 id="第三讲：数据的机器级表示"><a href="#第三讲：数据的机器级表示" class="headerlink" title="第三讲：数据的机器级表示"></a>第三讲：数据的机器级表示</h2><ul><li>原码、反码、补码<ul><li>无符号整数只有原码</li><li>正数三码合一</li><li>负数补码 &#x3D; 绝对值原码取反 + 1</li></ul></li><li>浮点数的二进制表示<ul><li>S： 1位标志，表示正负</li><li>E： 8位阶码（指数），无符号整数<ul><li>计算指数要减偏移量127</li></ul></li><li>B： 23位尾数</li><li>规格化数：2^-126 <strong>~</strong> (2 - 2 ^ -23) * 2^128，隐藏位为1</li><li>非规划数：阶码全0，尾数不全为0，2^-149 ~ 2^-126</li></ul></li></ul><p><img src="image-20231205154100699.png" alt="image-20231205154100699.png"></p><p><img src="image-20231205154159726.png" alt="image-20231205154159726.png"></p><ul><li>十进制数的BCD码<ul><li>符号（4位）：正数1100，负数1101</li><li>后面每四位表示十进制数的一位</li></ul></li></ul><h2 id="第四讲：数据校验码"><a href="#第四讲：数据校验码" class="headerlink" title="第四讲：数据校验码"></a>第四讲：数据校验码</h2><blockquote><p>本课程不考虑两位及以上出错</p></blockquote><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul><li>在数据结尾增加一位表示数据中1的数量是奇数还是偶数</li><li>数据输入<ul><li>奇校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1⊕1（偶数个1校验码为1）</li><li>偶校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1（奇数个1校验码为1）</li></ul></li><li>数据输出<ul><li>奇校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1⊕1</li><li>偶校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1</li></ul></li><li>检错： S&#x3D;𝐶′′⊕𝐶′<ul><li>若S ≠ 1：出错，数量为奇数</li><li>若S &#x3D; 0：正确</li></ul></li></ul><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><ul><li><p>将数据分成几组 对每一组都使用奇偶校验码进行检错</p></li><li><p>过程：</p><ul><li><p>将M位数据分为K组</p><ul><li><p>2^K &gt;&#x3D; M + K + 1</p></li><li><p>数据错：M；校验码错：K；无错：1</p></li><li><p>分组方法：</p><p><img src="image-20231205160431994.png" alt="image-20231205160431994.png"></p><ol><li>插入位置：原数据2的指数倍（1，2，4，8……）</li><li>校验码Ci等于所有对应故障字号低i位为1的数据位异或（例：C2 &#x3D; D1 ⊕ D3 ⊕ D4 ⊕ D6 ⊕ D7）</li></ol></li></ul></li><li><p>数据输入：为数据D中每组生成1位校验码，合并得到K位校验码C</p></li><li><p>数据输出：为数据 𝐷′中 每组生成1位校验码，合并得到新的 𝐾位校验码 𝐶′′</p></li><li><p>检错：将校验码 𝐶′′和取出的校验码 C’ 按位进行异或，生成𝐾位故障字</p><ul><li>故障字含两个及以上1：对应数据位错</li><li>故障字含一个1：校验码错，忽略</li><li>故障字全0：正确</li></ul></li></ul></li></ul><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><ul><li><p>适用于以流格式存储和传输大量数据</p></li><li><p>假设数据有M位，左移数据<strong>K</strong>位（右侧补0），并用<strong>K+1</strong>位生成多项式除它（模2运算）</p></li><li><p>K位余数为校验码，若无余数则正确</p><p><img src="image-20231205162055616.png" alt="image-20231205162055616.png"></p></li></ul><h2 id="第五讲：整数运算"><a href="#第五讲：整数运算" class="headerlink" title="第五讲：整数运算"></a>第五讲：整数运算</h2><h3 id="加法（减法）"><a href="#加法（减法）" class="headerlink" title="加法（减法）"></a>加法（减法）</h3><ul><li><p>串行进位加法器</p><p><img src="image-20231205162812144.png" alt="image-20231205162812144.png"></p><ul><li><p>延迟：</p><ul><li>Cn: 2n ty</li><li>Sn:（2n + 1）ty</li></ul></li></ul></li><li><p>全先行进位加法器（CLA）：比串行快，缺点为复杂</p></li><li><p>部分先行进位加法器：取多个CLA串联，取得平衡</p></li><li><p>减法：将C0置为1</p></li><li><p>加法溢出判断</p><ul><li>𝑋𝑛&#x3D;𝑌𝑛且𝑆𝑛≠𝑋𝑛,𝑌𝑛: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D; [𝑋𝑛 &amp; 𝑌𝑛 &amp; ( ~ 𝑆𝑛 ) ] | [ (~ 𝑋𝑛 ) &amp; ( ~ 𝑌𝑛 ) &amp; 𝑆𝑛 ]</li><li>𝐶𝑛≠𝐶𝑛−1: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D;𝐶𝑛⊕𝐶𝑛−1</li><li>减法同理</li></ul></li></ul><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>计算机乘法与手算不同：</p><p><img src="image-20231205165157005.png" alt="image-20231205165157005.png"></p><ul><li>每步都计算部分积求和结果</li><li>右移部分积，而不是左移</li><li>若Yi（当前乘的位）为0，直接移位</li></ul></li><li><p>布斯算法</p><p><img src="image-20231205165944658.png" alt="image-20231205165944658.png"></p><ul><li>增加Y0 &#x3D; 0</li><li>根据Yi - Yi+1 决定是否增加 X , -X , +0</li><li>右移部分积（移前第一位为0前面补0，反之补1）</li><li>重复上两步n次</li></ul></li></ul><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul><li><p>判断是否够减</p><p><img src="image-20231205203705216.png" alt="image-20231205203705216.png"></p></li><li><p>恢复余数除法过程</p><ul><li><p>通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄存器中</p></li><li><p>将余数和商左移，判断是否够减</p><ul><li>如果“够”，则做减法（同号）或者加法（异号），并上商为1</li><li>如果“不够”，则上商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>如果除数和被除数不同号，则将商替换为其相反数</p><p><img src="image-20231205204154289.png" alt="image-20231205204154289.png"></p></li></ul></li><li><p>不恢复余数除法过程</p><ul><li><p>思路：如果余数 𝑅𝑖足够大，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；如果余数 𝑅𝑖不够大，𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌−𝑌&#x3D;2𝑅𝑖+𝑌</p></li><li><p>如果除数和被除数符号相同，则做减法；否则，做加法</p><ul><li>如果余数和除数符号相同，则商𝑄𝑛&#x3D;1；否则， 𝑄𝑛&#x3D;0</li></ul></li><li><p>如果余数和除数符号相同，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；否则， 𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌</p><ul><li>如果新的余数和除数符号相同，使商为 1 ；否则，使商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>将商左移一位，若商为负，商加1</p></li><li><p>若余数与被除数符号不同修正余数：</p><ul><li><p>若被除数和除数符号相同，最后余数加除数；否则，最后余数减除数</p><p><img src="image-20231205205029238.png" alt="image-20231205205029238.png"></p></li></ul></li></ul></li></ul><h2 id="第六讲：浮点数运算"><a href="#第六讲：浮点数运算" class="headerlink" title="第六讲：浮点数运算"></a>第六讲：浮点数运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><ul><li><p>步骤</p><ul><li>检查是否为0</li><li>对齐</li><li>加减操作</li><li>规格化</li></ul><p><img src="image-20231206162424022.png" alt="image-20231206162424022.png"></p></li><li><p>加法</p><ul><li>若最高位有进位，则<strong>溢出</strong></li><li>符号与被加数相同</li></ul></li><li><p>减法</p><ul><li>若最高位有进位，正确（符号与被减数相同）</li><li>若最高位无进位，须计算结果补码（符号与被减数不同）</li></ul></li><li><p>对阶</p><ul><li>先计算ΔE &#x3D; Ex - Ey（均为补码）</li><li>若ΔE &lt; 0则Ex小，反之Ey小</li><li>对小的那个进行右移操作，右移过程中移出的位需保留用于尾数运算</li></ul></li><li><p>尾数加减</p><ul><li>隐藏位需加入运算</li></ul></li><li><p>规格化</p><ul><li>结果一：1.bb……b + 1.bb……b &#x3D; ±1b.bb……b<ul><li>右规：尾数右移一位；阶码加一</li><li>若阶码为127，加一后发生上溢</li><li>最后一位移出要考虑<strong>舍入</strong></li></ul></li><li>结果二：1.bb……b - 1.bb……b &#x3D; ±0.00…01b…b<ul><li>左规：尾数不断左移，阶码减一，直到最前面的1移到小数点前</li><li>若此过程中阶码小于0，发生下溢</li></ul></li></ul></li><li><p>舍入处理</p><ul><li>就近舍入：结果被舍入成最近的可表示的数</li><li>朝+∞舍入：结果朝正无穷大方向向上舍入</li><li>朝-∞舍入：结果朝负无穷大方向向下舍入</li><li>朝 0 舍入：结果朝 0 舍入</li></ul></li><li><p>溢出判断</p><ul><li>上溢：右规</li><li>下溢：左规</li></ul></li></ul><h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>过程</p><ul><li>尾数相乘，指数相加</li><li>尾数规格化</li><li>舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相乘，指数相加</p><ul><li>计算时将隐藏位1还原</li><li>乘积符号位为操作数符号位异或结果</li><li>指数：e &#x3D; e1 + e2 - 127</li></ul></li><li><p>尾数规格化</p><ul><li>尾数小数点前有三种：10、11、01（不用规格化）</li><li>10&#x2F;11:右规，位数右移一位，阶码加一</li><li>右规需要考虑溢出（与加法相同）</li></ul></li><li><p>尾数舍入</p><ul><li>对右规后的2n - 2位进行舍入</li><li>规则与加法一样</li></ul></li><li><p>溢出判断</p><ul><li>指数相加：上溢&#x2F;下溢</li><li>舍入：上溢</li><li>右规：上溢</li></ul></li></ul><h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ul><li><p>过程</p><ul><li>尾数相除，阶相减</li><li>尾数规格化</li><li>尾数舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相除，阶相减</p><ul><li>符号位为原操作数异或结果</li><li>阶码e &#x3D; e1 - e2 + 127</li><li>尾数还原隐藏位1后作为无符号整数相除</li></ul></li><li><p>尾数规格化</p><ul><li>结果范围：0.5~2</li><li>若第一位为0，小数点右边第一位必为1</li><li>若第一位为0，进行左规，尾数左移一位，阶码减一</li><li>左移时判断下溢</li></ul></li><li><p>尾数舍入</p><ul><li>与加减相同</li></ul></li><li><p>溢出判断</p><ul><li>左规：下溢</li><li>舍入：上溢</li><li>指数相减：上溢&#x2F;下溢</li></ul></li></ul><h2 id="第八讲：内部存储器"><a href="#第八讲：内部存储器" class="headerlink" title="第八讲：内部存储器"></a>第八讲：内部存储器</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li>地址：单元唯一标识符</li><li>地址空间：可标识单元总数</li><li>寻址能力：存储在每个单元中信息位数</li><li>位元：半导体存储器的基本元件，用于存储1位数据</li></ul><h3 id="RAM（随机存取存储器）"><a href="#RAM（随机存取存储器）" class="headerlink" title="RAM（随机存取存储器）"></a>RAM（随机存取存储器）</h3><ul><li>特点<ul><li>可快速进行读写操作</li><li>易失</li></ul></li><li>DRAM<ul><li>在电容器上用电容充电的方式存储数据</li><li>需要周期地充电刷新以维护数据存储</li></ul></li><li>SRAM<ul><li>使用传统触发器、逻辑门配置来存储二进制值</li><li>有电源就能一直保持</li></ul></li><li>两者对比<ul><li>DRAM比SRAM具有更简单、更小的位元，但要求能支持刷新的电路</li><li>DRAM比相应的SRAM密度更高，价格更低</li><li>SRAM通常比DRAM快</li><li>DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高速缓存（Cache），DRAM用于主存</li></ul></li><li>SDRAM<ul><li>传统DRAM与处理器异步，及CPU需要等待DRAM内部存取数据操作</li><li>SDRAM与处理器同步时钟信号</li></ul></li><li>DDR SDRAM<ul><li>每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在<br>下降沿</li></ul></li></ul><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><ul><li>特点<ul><li>非易失</li><li>只读，一般不能写入</li><li>随机存取（与RAM相同）</li></ul></li><li>PROM（可编程ROM）<ul><li>非易失</li><li>只能写入一次</li><li>通过电信号写入</li></ul></li></ul><h3 id="主要进行读操作的存储器"><a href="#主要进行读操作的存储器" class="headerlink" title="主要进行读操作的存储器"></a>主要进行读操作的存储器</h3><ul><li>EPROM<ul><li>光擦除：在写操作前将封装芯片暴露在紫外线下，需要20分钟</li><li>电写入</li><li>比PROM贵</li></ul></li><li>EEPROM（电可擦除可编程“只读”存储器）<ul><li>可以随时写入而不删除之前的内容</li><li>只更新寻址到的一个或多个字节</li><li>写操作每字节需要几百微秒</li><li>比EPROM更贵，且密度低，支持小容量芯片</li></ul></li><li>Flash Memory（快闪存储器）<ul><li>电可擦除：与EEPROM相同，优于EPROM</li><li>擦除时间为几秒：优于EPROM，不如EEPROM</li><li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM</li><li>达到与EPROM相同的密度：优于EEPROM</li><li>价格介于EPROM和EEPROM之间</li></ul></li></ul><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul><li><p>寻址单元（Addressable unit）：由若干相同地址的位元组成（一个存储单元）</p></li><li><p>寻址模式</p><ul><li>字节（常用）Byte</li><li>字Word</li></ul></li><li><p>存储阵列（Memory Array）：由大量寻址单元组成</p></li><li><p>地址译码器</p><p><img src="image-20231208194708017.png" alt="image-20231208194708017.png"></p><ul><li>一个n位译码器有2^n种输出</li><li>当所有n个寻址位都满足条件时，该输出为1</li><li>任何时候，只有一个输出是1其他的都是0</li></ul></li></ul><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul><li>集中式刷新：停止读写，刷新所有行，刷新过程中不能读写<ul><li>芯片刷新按每块芯片每行刷新：先算每块芯片是多少乘多少，得到有多少行，即为刷新次数</li></ul></li><li>分散式刷新：在每个存储周期中，当读写操作完成时进行刷新</li><li>异步刷新：每一行各自以64 ms间隔刷新</li></ul><h3 id="从位元到主存的架构"><a href="#从位元到主存的架构" class="headerlink" title="从位元到主存的架构"></a>从位元到主存的架构</h3><ul><li><img src="image-20231208195217394.png" alt="image-20231208195217394.png"></li><li>位扩展：地址线不变，数据线增加：使用8块 4K * 1bit的芯片组成 4K * 8bit的存储器</li><li>字扩展：地址线增加，数据线不变：使用4个16K * 8bit 的芯片组成64K * 8bit的存储器</li><li>字、位同时扩展：地址线增加，数据线增加：使用8个16K * 4bit 的芯片组成64K * 8bit的存储器</li><li>位元-&gt;寻址单元-&gt;存储阵列-&gt;芯片-&gt;模块组织-&gt;主存</li><li>DRAM与SRAM地址线与数据线计算<ul><li>SRAM : log2存储单元数量</li><li>DRAM : log2存储单元数量 &#x2F; 2（使用了地址复用技术）</li><li>数据线：该芯片一个存储单元有几位就几根</li></ul></li></ul><h2 id="第九讲：Cache"><a href="#第九讲：Cache" class="headerlink" title="第九讲：Cache"></a>第九讲：Cache</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li><p>检查：检查该字是否在Cache中</p><ul><li>命中：如果在cache中，则把这个字传送给 CPU</li><li>未命中：如果不在cache中 , 则将主存中包含这个字固定大小的块读入cache中，然后再从cache传送该字 给CPU</li></ul></li><li><p>判断是否命中</p><ul><li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li></ul></li><li><p>程序访问的局部性原理</p><ul><li>时间局部性 ：在相对较短的时间周期内重复访问特定的信息，也就是访问相同位置的信息</li><li>空间局部性 ：在相对较短的时间周期内访问相邻存储位置的数据</li></ul></li><li><p>平均访问时间</p><ul><li>注意点：即使未命中也需存取Cache</li></ul><p><img src="image-20231209093818319.png" alt="image-20231209093818319.png"></p><p><img src="image-20231231100740150.png" alt="image-20231231100740150.png"></p></li></ul><h3 id="Cache的设计"><a href="#Cache的设计" class="headerlink" title="Cache的设计"></a>Cache的设计</h3><ul><li>Cache行的构成<ul><li>标记 + 有效位 + (脏位) + 替换算法控制位 + 数据部分</li></ul></li><li>映射<ul><li>直接映射<ul><li>将主存中的每个块映射到一个固定可用的cache行中</li><li>假设i是cache行号，j是主存储器的块号，C是 cache 的行数，i &#x3D; j % C</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2𝐶位标记位，第二部分为𝑙𝑜𝑔2𝐶位Cache行号，第三部分为块内地址（位数由块大小决定）</li></ul></li><li>(全)关联映射<ul><li>一个块可以装入Cache内任意一行</li><li>主存地址分为标记和块内地址</li></ul></li><li>组关联映射<ul><li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行</li><li>组号 &#x3D; 块号 % 组数</li><li>K-路组关联：K &#x3D; Cache行数&#x2F;组数</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2S位标记位，第二部分为𝑙𝑜𝑔2S位Cache组号，第三部分为块内地址（位数由块大小决定）</li><li>如果 𝐾&#x3D;1，组关联映射等同于直接映射</li><li>如果 𝐾&#x3D;𝐶，组关联映射等同于关联映射</li></ul></li><li>关联度：一个主存块映射到cache中可能存放的位置个数<ul><li>直接映射：1</li><li>关联映射：C</li><li>组关联映射：K</li><li>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小</li></ul></li></ul></li><li>替换算法<ul><li>最近最少使用算法LRU<ul><li>策略：替换掉在cache中最长时间未被访问的数据块</li></ul></li><li>先进先出算法FIFO<ul><li>策略：替换掉在Cache中停留时间最长的块</li></ul></li><li>最不经常使用算法LFU<ul><li>策略：替换掉cache中被访问次数最少的数据块</li></ul></li><li>随机替换算法</li></ul></li><li>写策略<ul><li>写直达<ul><li>所有写操作都同时对cache和主存进行</li><li>确保主存中的数据总是和cache中的数据一致，总是最新的</li><li>产生大量的主存访问，减慢写操作</li></ul></li><li>写回法<ul><li>先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存</li><li>利用脏位</li><li>减少了访问主存的次数，但数据不一定最新</li></ul></li></ul></li><li>多级Cache<ul><li>当L1未命中时减少处理器对总线上DRAM或ROM的访问</li><li>使用单独的数据路径代替系统总线在L2缓存和处理器之间传输数据部分处理器将L2 cache结合到处理器芯片上</li></ul></li></ul><h2 id="第十讲：外部存储器"><a href="#第十讲：外部存储器" class="headerlink" title="第十讲：外部存储器"></a>第十讲：外部存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>特点<ul><li>非易失</li><li>用于存储不经常使用的、数据量较大的信息</li></ul></li><li>类型<ul><li>磁盘存储器</li><li>光存储器</li><li>磁带</li><li>U盘、固态硬盘</li></ul></li></ul><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><ul><li><p>磁盘是由涂有可磁化材料的非磁性材料 （基材）构成的圆形盘片</p></li><li><p>玻璃基材优势</p><p><img src="image-20231209100435594.png" alt="image-20231209100435594.png"></p></li><li><p>结构</p><p><img src="image-20231209100647883.png" alt="image-20231209100647883.png"></p><ul><li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动</li><li>在任何时候，所有磁头都位于距磁盘中心等距离的磁道上</li></ul></li><li><p>磁头：对盘片进行读写操作的装置</p><ul><li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li><li>磁头越窄，离盘片的距离就越近（飞行高度）</li><li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li><li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li><li>现代磁盘采用双磁头：读磁头和写磁头</li></ul></li><li><p>读写机制</p><ul><li>读：读取磁头是由一个部分屏蔽的磁阻MR敏感器组成其电阻取决于在其下移动的介质的磁化方向，通过电流后产生的电压指示其电阻</li><li>写：电流脉冲被发送到写入磁头，变化的电流激发出磁场，变化的电流激发出磁场</li></ul></li><li><p>数据组织结构</p><p><img src="image-20231209101418029.png" alt="image-20231209101418029.png"></p><ul><li>磁道：盘片上的数据组织呈现为一组同心圆环，称为磁道track</li><li>数据以扇区（sector）的形式传输到磁盘或从传出磁盘：扇区默认512B</li><li>相邻磁道之间有 间隙，相邻的扇区之间也留有间隙</li><li>所有盘片上处于相同的相对位置的一组磁道被称为柱面</li></ul></li><li><p>访问时间</p><ul><li><p>寻道时间：磁头定位到所需移动到的磁道所花费的时间</p></li><li><p>旋转延迟：等待响应扇区的起始处到达磁头所需的时间，<strong>通常为旋转半圈时间</strong></p></li><li><p>传送时间：数据传输所需的时间</p></li><li><p><img src="image-20231209101754880.png" alt="image-20231209101754880.png"></p><img src="计组整理.assets/image-20231209101819663.png" alt="image-20231209101819663" style="zoom:50%;" /><p><img src="image-20231209101819663.png" alt="image-20231209101819663.png"></p></li></ul></li><li><p>磁头寻道算法</p><ul><li>先来先服务FCFS<ul><li>按照请求访问磁盘的先后次序进行处理</li></ul></li><li>最短寻道时间优先SSTF<ul><li>优先处理起始位置与当前磁头位置最接近的读写任务</li></ul></li><li>扫描&#x2F;电梯（SCAN）<ul><li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li></ul></li><li>循环扫描C-SCAN<ul><li>只有磁头朝某方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，<strong>返回途中不做任何处理</strong></li></ul></li><li>LOOK<ul><li>SCAN 算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li></ul></li><li>C-LOOK<ul><li>C-SCAN 算法的升级，只要磁头移动方向上不再有请求，就立即让磁头返回起点</li></ul></li></ul></li></ul><h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><ul><li><p>分类</p><p><img src="image-20231209102434412.png" alt="image-20231209102434412.png"></p></li><li><p>CD和CD-ROM</p><ul><li>CD和CD-ROM采用类似的技术，但CD-ROM更加耐用且有纠错功能</li><li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD或CD-ROM处读取信息</li><li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同</li></ul></li><li><p>高清晰光盘</p><ul><li>通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li></ul></li></ul><h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><ul><li>介质是柔韧的聚酯薄膜带，外涂磁性材料</li><li>顺序读取</li></ul><h3 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h3><ul><li>U盘<ul><li>采用了快闪存储器，属于非易失性半导体存储器</li><li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li></ul></li><li>固态硬盘<ul><li>与 U 盘没有本质区别：容量更大，存储性能更好</li></ul></li></ul><h2 id="第十一讲：冗余磁盘阵列"><a href="#第十一讲：冗余磁盘阵列" class="headerlink" title="第十一讲：冗余磁盘阵列"></a>第十一讲：冗余磁盘阵列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>基本思想<ul><li>将多个独立操作的磁盘按某种方式组织成磁盘阵列 以增加容量</li><li>将数据存储在多个盘体上 通过这些盘并行工作来提高数据传输率</li><li>采用数据冗余来进行错误恢复以提高系统可靠性</li></ul></li><li><img src="image-20231214205505393.png" alt="image-20231214205505393.png"></li></ul><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p><img src="image-20231214205749592.png" alt="image-20231214205749592.png"></p><ul><li>数据以条带的形式在可用的磁盘上分布</li><li>不采用冗余来改善性能（不是 RAID 家族中的真正成员）</li><li>用途：1.高数据传输率 2.高速响应I&#x2F;O请求</li></ul><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p><img src="image-20231214210100316.png" alt="image-20231214210100316.png"></p><ul><li>采用了数据条带</li><li>采用简单地备份所有数据的方法来实现冗余</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li><li>两组硬盘都可以读取，读速度快</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li></ul><h3 id="RAID-2-3"><a href="#RAID-2-3" class="headerlink" title="RAID 2 &amp; 3"></a>RAID 2 &amp; 3</h3><ul><li><p>RAID 2</p><p><img src="image-20231214210342894.png" alt="image-20231214210342894.png"></p><ul><li>采用并行存取技术</li><li>采用<strong>非常小</strong>的数据条带</li><li>所有磁盘都参与每个I&#x2F;O请求的执行</li><li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li><li>对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li></ul></li><li><p>RAID 3</p><p><img src="image-20231214210503149.png" alt="image-20231214210503149.png"></p><ul><li>与RAID 2 不同点：对所有数据盘上同一位置的数据计算奇偶校验码</li></ul></li></ul><h3 id="RAID-4-5"><a href="#RAID-4-5" class="headerlink" title="RAID 4 &amp; 5"></a>RAID 4 &amp; 5</h3><ul><li><p>RAID 4</p><p><img src="image-20231214220218541.png" alt="image-20231214220218541.png"></p><ul><li>采用独立存取技术：每个磁盘成员的操作是独立的，各个I&#x2F;O请求能够并行处理</li><li>采用相对较大的数据条带</li><li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li><li>每次写操作都需要修改校验位，I&#x2F;O请求较大时有优势（可用新数据计算）</li></ul></li><li><p>RAID 5</p><p><img src="image-20231214220451002.png" alt="image-20231214220451002.png"></p><ul><li>与RAID 4组织方式相似</li><li>在所有磁盘上都分布了奇偶校验条带</li></ul></li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><img src="image-20231214220620920.png" alt="image-20231214220620920.png"></p><ul><li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li><li>提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才会造成数据丢失</li><li>写损失：每次写都要影响两个校验块</li></ul><h2 id="第十二讲：虚拟存储器"><a href="#第十二讲：虚拟存储器" class="headerlink" title="第十二讲：虚拟存储器"></a>第十二讲：虚拟存储器</h2><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul><li>分区<ul><li>分区方式将主存分为两大区域</li><li>系统区：固定的地址范围内，存放操作系统</li><li>用户区：存放所有用户程序</li><li>简单固定分区：用户区划分成长度不等的固定长的分区，当一个任务调入主存时，分配一个可用的、能容纳它的最小的分区</li><li>可变长分区：用户区按每个任务所需要的内存大小进行分配，会导致碎片化</li></ul></li><li>分页<ul><li>把主存分成固定长且比较小的存储块，称为页框；每个任务也被划分成固定长的程序块，称为页</li><li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li><li>逻辑地址：指令中的地址</li><li>物理地址：实际主存地址</li></ul></li></ul><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul><li><p>基本思想</p><ul><li>仅将当前需要的的页面调入主存</li><li>通过硬件将逻辑地址转换为物理地址</li><li>未命中时在主存和硬盘之间交换信息</li></ul></li><li><p>分页式虚拟存储器</p><p><img src="image-20231224164127892.png" alt="image-20231224164127892.png"></p><ul><li>主存储器和虚拟地址空间都被划分为大小相等的页面</li><li>页表：页表中包含了所有虚拟页的信息,包括虚拟页的存放位置 、装入位valid、修改位dirty、存取权限位、<strong>物理地址</strong>等等，存储在主存中</li><li>地址 &#x3D; 页号 + 页内偏移量</li><li>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li></ul></li><li><p>快表</p><ul><li>页表的使用增加了主存的访问次数，为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li><li>主存中的页表相应地称之为“慢表”</li></ul></li><li><p>CPU访存过程</p><ul><li><img src="image-20231224164538671.png" alt="image-20231224164538671.png"></li><li><img src="image-20231224165337226.png" alt="image-20231224165337226.png"></li><li><img src="image-20231224165513175.png" alt="image-20231224165513175.png"></li></ul></li><li><p>分段式虚拟存储器</p><ul><li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li><li>虚拟地址：段号 + 段内偏移量</li><li>与分页式虚拟存储器相比：分页式简单，但一个数据或一条指令可能会分跨在两个页面；分段式段的分界与程序的自然分界相对应，易于管理，但段大小不固定</li></ul></li><li><p>段页式虚拟存储器</p><ul><li>将程序和数据分段，段内再进行分页</li><li>每个段都有一个页表</li><li>虚拟地址 &#x3D; 段号 + 页号 + 页内偏移量</li></ul></li></ul><h2 id="第十三讲：指令系统"><a href="#第十三讲：指令系统" class="headerlink" title="第十三讲：指令系统"></a>第十三讲：指令系统</h2><h3 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h3><ul><li><p>指令要素</p><ul><li>操作码：指定将要完成的操作</li><li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li><li>结果操作数引用：操作可能会产生一个结果</li><li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li></ul></li><li><p>操作码</p><ul><li>指令类型：数据传送、算术运算、逻辑运算、转换、输入&#x2F;输出、系统控制、控制转移</li><li>数据传送：指明源和目标操作数的位置、将要传送数据的长度、寻址方式</li></ul></li><li><p>操作数</p><ul><li>大端法和小端法：大端为高位存在小地址，低位存在大地址，小端与之相反</li><li>寻址方式<ul><li>立即寻址：操作数实际出现在指令中</li><li>直接寻址：地址字段含有操作数的有效地址</li><li>间接寻址：地址字段指示一个存储器字地址 , 而此地址出保存有操作数的全长度地址</li><li>寄存器寻址：地址字段指示的是寄存器</li><li>寄存器间接寻址：地址字段指示的是寄存器，寄存器中存操作数地址</li><li>偏移寻址：EA &#x3D; (R) + A，即地址 &#x3D; 偏移量 + 地址，分为三种：相对寻址（R为PC）、基址寄存器寻址(R对应寄存器中为基址，A为偏移量)、变址寻址（A为某主存地址，R中为对于该地址正的偏移量）</li><li>栈寻址：方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li></ul></li></ul></li><li><p>指令设计原则</p><ul><li>指令尽量短</li><li>有足够的操作码位数：要为操作类型不断增加预留</li><li>操作码的编码必须有唯一的解释</li><li>指令长度是字节的整数倍</li><li>合理选择地址字段的个数</li><li>指令尽量规整：简化硬件的实现</li></ul></li><li><p>题型：计算指令系统需要多少位</p><p><img src="image-20240101163022494.png" alt="image-20240101163022494.png"></p><ul><li>先算地址多的，多出来没用的操作码n个给地址少的作为操作码前几位</li><li>地址少的用多出来的地址位k和n算出可用操作码数（2^k * n），与需要的操作码数量对比，如果足够就结束，不够就要增加一位</li><li>所有种类指令都验证完后将位数向上取整变成8的整数倍</li></ul></li></ul><h2 id="第十四讲：指令流水线"><a href="#第十四讲：指令流水线" class="headerlink" title="第十四讲：指令流水线"></a>第十四讲：指令流水线</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><p>指令周期 ：处理单个指令的过程</p><p><img src="image-20231224195348224.png" alt="image-20231224195348224.png"></p><p><img src="image-20231224195406263.png" alt="image-20231224195406263.png"></p></li><li><p>间址周期：把间接地址的读取看成是一个额外的指令子周期</p></li><li><p>CPU寄存器</p><ul><li>1个存储地址寄存器MAR</li><li>1个存储缓冲寄存器MBR&#x2F; 存储数据寄存器MDR</li><li>1个程序计数器PC</li><li>1个指令寄存器IR</li></ul></li><li><p>指令周期数据流</p><ul><li>取指周期<ul><li>控制器先发出控制信号告知存储器，PC使用地址总线传输待取指令地址，存储器得到地址</li><li>存储器将指令数据传入数据总线，存储缓冲寄存器MBR从数据线上得到指令，再传给IR</li><li>控制器告知PC取指完成，使PC中值对应 + 4</li></ul></li><li>间址周期<ul><li>MBR第一次取回的是地址，将它传入MAR再进行一次读取</li></ul></li><li>中断周期<ul><li>终端前要将所有寄存器状态存入存储器</li></ul></li></ul></li></ul><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ul><li><p>指令流水线 ：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成</p></li><li><p>六阶段方法：</p><p><img src="image-20231224200754205.png" alt="image-20231224200754205.png"></p><ul><li>取指令（ Fetch instruction FI ）：读下一条预期的指令到缓冲器</li><li>译码指令（ Decode instruction DI ）：确定操作码和操作数指定符</li><li>计算操作数（ Calculate operands CO ）：计算每个源操作数的有效地址</li><li>取操作数（ Fetch operands FO ）：从存储器取出每个操作数，寄存器中的操作数不需要取</li><li>执行指令（ Execute instruction EI ）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li><li>写操作数（ Write operand WO ）：将结果存入存储器</li><li>问题：不是所有指令都包含6个阶段；不是所有的阶段都能并行完成；若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</li><li>条件转移指令会使若干周期无效</li></ul></li><li><p><img src="image-20231224201109097.png" alt="image-20231224201109097.png"></p></li></ul><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ul><li>结构冒险<ul><li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源</li><li>解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源</li></ul></li><li>数据冒险<ul><li>原因：未生成指令所需要的数据</li><li>解决方案 1 ：插入 nop 指令</li><li>解决方案 2 ：插入 bubble</li><li>解决方案 3 ：转发 forwarding &#x2F; 旁路 bypassing：无需等待数据存入对应寄存器，而是将需要的其他指令执行结果直接传送到对应位置</li><li>解决方案 4 ：交换指令顺序</li></ul></li><li>控制冒险<ul><li>原因：指令的执行顺序被更改（转移、中断、异常、调用&#x2F;返回）</li><li>解决：取多条指令、分支预测</li></ul></li></ul><h2 id="第十五讲：控制器"><a href="#第十五讲：控制器" class="headerlink" title="第十五讲：控制器"></a>第十五讲：控制器</h2><h3 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h3><p><img src="image-20240101162745149.png" alt="image-20240101162745149.png"></p><ul><li>用户可见寄存器<ul><li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li><li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回</li><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：仅可用于保持数据而不能用于操作数地址的计算</li><li>地址寄存器：可以是自身有某些通用性，或是专用于某种具体的寻址方式</li><li>条件码寄存器&#x2F;标志寄存器：CPU硬件设置这些条件位作为操作的结果</li></ul></li><li>控制和状态寄存器<ul><li>由控制器来控制 CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li><li>大多数控制和状态寄存器在大多数机器上是用户不可见的</li><li>程序计数器PC（Program counter）：通常在每次取指令之后， PC 的内容即被CPU更改，因此总指向将被执行的下一条指令（用户可见）</li><li>指令寄存器IR（Instruction register）：存有最近取来的指令，在其中分析操作码和操作数</li><li>存储器地址寄存器MAR（Memory address register）：直接与地址总线相连，存有存储器位置的地址</li><li>存储器缓冲寄存器MBR（Memory buffer register）：直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR交换数据</li><li>ALU 可对MBR和用户可见寄存器直接存取</li></ul></li><li>程序状态字<ul><li>一个或一组包含状态信息的寄存器 包含条件码加上其他状态信息</li><li>符号、零、进位、等于、溢出、中断禁止&#x2F;允许、监管</li></ul></li></ul><h3 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h3><ul><li><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令，每个指令周期又可以看作是由几个更小的子周期组成（取指、间址、执行、中断），每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些步骤称为微操作</p></li><li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p><p><img src="image-20231225192443296.png" alt="image-20231225192443296.png"></p><ul><li>事件的流动顺序必须是恰当的</li><li>必须避免冲突</li><li>满足上述条件下 所用的时间单位尽可能少</li></ul></li><li><p>间址周期：如果指令采用间接寻址，则在指令执行前有一个间址周期</p><p><img src="image-20231225192951356.png" alt="image-20231225192951356.png"></p></li><li><p>执行周期：对于不同的操作码，会出现不同的微操作序列</p><img src="计组整理.assets/image-20231225193031697.png" alt="image-20231225193031697" style="zoom: 50%;" /><p><img src="image-20231225193031697.png" alt="image-20231225193031697.png"></p></li><li><p>中断周期：在完成执行周期时，要确定是否有允许的中断产生，如果有，则出现一个中断周期</p></li><li><p>指令周期代码：假设一个 2 位的ICC寄存器，明确 CPU 处于指令周期哪个阶段</p><p><img src="image-20231225193941116.png" alt="image-20231225193941116.png"></p><ul><li>00 ：取指</li><li>01 ：间址</li><li>10 ：执行</li><li>11 ：中断</li></ul></li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li><p>CPU内部总线</p><ul><li>ALU和寄存器都连接到CPU内部总线上</li><li>内部总线和寄存器之间有门和控制信号</li></ul></li><li><p>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</p></li><li><p>CPU需要完成的微操作：</p><ul><li>在寄存器之间传送数据</li><li>将数据由寄存器传送到外部接口（如系统总线）</li><li>将数据由外部接口传送到寄存器</li><li>将寄存器作为输入和输出，完成算术和逻辑运算</li></ul></li><li><p>控制器的两个基本任务：定序、执行</p></li><li><p>控制器的输入：</p><ul><li>指令寄存器：当前指令的寻址方式和操作码</li><li>标志：确定CPU的状态和前一个ALU操作的结果</li><li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li><li>来自控制总线的控制信号：向控制器提供控制信号（如中断请求）</li></ul></li><li><p>控制器的输出：CPU内的控制信号、到控制总线的控制信号</p></li><li><p>控制器实现</p><ul><li>硬布线实现：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，<br>即控制信号</li><li>微程序实现：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号</li></ul></li><li><p>硬布线实现</p><ul><li><p>硬布线控制器是将控制部件做成产生专门固定信号的逻辑电路，产生各种控制信号，因而又称为组合逻辑控制器。微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。</p></li><li><p>控制器输入：标志和控制总线信号、指令寄存器、时钟</p></li><li><p>控制器逻辑：为每个输出的控制信号设计一个关于控制器输入的布尔表达式</p></li></ul></li><li><p>微程序实现</p><ul><li><p>基本思路：</p><ul><li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li><li>构造一个<strong>控制字</strong>，每位代表一根控制线，这样每个微操作能用控制字中的不同的 0 和 1 的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li></ul></li><li><p>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址</p></li><li><p>任务：定序和执行</p><p><img src="image-20231225205024319.png" alt="image-20231225205024319.png"></p></li><li><p>微指令编码方式</p><ul><li><p>直接控制方式：在微指令的控制字段里对不同的微命令各自设置一个数位来表示发出与否（”0&#x2F;1”）</p></li><li><p>字段直接编译法：对控制字段进行划分，得到多个不同的字段，这些字段表示多个互斥的控制信号，这些微命令在同一时间只有其中的某一个微命令可以生效。</p><p><img src="image-20240101165541902.png" alt="image-20240101165541902.png"></p></li><li><p>字段间接编译法：同样是对控制字段进行划分，但是字段间接编译法在直接编译法以一个字段来表示一条微命令的基础上，辅以另一个字段来解释这个字段。这样的编译方法，可以使得指令的长度进一步减短，但微指令的并行控制能力被削弱了。</p><p><img src="image-20240101165705537.png" alt="image-20240101165705537.png"></p><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li><li><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li></ul></li><li><p>工作流程：</p><ul><li>为执行一条指令，定序逻辑发出一个读命令给控制存储器</li><li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li><li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息</li><li>定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存器中</li></ul></li></ul></li></ul><h2 id="第十六讲：总线"><a href="#第十六讲：总线" class="headerlink" title="第十六讲：总线"></a>第十六讲：总线</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>类型<ul><li>芯片内部总线：连接芯片内部的各个部分</li><li>系统总线：连接CPU、存储器、I&#x2F;O控制器和其他功能设备</li><li>通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</li></ul></li><li>总线结构<ul><li>数据线：在系统组件之间传输数据，数据线的数量决定了一次可以传输的数据的大小</li><li>地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向，地址线的数量决定了寻址空间的大小</li><li>控制线：控制对数据线和地址线的存取和使用</li></ul></li><li>特点<ul><li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</li><li>当总线在被使用过程中，其它设备不可以抢占</li></ul></li></ul><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ul><li><p>用途</p><ul><li>专用总线：始终只负责一项功能，或始终分配给特定的计算机组件</li><li>复用总线：将同一线路用于多种用途</li></ul></li><li><p>总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备</p><ul><li>集中式：由仲裁器或总线控制器负责分配总线使用权</li><li>分布式：每个设备都包含访问控制逻辑，各设备共同作用，分享总线</li></ul></li><li><p>链式查询</p><p><img src="image-20231227191653439.png" alt="image-20231227191653439.png"></p><ul><li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备</li><li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号</li><li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</li></ul></li><li><p>计数器查询</p><p><img src="image-20231227192026850.png" alt="image-20231227192026850.png"></p><ul><li>将总线允许线替换为设备ID线，如果总线空闲，总线仲裁器通过设备ID线发送计数</li><li>如果当前发送请求的设备ID等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为忙</li><li>通过使用不同的初始计数，可以灵活地确定设备优先级（强调优先级从1开始，强调公平性从上次使用总线的下一个设备的ID开始）</li></ul></li><li><p>独立请求</p><ul><li>每个设备都有自己的总线请求线和总线允许线，当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器，总线仲裁器决定哪个设备可以使用总线</li></ul></li><li><p>自举式</p><p><img src="image-20231227194000898.png" alt="image-20231227194000898.png"></p><ul><li>固定优先级，每个设备在其总线请求线上发送请求</li><li>每个设备自行判断自己是否在请求总线的设备中优先级最高</li></ul></li><li><p>时序</p><ul><li><p>确定每个总线事务的开始和结束时间</p></li><li><p>同步时序：事件的发生由时钟决定，所有设备共享同一个时钟</p></li><li><p>异步时序：一个事件的发生取决于前一个事件的发生</p></li><li><p><img src="image-20231227205709273.png" alt="image-20231227205709273.png"></p><p><img src="image-20231227201133777.png" alt="image-20231227201133777.png"></p></li><li><p>半同步时序：为了减少噪声的影响，在异步计时中使用时钟</p></li><li><p>分离事务：将一个总线事件分离为两个过程</p></li></ul></li><li><p>总线带宽（bus bandwidth）：总线的最大数据传输速率</p></li><li><p>数据传输速率：考虑地址传输、握手等因素</p><ul><li><p>同步总线时间：</p><ul><li>发送指令和地址到内存</li><li>内存准备数据时间（时钟周期整数倍，向上取整，例：时钟周期50 ns，230 ns -&gt; 250 ns）</li><li>将数据传输到CPU</li></ul></li><li><p>异步总线时间：</p><ul><li>步骤一握手</li><li>max{步骤2、3、4一起的时间，数据准备时间}</li><li>步骤5、6、7时间</li></ul></li><li><p>不同数据块大小：</p><p><img src="image-20231227212626052.png" alt="image-20231227212626052.png"></p><p><img src="image-20231227212641717.png" alt="image-20231227212641717.png"></p><p><img src="image-20231227212657044.png" alt="image-20231227212657044.png"></p></li><li><p>每秒总线事务数：用1s除以<strong>每个</strong>总线事务所需时间</p></li></ul></li><li><p>总线传输方式</p><ul><li>**猝发&#x2F;突发传输（Burst Transfer）：**在一次总线事务中，通过多个时钟周期连续传输一块数据，而不需要额外的地址和控制信号。这种方式可以提高数据传输的效率，因为它减少了每次传输所需的总线控制开销。</li><li><strong>DMA传输（Direct Memory Access）：</strong> DMA是一种通过专用的DMA控制器直接在主存储器和I&#x2F;O设备之间传输数据的方式，而无需CPU的直接干预。这提高了数据传输的效率。</li><li><strong>同步传输（Synchronous Transfer）：</strong> 在同步传输中，数据在一个统一的时钟信号下传输，根据时钟的边沿进行数据传送。这有助于确保数据的同步性，但要求系统中的各个部件都能保持同步。</li><li><strong>异步传输（Asynchronous Transfer）：</strong> 异步传输不依赖于统一的时钟信号，而是使用起始位和停止位来标识数据的开始和结束。异步传输通常用于短距离通信，例如串口通信。</li><li><strong>串行传输（Serial Transfer）：</strong> 串行传输是指每个时钟周期传输一个比特。虽然每个时钟周期只传输少量的数据，但串行传输通常具有较高的稳定性和较低的成本。典型：<strong>USB</strong></li><li><strong>并行传输（Parallel Transfer）：</strong> 在并行传输中，多个数据位同时在总线上传输。每个时钟周期传输多个比特，这样可以在同一时刻传输更多的数据，提高传输速率。</li></ul></li><li><p>总线层次</p><ul><li>单总线结构：CPU、存储器和I&#x2F;O模块都连接到一条系统总线</li><li>双总线结构：<ul><li>方案一：在 CPU 和存储器中间增加一个存储器总线</li><li>将系统总线分为存储器总线、 I&#x2F;O 总线 和 IOP (input&#x2F;output processor)</li></ul></li><li>多总线结构：<ul><li>方案一：增加一个本地总线（ local bus来连接CPU和cache）</li><li>方案二：将系统总线分为存储器总线、I&#x2F;O总线和DMA总线</li><li>方案三：增加一个高速I&#x2F;O总线来连接高速设备</li></ul></li></ul></li><li><p>注：60%的时间在读40%时间写直接用读写的数据传输速度加权；60%的访问为读40%访问为写需要在分母上对消耗的时钟周期加权然后重新计算数据传输速率</p><p><img src="image-20240102203024170.png" alt="image-20240102203024170.png"></p></li></ul><h2 id="第十七讲：输入输出（I-O）"><a href="#第十七讲：输入输出（I-O）" class="headerlink" title="第十七讲：输入输出（I&#x2F;O）"></a>第十七讲：输入输出（I&#x2F;O）</h2><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h3><ul><li><p>连接情况</p><ul><li>通过系统总线或中央交换器和存储器连接</li><li>通过专用数据线与一个或多个外设连接</li></ul></li><li><p>外部设备接口</p><p><img src="image-20231228163308278.png" alt="image-20231228163308278.png"></p><ul><li>I&#x2F;O模块的接口以控制 、 状态和数据信号的形式出现</li><li>与设备相关的控制逻辑控制外设的操作，以响应来自I&#x2F;O模块的命令</li><li>缓冲器用于缓存I&#x2F;O模块和外设之间传送的数据</li></ul></li><li><p>I&#x2F;O模块功能</p><ul><li>处理器通信<ul><li>命令译码：I&#x2F;O模块接收来自处理器的命令（I&#x2F;O指令），这些命令一般作为信号发送到控制总线</li><li>数据：数据是在处理器（通用寄存器组）和I&#x2F;O模块之间经由数据总线来交换的</li><li>状态报告：由于外设速度很慢 , 所以知道I&#x2F;O模块的状态很重要</li><li>地址识别：I&#x2F;O模块必须能识别它所控制的每个外设的唯一地址</li></ul></li><li>设备通信：通信内容包含命令、状态信息和数据</li><li>数据缓冲：外设的数据传送速度与存储器或处理器不同，有的快有的慢</li><li>控制和定时：处理器会非预期的与一个或几个外设进行通信</li><li>检错：检错并把差错信息报告给处理器</li></ul></li><li><p>结构</p><p><img src="image-20231228165511903.png" alt="image-20231228165511903.png"></p></li><li><p>I&#x2F;O端口和I&#x2F;O模块区别</p><ul><li>I&#x2F;O端口是计算机体系结构中的一个机制，用于通过特定地址进行I&#x2F;O访问，而I&#x2F;O模块表示连接到计算机系统的外部设备及其相关的控制电路。 I&#x2F;O模块通常包含一个或多个I&#x2F;O端口，其中每个端口对应于不同的功能或寄存器。</li></ul></li><li><p>外部接口</p><ul><li>并行接口：多根线连接I&#x2F;O模块和外设，同时传送多位数据</li><li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li></ul></li><li><p>编址方式</p><ul><li><strong>独立编址（Separate Addressing）：</strong> 在独立编址中，内存和I&#x2F;O设备拥有不同的地址空间。系统使用不同的地址范围来访问内存和I&#x2F;O设备，这意味着CPU使用不同的指令或地址范围来读写内存和I&#x2F;O设备。</li><li><strong>统一编址（Unified Addressing）：</strong> 在统一编址中，内存和I&#x2F;O设备共享相同的地址空间。系统使用相同的地址范围来访问内存和I&#x2F;O设备，使得CPU可以使用相同的指令和地址范围来读写内存和I&#x2F;O设备。</li></ul></li></ul><h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h3><ul><li><p>编程式I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</p><ul><li>当处理器在执行过程中遇到一条与I&#x2F;O操作有关的指令时，它通过发送指令到对应I&#x2F;O模块来执行这条指令</li><li>I&#x2F;O模块将执行所要求的动作，然后在I&#x2F;O状态寄存器中设置一些适当的位</li><li>I&#x2F;O不会中断处理器 因此处理器需要周期性地检查I&#x2F;O模块的状态 直到发现该操作完成</li></ul></li><li><p>中断驱动式I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令；并且当I&#x2F;O模块完成其工作后，才去中断处理器工作</p><p><img src="image-20231228171431496.png" alt="image-20231228171431496.png"></p><ul><li>处理器发送一个I&#x2F;O命令到模块，然后去处理其它有用的工作</li><li>当I&#x2F;O模块准备和处理器交换数据时，它中断处理器以请求服务</li><li>处理器执行数据传送，最后恢复它原先的处理工作</li><li>响应优先级和处理优先级<ul><li>响应优先级：中断被触发时，系统多快能够响应并开始执行相应的中断服务程序</li><li>处理优先级：在处理器已经响应中断并开始执行中断服务程序后，不同中断服务程序之间的执行顺序</li><li>过程：当中断同时来临时先按照响应优先级顺序响应中断，然后按该顺序处理，准备好当前响应优先级最高的中断所需环境后，比较处理优先级，如果有比当前中断处理优先级高的，插入该中断，完成后再回到原中断。在此过程中新的中断来了正常响应加入队列，但只在每次处理前检查队列的处理优先级</li><li>掩码字&#x2F;屏蔽字：该位为1表示可屏蔽对应的中断（自己一定可以屏蔽自己），即当前处理优先级高于该位对应中断的优先级</li></ul></li><li>设备识别方法：多条中断线、软件轮询、菊花链、独立请求</li></ul></li><li><p>直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与主存直接交换数据，而不需要处理器的干涉</p><ul><li>处理器通过发送以下信息向DMA模块发出命令：读&#x2F;写、I&#x2F;O设备地址、内存中的起始位置、字数，然后处理器继续进行其他工作</li><li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出而无需经过处理器</li><li>当传输完成时DMA模块向处理器发送一个中断信号</li><li><strong>DMA使用总线优先级高于CPU</strong></li></ul></li><li><p>DMA访问方法</p><ul><li>CPU停止法：控制简单，但影响CPU，没有充分利用内存</li><li>周期窃取：充分利用CPU和内存，及时响应I&#x2F;O请求，但每次都要申请总线，且一次只传输一个字</li><li>交替分时访问：CPU未停止或等待，DMA不请求总线</li></ul></li><li><p>查询式I&#x2F;O</p><ul><li>在轮询方式中，CPU定期地检查I&#x2F;O设备是否准备好进行数据传输。这种方式包括以下步骤：<ul><li><strong>步骤1：CPU发起请求</strong> CPU向I&#x2F;O设备发送一个请求，询问设备是否准备好进行数据传输。</li><li><strong>步骤2：等待设备准备</strong> CPU在一定的时间间隔内不断轮询（检查）设备的状态，看是否已经准备好执行请求。</li><li><strong>步骤3：数据传输</strong> 一旦I&#x2F;O设备准备好，CPU开始执行实际的数据传输。</li></ul></li><li>在此方式下，CPU全程参与数据传输，占用率为100%</li></ul></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法整理"><a href="#数据结构与算法整理" class="headerlink" title="数据结构与算法整理"></a>数据结构与算法整理</h1><h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><ul><li>数据结构概念<ul><li>A data structure is a data object together with the relationships among the data members that compose the object</li><li>Data Structure &#x3D; {D，R}，D为数据，R为所有数据间的关系</li><li>抽象数据结构ADT：数据 + 对应操作</li></ul></li></ul><span id="more"></span><ul><li>线性结构<ul><li><img src="image-20240106150547680.png" alt="image-20240106150547680" style="zoom: 50%;" /></li></ul></li><li>算法<ul><li>an operation sequence of solving a problem</li></ul></li><li>递归<ul><li>递归的两条基本规则: (1) Base cases (2) Making progress</li><li>直接递归：函数或过程直接调用自身。</li><li>间接递归：函数或过程调用其他函数，而这些其他函数中又调用原始函数，最终形成一个递归循环。</li></ul></li><li>泛型<ul><li>泛型（Generic）是一种编程范式，它允许在编写代码时使用一种抽象的方式来操作数据类型。</li></ul></li></ul><h2 id="第二章-算法分析"><a href="#第二章-算法分析" class="headerlink" title="第二章 算法分析"></a>第二章 算法分析</h2><ul><li><p>空间复杂度</p><ul><li><p>用来衡量算法在执行过程中所需存储空间的度量。它表示算法的额外空间需求与输入规模之间的关系。</p></li><li><p>组成部分</p><ul><li>指令空间</li><li>数据空间</li><li>运行环境栈空间</li></ul></li><li><p>分类</p><ul><li>固定部分：指令、简单变量、定长复合变量、常量</li><li>可变部分：复合变量、动态分配空间、递归栈</li></ul></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">SequentialSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> [] a, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length &amp;&amp;a[i]!=x; i++) ;<br>        <span class="hljs-keyword">if</span>(i= = a.length) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据空间：12 bytes : x，i，a[i]，0，1，a.length</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">float</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> sum(a, n - <span class="hljs-number">1</span>) + a[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归栈空间：（参数 + 返回地址）* 递归深度</li></ul></li></ul></li><li><p>时间复杂度</p><ul><li><p>用来衡量算法执行时间随输入规模增长而变化的度量，描述的是随着输入规模的增大，算法的运行时间将如何增长。</p></li><li><p>最优、最差与平均复杂度：平均复杂度一般难以计算，因此多用最差和最优情况分析</p></li><li><p>计算</p><ul><li>统计基本操作的执行次数： 首先，确定算法中的基本操作，例如赋值、比较、循环迭代等。然后，统计这些基本操作的执行次数，以及它们与输入规模的关系。</li><li>忽略常数项： 在计算时间复杂度时，通常会忽略常数项，即忽略执行次数中与输入规模无关的常数因子。这是因为在大规模输入时，常数项对总体复杂度的增长影响较小。</li><li>关注主导因子： 确定算法执行步骤中占主导地位的因子，即最大影响复杂度增长的部分。通常，我们关注循环中执行次数最多的部分或递归算法的递归关系。</li></ul></li><li><p>秩排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RankSort</span> &#123;<br>    <span class="hljs-comment">// Rank the elements in the array a[0:n-1] and store ranks in the array r</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rank</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            r[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[j] &lt;= a[i]) &#123;<br>                    r[i]++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r[j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rearrange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (r[i] != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> r[i];<br>                swap(a[i], a[t]);<br>                swap(r[i], r[t]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>数据比较：n * (n - 1) &#x2F; 2</p></li><li><p>元素交换次数：2 * n（每次循环中至少有一个元素的秩被正确放置，故不超过n次）</p></li></ul></li><li><p>注意点</p><ul><li>在计算数据移动次数时，一次swap需要移动元素3次</li><li>循环里的变量初始赋值以及循环条件里的赋值也各算一次移动，当存在多重循环时需要考虑（一般只考虑循环体里的赋值）</li></ul></li></ul></li><li><p>大O表示法</p><ul><li>定义：对于一个函数 f(n)，如果存在正常数 c 和正整数 n0，使得对于所有的 n &gt; n0，都有 f(n) &lt;&#x3D; c * g(n)，其中 g(n) 是某个已知函数，那么我们就说 f(n) 的渐近上界是 O(g(n))，记作 f(n) &#x3D; O(g(n))。</li><li>Ω表示法：渐近下界</li><li>θ表示法：介于中间</li></ul></li><li><p>折半查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 如果目标值等于中间值，找到目标值</span><br>        <span class="hljs-keyword">if</span> (array[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果目标值小于中间值，在左侧继续查找</span><br>        <span class="hljs-keyword">if</span> (target &lt; array[mid]) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果目标值大于中间值，在右侧继续查找</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br>    <span class="hljs-comment">// 如果未找到目标值，返回 -1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SelectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> n; size &gt; <span class="hljs-number">1</span>; size --)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Max(a,size);<span class="hljs-comment">//寻找a[0 : size - 1]中的最大值,O(n)</span><br>swap(a[j],a[size-<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Max数据比较次数：n * (n - 1) &#x2F; 2</li><li>数据交换次数：3 * (n - 1)</li></ul></li><li><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">1</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j &lt; i - <span class="hljs-number">1</span>, j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &gt; a[j+<span class="hljs-number">1</span>])swap(a[j],a[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据比较次数和选择排序一样</li></ul></li><li><p>插入排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j+<span class="hljs-number">1</span>]&lt;arr[j])&#123;swap(&amp;arr[j],&amp;arr[j+<span class="hljs-number">1</span>]);&#125; <br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第三章-线性表"><a href="#第三章-线性表" class="headerlink" title="第三章 线性表"></a>第三章 线性表</h2><ul><li><p>定义</p><ul><li><p>L &#x3D; (e1, e2, ···, en), size 为n，n &#x3D; 0 -&gt; 空表</p></li><li><p>操作：<img src="image-20240106173001935.png" alt="image-20240106173001935" style="zoom:50%;" /></p></li></ul></li><li><p>数组实现的线性表</p><ul><li><img src="image-20240106173658855.png" alt="image-20240106173658855" style="zoom:50%;" /></li><li>search(x) ：O(length)</li><li>remove( k,x)：O(n)</li><li>insert (x , i)：O(n)</li><li>缺点：插入和删除时间长</li></ul></li><li><p>单链表实现的线性表</p><ul><li><img src="image-20240106210937444.png" alt="image-20240106210937444" style="zoom:50%;" /></li><li>操作方法和链表一样</li></ul></li><li><p>单链表操作</p><ul><li>删除：<ul><li>若为头节点直接将head指针指向下一个节点</li><li>将下一个节点的值复制到当前节点，覆盖当前节点的值。</li><li>将当前节点的 next 指针指向下一个节点的下一个节点。</li></ul></li><li>插入<ul><li>创建一个新节点，将新节点的next指针指向目标节点的下一个节点。</li><li>将目标节点的 next指针指向新节点。</li></ul></li><li>交换<ul><li>设有abcd四个节点</li><li>先让a指向c，再让b指向d，最后再让c指向b（b有额外指针，即已知）</li></ul></li><li>单链表类<ul><li>ListNode：链表结点类</li><li>LinkedList：链表本身的类isEmpty()、makeEmpty()、zeroth()、first()、find(object x)、remove()、insert(Object x, LinkedListItr p)、findprevious(Object x)</li><li>LinkedListItr：一个迭代器（类比读卡器），用来读取链表节点isPastEnd()、retrieve()、advance()</li></ul></li></ul></li><li><p>带表头结点的单链表</p><ul><li>头结点是链表的第一个结点，但不存储实际的数据。它的存在使得链表的插入、删除等操作在任何位置都可以统一为一种操作，无需特殊处理头结点。</li><li>空链表表示为头结点的 next 指针为 null</li></ul></li><li><p>链表的数组实现</p><img src="image-20240106210926230.png" alt="image-20240106210926230" style="zoom:50%;" /></li><li><p>基数排序</p><ul><li><img src="image-20240106212447675.png" alt="image-20240106212447675" style="zoom:40%;" /></li><li>按从低位到高位依次放入桶中，n（最高位数）次后排序完成</li><li>实现：原始要排序的数据、桶中的数据都可以用链表或数组来实现。</li></ul></li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><ul><li>定义<ul><li>插入和删除都在同一侧的线性表</li><li>末端叫top，另一端叫bottom</li></ul></li><li>方法<ul><li><img src="image-20240107091929146.png" alt="image-20240107091929146" style="zoom:50%;" /></li><li>pop()：出栈</li><li>push()：入栈</li></ul></li></ul><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h3><ul><li>定义<ul><li>插入和删除在两端的线性表</li><li>也叫先进先出列表</li><li>新元素进入的端叫rear，旧元素出队的端叫front</li></ul></li><li>方法<ul><li><img src="image-20240107093052919.png" alt="image-20240107093052919" style="zoom:50%;" /></li><li>数组实现：<img src="image-20240107093427609.png" alt="image-20240107093427609" style="zoom:50%;" /></li><li>enqueue()：入队</li><li>dequeue()：出队</li></ul></li></ul><h2 id="第四章-树"><a href="#第四章-树" class="headerlink" title="第四章 树"></a>第四章 树</h2><ul><li>定义<ul><li>节点的集合，由一个根节点和若干子树构成</li><li>节点的度degree：孩子的个数</li><li>树的度：节点度的最大值</li><li>枝和叶：度为0的节点称为叶，度数不为0的节点称为枝</li><li>级level：根的级为0&#x2F;1，其他节点的级为父节点的级+1</li><li>树的深度&#x2F;高度：最大的级</li></ul></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><p>二叉树</p><ul><li>定义：有根节点且其余每个节点构成两棵子树，称为左子树和右子树</li><li>定理<ul><li>二叉树的边数 &#x3D; 节点数 - 1</li><li>第i层的节点数最多为2 ^ i</li><li>高度为h的二叉树节点个数：h + 1 到 2 ^ (h + 1) - 1</li><li>叶节点数量 &#x3D; 度为2节点个数 + 1</li><li>有n个节点的树高度范围：n - 1 到 log2(n + 1) - 1</li></ul></li><li>满二叉树：高度为h且有2 ^ (h + 1) - 1个节点的树</li><li>完全二叉树：<img src="image-20240107111044518.png" alt="image-20240107111044518" style="zoom:50%;" /></li><li>数组实现：二叉树被看作完全二叉树缺失了部分节点，完全二叉树按顺序填入数组</li><li>链表实现：节点结构为数据 + 左子树 + 右子树</li><li>cursor实现：<img src="image-20240107115634904.png" alt="image-20240107115634904" style="zoom: 33%;" /></li><li>方法：<img src="image-20240107115801585.png" alt="image-20240107115801585" style="zoom:40%;" /></li></ul></li><li><p>二叉树的遍历</p><ul><li><img src="image-20240107120939766.png" alt="image-20240107120939766" style="zoom:50%;" /></li><li><p>前序遍历：根-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历：左子树-&gt;根-&gt;右子树</p></li><li><p>后序遍历：左子树-&gt;右子树-&gt;根</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Preorder traversal递归写法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BinaryNode&lt;T&gt;* t)</span></span>&#123;<br>    <span class="hljs-comment">// preorder traversal of *t.</span><br><span class="hljs-keyword">if</span>(t)&#123;<br>        <span class="hljs-built_in">visit</span>(t);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Left);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Right);<br>        <span class="hljs-comment">//InOrder和PostOrder只需要换顺序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法：<img src="image-20240107123919487.png" alt="image-20240107123919487" style="zoom: 40%;" /></p></li><li><p>用遍历结果建树</p><ul><li><img src="image-20240107123115144.png" alt="image-20240107123115144" style="zoom:45%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  void CreateBT(String pres, String ins, BinaryNode<Type>* &amp; t){<br>      int inpos;<br>      String prestemp, instemp;</p><pre><code class="hljs">  if (pres.length() == 0)      t = NULL;  else &#123;      t = new BinaryNode;      t-&gt;element = pres.ch[0];      inpos = 0;      while (ins.ch[inpos] != t-&gt;element)inpos++;      //对左子树建树      prestemp = pres(1, inpos);      instemp = ins(0, inpos-1);      CreateBT(prestemp, instemp, t-&gt;left);      //对右子树建树      prestemp = pres(inpos + 1, pres.length() - 1);      instemp = ins(inpos + 1, pres.length() - 1);      CreateBT(prestemp, instemp, t-&gt;right);  &#125;</code></pre><p>  }<br>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 如果为后序+中序：建根节点时和移动inpos时注意后序最后一个元素为根,递归部分如下：<br><br>  ````c++<br>  posttemp = posts(<span class="hljs-number">0</span>, inpos - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(0, </span>inpos - <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;left);<br>  <br>  posttemp = posts(inpos, posts.length() - <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(inpos </span>+ <span class="hljs-number">1</span>, <span class="hljs-keyword">ins.length() </span>- <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;right);<br></code></pre></td></tr></table></figure></p></li></ul><h3 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h3><ul><li>树的存储方式<ul><li><strong>左子女右兄弟表示法</strong>（重点）<ul><li>每个节点除了存储自己的信息外，还存储了其<strong>最左边</strong>的子节点和<strong>最靠近</strong>的右兄弟节点的指针。</li><li><code>TreeNode *firstchild, *nextsibling;</code></li></ul></li><li>双亲表示法：在树节点中存储父节点的位置</li><li>广义表（基本不考）：如a(b(f,g),c,d(h,i,j),e)</li></ul></li><li>森林<ul><li>若干树的集合</li><li>森林-&gt;树：先将树全部转成二叉树，再将树的根节点用右链相连</li><li>树-&gt;森林：依次剪断根节点和右子树，形成新的树</li><li>把一棵树转化为二叉树：从这棵树的根结点开始，从上到下，看每一个结点，把你正在看的结点的孩子放在左子树，兄弟放在右子树。（将节点的孩子放在左子树，将节点的兄弟放在右子树）</li></ul></li><li>树的遍历<ul><li>深度优先遍历<ul><li>先序次序遍历：先访问树的根，再按先序遍历根的第一棵子树，第二棵子树，……</li><li>后序次序遍历：按先序遍历根的第一棵子树，第二棵子树，……，最后访问树的根</li></ul></li><li>广度优先遍历<ul><li>分层访问</li></ul></li><li>森林的遍历：先把森林转化成二叉树，再进行树的遍历</li></ul></li></ul><h3 id="特殊的树"><a href="#特殊的树" class="headerlink" title="特殊的树"></a>特殊的树</h3><ul><li><p>线索树</p><ul><li><p>n个结点的二叉树有2n个链域，其中真正有用的是n - 1 个，其它 n + 1 个都是空域。为了充分利用结点中的空域，使得对某些运算更快，用这些空域存储额外的信息</p></li><li><p>一个节点内增加两个标记：左子女|左线索|数据|右线索|右子女</p></li><li><p>若左线索为0，左子女指针正常指向左子女；若左线索为1，左子女指向前驱（某线性序列）</p></li><li><p>若右线索为0，右子女指针正常指向右子女；若右线索为1，右子女指向后继</p></li><li><p>中序线索树节点A的<strong>前驱</strong>为A左子树中的最右节点或者A的某个右子树包含A的祖先节点</p></li><li><p>中序线索树节点A的<strong>后继</strong>为A的右子树中的最左节点，或者是A的某个左子树包含A的祖先节点</p></li></ul><blockquote><p>注：这里的左右看的是垂直位置</p><p>​             1</p><p>如： &#x2F;        \     中从左到右为2-&gt;1-&gt;3</p><p>​     2              3</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadedTreeNode prev;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createThreadedTree</span><span class="hljs-params">(ThreadedTreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            createThreadedTree(root.left);<br><span class="hljs-comment">//左子女为空填前驱</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                root.left = prev;<br>                root.leftThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//pre右子女为空填当前节点</span><br>            <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span> &amp;&amp; prev.right == <span class="hljs-literal">null</span>) &#123;<br>                prev.right = root;<br>                prev.rightThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            prev = root;<span class="hljs-comment">//更新前驱</span><br><br>            createThreadedTree(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>霍夫曼树</p><p><a href="https://blog.csdn.net/qinglongzhan/article/details/80983492">Huffman编码算法详解_哈夫曼编码怎么算-CSDN博客</a></p><ul><li>增长树：对原二叉树中度为1的结点，增加一个空树叶；对原二叉树中的树叶，增加两个空树叶</li><li>外通路长度(外路径)E：根到每个外结点(增长树的叶子)的路径长度的总和(边数)；与之类似，内路径长度I对应内节点(非叶子)</li><li>结点的带权路径长度：一个结点的权值与结点的路径长度的乘积，用于算带权的外(内)路径长度</li><li>霍夫曼树：给出 m 个实数作为m个外结点的权构造一棵增长树，使得带权外路径长度最短</li><li>霍夫曼算法<ul><li><strong>初始化：</strong> 将每个字符看作一个独立的树，节点的权重为字符的频率。</li><li><strong>选择两棵权重最小的树：</strong> 从当前的树集合中选择两棵权重最小的树，合并成一棵新的树，新树的权重为两棵树的权重之和。</li><li><strong>重复步骤2：</strong> 不断重复步骤2，直到只剩下一棵树为止。</li><li>注意: 当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。</li></ul></li></ul></li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li><p>定义：二叉搜索树（Binary Search Tree，简称BST）是一种二叉树，其中每个节点都包含一个键值，并且满足以下性质：</p><ol><li>对于每个节点，其左子树中所有节点的键值都小于该节点的键值。</li><li>对于每个节点，其右子树中所有节点的键值都大于该节点的键值。</li><li>对于每个节点，其左右子树都是二叉搜索树。</li></ol></li><li><p>Indexed binary search tree：在二叉搜索树基础上每个节点增加一个leftsize &#x3D; 左子树节点个数 + 1</p></li><li><p>查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">find</span><span class="hljs-params">( Comparable x, BinaryNode t )</span>&#123;<br>    <span class="hljs-keyword">if</span>( t = = <span class="hljs-literal">null</span> )&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-keyword">if</span>( x. compareTo( t.element ) &lt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.left );&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo( t.element ) &gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.right );&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> t;&#125; <span class="hljs-comment">//Match</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>插入：<code>if( t = = null )&#123;t = new BinaryNode( x, null, null );&#125;</code>其他与查找相同</p></li><li><p>删除</p><ul><li>待删节点为叶节点：直接删</li><li>待删节点有一个非空子树：删除该节点后将它的子树接在被删节点的位置</li><li>待删节点有两个非空子树：找出左子树的最大值或右子树的最小值，将这个节点与待删节点互换位置，然后删除换位后的待删节点</li></ul></li><li><p>查找时间复杂度：worst-&gt;O(n)，best-&gt;O(log2 n)</p></li></ul><h3 id="AVL树（自平衡的二叉搜索树）"><a href="#AVL树（自平衡的二叉搜索树）" class="headerlink" title="AVL树（自平衡的二叉搜索树）"></a>AVL树（自平衡的二叉搜索树）</h3><ul><li>平衡因子：左子树和右子树的高度（或深度）之差，不能超过1</li><li>AVL的插入与删除：与二叉搜索树相同，但插入和删除若破坏平衡，要进行<strong>旋转</strong></li><li>AVL的旋转<ul><li>最小失衡树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。只需要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</li><li>左外侧不平衡：右单旋</li><li>右外侧不平衡：左单旋</li><li>左内侧不平衡：左双旋转</li><li>右内侧不平衡：右双旋转</li><li><img src="image-20240107185808987.png" alt="image-20240107185808987"  /></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><ul><li><p>m-路搜索树</p><ul><li>在m路搜索树中，每个内部节点可以有多达m个子树。它有以下特性：<ol><li>每个节点最多有m个子树。</li><li>除根节点和叶子节点外，每个节点至少有m &#x2F; 2个子树。</li><li>所有叶子节点都在同一层次上。</li></ol></li></ul></li><li><p>B-树：平衡的m-路搜索树</p><ul><li><p>查找：</p><ul><li><strong>从根节点开始：</strong> 从B树的根节点开始，逐级向下搜索。</li><li><strong>在节点中查找关键字：</strong> 在当前节点中查找目标关键字。如果目标关键字等于当前节点中的某个关键字，则查找成功，返回相应的信息或指针。</li><li><strong>选择子树：</strong> 如果目标关键字小于当前节点中的所有关键字，选择当前节点的第一个子树。如果目标关键字大于当前节点中的某个关键字，选择该关键字右侧的子树。</li><li><strong>递归：</strong> 递归地在所选择的子树上执行查找操作，回到步骤2。</li><li><strong>叶子节点：</strong> 如果当前节点是叶子节点，表示到达了树的底部，但仍未找到目标关键字。查找失败，返回相应的提示或空值。</li></ul></li><li><p>插入（假设为3阶B-树）</p><ul><li>首先与查找操作一样，找到待插入节点</li><li>若目标插入节点关键字数量小于2（m - 1），直接插入</li><li>若目标插入节点关键字数量已经为2进行<strong>分裂</strong></li><li>分裂：分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</li><li><img src="image-20240107194100165.png" alt="image-20240107194100165" style="zoom: 60%;" /></li></ul></li><li><p>删除</p><ul><li><p>若该节点删除前关键字个数大于m &#x2F; 2，直接删除</p></li><li><p>若该节点关键字个数等于m &#x2F; 2，即删除后不满足B-树要求，按从左到右顺序从相邻的兄弟节点借一个数据</p><img src="image-20240107200008343.png" alt="image-20240107200008343" style="zoom: 40%;" /></li><li><p>若相邻兄弟节点关键字个数为m &#x2F; 2，则将两个节点合并（把父节点里根位置关键字也合并进来），若此过程使父节点也不满足B-树定义，递归向上进行</p><img src="image-20240107200139516.png" alt="image-20240107200139516" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><ul><li>装载因子<ul><li>定义：装载因子（Load Factor）是哈希表中用于衡量已经存储的元素数量与哈希表容量之比的一个指标，表示为：Load Factor &#x3D; 哈希表容量已存储的元素数量 &#x2F; 哈希表容量</li><li>装载因子大于1碰撞概率大，小于1碰撞概率小</li></ul></li></ul><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><ul><li><p>取余法：</p><img src="image-20240107201105493.png" alt="image-20240107201105493" style="zoom: 67%;" /></li><li><p>平方取中法</p><img src="image-20240107201206982.png" alt="image-20240107201206982" style="zoom: 67%;" /></li><li><p>乘法杂凑法：使用[M * ( k * A % 1) ]作为哈希地址，其中A是一个在0和1之间的常数。</p><img src="image-20240107201240355.png" alt="image-20240107201240355" style="zoom: 67%;" /></li></ul><h3 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h3><ul><li>线性探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 2 ··· m - 1，0 ··· d - 1号位置，若检测到空闲，则占据该位置</li><li>简单地说就是从原位置沿数组找第一个空位置插入</li></ul></li><li>二次探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 4，d + 9··· 号位置，若检测到空闲，则占据该位置</li></ul></li><li>双哈希<ul><li>使用两个独立的哈希函数来计算下一个探测位置。这两个哈希函数分别为h1(key)和h2(key)</li><li>若发生冲突，探测d + c, d + 2c, d + 3c······号位置</li></ul></li><li>再散列：当哈希表中的元素数量达到一定阈值时，再散列会触发，引发哈希表的重新构建。主要步骤：<ul><li><strong>创建新的哈希表：</strong> 当哈希表中的元素数量达到一定的阈值（例如，装载因子超过某个预定的阈值），再散列会创建一个新的更大的哈希表。</li><li><strong>重新哈希：</strong> 将哈希表中的所有元素重新插入到新的哈希表中。这个过程会使用新的哈希函数，通常是一个更大的哈希表大小对应的函数。</li><li><strong>替换原有哈希表：</strong> 重新哈希完成后，新的哈希表替换了原有的哈希表，成为存储元素的主要数据结构。</li></ul></li><li>分离链接<ul><li><img src="image-20240107205422549.png" alt="image-20240107205422549" style="zoom:50%;" /></li></ul></li></ul><h2 id="第六章-优先级队列（堆）"><a href="#第六章-优先级队列（堆）" class="headerlink" title="第六章 优先级队列（堆）"></a>第六章 优先级队列（堆）</h2><ul><li>定义<ul><li>类似于普通的队列或堆栈，但是每个元素都关联有一个优先级。在优先级队列中，元素按照其优先级被处理，而不是按照插入的顺序。</li><li>查找、删除最高优先级的叫最大优先级队列，反之称为最小优先级队列</li></ul></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>定义：一个最大（小）堆是所有节点值都比其孩子节点值大（小）的<strong>完全二叉树</strong></p></li><li><p>插入：新插入的元素插在堆的最后，若插入后不满足最大（小）堆的要求，向上调整，即不断交换</p><img src="image-20240107211422734.png" alt="image-20240107211422734" style="zoom:67%;" /></li><li><p>删除：堆只能删除顶部元素，删除后将底部元素提到顶部，再从上向下调整（例：若为最大堆则每次选择两个孩子中更大的进行交换）</p><img src="image-20240107211726374.png" alt="image-20240107211726374" style="zoom:67%;" /></li><li><p>方法：<img src="image-20240107211909366.png" alt="image-20240107211909366" style="zoom:50%;" /></p></li><li><p>向下调整算法建堆</p><ul><li><p>向下调整算法：如图，以下二叉树经过以下步骤转换为大堆</p><ul><li>选出孩子节点中大的值大的与父结点比较，如孩子节点大于父结点则交换，如小于则停止。</li><li>持续向下比较，比较到叶子结点或者孩子结点小于父结点则停止。</li></ul><p><img src="image-20240107212509783.png" alt="image-20240107212509783"></p></li><li><p>从后向前建堆：找到数组最后一个元素的父节点，为图中编号为1的子树，从后向前执行向下调整算法。</p><img src="image-20240107212531304.png" alt="image-20240107212531304" style="zoom: 67%;" /></li></ul></li><li><p>向上调整算法建堆</p><ul><li><p>向上调整算法建堆的过程与向下调整算法相似，从下标为1（即顶部）的结点开始向后调整：</p><ul><li>如孩子节点大于父结点就进行交换，直到与根结点比较完毕。</li><li>如孩子节点小于父节点也停止调整，让下一结点进行调整。</li></ul><p><img src="image-20240107213231846.png" alt="image-20240107213231846"></p></li></ul></li><li><p>堆排序</p><ul><li>第一步：将给定数据按顺序建成完全二叉树，然后调整成最大堆（从小到大排序用最大堆，从大到小排序用最小堆）</li><li>第二步：堆分为有序区和无序区，每次把无序区的最后一个元素与堆顶元素交换，此时有序区扩增，然后对无序区进行向下调整让它重新成为最大（小）堆</li><li>重复进行第二步直到排序完成</li></ul><img src="image-20240107213415919.png" alt="image-20240107213415919" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        percDown(a, i, a.length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        swapReferences(a, <span class="hljs-number">1</span>, i);<br>        percDown(a, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(Comparable[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    Comparable tmp;<br>    <br>    <span class="hljs-keyword">for</span> (tmp = a[i]; leftChild(i) &lt; n; i = child) &#123;<br>        child = leftChild(i);<br>        <br>        <span class="hljs-keyword">if</span> (child != n - <span class="hljs-number">1</span> &amp;&amp; a[child].compareTo(a[child + <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>            child++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (tmp.compareTo(a[child]) &lt; <span class="hljs-number">0</span>) &#123;<br>            a[i] = a[child];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    a[i] = tmp;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第七章-并查集"><a href="#第七章-并查集" class="headerlink" title="第七章 并查集"></a>第七章 并查集</h2><ul><li><p>等价类：指集合中的元素按照某个等价关系被划分成若干个子集，其中每个子集内的元素在这个等价关系下是相互等价的。一个等价关系是满足以下三个性质的关系：自反性、对称性、传递性</p></li><li><p>并查集定义：用于处理集合的数据结构，主要用于解决元素的等价关系和集合合并的问题。每个元素都被分配一个唯一的标识符，并且每个集合由一棵树来表示，其中树的根节点是集合的代表元素。</p></li><li><p>操作</p><ul><li>find(e)：在并查集中寻找e</li><li>union(a, b)：将a、b两个等价类合并，通常把其中一个的根节点连到另一个的根节点上</li><li>combine(a, b)：i&#x3D;Find(a)；j&#x3D;Find(b)；if(i !&#x3D; j) Union(i, j)；</li></ul></li><li><p>实现：每个等价类取出一个代表元素作为根，其他元素按层级结构作为孩子</p><ul><li><img src="image-20240108093433682.png" alt="image-20240108093433682" style="zoom:50%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  int Find(int e){<br>      while(parent[e])<br>          e &#x3D; parent[e];<br>      return e;<br>  }</p><p>  void Union(int i, int j){<br>      parent[j]&#x3D;i;<br>  }<br>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>    - 时间复杂度：find-&gt;<span class="hljs-built_in">O</span>(h)，<span class="hljs-keyword">union</span>-&gt;θ(<span class="hljs-number">1</span>)<br><br>+ <span class="hljs-keyword">union</span>算法的提升<br><br>    - 重量规则：将树中节点多的根作为合并后的新根<br>    - 高度规则：将树高更高的根节点作为合并后的新根，用一个数组实现，根结点中放负数，绝对值代表高度<br><br>  ````c++<br>  <span class="hljs-comment">//重量规则</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>      root = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//指示该节点是否为根</span><br>      parent = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//存放树节点个数</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">1</span>; e &lt;= n; e++) &#123;<br>          parent[e] = <span class="hljs-number">1</span>;<br>          root[e] = <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (!root[e]) &#123;<br>          e = parent[e];<br>      &#125;<br>      <span class="hljs-keyword">return</span> e;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (parent[i] &lt; parent[j]) &#123; <span class="hljs-comment">// i becomes subtree of j</span><br>          parent[j] = parent[j] + parent[i];<br>          root[i] = <span class="hljs-literal">false</span>;<br>          parent[i] = j;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          parent[i] = parent[i] + parent[j];<br>          root[j] = <span class="hljs-literal">false</span>;<br>          parent[j] = i;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//高度规则</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[root2] &lt; s[root1]) &#123;<br>        s[root1] = root2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (s[root1] == s[root2]) &#123;<br>            s[root1] = root2;<br>            s[root2] = root1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>find的提升：路径压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(parent[e] == e)&#123;<span class="hljs-keyword">return</span> e;&#125;<br>    <span class="hljs-keyword">return</span> parent[e] = <span class="hljs-built_in">find</span>(parent[e]);<br>&#125;<br><span class="hljs-comment">//第一次find没有压缩，以后的都压缩过了</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="第八章-图"><a href="#第八章-图" class="headerlink" title="第八章 图"></a>第八章 图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>定义：Graph&#x3D;(V, E)；V：非空有限点集；E：边集合</p><ul><li>无向图：边(v1, v2) &#x3D; (v2, v1)</li><li>有向图与无向图相反</li></ul></li><li><p>完全图：有n个点和n * (n - 1) &#x2F; 2条边的无向图（有向图n * (n - 1)条边），即每个点都和其他点直接相连</p></li><li><p>度</p><ul><li>入度：以该点为终点的边的条数</li><li>出度：以该点为起点的边的条数</li><li>对无向图，度就是节点连接的边的条数</li></ul></li><li><p>子图：V’ 包含于V，E’ 包含于E，则(V’, E’)为(V, e)的子图</p></li><li><p>简单路径与简单回路：一个简单路径是指图中不包含重复节点的路径，简单回路是起始点相同的简单路径</p></li><li><p>连通图</p><ul><li>一个图是连通图，如果图中的任意两个节点之间存在至少一条路径</li><li>一个有向图是强连通图，如果图中的任意两个节点之间存在双向路径</li></ul></li><li><p>连通分量</p><ul><li>一个图的连通分量是指图中的一个最大连通子图</li><li>强连通分量是指有向图中的一个极大强连通子图，即一个最大的子图，其中任意两个节点都是强连通的。</li></ul></li><li><p>权重图：边上带有权值，表示对象之间的关系具有权重。</p></li><li><p>网络：连通的权重图和子图</p></li><li><p>生成树：无环连通图的一种特殊子图。对于一个连通图 G，它的生成树是 G 的一个子图，包含了图中的所有节点，并使得这个子图是一个树（无环连通图）。</p><p>生成树有以下特性：</p><ol><li>包含了图中的所有节点。</li><li>是一个树，即无环连通图。</li><li>保留了原图中的边，但是边的数量是节点数减一。</li></ol></li><li><p>方法：<img src="image-20240108103611106.png" alt="image-20240108103611106" style="zoom: 60%;" /></p></li><li><p>邻接矩阵（Adjacency Matrix）： 用二维数组表示节点之间的关系，矩阵中的元素表示边的存在或权值。</p><ul><li>aij &#x3D; 1表示存在(i, j)这条边</li><li>无向图的邻接矩阵是对称矩阵</li><li>若图为网络（权重图），则将0换为∞，1换为权重</li></ul></li><li><p>邻接表</p><ul><li>如果边的数量少，使用邻接表可以减少内存消耗</li><li><img src="image-20240108104520940.png" alt="image-20240108104520940" style="zoom:50%;" /></li><li><img src="image-20240108104535783.png" alt="image-20240108104535783" style="zoom:50%;" /></li></ul></li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li><p>深度优先遍历 DFS</p><ul><li><p>沿着图的深度尽可能远的方式遍历图的节点，直到无法再继续前进为止，然后回溯到之前的节点，继续探索其他路径。</p><img src="image-20240108110219014.png" alt="image-20240108110219014" style="zoom:67%;" /></li><li><p>步骤：</p><ul><li>选择一个起始节点作为当前节点。</li><li>访问当前节点，并标记为已访问。</li><li>对当前节点的每个邻接节点，如果该邻接节点未被访问，递归地应用 DFS。</li><li>若该节点向下的邻接节点都已被访问，返回到上一步，继续对其他未访问的节点应用 DFS。</li></ul></li><li><p>使用辅助数组visited[]实现</p></li></ul></li><li><p>广度优先遍历</p><ul><li>思想：从图中某顶点v0出发，在访问了v0之后依次访问v0的各个未曾访问过的邻接点，然后分别从这些邻接点出发广度优先遍历图，直至图中所有顶点都被访问到为止</li><li><img src="image-20240108110234403.png" alt="image-20240108110234403" style="zoom:50%;" /></li><li>使用辅助数组visited[]实现</li></ul></li><li><p>连通分量</p><ul><li>当无向图(以无向图为例)为非连通图时，从图的某一顶点出发进行遍历(深度&#x2F;广度)只能访问到该顶点所在的最大连通子图(即连通分量)的所有顶点</li><li><img src="image-20240108110814458.png" alt="image-20240108110814458" style="zoom:40%;" /></li></ul></li></ul><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul><li><p>最小代价生成树：各边权的总和为最小的生成树</p></li><li><p>逐步求解(Grandy)策略：</p><ul><li>设：连通网络<br>N&#x3D;{V,E}, V 中有 n 个顶点。<ul><li>先构造 n 个顶点， 0 条边的森林 F&#x3D;{T0 ,T1 ,…..,Tn-1}</li><li>每次向 F 中加入一条边。该边是一端在 F 的某棵树Ti上而另一端不在Ti上的所有边中具有最小权值的边。这样使F中两棵树合并为一棵，树的棵数 - 1</li><li>重复n - 1次</li></ul></li></ul></li><li><p>Kruskal算法</p><ul><li><img src="image-20240108114809407.png" alt="image-20240108114809407" style="zoom:50%;" /></li><li><p>图用邻接矩阵表示，顶点信息在顶点表Verticelist中，取最小的边利用最小堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> edgesAccepted;<br>    DisjSet s;<br>    PriorityQueue h;<br>    Vertex u, v;<br>    SetType uset, vset;<br>    Edge e;<br>    <span class="hljs-comment">// 从图中读取边并构建最小堆</span><br>    h = readGraphIntoHeapArray();<br>    h.buildHeap();<br>    <span class="hljs-comment">// 初始化并查集和边的数量</span><br>    s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisjSet</span>(NUM_VERTICES);<br>    edgesAccepted = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环直到生成树中的边数量达到 NUM_VERTICES - 1</span><br>    <span class="hljs-keyword">while</span> (edgesAccepted &lt; NUM_VERTICES - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从最小堆中取出权值最小的边</span><br>        e = h.deleteMin(); <span class="hljs-comment">// Edge e = (u, v)</span><br>        <span class="hljs-comment">// 查找边两端节点所在的集合</span><br>        uset = s.find(u);<br>        vset = s.find(v);<br>        <span class="hljs-comment">// 如果两个节点不在同一集合，说明加入这条边不会形成环</span><br>        <span class="hljs-keyword">if</span> (uset != vset) &#123;<br>            edgesAccepted++;<br>            <span class="hljs-comment">// 合并两个点集合</span><br>            s.union(uset, vset);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Prim算法</p><ul><li><img src="image-20240108115459395.png" alt="image-20240108115459395" style="zoom:50%;" /></li><li><img src="image-20240108115748149.png" alt="image-20240108115748149" style="zoom:50%;" /></li><li>算法实现<ul><li><img src="image-20240108121334560.png" alt="image-20240108121334560" style="zoom:50%;" /></li><li><img src="image-20240108121352722.png" alt="image-20240108121352722" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li><p>含非负权值的单源最短路径(Dijkstra)</p><ul><li><p>目标：得到指定点V0到所有其他点的最短路径</p></li><li><p>第一步：先排出V0点到所有目标点的直接路径（不可达用∞）</p></li><li><p>第二步：从中挑出最短的那一条，放入结果区，即V0到该点最短路径</p></li><li><p>第三步：根据新加入结果区的那一条路径更新路径表（比较取短的）</p></li><li><p>重复以上步骤n - 1次即可得到结果</p></li><li><img src="image-20240108141408779.png" alt="image-20240108141408779" style="zoom:50%;" /></li></ul></li><li><p>边上权值为任意值的单源最短路径（贝尔曼-福特）</p><ul><li><p>目标：在边上权值可以为负数的情况下，寻找指定点V0到所有其他点的最短路径</p></li><li><p>算法内容：构造一个最短路径长度数组，dist 1[u]，dist 2[u]，···，dist n-1[u]，其中dist k[u]表示从V0出发最多经过k条边到达终点u的最短路径长度，并且不允许负权重边参与构成回路</p></li><li><p>递推公式：dist 1[u]&#x3D;Edge[v] [u] ;</p><p>[dist k[u] &#x3D; min{dist k-1[u] , min{dist k-1[j] + Edge[j] [u] } }      {j &#x3D; 0,1,2,…,n - 1}</p></li><li><img src="image-20240108143316318.png" alt="image-20240108143316318" style="zoom:50%;" /></li></ul></li><li><p>所有顶点之间的最短路径(Floyed)</p><ul><li>前提：各边权值均大于0的带权有向图。</li><li>算法内容：<ul><li>设A为原邻接矩阵，在A上作n次迭代，设每次迭代结果分别为A1，A2······An</li><li>迭代方法（自己理解的）：对于An，取矩阵An-1的第n行和第n列为基准，对于aij（基准行列上的可以剔除），用以它为中心的十字与基准行列交叉得到两个数据相加，若结果小于当前的aij，则更新aij</li><li>最后得到的An对应的path矩阵aij对应i-&gt;j最短路径的 j 前最后一个点</li></ul></li></ul></li></ul><h3 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h3><ul><li><p>用顶点表示活动的网络（AOV网络）</p><ul><li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网</li><li>直接前驱、直接后继：&lt;i,j&gt; 是网中一条弧，则 i 是 j 的直接前驱，j是 i 的直接后继</li><li>前驱、后继：从顶点 i 到顶点 j 有一条有向路径，则称 i 是 j 的 前驱，j 是 i 的后继</li><li>不能出现有向环</li><li>有向图G&#x3D;(V,E),V 里结点的线性序列（vi1 ,vi2 ,…,vin）如果满足：在 G 中从结点vi 到vj 有一条路径，则序列中结点vi 必先于结点vj，称这样的线性序列为一拓扑序列。</li><li>拓扑排序：求拓扑序列<ul><li>从图中选择一个入度为 0 的结点输出之。（如果一个图中，同时存在多个入度为0的结点，则随便输出哪一个结点）</li><li>从图中删掉此结点及其所有的出边。</li><li>反复执行以上步骤，直到所有结点都输出了，则算法结束；如果图中还有结点，但入度不为 0 ，则说明有环路</li></ul></li></ul></li><li><p>用边表示活动的网络（AOE网络）</p><ul><li><p>顶点：表示事件(event)，它的入边代表的活动已完成，它的出边代表的活动可以开始</p></li><li><p>有向边：表示活动，边上的权表示完成一项活动需要的时间</p></li><li><p>有唯一的入度为0的开始结点，唯一的出度为0的完成结点</p></li><li><p><strong>关键路径（Critical Path）：</strong> 是指由一系列关键活动组成的路径，即具有从开始顶点(源点)-&gt;完成顶点(汇点)的最长的路径，其总持续时间等于项目的最短完成时间。</p></li><li><p>找关键活动算法中一些量的定义</p><ul><li>Ve[i]：表示事件 V i 的可能最早发生时间，定义为从源点V0到Vi 的最长路径长度 , 如 Ve[4]&#x3D;7 天</li><li>Vl[i]：表示事件 Vi 的允许的最晚发生时间。是在保证汇点Vn-1在Ve[n-1] 时刻完成的前提下，事件<br>Vi允许发生的最晚时间＝ Ve[n-1] - Vi到Vn-1的最长路径长度。</li><li><img src="image-20240108161745262.png" alt="image-20240108161745262" style="zoom: 40%;" /></li><li>e[k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的可能的最早开始时间。即等于事件Vi 的可能最早发生时间。e[k]&#x3D;Ve[i]</li><li>l [k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的允许的最迟开始时间。l[k] &#x3D; Vl [j] - &lt;i, j&gt;</li><li>e[k] - l [k]表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间</li><li>若松弛时间为0，则ak为关键事件</li></ul></li><li><p>找关键活动算法步骤</p><ul><li><p>求各事件的可能最早发生时间：从Ve[0]&#x3D;0开始，向前推进求其它事件的Ve</p><p>（Ve[i] &#x3D; max{ Ve[j] + dur(&lt;Vj ,Vi &gt;) }<img src="image-20240108203531665.png" alt="image-20240108203531665" style="zoom:40%;" /></p></li><li><p>求各事件的允许最晚发生时间：从Vl [n-1] &#x3D; Ve[n-1]开始，反向递推</p><p>Vl [i]&#x3D;min{ Vl[j] - dur (&lt;Vi ,Vj &gt;) } <img src="image-20240108203823440.png" alt="image-20240108203823440" style="zoom:40%;" /></p></li><li><p>求e[k]和l [k]，若e[k] &#x3D; l [k]则ak为关键活动</p></li></ul></li></ul></li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><img src="image-20240108155038706.png" alt="image-20240108155038706" style="zoom:67%;" /></li><li><img src="image-20240108155112178.png" alt="image-20240108155112178" style="zoom: 67%;" /></li><li>分类<ul><li>内排序：对内存中的 n 个对象进行排序 。(插入排序，交换排序，选择排序，归并排序，基数排序)</li><li>外排序：内存放不下，还要使用外存的排序。</li></ul></li><li>稳定性：如果待排序的对象序列中，含有多个关键码值相等的对象，用某种方法排序后，这些对象的相对次序是不变的，则是稳定的，否则为不稳定</li><li>算法分析：<ul><li>时间开销：比较次数 + 移动次数</li><li>所需的附加空间</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>直接插入排序：<img src="image-20240108195151936.png" alt="image-20240108195151936" style="zoom:50%;" /><ul><li>最优：原数据按大小顺序排列，比较次数n - 1，移动次数0</li><li>最差：原数据按大小逆序排列，比较次数1 + 2 + ··· + n - 1 &#x3D; O(n^2)，移动次数(1 + 2) + ··· + (n - 1 + 2) &#x3D; O(n^2)</li></ul></li><li><del>折半插入排序</del> <strong>不考</strong><ul><li>对于已排序的部分，使用二分查找的方法，将插入位置的搜索范围缩小一半，从而提高排序的效率。</li><li>O(n * log2 n)</li></ul></li><li>希尔排序<ul><li>取一增量（间隔 gap&lt;n ），按增量分组，对每组使用直接插入排序或其他方法进行排序。</li><li>减少增量（分的组减少，但每组记录增多）。直至增量为1，即为一个组时。</li><li><img src="image-20240108200440789.png" alt="image-20240108200440789" style="zoom:50%;" /></li><li>算法分析：与选择的缩小增量有关，但到目前还不知如何选择最好结果的缩小增量序列。</li></ul></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ul><li>冒泡排序<ul><li>从头到尾做一遍相邻两元素的比较有颠倒则交换，记下交换的位置。一趟结束，一个或多个最大(小)元素定位。</li><li>去掉已定位的的元素，重复上一步，直至一趟无交换。</li><li>算法分析：最优n-1 次比较，0次移动；最差：(n - 1) + (n - 2) + ··· + 1次比较和交换</li></ul></li><li>快速排序 <strong>重要</strong><ul><li>在 n 个对象中，取一个对象(如第一个对象 -&gt; 基准pivot),按该对象的关键码把所有&lt;&#x3D;该关键码的对象分划在它的左边。&gt; 该关键码的对象分划在它的右边。</li><li>对左边和右边（子序列）分别再用快速排序。</li><li><img src="image-20240108210555872.png" alt="image-20240108210555872" style="zoom:50%;" />- j指针一直左移，直到它指的数比i指的数(基准)小，然后交换i、j所指数，i右移一位，继续该过程- 当i、j相遇，本轮快排完成</li><li>算法分析<ul><li><img src="image-20240108210823462.png" alt="image-20240108210823462" style="zoom:50%;" /><img src="image-20240108210953952.png" alt="image-20240108210953952" style="zoom:50%;" /></li><li>平均时间复杂度：O(n * log2 n)</li></ul></li></ul></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>直接选择排序<ul><li>思想：首先在n个记录中选出关键码最小（最大）的记录，然后与第一个记录（最后第n 个记录）交换位置，再在其余的n-1 个记录中选关键码最小（最大）的记录，然后与第二个记录（第n-1个记录）交换位置，直至选择了n-1个记录。</li><li>比较次数：n - 1 + n - 2 + ··· + 1 &#x3D;n * (n - 1) &#x2F; 2&#x3D;O(n^2)</li></ul></li><li>堆排序<ul><li>思想：第一步，建堆，根据初始输入数据，利用堆的调整算法，形成初始堆。第二步，一系列的对象交换和重新调整堆</li><li>算法分析：调整n - 1次(FilterDown)，时间为 O(n * log2 n)；交换次数为2n次，时间为O(n)；总复杂度为O(n * log2 n)</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>步骤</p><ul><li><strong>分解（Divide）：</strong> 将待排序的序列分解成两个子序列，通常是平均划分。这一步鼓励递归的应用，直到每个子序列只有一个元素。</li><li><strong>解决（Conquer）：</strong> 递归地对每个子序列进行排序。当子序列长度为1时，它已经是有序的。</li><li><strong>合并（Combine）：</strong> 将已排序的子序列合并成一个新的有序序列。这是归并排序的关键步骤。</li></ul></li><li><p>算法分析：合并趟数 log 2 n, 每趟比较 n 次，所以为 O(n log2 n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    Comparable[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[a.length];<br>    mergeSort(a, tmpArray, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        mergeSort(a, tmpArray, left, center);<br>        mergeSort(a, tmpArray, center + <span class="hljs-number">1</span>, right);<br>        merge(a, tmpArray, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> leftPos, <span class="hljs-type">int</span> rightPos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftEnd</span> <span class="hljs-operator">=</span> rightPos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpPos</span> <span class="hljs-operator">=</span> leftPos;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numElements</span> <span class="hljs-operator">=</span> rightEnd - leftPos + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;<br>        <span class="hljs-keyword">if</span> (a[leftPos].compareTo(a[rightPos]) &lt;= <span class="hljs-number">0</span>) &#123;<br>            tmpArray[tmpPos++] = a[leftPos++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpArray[tmpPos++] = a[rightPos++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd) &#123;<br>        tmpArray[tmpPos++] = a[leftPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (rightPos &lt;= rightEnd) &#123;<br>        tmpArray[tmpPos++] = a[rightPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numElements; i++, rightEnd--) &#123;<br>        a[rightEnd] = tmpArray[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计网重点"><a href="#计网重点" class="headerlink" title="计网重点"></a>计网重点</h1><span id="more"></span><img src="OSI.jpg" style="zoom:100%;" /><img src="transfer.png" style="zoom:100%;" /><img src="transfer2.jfif" style="zoom:100%;" /><ul><li><p>数据传输过程梳理</p><p>发送方：</p><ul><li>第一步：发送方从应用程序出发，应用层产生数据，表示层进行格式转换，会话层管理应用程序间的连接</li><li>第二步：数据进入传输层，如果是UDP，直接加上首部后进入网络层；如果是TCP，将数据进行切片变成数据段（segment），先建立连接，然后加上TCP报文首部，进入网络层</li><li>第三步：网络层IP协议加上IP报头封装成IP数据包</li><li>第四步：数据链路层的LLC和MAC子层先后加上其对应的报头，将数据包封装成数据帧<ul><li>此过程中若未知MAC地址，通过ARP协议获取</li></ul></li><li>第五步：数据帧进入物理层，作为比特流开始发送</li></ul><p>分情况：</p><ul><li>局域网内：比特流传给目标主机解析</li><li>局域网外：比特流传给路由器连接本网段的端口（网关），路由器的物理层、数据链路层、网络层等对其进行解析，根据目标IP地址进行路由决策，然后从对应的端口再次封装成数据包，进行转发（线路传播时以比特流形式）；对应网络的路由器收到后再进行这些过程之后把数据包再传输给目标主机</li></ul><p>接收方：</p><ul><li><strong>物理层：</strong><ul><li><strong>比特流接收：</strong> 接收方的物理层负责从传输媒介（电缆、光纤等）接收比特流。</li></ul></li><li><strong>数据链路层：</strong><ul><li><strong>帧解析：</strong> 物理层传递的比特流被数据链路层接收，数据链路层负责解析帧，提取出帧头和帧尾，确保帧的完整性。</li><li><strong>MAC地址比对：</strong> 数据链路层检查帧中的目标MAC地址，与接收设备的MAC地址进行比对，以确定是否是发给自己的帧。</li><li><strong>数据帧提取：</strong> 如果目标MAC地址匹配，数据链路层提取出帧中的数据部分。</li></ul></li><li><strong>网络层：</strong><ul><li><strong>IP头解析：</strong> 数据链路层提供的数据帧中包含IP数据包，网络层解析IP头，提取源IP地址和目标IP地址。</li></ul></li><li><strong>传输层：</strong><ul><li><strong>TCP&#x2F;UDP头解析：</strong> 如果使用TCP或UDP协议，传输层解析TCP或UDP头，提取端口号等信息。</li></ul></li><li><strong>应用层：</strong><ul><li><strong>数据交付应用程序：</strong> 最终，数据交付给应用层，应用层根据协议和数据的特定格式进行解析，将数据交付给目标应用程序进行进一步处理</li></ul></li></ul></li><li><p>网络拓扑</p><img src="17.png" style="zoom:50%;" /><ul><li>最可靠的是网状拓扑（mesh）</li></ul></li><li><p>多层ISP结构的Internet</p><img src="5.png" style="zoom: 40%;" /><ul><li>互联网服务提供商(ISP,Internet Service Providers)</li><li>第一层ISP是核心层，主要负责远距离连通。</li><li>这种多层ISP结构可以将大量的流量本地化</li><li>NAP(Network Access Point):第一二层之间的接入点,也可以是google(大公司)直接和第一层ISP进行链接</li><li>ICP(Internet Content Provider):互联网内容提供商,不提供接入服务</li><li>在低层次的ISP可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li></ul></li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="局域网介质"><a href="#局域网介质" class="headerlink" title="局域网介质"></a>局域网介质</h3><ul><li>UTP (无屏蔽双绞线 Unshielded Twisted Pair)<ul><li>由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限)</li><li>易于安装且成本较低，线薄接口小</li><li>与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声和干扰</strong></li><li>双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)<strong>短</strong></li></ul></li><li>同轴电缆 Coaxial<ul><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，比双绞线传输更加远，成本也要高一点</li></ul></li><li>光缆 Fiber-Optic<ul><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ul></li><li>光缆模式<ul><li>单模式：单个光传输</li><li>多模式：多根光不同角度传输 Multi-mode</li></ul></li><li>无线通信<ul><li>激光</li><li>红外线</li><li>无线电波</li></ul></li></ul><h3 id="UTP-for-Ethernet"><a href="#UTP-for-Ethernet" class="headerlink" title="UTP for Ethernet"></a>UTP for Ethernet</h3><blockquote><p>UTP线分类见笔记</p></blockquote><h3 id="介质和信号问题"><a href="#介质和信号问题" class="headerlink" title="介质和信号问题"></a>介质和信号问题</h3><ul><li>信令和通信问题<ul><li>传播(本质是电磁波)延迟</li><li>衰减 Attenuation</li><li>反射 Reflection</li><li>噪声(电子干扰) Noise</li></ul></li><li>冲突和冲突域<ul><li>当两个位元在同一网路上同时传播时，会发生碰撞</li><li>分割冲突域：将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中</li><li>通过添加中继器和集线器<strong>扩展</strong>冲突域。</li><li>可以通过添加智能设备(如网桥、交换机和路由器)来<strong>分割</strong>冲突域</li></ul></li></ul><h3 id="数据通信基础概念"><a href="#数据通信基础概念" class="headerlink" title="数据通信基础概念"></a>数据通信基础概念</h3><ul><li><p>概念</p><ul><li><p>码元(code)：在使用<strong>时间域</strong>(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形，是传输基本单位，并不一定只包含一位</p></li><li><p>香农公式：C &#x3D; W log<sub>2</sub>(1 + S&#x2F;N) bps（C：最高数据传输速率，W：带宽Hz，S：信号功率，N：噪声功率）</p></li><li><p>波特率(调制速率)：波信号每秒钟变化的次数</p></li><li><p>比特率：每秒钟传送的二进制位数</p></li><li><p>传输过程：</p><img src="16.png" style="zoom:50%;" /></li></ul></li><li><p>数字数据编码</p><ul><li>将数字数据转换到模拟信号：调制</li><li>将数字数据转换到数字信号：线路编码<ul><li>线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波</li></ul></li></ul></li><li><p>编码方式的分类</p><ul><li><p>单极性编码:一个正极或者负极，用0电平表示”0”，正电平表示”1”</p></li><li><p>极化编码：不归零制码(NRZ: Non-Return to Zero)</p><ul><li>不归零电平编码：用负电平表示”0”，正电平表示”1” (或相反)，一定的中和</li><li>不归零反相编码：信号电平的一次<strong>翻转</strong>代表比特1，无电平变化代表0</li></ul></li><li><p>极化编码：归零制码(RZ: Return to Zero)</p><img src="19.png" style="zoom: 80%;" /><ul><li>用负电平表示”0”，正电平表示”1”(或 相反)，比特中位跳变到零电平，从而提供同步</li></ul></li><li><p>极化编码：曼彻斯特码(Manchester)</p><img src="20.png" style="zoom: 80%;" /><ul><li>每一位中间都有一个跳变，从低跳到高表示”0”，从高跳到低表示”1”</li></ul></li><li><p>极化编码：差分曼彻斯特码(Differential Manchester)</p><img src="21.png" style="zoom:50%;" /><ul><li>每一位中间跳变：表示时钟</li><li>每一位位前跳变：表示数据：有跳变表示”0”，无跳变表示”1”</li></ul></li><li><p>双极性编码：双极性传号交替反转码(AMI)</p><img src="22.png" style="zoom: 80%;" /><ul><li>采用三个电平：正、负与零，零电平表示”0”，正负电平的跃迁表示 “1”，实现对”1”电平的交替反转</li></ul></li></ul></li><li><p>多路复用</p><ul><li><p>时分复用TDM：时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙</p><img src="25.png" style="zoom:50%;" /></li><li><p>统计时分复用 STDM (Statistic TDM)</p><img src="26.png" style="zoom:50%;" /></li><li><p>频分复用 FDM：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p></li><li><p>波分复用 WDM：波分复用就是光的频分复用：频率和波长是成倒数关系的</p></li><li><p>码分复用 CDM：用户采用相同频率，但是对于数据编码进行变换</p></li></ul></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>主要任务</p><ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li><strong>流控制</strong>(Flow control)</li></ul></li><li><p>用帧组织比特流</p></li><li><p>提供三种服务</p><ul><li><p>不带有确认的无连接服务</p></li><li><p>带有确认的无连接服务：无线网</p></li><li><p>带有确认的有连接服务：蓝牙</p></li></ul></li><li><p>与物理层的对比</p></li></ul><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织&#x2F;分组比特</td></tr></tbody></table><ul><li>局域网三种传输方式<ul><li>单播：将单个数据包从源发送到网络上的单个目标</li><li>多播：由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播：单个数据包传输到网络上的所有节点</li></ul></li><li>多播地址<ul><li>IPv4 中的多播地址是从 224.0.0.0 到 239.255.255.255 的范围</li><li><strong>224.0.0.0 - 224.0.0.255：</strong> 为系统保留，用于本地网络控制块。</li><li><strong>224.0.1.0 - 224.0.1.255：</strong> 为路由信息协议（Routing Information Protocol, RIP）的用途保留。</li><li><strong>224.0.0.0&#x2F;4：</strong> 称为预留地址空间，用于各种用途。</li><li><strong>232.0.0.0 - 232.255.255.255：</strong> 为源特定多播（Source-Specific Multicast, SSM）保留。</li></ul></li></ul><h3 id="以太网与带冲突检测的载波侦听多路访问（CSMA-CD）"><a href="#以太网与带冲突检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）"></a>以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）</h3><ul><li><p>IEEE 802.2、802.3、802.5</p><ul><li><p>LLC子层（802.2）</p><ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li><li><p>MAC子层（802.3）</p><ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li><li><strong>802.3 覆盖了物理层和第二层下半层</strong></li></ul></li><li><p>令牌环（802.5）</p><ul><li>在令牌环网络中，计算机连接成一个物理环或逻辑环，数据包通过一个称为“令牌”的特殊控制帧在环上传递。令牌是一种允许持有它的设备在网络上传递数据包的权限标记。</li></ul></li></ul></li><li><p>帧结构</p><ul><li>前同步码：8字节（不算在帧长度里）</li><li>目标地址：6字节</li><li>源地址：6字节</li><li>长度&#x2F;类型：2字节</li><li>数据：46(18 + 46 &#x3D; 64字节) ~ 1500字节</li><li>FCS字段（包含循环冗余校验码）：4字节</li></ul></li><li><p>最短帧长：64字节</p></li><li><p>LLC子层对数据包进行封装并添加控制信息，然后交给MAC子层进一步封装</p></li><li><p>MAC子层</p><ul><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong></li><li>广播目标MAC：全1(FFFF.FFFF.FFFF)，仅在未知目的主机MAC和目的主机为全部主机时使用</li><li>以太网是广播网络</li></ul></li><li><p>以太网的CSMA&#x2F;CD</p><img src="11.png" style="zoom:50%;" /><ol><li>首先设备要发送数据</li><li>开始侦听链路是否忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam signal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完链路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol></li></ul><h3 id="无线局域网的CSMA-CA"><a href="#无线局域网的CSMA-CA" class="headerlink" title="无线局域网的CSMA&#x2F;CA"></a>无线局域网的CSMA&#x2F;CA</h3><ul><li><p>无线局域网分类</p><ul><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ul></li><li><p>一些名词</p><ul><li>BSS：基础服务集</li><li>BS：基站</li><li>AP：无线接入点</li></ul></li><li><p>无线局域网标准</p><ul><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5 GHz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为”速率加倍”的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ul><img src="13.png" style="zoom:50%;" /></li><li><p>数据帧结构</p></li><li><p>无线网络的CSMA&#x2F;CA</p><ul><li>A向B发送RTS(Request To Send，请求发送)帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A；</li><li>B向A回答CTS(Clear To Send，清除发送)帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据；</li><li>A开始发送</li><li>若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。(A和C同时发送RTS)</li></ul></li></ul><img src="16-1746703648396.png" style="zoom: 50%;" /><ul><li><img src="data_link_layer-1-CSMACA.png" style="zoom: 33%;" /></li><li><p>WLAN和以太网区别</p><table><thead><tr><th>Ethernet</th><th>WLAN</th></tr></thead><tbody><tr><td>信号被传输到连接在线缆上的所有站点上</td><td>信号只被传输到接近发送站点的站点</td></tr><tr><td></td><td>接受站点检测冲突</td></tr><tr><td>只会有一个有效帧在信道上传播</td><td>会有多个有效帧同时在信道上传播</td></tr><tr><td></td><td>MAC协议必须尽可能保证只有发送站点接近接收站点</td></tr></tbody></table></li></ul><h3 id="第二层设备"><a href="#第二层设备" class="headerlink" title="第二层设备"></a>第二层设备</h3><ul><li><p>网桥、交换机：具体见笔记</p></li><li><p>分割冲突域：</p><p><strong>网桥</strong></p><ul><li>用网桥来分割局域网的以太网，给每个用户提供更多带宽，因为每个网段上用户更少</li><li>网桥增加了10%~30%的网络延迟，因为需要做决定</li></ul><p><strong>交换机</strong></p><ul><li>交换机比网桥更快，因为他们在硬件中交换，然而网桥在软件中交换</li><li>局域网交换机减小了冲突域的大小</li><li>所有连接到交换机的主机仍然在同一个广播域中</li></ul><p><strong>路由器</strong>（第三层）</p><ul><li>路由器可以创建最高级别的细分：<ol><li>创建较小的<strong>冲突域</strong></li><li>创建较小的<strong>广播域</strong>：除非经过编程，否则路由器不会转发广播。</li></ol></li><li>路由器通过检查数据包上的<strong>目标逻辑地址</strong>，然后在其路由表中查找转发指令来完成数据包的转发</li><li>由于路由器比网桥执行更多的功能，因此它们以更高的延迟率运行。</li><li>路由器可以用作<strong>网关</strong>，用于连接不同的网络媒体和不同的LAN技术</li><li>是根据逻辑地址(IP地址)进行转发，不再是MAC</li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)    <strong>Q：到底能不能流量控制</strong></li><li>路由器<ul><li>互连网段或网络(不同网段的分割)</li><li>根据IP地址做出合理的决定</li><li>确定最佳路径，根据路由表。</li><li>将数据包从入站端口切换到出站端口</li></ul></li><li>广播域划分：如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发送的是<strong>本网段</strong>的广播地址，路由器则不会进行转发</li></ul><h3 id="IP地址和子网划分"><a href="#IP地址和子网划分" class="headerlink" title="IP地址和子网划分"></a>IP地址和子网划分</h3><ul><li><p>IPv4报文结构（具体见笔记）</p><img src="3.png" style="zoom:50%;" /></li><li><p>IP地址</p><ul><li><p>IP地址为32位长(IPv4中)</p></li><li><p>它们以点分十进制格式表示为四个八位字节：133.14.17.0</p></li><li><p>IP地址包含两个组成部分：</p><ol><li>网络ID</li></ol></li></ul><ol start="2"><li>主机ID</li></ol><ul><li><p>分类：</p><ul><li>0–127 Class A address A类地址</li><li>128-191 Class B address B类地址</li><li>192–223 Class C address C类地址</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)</li><li>240–255 Class E - Research  E类地址：研究</li><li>host不能全取0，也不能全取1。全取0：网络地址；全取1：广播地址</li></ul></li><li><p>专用地址&#x2F;私有地址：用于局域网内部网段</p><blockquote><p>10.0.0.0 - 10.255.255.255<br>172.16.0.0 - 172.31.255.255<br>192.168.0.0 - 192.168.255.255</p></blockquote></li></ul></li><li><p>子网</p><img src="11-1746703659590.png" style="zoom: 67%;" /><img src="12.png" style="zoom: 50%;" /><ul><li><p>借用的最小位数是2，为什么？</p><ol><li>如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。</li><li>两位的时候，01和10给Host，00为网络ID，11为广播地址</li><li>全0可能导致误判</li></ol></li><li><p>子网掩码：网络位全1，主机位全0</p><p>计算子网网络地址：子网地址和子网掩码按位与</p><p>计算过程见笔记</p></li></ul></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul><li>端口与网关<ul><li>接口是路由器连接到网络的附件，在IP路由中也可以称为<strong>端口。</strong></li><li>这个IP地址往往被作为这个<strong>网络的网关</strong></li><li>每个接口必须具有一个单独的唯一网络地址</li></ul></li><li>IP地址分配<ul><li>静态地址分配</li><li>动态地址分配：<ul><li>RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。ARP为IP到MAC的转换，而RARP为MAC到IP的转换，向RARP服务器请求分配IP。主要流程：发出要反向解析的物理地址并希望返回其对应的IP地址。发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个 IP 地址。 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的 IP 地址。 如果存在，RARP服务器器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用; 如果不存在，RARP服务器对此不做任何的响应。 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯;如果一直没有收到RARP 服务器的响应信息，表示初始化失败。</li><li>BOOTstrap协议。用于工作栈</li><li>DHCP: Dynamic Host Configuration Protocol. (比较多用)动态主机配置协议</li></ul></li></ul></li><li>ARP协议（地址解析协议）<ul><li>源主机访问目的主机不知道对方MAC，优先查找本地ARP表（时效性）</li><li>若ARP表中没有，将目标MAC设为全1进行广播，发送ARP请求<ul><li>若目标主机在局域网内，它收到ARP请求后检查IP地址发现与自己IP一致，将自己的MAC放进帧中发送给源主机</li><li>若目标主机处于另一个网络，则路由器会将自己的MAC作为目标主机MAC给源主机，此后源主机的帧由路由器转发给目的主机（代理ARP）</li><li>此过程中所有收到帧的主机都会将发送方MAC存进自己的ARP表</li></ul></li></ul></li><li>默认网关<ul><li>除了代理ARP，还可以通过默认网关与另一网络设备通信</li><li>默认网关是路由器上连接到源主机所在网段的<strong>接口的IP地址</strong></li><li>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong></li></ul></li></ul><h3 id="网络协议操作"><a href="#网络协议操作" class="headerlink" title="网络协议操作"></a>网络协议操作</h3><ul><li>Routed protocol 被动可路由协议<ul><li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li><li>然后请求路由表可以发现目的网段对应端口</li><li>再次将报文封装转发给对应的主机</li><li>路由表是存储在内存中的</li></ul></li><li>管理距离<ul><li>管理距离（Administrative Distance）是路由选择过程中一个用于衡量路由可信度的参数。在多路由协议环境中，可能存在多个路由到达相同目的地的候选项，管理距离用于确定使用哪个路由信息。较低的管理距离值表示路由更可信。</li><li>直接连接（Connected）：0</li><li>静态路由（Static Route）：1</li><li>Enhanced Interior Gateway Routing Protocol (EIGRP)：90</li><li>Open Shortest Path First (OSPF)：110</li><li>Routing Information Protocol (RIP)：120</li><li>Border Gateway Protocol (BGP)：200</li><li>当未指定管理距离时，使用以上默认值（default）</li></ul></li><li>静态路由和动态路由的区别<ul><li>静态路由<ol><li>用于<strong>隐藏</strong>部分网络。安全(不必进行路由表的交换)</li><li>测试网络中的特定链接。</li><li>用于仅在到达目标网络的路径时维护路由表。</li></ol></li><li>动态路由<ol><li>维护路由表。</li><li>以路由更新的形式及时分发信息。</li><li>依靠路由协议共享知识。</li><li>路由器可以调整以适应不断变化的网络状况。</li><li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li></ol></li></ul></li><li>被动路由协议和主动路由协议<ul><li>Routed Protocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。</li><li>Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。</li><li>Routing Protocol 决定 Routed Protocols</li></ul></li><li>动态路由协议的分类<ul><li>内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)：可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司网络，学区的网络或政府机构的网络。</li><li>外部网关协议(Exterior Gateway Protocols，EGP，BGP)：用于在<strong>自治系统之间路由数据包</strong>。</li></ul></li><li>内部网关协议的分类：DVP and LSP<ul><li>距离矢量协议(Distance-Vector Protocols，RIP, IGRP):<ol><li>从<strong>邻居</strong>的角度查看网络拓扑，只知道到达一个网段的最少跳数(注意不基于全局)</li><li>在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次)</li><li>经常定期(periodic)更新，即与邻居交换路由信息</li><li>将整个路由表的<strong>副本</strong>传递到邻居路由器。</li></ol></li><li>链路状态协议(Link State Protocols, OSPF):<ol><li>获取整个网络拓扑的通用视图。(全局的视角，会有代价)</li><li>计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据)</li><li><strong>事件</strong>触发的更新。如果没有事件发生那么就不会更新</li><li>将链接状态路由更新传递给其他路由器。</li><li>LSP操作过程:<ol><li>相互交换彼此学到对应的Topological Database(是全局的信息)</li><li>之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li><li>根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。</li></ol></li></ol></li></ul></li><li>RIP（典型DVP）<ul><li>基于DVP</li><li>唯一的指标是跳数。</li><li>最大跳数为15。(评判依据简单，是一个短板)</li><li><strong>每30秒更新一次(广播)，可以修改</strong></li><li>并非总是选择最快的路径(而是走跳数最短的路径)。</li><li>产生大量的网络流量。</li></ul></li><li>OSPF(Open Shortest Path First)：典型LSP<ul><li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li><li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，<strong>本科阶段只考虑带宽的。</strong></li><li><strong>事件触发更新</strong></li><li>在LSP中用的比较多。它节约了带宽资源，需要host的CPU资源来执行算法。将最小生成树转化成路由表</li><li>最快和什么有关？(最快指的是带宽)<ol><li>和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关</li><li>带宽表示为代价，带宽和代价成<strong>反比</strong></li></ol></li></ul></li><li>IGRP (Interior Gateway Routing Protocol)和EIGRP (Enhanced IGRP)<ul><li>思科开发的一种用于在较大的企业网络中进行内部路由选择的距离矢量路由协议。它是专有协议，用于在局域网（LAN）和广域网（WAN）中的路由器之间交换路由信息。</li><li>IGRP最大跳数为255，每90秒更新一次。</li><li>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</li></ul></li></ul><h3 id="VLSM（可变长子网掩码）"><a href="#VLSM（可变长子网掩码）" class="headerlink" title="VLSM（可变长子网掩码）"></a>VLSM（可变长子网掩码）</h3><ul><li><h4 id="经典路由-Classful-routing，有类路由-无子网掩码"><a href="#经典路由-Classful-routing，有类路由-无子网掩码" class="headerlink" title="经典路由(Classful routing，有类路由) 无子网掩码"></a>经典路由(Classful routing，有类路由) 无子网掩码</h4><ol><li>有类的路由协议要求单个网络使用相同的子网掩码。</li><li>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</li><li>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</li></ol></li><li><p>VLSM特点</p><ul><li>VLSM允许组织<strong>在同一网络地址空间内使用多个子网掩码</strong></li><li>实施VLSM通常被称为”子网划分”，可用于最大化寻址效率</li><li>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一</li><li>会导致地址空间的浪费:广播地址和网络号都无法被使用</li><li>更好的路由聚合(aggregation):构建超网</li><li>全0子网是否可用看题目，全1子网不可用</li></ul></li><li><p>计算过程**（重要）**</p><ul><li>第一步：先对划分的子网按主机需求量排序，按从大到小计算</li><li>第二步：分别对每个子网进行计算<ul><li>每个子网第一个为网络地址，最后一个为广播地址</li><li>下一个子网从前一个最后的地址（广播）后一个开始</li><li>在每个子网分配完后，最后需要对WAN分配地址，每个WAN（两两连接）需要2个网络地址（两个路由器双方的端口），所以需要2位主机号（还需要网络号和广播地址）</li></ul></li><li>总结<ul><li>重要的是要记住，只有未使用的子网才能进一步划分子网。</li><li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li><li>一般是从主机多大到主机少(路由间网络)进行划分</li></ul></li></ul></li><li><p>CIDR（Classless Inter Domain Routing，无类域间路由）</p><ul><li><strong>无类别地址块：</strong> CIDR不再依赖于固定的类别，而是将IP地址块视为连续的一段。这样，IP地址可以更灵活地分配，而不受限于A、B、C类别。</li><li><strong>前缀表示法：</strong> CIDR使用前缀表示法，例如，192.168.1.0&#x2F;24，其中“&#x2F;24”表示子网掩码中的前24位是网络部分，剩余的8位是主机部分。</li><li><strong>地址聚合：</strong> CIDR支持对相邻的地址块进行聚合，减少了路由表的大小。这对于减少路由表的条目数量，提高路由表的效率非常重要。</li></ul></li><li><p>路由聚合</p><ul><li>多个路由条目汇聚成小的路由条目，使用了CIDR和VLSM</li><li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少</li><li>方法</li></ul><img src="60.png" style="zoom:50%;" /><blockquote><p>如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果</p></blockquote></li></ul><h3 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议 ICMP"></a>因特网控制报文协议 ICMP</h3><ul><li>概述<ul><li>ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)</li><li>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</li><li>ICMP 只是IP层的协议</li><li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li><li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个<strong>ICMP差错报文</strong>。</li></ul></li></ul><img src="61.png" style="zoom: 50%;" /><ul><li><p>分类</p><ul><li>查询报文</li><li>差错报告报文</li></ul></li><li><p>差错报告报文内容</p><ul><li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li><li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li><li>然后添加一个首部作为IP数据报进行发送</li></ul><img src="63.png" style="zoom: 50%;" /></li><li><p>不应发送 ICMP 差错报告报文的几种情况</p><ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol><li>127.0.0.0:逻辑回路地址</li><li>0.0.0.0:确认路由地址</li></ol></li></ul></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><ul><li>第四层功能<ul><li>分割上层应用程序数据(新的数据单元-数据段)，<strong>第四层只会在终端上有</strong></li><li>建立端到端(end to end)的运营</li><li>从一个终端主机向另一个终端主机发送段**(第三层和第二层不进行可靠性检验，第四层完成可靠性检验）**，接受方认为数据错误，在第四层进行要求重传)</li><li>流量控制和可靠性</li></ul></li><li>第四层重要协议<ul><li>传输控制协议(TCP, Transmission Control Protocol)  <strong>可靠传输</strong>，使用<strong>数据段</strong>作为传输单位</li><li>用户数据报协议(UDP, User Datagram Protocol)，使用<strong>用户数据报</strong>作为传输单位</li><li>SCTP(Stream Control Transmission Protocol)：流控制传输协议，用于<strong>视频和音频的传输</strong></li></ul></li><li>端口<ul><li>TCP和UDP都使用<strong>端口</strong>来跟踪(track)同时穿越网络的<strong>不同会话（即不同进程）</strong></li><li>进程通过端口号来标识</li><li>端口分配规范<ul><li>低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)</li><li>0-1023是熟知端口，有分发的规范，不应当被随意使用</li><li>1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</li><li>49152~65535即为短暂端口号，用于和远端通信</li><li>基于端口号的不同，进行不同的包的分发</li></ul></li></ul></li><li>套接字 Socket<ul><li>第四层进行通信的单位是进程，由IP和端口共同指定。socket是第四层的地址</li><li>套接字表示为(IP地址，端口)</li><li>通讯被认为<strong>是以一个socket和另一个socket之间的连接</strong></li></ul></li></ul><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><ul><li>概述<ul><li><strong>TCP不支持多播和广播</strong></li><li>TCP解决问题：<ul><li>可靠传输</li><li>流传输<ol><li>滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)</li><li>避免拥塞</li></ol></li><li>连接控制<ol><li>建立连接:三次握手</li><li>断开连接:四次握手</li></ol></li></ul></li></ul></li><li>TCP数据报结构</li></ul><img src="2.png" style="zoom:50%;" /><ul><li><p>段的大小必须与IP数据包匹配，并且还必须满足底层的需求</p><ol><li>例如，以太网的MTU(最大传输单位)为1500字节</li><li>是面向字节的传输。</li></ol></li><li><p>每个段都有：</p><ol><li>标头为20个字节(可选部分除外)</li><li>0或更多数据字节(请求连接的时候)</li></ol></li><li><p>TCP建立连接：三次握手</p><img src="8.png" style="zoom:50%;" /><blockquote><p>英文缩写含义：</p><p>SYN：控制信号之一，表示同步序号用于建立连接</p><p>ACK：控制信号之一，表示确认号是否有效</p><p>seq：序号（4字节），标识发送方发送的数据字节的顺序</p><p>ack：确认号（4字节），期望收到的下一个数据段的序号</p></blockquote><ul><li>第一次：<ul><li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li><li>客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求</li></ul></li><li>第二次：服务器检查是否存在监视端口的服务进程<ul><li>如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段</li><li>如果存在进程，则决定拒绝或接受请求</li><li>如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段</li></ul></li><li>第三次：<ul><li>客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接</li><li>为了避免出现延时之类的情况(如果只有两次会浪费服务器资源)</li></ul></li></ul><blockquote><p>有时候我们会选择，第三次握手的时候同时携带数据</p></blockquote></li><li><p>连续ARQ协议</p><ul><li>ARQ (Automatic Repeat reQuest) 自动重传请求：这表示”重新发送请求”为自动发送并且接收方无需请求发送方重新发送错误段</li></ul><img src="12-1746703681176.png" style="zoom:50%;" /><ul><li><p>多个数据同时发送过去(一次发送多个)</p></li><li><p>窗口大小是双方协商的，通过TCP报文中的<strong>窗口字段</strong>表示</p></li><li><p><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong></p></li><li><p>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离</p><img src="14.png" style="zoom:50%;" /></li><li><p>此过程中接收方可在回复报文中设置WIN字段值来改变发送方窗口大小</p></li></ul></li><li><p>TCP结束连接：四次握手</p><img src="21-1746703684266.png" style="zoom: 50%;" /><ul><li>步骤<ul><li>客户端：发起断开连接请求（FIN &#x3D; 1）</li><li>服务器端：Ack &#x3D; 1:允许断开，但是此时并不是断开连接，而是说不在发送新的数据，此时我们需要<strong>完成之前未处理完成的数据的处理</strong>。(这里只是说我已经收到了你请求停止传输的请求)</li><li>服务器端：FIN &#x3D; 1:数据处理完成，注意需要的变化(此时表示<strong>所有的需要处理的数据已经处理完了</strong>，此时表示正式确认断开)</li><li>客户端：确认收到B的断开信息（ACK &#x3D; 1）</li><li>在完全断开连接前，等待最大的网路往返时间(保证能处理到B最后发送的报文)</li></ul></li><li>为什么必须等待2 MSL？（MSL：最大报文段生存时间）<ol><li>为了确保A发送的最后一个ACK可以到达B</li><li>防止出现任何无效的连接请求段：等待2 MSL之后，我们可以确保连接上的所有段（最后一个ACK）均已消失，以免与后续的新连接产生混淆</li></ol></li></ul></li><li><p>TCP中的计时器</p><ul><li>重传计时器：当发送方发送一个数据段后，会启动一个重传计时器。如果在规定的时间内没有收到对应的确认（ACK）或者接收方没有成功接收数据，发送方会认为数据段可能丢失了，就会触发重传机制，重新发送该数据段。</li><li>坚持计时器：在TCP中，发送方可能会使用持续计时器来处理窗口大小为零的情况。当发送方的窗口大小为零时，表明接收方的缓冲区已满，但发送方仍然希望保持连接的活动性。在这种情况下，发送方会启动持续计时器，定期发送窗口探测段以维持连接。</li><li>保持计时器：保活计时器用于检测连接是否仍然处于活动状态。如果在一段时间内没有收到任何数据，保活计时器会触发，并发送保活探测段。这有助于检测连接是否断开，并在必要时终止连接。</li><li>时间等待计时器：在TCP的四次握手结束后，连接的一方会进入TIME-WAIT状态，等待2倍的最大报文段生存时间（2MSL）。这个等待时间由时间等待计时器控制。它确保在TIME-WAIT状态期间，之前的连接的所有报文都已经从网络中消失，以防止新连接与旧连接的报文混淆。</li></ul></li></ul><h3 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h3><ul><li><p>概述</p><ul><li>没有建立连接(避免延时)</li><li>没有拥塞控制：UDP可以按照期望的速度传输</li><li>常用于流媒体、多媒体应用（<strong>速率敏感</strong>）</li><li>应用：RIP（路由信息协议）、DNS（域名解析协议）、SNMP（简单网络管理协议，位于应用层）、TFTP（简单文件传输协议，位于传输层）、DHCP（动态主机配置协议，位于应用层）</li></ul></li><li><p>数据帧格式</p><img src="23.png" style="zoom:67%;" /><ul><li>UDP只有8个字节的首部，所以UDP报文最少是8个字节</li><li>源端口、目的端口、长度、校验(data)、Data</li><li>校验也要对data一并校验，如果出现错误，直接丢弃。</li><li>应用层进行数据切片，决定如何进行发送，UDP直接发送，UDP不会再自己分片了</li></ul></li><li><p>TCP与UDP比较</p><ul><li>TCP<ul><li>不是立即交给上层校验，而是需要先和对方沟通</li><li><strong>缓存满了才统一交付</strong></li></ul></li><li>UDP<ul><li>直接转发报文，保留报文边界</li><li>应用程序会发送比较合适的UDP报文大小进行发送</li></ul></li></ul></li></ul><h3 id="NAT-和-PAT"><a href="#NAT-和-PAT" class="headerlink" title="NAT 和 PAT"></a>NAT 和 PAT</h3><ul><li><p>NAT是在IP数据包头中将一个地址交换为另一个地址的过程</p><ol><li>网络地址转换</li><li>是网络地址即将用完的解决方案</li><li>内部主机发送报文给网关，网关根据NAT Table进行翻译，转换成内部全局地址，然后进行转发</li><li>主要设备：路由器</li></ol><ul><li>在NAT 路由器将局域网地址转换成网络上的地址(双向转换，有一个NAT表)</li><li>路由器会将IP数据包中的地址字段进行修改</li></ul></li><li><p>NAT类型</p><ul><li>静态NAT：固定的内部地址(internal address)到注册地址(registered address)的映射(一开始就写死)</li><li>动态NAT：映射以先到先得的方式动态进行(不是写死，配一个地址池,不断更新)</li><li>PAT(过载，Port address translation)：端口地址转换用于允许许多内部用户共享一个”内部全局”地址(基于Socket映射，而不是IP地址，多个内网主机映射到一个公网地址)</li></ul></li><li><p>NAT地址类型</p><img src="25-1746703689130.png" style="zoom: 50%;" /><ul><li>Inside Local address (内部本地地址):内网IP地址</li><li>Inside Global address (内部全局地址): 注册IP地址, 对外部展示的内部地址</li><li>Outside Global address (外部全局地址):由主机所有者分配的IP地址。通常是注册地址。(对内网而言的外部，是目的地址)</li></ul></li><li><p>PAT</p><img src="29.png" style="zoom:40%;" /><img src="28.png" style="zoom:50%;" /></li></ul><ul><li>基于socket映射</li><li>出口IP相同，通过端口号来区别</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：会话层</h3><ul><li>职责<ul><li>基于令牌进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li><li>进行数据分段、拼接，保证传输的有效。</li><li>同步技术，保证故障恢复</li></ul></li><li>服务<ul><li><strong>半双工通信（Half-Duplex）：</strong> 在半双工通信中，数据可以在通信双方之间进行双向传输，但同一时刻只能有一个方向上的数据传输。这意味着通信的两端能够交替发送和接收数据，但不能同时进行。对讲机就是一个常见的半双工通信的例子，一方说话时，另一方必须听，不能同时说话。</li><li><strong>全双工通信（Full-Duplex）：</strong> 在全双工通信中，通信双方能够同时进行双向数据传输。这意味着每一方都可以独立地发送和接收数据，而不会干扰对方。典型的电话通信就是全双工通信的例子，双方可以同时说话和听对方说话。</li><li><strong>多点通信（Multipoint Communication）：</strong> 多点通信是指多个设备之间进行通信的情境。在多点通信中，一个设备可以与多个其他设备进行通信，而不仅仅是与一个设备进行通信。这包括点对点通信（两个设备之间的直接通信）、广播通信（发送方向网络上的所有设备广播消息）以及多播通信（发送方向特定组中的多个设备发送消息）。</li></ul></li></ul><h3 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：表示层</h3><ul><li>表示层负责以接收<strong>设备可以理解</strong>的形式表示数据</li><li>表示层具有3个主要功能：<ol><li>数据格式(format)</li><li>数据压缩(compression):早期网络比较慢，倾向于先压缩在发送</li><li>数据加密(encryption)</li></ol></li><li>图像文件格式<ul><li>图形交换格式(GIF，Graphic Interchange Format)</li><li>联合图像专家组(JPEG，Joint Photographic Experts Group)。</li></ul></li></ul><h3 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h3><img src="5-1746703695119.png" style="zoom:50%;" /><ol><li><p>上图中各层的一些协议和使用：会话层对端口进行管理</p></li><li><p>第七层对应了应用界面，第六层对应了各种协议</p></li><li><p>应用程序层(最接近用户)支持应用程序的通信组件</p></li></ol><ul><li><p>超文本传输协议 (HTTP，HyperText Transfer Protocol)</p><ul><li><p>统一资源定位符 URL(Uniform Resource Locator)</p><ol><li>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</li><li>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</li><li>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</li><li>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</li><li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ol><li>访问方式:协议HTTPS 或者 HTTP</li><li>主机:域名的方式</li><li>端口对应进程</li><li>路径对应具体的文件</li></ol></li></ol></li><li><p>HTTP</p><ol><li>HTTP 是<strong>面向事务</strong>的客户服务器协议。</li><li>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)。<ol><li>每一次请求是独立的，不记录上一次请求信息。</li><li>Cookie是征求同意的存储(维持登录状态)，可以保证在多个应用之间维持登录状态。</li></ol></li><li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为HTTP daemon， 有的文献将它缩写为 HTTPD。</li><li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户</li></ol></li><li><p>http报文结构</p><img src="7.png" style="zoom: 50%;" /></li><li><p>HTML(HyperText Markup Language)</p><ol><li>定义了许多用于排版的命令(标签)。</li><li>HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。</li><li>仅当HTML文档是以.html或.htm为后缀时，浏览器才对此文档的各种标签进行解释。</li><li>当浏览器从服务器读取HTML文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li><li>HTML用一对标签(一个开始标签和一个结束标签)或几对标签来标识一个元素。</li></ol></li></ul></li><li><p>FTP(File Transfer Protocol) and TFTP(Trivial File Transfer Protocol)</p><ol><li>FTP是一种可靠的，面向连接的服务，它使用TCP传输文件。<ol><li>FTP首先在客户端和服务器(端口21)之间建立<strong>控制连接</strong></li><li>然后，建立第二个连接，这是计算机之间通过其传输数据的链接。(端口20)</li></ol></li><li>TFTP是使用UDP的无连接服务(简化的FTP)<ol><li>体积小，易于实施。更加方便</li><li>例如。 TFTP在路由器上用于传输配置文件和Cisco IOS映像</li><li>不支持交互，没有目录浏览功能</li></ol></li></ol></li><li><p>Telnet 协议</p><ul><li>Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能</li></ul></li><li><p>简单邮件传输协议 SMTP(Simple Mail Transfer Protocol) and POP(Post Office Protocol)</p><ul><li><p>电子邮件服务器使用SMTP发送和POP接收邮件相互通信</p><ul><li>SMTP (Simple Mail Transfer Protocol) SMTP(简单邮件传输协议)邮件发送，登录发送等操作</li><li>POP 3 (Post Office Protocol version 3) 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。</li><li>两者都使用TCP</li></ul></li></ul><blockquote><p>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器，然后用户登录后通过POP3协议收邮件到本地</p></blockquote></li><li><p>简单网络管理协议 SNMP(Simple Network Management Protocol)</p><img src="11-1746703699380.png" style="zoom: 67%;" /><ul><li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li><li>通过管理数据库(MIB)进行信息交流</li><li>使用<strong>UDP</strong>通过广播进行实现。</li></ul></li><li><p>域名系统(DNS, Domain Name System)</p><ul><li><p>多数使用UDP，少数情况TCP（大型网络）</p></li><li><p>Domain Name 域名</p><img src="13-1746703701223.png" style="zoom:67%;" /><ul><li>使用<code>.</code>将字符串进行分隔开，字符串不应该太长</li><li>越靠后域名级别越高</li><li>www就是对应到主机群</li></ul></li><li><p>顶级域 ：TLD (Top Level Domain)</p><ul><li>如<code>.cn</code>、<code>.com</code>、 <code>.edu</code>等，具体见笔记</li></ul></li><li><p>Domain Name Server 域名服务器</p><img src="14-1746703702903.png" style="zoom:50%;" /><ul><li>顶级域名底下的域名就是由顶级域名下面进行管理</li><li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li></ul></li><li><p>结合域名服务器查找IP地址</p><img src="15.png" style="zoom: 67%;" /><ul><li>DNS系统以层次(hierarchy)结构设置，该层次结构创建不同级别的DNS服务器。</li><li>此级别的DNS服务器判断其自身是否能够将域名转换为关联的IP地址：<ol><li>如果可以，则将结果返回给客户端</li><li>如果没有，它将请求发送到更高级别。(向上级请求)</li></ol></li><li>递归地进行查找，下面递归，上面迭代</li></ul></li></ul></li><li><p>应用层沟通的方式</p><ul><li>通信处理发生的一种方式：(无上下文，请求后就断开)<ol><li>当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端。</li><li>处理完成后，连接断开</li></ol></li><li>第二种方式：(有上下文)<ol><li>作为Telnet和FTP，建立与服务器的连接并保持该连接，直到执行所有处理。</li><li>当用户确定他&#x2F;她已完成时，客户端将终止连接。</li></ol></li><li>所有的交流活动都属于这两类之一</li></ul></li><li><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)</p><ul><li><p>概述</p><ul><li>一个协议软件在使用之前先作正确协议配置，具体配置内容取决于协议。</li><li>接到因特网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址</li><li>子网掩码</li><li>默认路由器的 IP 地址</li><li>域名服务器的 IP 地址</li></ol></li><li>Dynamic Host Configuration Protocol可以高效地分配IP地址<ol><li>局域网的网络协议</li><li>使用UDP来实现</li></ol></li><li>目前一般都是自动获取IP地址，而不需要手动去获取IP地址等信息</li></ul></li><li><p>工作过程</p><img src="16-1746703706866.png" style="zoom:60%;" /><ul><li><p>Client先广播Discover报文去搜索（广播携带地址是MAC地址，因为未知server地址）</p></li><li><p>所有Server在IP地址池中查找合法的IP地址，返回一个Offer报文</p></li><li><p>Client选择优先返回的Offer来优先服务</p></li><li><p>Client进行广播，告知接受谁的服务</p></li><li><p>然后B返回一个Ack报文</p></li><li><p>到了时间之后，选择release或者续租</p><ol><li><p>在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP 参数更新自己的配置，IP租用更新完成</p></li><li><p>当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约到时间后，Server会主动询问，如果没有应答会自动释放</p></li></ol></li></ul></li><li><p>DHCP报文类型</p><ul><li>DHCP Discover：发现</li><li>DHCP Offer：提供</li><li>DHCP Request：告知决定</li><li>DHCP ACK：租约确认</li><li>DHCP NAK：租约不确认</li><li>DHCP Release：释放租约</li><li>DHCP Decline:收到Ack后，Client告诉服务器不接受</li><li>DHCP Inform:客户端向服务器端请求详细信息</li></ul></li><li><p>DHCP欺骗：见笔记</p></li></ul></li></ul><h2 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器的内部组件"><a href="#路由器的内部组件" class="headerlink" title="路由器的内部组件"></a>路由器的内部组件</h3><img src="1.png" style="zoom:60%;" /><ul><li><h4 id="随机存取存储器-RAM-Random-Access-Memory"><a href="#随机存取存储器-RAM-Random-Access-Memory" class="headerlink" title="随机存取存储器(RAM, Random Access Memory)"></a>随机存取存储器(RAM, Random Access Memory)</h4><ul><li><p>路由器配置文件的临时存储，一般做为内存使用</p></li><li><p>断电或重新启动时RAM内容丢失</p></li><li><p>存储:</p><ul><li>路由表</li><li>ARP缓存</li><li>快速切换缓存</li><li>报文缓存:可能前面有正在处理的，需要等待</li><li>数据包保留队列</li></ul></li><li><p>根据地址位就可以读到地址内容(访问比较快)</p></li></ul></li><li><h4 id="非易失随机存取存储器-NVRAM-Non-volatile-RAM"><a href="#非易失随机存取存储器-NVRAM-Non-volatile-RAM" class="headerlink" title="非易失随机存取存储器(NVRAM, Non-volatile RAM)"></a>非易失随机存取存储器(NVRAM, Non-volatile RAM)</h4><ul><li><p>存储备份(backup)&#x2F;启动(startup)配置文件</p></li><li><p>路由器掉电或重启时内容不会丢失。</p></li><li><p>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</p></li><li><p>保证快速访问，但是存储空间有限</p></li></ul></li><li><h4 id="Flash-相当于台式机硬盘"><a href="#Flash-相当于台式机硬盘" class="headerlink" title="Flash (相当于台式机硬盘)"></a>Flash (相当于台式机硬盘)</h4><ul><li><p>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</p></li><li><p>存储了Cisco IOS(互联网操作系统)</p></li><li><p>允许更新软件而无需更换闪存芯片</p></li><li><p>可以存储多个版本的IOS</p></li><li><p>断电保持</p></li></ul></li><li><h4 id="只读存储器-ROM-Read-Only-Memory"><a href="#只读存储器-ROM-Read-Only-Memory" class="headerlink" title="只读存储器(ROM, Read-Only Memory)"></a>只读存储器(ROM, Read-Only Memory)</h4><ul><li><p>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</p></li><li><p>引导程序(加载Cisco IOS)</p></li><li><p>系统软件</p><ul><li>IOS的备份，精简(trimmed down)版本</li><li>升级需要安装新的芯片组</li></ul></li></ul></li><li><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>数据包通过其进入和离开路由器的网络连接口</p></li><li><p>附在主板(motherboard)上或作为单独的模块。</p></li><li><p>大部分是网口，主要是用来支持网络的</p></li><li><p>0&#x2F;0第一个，串口接口可能还分多个</p></li></ul></li></ul><h3 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h3><ul><li>系统启动程序<ul><li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li><li>验证CPU，内存和网络接口端口的基本操作</li><li>软件初始化</li></ul></li><li>软件启动程序<ul><li>步骤1：让ROM中的通用引导加载程序(bootstrap)在CPU卡上执行</li><li>步骤2：可以在以下几个位置之一找到操作系统：<ul><li>先从Flash找，也就只有一个image文件，将image导入内存</li><li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li><li>如果TFTP也没有配置，则去ROM中导出IOS</li></ul></li><li>步骤3：将保存在NVRAM中的<strong>配置文件</strong>加载到主存储器中，并一次执行一行<ul><li>先看NVRAM中有没有配置(start.config)</li><li>然后看TFTP Server有没有配置，如果有则下载一个</li><li>如果都没有，用console进行配置</li></ul></li><li>步骤4：如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong></li></ul></li><li>路由器初始化过程<ul><li>设置不用作在路由器中输入复杂协议功能的模式。</li><li>对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序</li></ul></li></ul><h3 id="路由和配置"><a href="#路由和配置" class="headerlink" title="路由和配置"></a>路由和配置</h3><ul><li><p>路由器功能：路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。</p><ul><li><p><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></p></li><li><p><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</p></li></ul></li></ul><h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><ul><li>当只有一条路径可访问网络时，到网络的静态路由就足够了</li></ul><ul><li>管理距离<ul><li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)<ul><li>数字越大，可信度(trustworthiness)越低。</li><li>因此静态路由的管理距离通常很短(默认值为1)</li><li>管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高</li></ul></li></ul></li><li>配置命令<ul><li><code>ip route [目标网络] [子网掩码] [下一跳地址]</code></li><li><code>ip route 192.168.2.0 255.255.255.0 10.0.0.1</code></li><li>这个命令指定了将数据包发送到目标网络192.168.2.0&#x2F;24时，下一跳路由器的IP地址是10.0.0.1</li></ul></li></ul><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><ul><li><p>收敛时间:</p><ul><li><p>从刚启动到网络达到稳定的时间</p></li><li><p>从发生变化到再次稳定的时间</p></li></ul></li><li><p>动态路由协议分类</p><ul><li>距离矢量(DV,Distance Vector)</li><li>链路状态(LS,Link State)</li><li>混合路由(HR,Hybrid Routing)</li></ul></li><li><p>距离矢量协议 DVP</p><ul><li><p>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></p></li><li><p>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递<em><strong>路由表</strong></em>的周期性副本。</p><ul><li><p>邻居交换Routing Table</p></li><li><p>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</p></li></ul></li><li><p>代表：RIP</p></li></ul></li><li><p>路由环路问题：<strong>有名词解释题目</strong></p><img src="18.png" style="zoom: 50%;" /><ul><li><p>解决方案</p><ul><li><p>路由环路解决方案一：定义最大值</p><p>1.设置最大跳数，比如最多转发15跳，16跳以上为不可达</p></li><li><p>路由环路解决方案二：路由中毒(Route Poisoning)</p><img src="21-1746703714747.png" style="zoom:67%;" /><ol><li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li><li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li><li>最终所有的路由器都知道不可达</li><li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li></ol></li><li><p>路由环路解决方案三：水平分隔(Split Horizon)</p><img src="22-1746703716393.png" style="zoom:50%;" /><ol><li>从某个端口收到的报文信息，不能再从端口发送回去</li><li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的</li><li>如果B和D接收到一个到达目的网段1的更好的路径，A会接收</li></ol></li><li><p>路由环路解决方案四：计时器(Hold-Down Timers)</p><ol><li>收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li><li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li><li>计时器结束后，删除掉对应的条目，避免出现问题</li><li>每一条路由表的记录都有<strong>有效时间</strong></li></ol></li></ul></li></ul></li><li><p>链接状态协议(LSP, Link-state Protocol)</p><ul><li>过程<ul><li><strong>邻居发现：</strong> 路由器首先通过一些机制（例如Hello消息）发现它的直接邻居。这些邻居是直接连接的路由器。</li><li><strong>链路状态信息收集：</strong> 每个路由器收集关于它与邻居之间链路的状态信息。这包括链路的带宽、延迟、可靠性等信息。</li><li><strong>链路状态信息传播：</strong> 路由器将它所知道的链路状态信息通过链路状态通告（Link State Advertisement, LSA）广播给所有邻居。LSA包含了路由器所连接的链路的信息，以及这些链路的状态。</li><li><strong>LSA数据库维护：</strong> 每个路由器维护一个LSA数据库，其中包含了它所收到的所有LSA。这个数据库用于构建整个网络的拓扑图。</li><li><strong>拓扑图建立：</strong> 路由器使用LSA数据库中的信息构建整个网络的拓扑图。这是一个图形表示，显示了网络中所有路由器和它们之间的链路关系。</li><li><strong>最短路径计算：</strong> 一旦拓扑图建立完成，路由器使用某种最短路径算法（如Dijkstra算法）计算到达网络中每个路由器的最短路径。</li><li><strong>路由表更新：</strong> 路由器根据最短路径计算结果更新它的路由表。路由表包含了到达网络中每个目的地的最佳路径。</li><li><strong>定期更新：</strong> 为了保持网络状态的实时性，链路状态协议定期发送Hello消息并交换LSA。这有助于检测链路状态的变化，并及时更新路由表。</li></ul></li><li>当发生事件导致链路变化，路由器广播一个LSU消息（一种用于传递链路状态信息的消息类型）</li><li>传递的是链路信息，不是路由表（与DVP区别）</li></ul></li><li><p>Routing Protocols 主动路由协议</p><table><thead><tr><th>英文缩写</th><th>英文解释</th><th>中文解释</th><th>备注</th></tr></thead><tbody><tr><td>RIP</td><td>a distance-vector routing protocol</td><td>距离矢量协议</td><td>DV</td></tr><tr><td>IGRP</td><td>Cisco’s distance-vector routing protocol IGRP</td><td>思科的距离矢量路由协议</td><td>DV，基本启用</td></tr><tr><td>OSPF</td><td>Open Shortest Path First</td><td>开放式最短路径优先</td><td>LSP</td></tr><tr><td>EIGRP</td><td>Enhanced IGRP</td><td>平衡的混合路由协议</td><td>杂合</td></tr></tbody></table></li><li><p>路由协议的主要目标</p><ul><li>最佳(Optimal)路线:选择最佳路线</li></ul></li></ul><ul><li>效率(Efficiency):最少使用带宽和路由器处理器资源<ul><li>快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。</li></ul></li><li>灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由</li></ul><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><ul><li>默认路由使路由表更短。(很多路由被省略)</li><li>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</li><li>命令：<code>ip route 0.0.0.0 0.0.0.0 [默认下一跳地址]</code></li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="RIP-v1-v2"><a href="#RIP-v1-v2" class="headerlink" title="RIP v1 &#x2F; v2"></a>RIP v1 &#x2F; v2</h3><ul><li>RIP v1<ul><li>RIP v1被认为是一种<strong>内部网关协议</strong>，它是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器。默认间隔为<strong>30秒</strong>。</li><li>RIP使用<strong>跳数</strong>作为度量标准，最大跳数为<strong>15</strong>，达到16跳的报文自动抛弃</li><li>RIP v1能够在多达六个等价路径上进行<strong>负载平衡(Load Balancing)</strong>，默认情况下为四个路径，最多6个，跳数相同才能完成负载均衡，跳数不同不满足条件</li><li>负载平衡：在多条路径之间分配网络流量，以确保网络资源的均衡利用和提高网络性能</li><li>更新中不发送子网掩码：不支持VLSM</li><li>不支持身份验证，安全性差</li><li>以255.255.255.255的广播形式发送更新:只能发给邻居，不能通过路由器转发</li></ul></li><li>RIP v2<ul><li>RIP v2是RIP v1的改进版本，并且新增了以下的功能：<ul><li>这是一种使用<strong>跳数指标</strong>的距离矢量协议。</li><li>它使用<strong>抑制计时器</strong>来防止路由循环-默认值为<strong>180秒</strong>,6倍于交换时间</li><li>它使用水平分割(Split Horizon)来防止路由循环(Routing Loops)。</li><li>它使用16跳作为<strong>无限距离的度量</strong>。(15跳及以内可达)</li></ul></li></ul></li><li>RIP v1和RIP v2之间的区别<ul><li>支持有类路由:可以携带子网掩码</li><li>使用组播地址进行发送广播:<strong>特定给RIP接受，避免了接受后发现没有启动RIP进程耽误时间</strong></li><li>需要身份认证才确定是否继续进行接收</li></ul></li></ul><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ul><li><p>概述</p><ul><li>链接的状态是对<strong>接口</strong>及其与其<strong>相邻路由器关系</strong>的描述</li><li>链接状态的集合形成一个<strong>链接状态数据库</strong>，有时也称为<strong>拓扑数据库</strong></li><li>路由器应用<strong>Dijkstra最短路径优先</strong>(SPF)算法来构建以自己为根的SPF树</li><li>路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放置在<strong>路由表</strong>中</li></ul></li><li><p>特征</p><img src="10.png" style="zoom:67%;" /><ul><li>将大的网络分成多个area，每一个area只和area 0相连，<strong>保证area没有回路</strong></li><li><strong>层次最多只有2个</strong>，只存在一个area 0。其它area都和area 0相连。</li><li>层次维持树的关系</li><li>在一个Area中才算是neighbours，neighbour之间交换Topology Databases（存的是link-state）</li><li>一个Area中获得全部LS(Link State)后计算Tree，生成表</li></ul></li><li><p>OSPF与RIP对比</p><ul><li><img src="image-20231223162518274.png" alt="image-20231223162518274" style="zoom:67%;" /></li><li><img src="9.png" style="zoom: 50%;" /></li><li>上面带宽大，2跳达到，下面带宽小，1跳到达。</li><li>OSPF从上面走，RIP从下面走，但是上面会快一些，因此OSPF选择的路径是更加优越的</li></ul></li><li><p>名词</p><ul><li>区域：有着同样区域ID的网络&#x2F;路由器集合。在同一个区域的每个路由器有着同样的链路状态信息</li><li>开销：固定值除以带宽</li><li>链路状态:物理链路的信息，路由器连接关系、通过什么接口、链路带宽、网络类型(点对点、多路复用)等</li><li>自治系统：一组具有相同的路由政策的IP网络和路由器的集合</li><li>DR：指定路由器，只有在多路复用的链路下使用，被选举出来</li><li>BDR：备份指定路由器，如果DR坏了，再次选举会出现问题，如果DR损坏，BDR立即成为DR</li><li>ABR(Area Border Router):区域边界路由器，有一定的约束(一个路由器最多不连接超过3个以上的路由器)</li></ul></li><li><p>OSPF域</p><img src="20-1746703728020.png" style="zoom: 60%;" /><ul><li>区域用32位数字标识：可以是IP格式（标准定义），也可以是一个十进制值</li><li>区域0：区域编号为0的单个区域。 area是OSPF两层结构划分的单位</li><li>OSPF使用2级分层模型：逻辑上必须是2层结构，而物理实现上可能有一定的差异，如果更多需要进行逻辑配置</li><li>在多区域OSPF网络中，要求所有区域都连接到区域0(主干)</li></ul></li><li><p>成为邻居的条件</p><ul><li>**Hello协议匹配：**OSPF邻居的建立依赖于Hello协议。路由器必须能够相互发送和接收Hello消息，并且这些消息中的参数必须匹配，包括Hello定时器、Dead定时器等。</li><li>**IP配置正确：**路由器必须配置正确的IP地址，并且它们之间能够相互通信。这通常包括确保两个路由器在同一个子网内，并且能够通过IP层相互到达。</li><li>**区域号匹配：**OSPF使用区域的概念，路由器必须在同一区域内才能成为邻居。如果两个路由器的区域不同，它们将无法建立邻居关系。</li></ul></li><li><p>OSPF过程</p><ul><li>步骤1：建立邻接关系<ul><li>路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播（TTL每经过一个路由器减一）</li><li>如果邻居被发现了：将邻居添加到邻居数据库</li><li>发现网络类型<ol><li>如果是多路复用网络，进入DR&#x2F;BDR选举过程，然后进入步骤2。</li><li>如果是点对点或点对多点网络，则不会举行DR&#x2F;BDR选举过程，并跳过步骤2。</li><li>如果hello数据包标头中的DR&#x2F;BDR字段已被占用(即DR &#x2F; BDR对已经存在)，则不会进行DR&#x2F;BDR选举，并跳过步骤2</li></ol></li></ul></li><li>步骤2：选择DR和BDR(如果需要):<strong>多路复用的时候才需要</strong><ul><li>如果没有其他路由器联机，则该路由器将成为DR。下一个要”启动”的路由器将是BDR</li><li>如果多个路由器(两个或更多)同时联机，进行选举</li></ul></li><li>步骤3：发现路线<ul><li>路由器确定”主&#x2F;从(master&#x2F;slave)”关系</li><li>多路复用网络中的DR&#x2F;BDR交换LSA(Type 2)，并且所有其他路由器将其Type 2 DBD发送给DR&#x2F;BDR</li><li>如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态：所有路由器必须在”加载状态”中等待，直到完全更新请求的路由器</li></ul></li><li>步骤4：选择适当的路线<ul><li>与网络上的所有其他路由器并行地计算SPF算法</li><li>在发生这种情况之前，所有路由器必须具有相同的链接状态数据库</li><li>SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树，OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享</li></ul></li><li>步骤5：维护路线信息<ul><li>常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制</li><li>根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)<ol><li>对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接</li><li>对于小于T1的链接，每30秒：非广播多路访问链接</li><li>“死间隔”是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)</li></ol></li></ul></li></ul></li><li><p>DR和BDR选举</p><ul><li><p>为什么要选择DR和BDR？</p><ul><li>如果不选择DR和BDR会导致每一个路由器都和其他所有路由器交流</li><li>每一个都要建立n * n - 1 &#x2F; 2个链接，对于链路的复杂比较高，如果有了DR就只需要(n-1)个连接</li><li>BDR是DR的备份，其他路由器之间就不用通信了</li></ul></li><li><p>选举方法</p><ul><li>优先级+路由器ID，最大的是DR，第二大的是BDR</li><li>路由器ID：手动配置、自动分配</li><li>自动分配时，如果有一个已经分配的回环接口（Loopback Interface），OSPF会选择其中最高的回环IP地址作为路由器ID，如果没有分配回环接口，OSPF将选择路由器上最高的活动接口的IP地址作为路由器ID</li><li>回环接口：是网络设备上的虚拟接口，通常用于本地主机内部进行测试和通信。它是一个虚构的网络接口，不连接到任何物理硬件，而是直接与本地设备的内部协议栈进行通信。</li></ul></li><li><p>过程</p><img src="25-1746703731030.png" style="zoom:60%;" /><ul><li>每个路由器与DR和BDR形成邻接关系</li><li>对于所有OSPF路由器，DR使用224.0.0.5(自己的IP)的<strong>主播地址</strong>向该网段上的所有其他路由器发送链接状态信息</li><li>为确保DR&#x2F;BDR看到所有路由器在网段上发送的链接状态，<strong>给所有DR&#x2F;BDR的多播地址是224.0.0.6</strong> <strong>(DR和BDR之间)</strong></li><li>几个Area有几个DR和BDR(是在不同Area上)</li></ul></li></ul></li><li><p>OSPF报文</p><ul><li><img src="26-1746703735937.png" style="zoom:50%;" /></li><li>Hello报文<ul><li>路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔（<strong>每10秒</strong>）发送hello</li><li>Hello数据包的地址为224.0.0.5</li></ul></li><li>DBD与LSA区别<ul><li>DBD消息是用于同步链路状态数据库的摘要信息，而LSA是用于传递链路状态数据库中详细的拓扑信息。</li><li>一旦通过DBD消息同步了LSDB（链路状态数据库）的状态，路由器之间就会进行LSA的交换。在LSA交换过程中，路由器可以请求缺失的LSA，也可以发送新的或者更新的LSA。</li></ul></li></ul></li></ul><h2 id="局域网交换与VLAN"><a href="#局域网交换与VLAN" class="headerlink" title="局域网交换与VLAN"></a>局域网交换与VLAN</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>基本功能<ul><li>根据MAC地址建立和维护<strong>交换表</strong>(类似于网桥表)</li><li>将帧切换出接口到目标</li><li>若收到的帧目的地址不在MAC表中，从所有端口转发</li></ul></li><li>对称交换与非对称交换<ul><li>对称交换可在具有相同带宽的端口之间提供交换连接</li><li>非对称交换通过将带有服务器的网段连接到更高带宽的端口，减少了服务器上潜在瓶颈的可能性</li></ul></li><li>内存缓冲<ul><li>作用：交换机中临时存储目标和传输数据的内存区域，直到可以将其切换出正确的端口为止</li><li>基于端口(Port)的内存缓冲<ul><li>数据包存储在每个端口的队列中</li><li>由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输，其他端口可能会空闲，存在不均衡的问题</li><li>每个端口都有一个buffer</li></ul></li><li>共享内存缓冲<ul><li>所有端口共享的公用内存缓冲</li><li>允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。</li><li>需要自己记录端口的信息</li></ul></li></ul></li><li><strong>交换方式</strong><ul><li>存储转发：交换机<strong>接收整个帧</strong>，先将其计算为循环冗余校验码（CRC），校验正确后再将其发送到目的地</li><li>直通：快速转发切换：<strong>仅在立即转发帧之前检查目标MAC(只看到帧的目的地址就转发，而不看帧的后面的部分)</strong></li><li>无碎片转发：交换机在接收到数据包的前64字节后，再开始进行数据包的转发。这意味着交换机会检查数据包的前64字节以确保没有任何碎片</li></ul></li><li>分层交换机<ul><li>第二层交换机：大规模集成电路，保证链路效率，低时延，低成本，有MAC地址</li><li>第三层交换机：基于硬件的帧转发机制，较高的帧转发性能，低时延（路由器是针对路由表进行转发），<strong>对数据流进行路由</strong>，<strong>生成MAC和IP的映射</strong>能够划分广播域，支持更复杂的网络拓扑</li><li>第四层交换机：可以根据端口主机的应用特点进行一定的流量控制，识别到前80个字节的数据报长度，对指定应用进行管理</li></ul></li></ul><h3 id="生成树协议-STP-The-Spanning-Tree-Protocol"><a href="#生成树协议-STP-The-Spanning-Tree-Protocol" class="headerlink" title="生成树协议(STP, The Spanning-Tree Protocol)"></a>生成树协议(STP, The Spanning-Tree Protocol)</h3><ul><li><p>桥环路：网络环路可能导致数据包在网络中无限循环，造成网络拥塞和性能问题，主要由第二层交换机冗余造成。STP通过自动选择和维护一棵”生成树”，从而阻止环路的产生。</p></li><li><p>概述</p><ul><li>主要功能：在<strong>交换&#x2F;桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</li><li>STP通过计算<strong>稳定的生成树</strong>网络拓扑<strong>来防止环路</strong></li><li><strong>生成树帧</strong>：桥协议数据单元BPDU(bridge protocol data unit)用于确定生成树拓扑</li></ul></li><li><p>STP决策顺序</p><ul><li>生成树始终使用相同的四步决策序列：<ul><li>在拓扑里面最低的root BID(网桥标识)</li><li>找到 Root bridge的最低路径成本</li><li>每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子</li><li>每个路径再指定一个最低的ID端口</li></ul></li><li>这些信息的得取都是靠的BPDU帧的交换</li></ul></li><li><p>BPDU(Bridge Protocol Data Unit)</p><ul><li>STP建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</li><li>不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)</li><li>在阻塞的链接上收到的数据帧将被丢弃。</li><li>交换机发送的允许形成无环逻辑拓扑的消息是BPDU</li></ul></li><li><p><strong>端口状态：</strong> STP定义了几种端口状态，包括：</p><ul><li><strong>指定端口（Designated Port）：</strong> 被选中作为某个网络段上的主端口，用于传输数据。</li><li><strong>根端口（Root Port）：</strong> 每个非根桥上选择通往根桥的最短路径的端口。</li><li><strong>阻塞端口（Blocked Port）：</strong> 阻塞状态的端口，用于防止环路的形成。</li></ul></li><li><p>选举根交换机</p><ul><li>交换机通过查找具有<strong>最低BID</strong>（较小的优先级值表示更高的优先级）的交换机(通常称为根战争)来选择单个根交换机。</li><li>如果所有交换机都使用默认的网桥优先级32768，则最低的MAC地址将作为根交换机。</li></ul></li><li><p>路径代价 Cost</p><ul><li>桥梁使用成本的概念来评估它们与其他桥梁的距离。</li><li>和OSPF算法相同的，这个标准是比较合适的，比之前OSPF要新，<strong>用固定的数值除以带宽来获得代价</strong></li></ul></li><li><p>STP状态的默认顺序为：</p><ol><li>阻塞：不转发帧，接收BPDU</li><li>监听：不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了</li><li>学习：不转发帧，学习地址</li><li>转发：转发帧，学习地址</li><li>禁用：不转发帧，不接收BPDU</li></ol></li><li><p>步骤</p><ul><li><p>步骤一：根交换机决定</p><ul><li>每个交换机都有一个优先级（Priority）值和一个唯一的MAC地址。首先，所有交换机都假定自己是根桥，广播一个BPDU（Bridge Protocol Data Unit）消息，其中包含了自己的优先级和MAC地址信息。</li><li>当其他交换机收到BPDU消息时，它们会比较收到的BPDU的根桥信息和自身的根桥信息，选择具有最小优先级和最小MAC地址的交换机作为根桥。这个过程会逐级传递，最终网络中的所有交换机都能得知根桥的信息。</li></ul></li><li><p>步骤2：选择根端口</p><ul><li><p>每个非根桥必须选择一个根端口</p></li><li><p>桥的根端口是最接近根桥的端口。</p></li><li><p>根路径成本是到根网桥的<strong>所有链接的累积成本。</strong></p></li></ul></li><li><p>步骤3：选择网段的指定端口</p><ul><li>每个网络段（两台交换机间的链路）上都会有一个指定端口，用于连接到生成树上。指定端口是具有最小根路径开销的端口。</li><li>如果有多个端口的根路径开销相同，则选择具有最小端口ID的端口作为指定端口。</li></ul></li></ul></li><li><p>解题技巧</p><ul><li>计算cost时，不能穿过自己</li><li>包含根的网段的指定端口一定是根交换机自己的端口</li></ul></li></ul><h3 id="VLAN-Virtual-Local-Area-Network-虚拟局域网"><a href="#VLAN-Virtual-Local-Area-Network-虚拟局域网" class="headerlink" title="VLAN(Virtual Local Area Network 虚拟局域网)"></a>VLAN(Virtual Local Area Network 虚拟局域网)</h3><ul><li><p>VLAN特点</p><ul><li>在第2层和第3层工作</li><li>控制网络广播，提供更严格的网络安全性</li><li>允许用户由网络管理员分配</li><li>VLAN<strong>创建一个不限于物理网段</strong>的单个广播域，并且将其视为子网</li><li>广播帧仅在具有相同VLAN ID的一个或多个交换机的端口之间切换。(VLAN ID属于端口)</li></ul></li><li><p>虚拟局域网中路由器的作用</p><ul><li>路由器为不同VLAN提供网关以实现不同VLAN之间的连接，可以用子接口，也可以用多个接口</li><li>交换机与路由器连接的端口设置为trunk：节约交换机端口，否则每个VLAN都需要一个端口</li><li>路由器将一个VLAN的帧转发到另一个VLAN时，接受帧的子接口会先解析标识，然后交给对应目标VLAN的子接口加上新的标记后转发</li></ul></li><li><p>设备连线</p><ul><li>PC控制路由器、交换机用全反线连接console口</li><li>同种类型（同层）设备之间使用交叉线连接，不同类型（不同层）设备间使用直通线连接</li><li>特例：PC和路由器看作同层，用交叉线连接</li></ul></li><li><p>虚拟局域网中帧的使用</p><ul><li><p>骨干网（BackBone）：用于VLAN间通信的区域，速度快</p></li><li><p>交换机根据帧中的数据做出过滤和转发决策</p></li><li><p>帧过滤：检查有关每个帧的特定信息（MAC地址或第3层协议类型）,特定的VLAN记录或者映射</p></li><li><p>帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符</p></li><li><p>标记过程：在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符，当帧到达终端之前删除该标记</p></li></ul></li><li><p>静态VLAN</p><ul><li>静态VLAN是指将交换机上的端口管理性地分配给VLAN</li><li>VLAN信息是写死在交换机的端口上的，基于端口</li></ul></li><li><p>动态VLAN</p><ul><li>当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口</li><li>基于MAC地址</li></ul></li><li><p>以端口为中心的VLAN</p><ul><li>同一VLAN的所有节点连接到路由器的同一个端口</li><li>使管理更容易</li></ul></li><li><p>交换机端口分类</p><ul><li>访问链接（access link）：只属于一个VLAN，且仅向该VLAN转发数据帧，一般与客户机连接</li><li>汇聚链接（Trunk Link）：主干链路能够支持多个VLAN，通常用于将交换机连接到其他交换机或路由器<ul><li><strong>一般Trunk就是BackBone</strong></li><li>骨干链路不属于特定的VLAN：充当交换机和路由器之间VLAN的通道</li><li>trunk口可以理解为两台交换机或路由器之间的通道，若无trunk口，每个VLAN都需要消耗交换机的一个接口，trunk相当于它们的汇集</li><li>一般将两台交换机间的连接端口设置为trunk，在帧出trunk端口时会被加上标记（VLAN标识符），进入另一个trunk端口后标记会在解析后被删除</li></ul></li></ul></li><li><p>解题注意</p><ul><li>同一VLAN中的两台主机可以跨越多台交换机</li><li>必须是第三层及以上的交换机才能用来构建VLAN</li><li>新交换机会有一个默认的vlan 1</li><li>vlan只能分割广播域，不能分割冲突域</li><li>每个vlan中都有一个分离的桥接表（bridging table）</li></ul></li></ul><h2 id="WAN-广域网"><a href="#WAN-广域网" class="headerlink" title="WAN(广域网)"></a>WAN(广域网)</h2><h3 id="广域网技术和服务"><a href="#广域网技术和服务" class="headerlink" title="广域网技术和服务"></a>广域网技术和服务</h3><ul><li><p>WAN Services 广域网服务</p><ul><li>定义:WAN是通过WAN服务提供商连接LAN的通信网络</li><li>WAN在OSI的前三层运行，但<strong>主要集中在物理和数据链路层</strong></li><li>广域网的最小单位是公司，一般由运营商完成</li></ul></li><li><p>物理结构</p><ul><li>通过Network远程接入，通过WSP提供的CO Switch来连接到中心局</li><li>CPE:位于公司本地的设备(主要是接入设备)，安装在用户的场所，用于连接到服务提供商网络</li><li>CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案</li><li>Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理</li><li>实际上实现了点对点的连接</li></ul></li><li><p>广域网虚拟电路</p><ul><li><p>广域网虚拟电路是一种在广域网中建立的逻辑通信路径，它允许在远距离的地理位置之间进行数据通信。虚拟电路是一种面向连接的通信方式，其中数据通过在网络中建立的虚拟通道进行传输。</p></li><li><p>三个阶段：</p><ol><li><p>电路建立–创建虚拟电路(逻辑确定)</p></li><li><p>数据传输–发送和接收用户数据(含有虚电路号等)，<strong>不会出现丢失和乱序问题，实现了可靠传输</strong></p></li><li><p>电路中断–拆除虚拟电路</p></li></ol></li></ul></li><li><p>广域网设备</p><ul><li>为了连接到专线(leased line)，客户必须具备以下条件：<ol><li>访问服务提供商的电路</li><li>可用的适当路由器端口</li><li>CSU&#x2F;DSU，调制解调器，ISDN终端适配器等</li></ol></li><li><img src="6.jpg" style="zoom:67%;" />- CSU：负责在用户设备和数字线路之间提供物理层连接的设备- DSU：负责在用户设备和数字线路之间提供数据链路层连接的设备- 这两者通常一起使用，合称为 "CSU/DSU"，它们提供了一个完整的连接，确保用户设备与数字通信线路之间的兼容性和有效通信</li></ul></li></ul><h3 id="广域网和OSI模型"><a href="#广域网和OSI模型" class="headerlink" title="广域网和OSI模型"></a>广域网和OSI模型</h3><ul><li>设备：<ul><li>DCE：代表 “Data Circuit-terminating Equipment”，它是用于连接到数字通信线路的设备，工作在物理层、数据链路层。DCE 通常是一种数字通信设备，负责提供物理连接、数据格式转换和时钟同步等功能，如调制解调器、CSU&#x2F;DSU。</li><li>DTE：代表 “Data Terminal Equipment”，数据终端设备。DTE 是指在数字通信系统中生成、处理或终结数据的设备，如计算机、终端、打印机、路由器或其他生成或处理数字数据的设备，工作在应用层、表示层和部分会话层</li><li><strong>DCE与 DTE 的连接：</strong><ul><li>用户设备（DTE，如计算机、路由器等）通过一个数据接口连接到 DCE。</li><li>DCE 然后连接到数字通信线路</li></ul></li></ul></li><li>物理层协议<ul><li>描述如何为WAN服务提供电气，机械，操作和功能连接的协议</li><li>描述数据终端设备和数据电路终端设备之间的接口</li><li>在此模型中，通过调制解调器或CSU&#x2F;DSU提供给DTE的服务</li></ul></li><li>数据链路层协议<ul><li>WAN数据链路协议描述了如何在单个数据链路上的系统之间承载帧</li><li><strong>点对点协议(PPP,Point-to-Point Protocol)</strong>：PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议)，根据不同的网络协议对帧做控制与检查</li><li><strong>高级数据链路控制(HDLC, High-Level Data Link Control)</strong>：不同供应商之间不兼容HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点&#x2F;多点配置(抽象规范和约束，各个厂商不同)</li><li><strong>帧中继(Frame Relay)</strong>：使用简化的封装，对高质量的数字设备不进行纠错</li><li><strong>ISDN</strong>：通过现有电话线传输语音和数据的一组数字服务</li><li><strong>平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)</strong>：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制。</li></ul></li></ul><h3 id="广域网访问方法"><a href="#广域网访问方法" class="headerlink" title="广域网访问方法"></a>广域网访问方法</h3><ul><li><p>PPP&#x2F;HDLC</p><ul><li>点对点的标准，工作在串行链路上（数据链路层）</li><li>如果都是同一个厂商的可以用HDLC，不然使用PPP</li><li>两者都是广域网点对点链路中的封装方式</li></ul></li><li><p>PPP 点对点协议  <strong>考点</strong></p><ul><li>串行链路上使用最广泛的第2层协议</li><li><strong>多协议支持：</strong> PPP 支持多种网络层协议，如 IP、IPv6等。</li><li><strong>可靠性：</strong> PPP 提供了一系列的错误检测和纠正机制，以确保数据的可靠传输。</li><li><strong>认证：</strong> PPP 支持用户身份验证，可以使用用户名和密码进行认证。</li></ul></li><li><p>PPP组件</p><ul><li>HDLC：封装第3层数据报的基础</li><li>LCP(链接控制协议Link Control Protocol)：建立连接、连接配置选项、链接质量测试</li><li>NCP(网络控制协议Network Control Protocol)：选择和配置第3层协议</li></ul></li><li><p>PPP帧格式</p><img src="10.jpg" style="zoom:50%;" /><ul><li>Flag: 01111110 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li><li>Address ：11111111，广播地址</li><li>Control ：00000011，用户数据作为无序帧传输</li><li>Protocol: 数据字段中的协议类型（既可以指网络层，又可以指数据链路层）</li><li>Data: 数据报，最大默认值为1500字节</li><li>FCS: 2或者4字节</li></ul></li><li><p>PPP会话建立&#x2F;终止</p><ul><li>为了通过点对点链路建立通信，PPP经历四个不同的阶段：<ol><li>步骤一:链接建立和配置协商(negotiation)(LCP)。</li><li>步骤二:链接质量测试。</li><li>步骤三:网络层协议配置(NCP)。</li><li>步骤四:链接终止。</li></ol></li><li><strong>链路建立阶段：</strong><ul><li>通信的第一步是链路建立阶段。在这个阶段，通信的两端（通常是两个路由器或计算机）通过 PPP 协议建立连接。</li><li>LCP（Link Control Protocol）运行在这个阶段，它负责协商链路的特性。这包括链路的最大帧大小、帧起始标志、帧校验序列（FCS）类型等。LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如<strong>压缩和身份验证协议</strong>等。</li></ul></li><li><strong>链路质量和参数协商：</strong><ul><li>在链路建立阶段，LCP 还负责检测链路的质量，发送和接收LCP数据包以测量链路上的错误率，并根据需要进行调整。它可以选择性地协商和改变链路特性，以适应网络的需求。</li><li>身份验证(如果使用)在网络层协议配置阶段开始之前进行</li><li>一旦 LCP 完成成功，链路建立阶段就结束，进入 NCP（Network Control Protocol）阶段。</li></ul></li><li><strong>网络层协议配置：</strong><ul><li>NCP 运行在链路建立后的阶段，其目标是协商和配置网络层协议。在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。</li><li>通信的两端通过 NCP 协商确定要在 PPP 连接上使用的网络层协议。一旦协商成功，通信的两端就可以开始在 PPP 连接上发送来自每个网络层协议的数据报。</li></ul></li><li><strong>连接终止阶段：</strong><ul><li>当数据传输完成或者需要终止连接时，通信的一方可以发起连接的终止。</li><li>LCP可以随时终止链接：应用户要求(一方请求终止)、链接质量、超时</li><li>LCP 可能会再次参与，协商关闭链路。在 PPP 连接终止阶段，LCP 和 NCP 都可能发挥作用。</li></ul></li></ul></li><li><p>PPP安全认证</p><ul><li>PAP 安全认证协议<ul><li>链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。</li><li>远程节点使用双向握手PAP建立其身份。</li><li>远程节点<strong>重复</strong>发送用户名&#x2F;密码对，直到确认身份验证或连接终止</li><li>密码以明文形式通过链接发送。</li><li>在建立连接阶段之后，仅对远程节点进行一次身份验证</li></ul></li><li>CHAP(Challenge Handshake Authentication Protocol)<ul><li><strong>挑战：</strong> 在连接建立时，认证服务器向客户端发送一个挑战，这是一个随机生成的字符串。挑战的目的是验证客户端是否知道共享的密钥。</li><li><strong>响应：</strong> 客户端收到挑战后，使用共享的密钥（通常是密码）对挑战进行哈希运算，生成一个响应字符串。客户端将这个响应字符串发送回认证服务器。</li><li><strong>验证：</strong> 服务器收到客户端的响应后，使用与客户端共享的密钥进行相同的哈希运算，然后比较计算出的响应与客户端发送的响应是否匹配。如果匹配，认证成功；否则，认证失败。</li><li><strong>周期性挑战：</strong> 为增强安全性，CHAP可以使用周期性挑战。在初始认证成功后，认证服务器可以定期发送新的挑战给客户端，要求客户端再次提供响应，以确保连接仍然是合法的。</li></ul></li></ul></li><li><p>综合数字服务网络(ISDN, Integrated Services Digital Networks)</p><ul><li>集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接</li><li>可以携带语音，视频和数据</li><li>服务有两种：BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP；PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD</li><li>BRI是ISDN的基本服务接口，提供两个B通道（Bearer Channels）和一个D通道（Data Channel）。每个B通道的带宽为<strong>64 Kbps</strong>，D通道的带宽为<strong>16 Kbps</strong>。因此，BRI总带宽为<strong>144 Kbps</strong>。</li><li>PRI是ISDN的高级服务接口，通常用于更大规模的组织。它提供了更多的B通道和更高的总带宽，通常为23个B通道和1个D通道，总带宽为1.544 Mbps（T1）或30个B通道和1个D通道，总带宽为2.048 Mbps（E1）。</li></ul></li><li><p>非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)</p><ul><li>xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</li><li>xDSL 的几种类型<ul><li>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</li><li>HDSL (High speed DSL)：高速数字用户线</li><li>SDSL (Single-line DSL)：1 对线的数字用户线</li><li>IDSL：ISDN用户线</li><li>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率</li></ul></li><li>ADSL的极限传输距离：与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系(用户线越细，信号传输时的衰减就越大)</li><li>ADSL特点：<ul><li>上行和下行带宽不对称:上行指从用户到ISP，而下行指从ISP 到用户，下载速度通常比上传速度快</li><li>ADSL在用户线(铜线)的两端各安装一个ADSL调制解调器，在用户端，调制器将数字数据转换为模拟信号，以适应电话线的传输特性。在ISP端，解调器将模拟信号转换回数字数据。</li><li>我国目前采用的方案是离散多音调（DMT） 调制技术，采用频分复用的方法</li><li>通常下行数据率在 32 kb&#x2F;s 到 6.4 Mb&#x2F;s 之间，而上行数据率在 32 kb&#x2F;s 到 640 kb&#x2F;s 之间。</li></ul></li></ul></li><li><p>其他广域网连接技术（应该不考，仅简写）</p><ul><li>同步光纤网SONET和同步数字系列SDH</li><li>光纤同轴混合网 HFC (Hybrid Fiber Coax)</li></ul></li></ul><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>被动攻击：截获信息的攻击称为被动攻击(并不改变通讯的过程)</li><li>主动攻击：更改信息和拒绝用户使用资源的攻击称为主动攻击</li><li>恶意程序<ul><li>计算机病毒:会”传染”其他程序的程序，”传染” 通过修改其他程序来把自身或其变种复制进去而完成。</li><li>计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)</li><li>特洛伊木马:一种程序，它执行的功能超出所声称的功能。运作木马获得特殊的权限</li><li>逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li></ul></li><li><img src="2-1746703748557.png" style="zoom:50%;" /></li></ul><h3 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h3><ul><li><strong>密码编码学</strong>(cryptography)：密码体制的设计学(设计密码)</li><li><strong>密码分析学</strong>(cryptanalysis)：在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。</li><li>对称密钥密码体系：常规密钥密码体制，即加密密钥与解密密钥是<strong>相同</strong>的密码体制</li><li>数据加密标准(DES Data Encryption Standard)：一种分组密码，属于常规密钥密码体制，详细略</li><li>公钥密码体制：使用<strong>不同的加密密钥与解密密钥(非对称密码体系)</strong></li><li>任何加密方法的安全性取决于<strong>密钥的长度</strong>，以及<strong>攻破密文所需的计算量</strong></li><li>数字签名：<ul><li>数字签名必须保证以下三点：<ol><li>报文鉴别:接收者能够核实发送者对报文的签名</li><li>报文的完整性:发送者事后不能抵赖对报文的签名</li><li>不可否认:接收者不能伪造对报文的签名</li></ol></li></ul></li></ul><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul><li><p>防火墙在互连网络中的位置</p><img src="6.png" style="zoom: 50%;" /></li><li><p>防火墙的功能与分类</p><ul><li>防火墙的功能有两个：<strong>阻止和允许</strong>。<ol><li><strong>阻止</strong>就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)</li><li><strong>允许</strong>的功能与<strong>阻止</strong>恰好相反</li></ol></li><li>防火墙的分类<ul><li><strong>网络级防火墙</strong>:用来防止整个网络出现外来非法的入侵。属于这类的有<strong>分组过滤和授权服务器</strong><ol><li>前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据</li><li>后者则检查用户的登录是否合法</li></ol></li><li><strong>应用级防火墙</strong>:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过</li></ul></li></ul></li></ul><h3 id="访问控制列表ACL-Access-Control-Lists"><a href="#访问控制列表ACL-Access-Control-Lists" class="headerlink" title="访问控制列表ACL(Access Control Lists)"></a>访问控制列表ACL(Access Control Lists)</h3><ul><li><p>概述</p><ul><li>ACL是指令列表，它告诉<strong>路由器</strong>允许或拒绝什么类型的数据包</li><li>如果要让路由器拒绝某些数据包，则必须配置ACL。否则只要链路打开，路由器将接受并转发所有数据包</li></ul></li><li><p>入站ACL过程</p><ul><li>收到数据包时，按照ACL列表逐个语句比对</li><li>当一个语句”匹配”时，<strong>不再评估任何语句</strong>。(前面的语句先匹配，处理掉)</li><li>ACL末尾有一个隐含的”deny any”语句：如果数据包与ACL中的任何语句都不匹配，则将其丢弃</li></ul></li><li><p>出站ACL过程</p><ul><li>检查数据包是否可路由。如果是这样，请在路由表中查找路由</li><li>检查出站接口的ACL：如果没有ACL，则将数据包切换出目标接口；如果有ACL，匹配<strong>源地址</strong></li></ul></li><li><p>ACL分类</p><img src="8-1746703752741.png" style="zoom:50%;" /><ul><li><p>ACL命令：<code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></p><ul><li><p>在ACL的<code>&#123;test condition&#125;</code>部分中，大多数访问列表的共同点是源地址和通配符掩码</p></li><li><img src="image-20231229125458373.png" alt="image-20231229125458373" style="zoom:67%;" /></li><li><p>通配符掩码和子网掩码是取反关系（如子网掩码为255.255.255.224，通配符掩码为0.0.0.31）</p></li><li><p>源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为IP掩码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">//拒绝来自192.168.2.0/24的流量<br>Router(config)# access-list 2 deny 192.168.2.0 0.0.0.255<br>Router(config)# access-list 2 permit any<br><br>//拒绝来自主机 192.168.1.10 的流量<br>Router(config)# access-list 1 deny host 192.168.1.10<br>Router(config)# access-list 1 permit any<br>//拒绝某主机也可用：<br>Router(config)#access-list 1 permit 192.5.5.10 0.0.0.0<br></code></pre></td></tr></table></figure></li></ul></li><li><img src="10-1746703757308.png" style="zoom:67%;" /><blockquote><ol><li>IP mask ：IPv4的地址</li><li><strong>Wildcard mask</strong>:和netmask是不同的，指示哪些位置被检查</li></ol></blockquote></li></ul></li></ul><ul><li><p>标准ACL：序号通常在1到99之间，仅检查源IP地址</p></li><li><p>扩展ACL：序号通常在100到199之间，可检查源和目标IP地址、协议类型、端口号等信息</p></li><li><p><strong>标准ACL靠近目的，拓展ACL靠近源</strong></p></li></ul><ul><li><p>常见端口号</p><ul><li><img src="13-1746703759203.png" style="zoom:67%;" /></li><li><strong>DHCP (Dynamic Host Configuration Protocol):</strong><ul><li>服务端口：67</li><li>客户端端口：68</li></ul></li><li><strong>HTTP (HyperText Transfer Protocol):</strong><ul><li>默认端口：80</li></ul></li><li><strong>HTTPS (HTTP Secure):</strong><ul><li>默认端口：443</li></ul></li><li><strong>POP3 (Post Office Protocol version 3):</strong><ul><li>默认端口：110</li></ul></li><li>注：20也是FTP的端口号，21用于建立连接，20用于传输数据</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫自学笔记</title>
    <link href="/2023/01/25/%E7%88%AC%E8%99%AB%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/25/%E7%88%AC%E8%99%AB%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫学习笔记"><a href="#爬虫学习笔记" class="headerlink" title="爬虫学习笔记"></a>爬虫学习笔记</h1><blockquote><p>本文记录了我自学 Python 爬虫的过程中，通过 <code>Selenium</code> 与 <code>Requests</code> 所掌握的一些基础操作与实战技巧，适合入门者阅读。</p></blockquote><span id="more"></span><hr><h2 id="一、使用-Selenium-控制浏览器自动化"><a href="#一、使用-Selenium-控制浏览器自动化" class="headerlink" title="一、使用 Selenium 控制浏览器自动化"></a>一、使用 Selenium 控制浏览器自动化</h2><p>Selenium 是一个强大的自动化测试工具，也常被用于爬虫任务中，尤其是需要模拟用户操作的场景。</p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>首先需要下载与浏览器版本匹配的 WebDriver。以 Edge 浏览器为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 指定驱动路径</span><br>edge_driver_path = <span class="hljs-string">&quot;E:\\EdgeDriver\\msedgedriver.exe&quot;</span><br>edge_service = webdriver.EdgeService(executable_path=edge_driver_path)<br><br><span class="hljs-comment"># 创建浏览器实例</span><br>edge_options = webdriver.EdgeOptions()<br>driver = webdriver.Edge(service=edge_service, options=edge_options)<br><br><span class="hljs-comment"># 打开网页</span><br>driver.maximize_window()<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-常见操作"><a href="#2-常见操作" class="headerlink" title="2. 常见操作"></a>2. 常见操作</h3><ul><li>刷新页面：<code>driver.refresh()</code></li><li>后退&#x2F;前进：<code>driver.back()</code> &#x2F; <code>driver.forward()</code></li><li>获取信息：<ul><li>当前网址：<code>driver.current_url</code></li><li>页面标题：<code>driver.title</code></li><li>页面源码：<code>driver.page_source</code></li></ul></li></ul><h3 id="3-元素交互"><a href="#3-元素交互" class="headerlink" title="3. 元素交互"></a>3. 元素交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入关键词</span><br>element = driver.find_element(By.NAME, <span class="hljs-string">&quot;wd&quot;</span>)<br>element.send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br><br><span class="hljs-comment"># 点击搜索按钮</span><br>button = driver.find_element(By.ID, <span class="hljs-string">&quot;su&quot;</span>)<br>button.click()<br>time.sleep(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 点击搜索结果中的某个链接</span><br>result_links = driver.find_elements(By.CSS_SELECTOR, <span class="hljs-string">&quot;h3 a&quot;</span>)<br>result_links[<span class="hljs-number">2</span>].click()<br></code></pre></td></tr></table></figure><h3 id="4-鼠标操作示例"><a href="#4-鼠标操作示例" class="headerlink" title="4. 鼠标操作示例"></a>4. 鼠标操作示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>actions = ActionChains(driver)<br><br><span class="hljs-comment"># 单击、双击、右键</span><br>actions.click(element).perform()<br>actions.double_click(element).perform()<br>actions.context_click(element).perform()<br><br><span class="hljs-comment"># 拖拽</span><br>actions.drag_and_drop(source_element, target_element).perform()<br></code></pre></td></tr></table></figure><hr><h2 id="二、使用-Requests-模拟网络请求"><a href="#二、使用-Requests-模拟网络请求" class="headerlink" title="二、使用 Requests 模拟网络请求"></a>二、使用 Requests 模拟网络请求</h2><p>相比 Selenium，<code>requests</code> 更轻量，适合处理静态页面或 API 数据。</p><h3 id="1-基本-GET-请求"><a href="#1-基本-GET-请求" class="headerlink" title="1. 基本 GET 请求"></a>1. 基本 GET 请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>r = requests.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><span class="hljs-built_in">print</span>(r.content.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="2-模拟浏览器请求"><a href="#2-模拟浏览器请求" class="headerlink" title="2. 模拟浏览器请求"></a>2. 模拟浏览器请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 ...&quot;</span><br>&#125;<br>response = requests.get(<span class="hljs-string">&quot;https://bing.com&quot;</span>, headers=headers)<br><span class="hljs-built_in">print</span>(response.status_code)<br></code></pre></td></tr></table></figure><h3 id="3-带参数的请求"><a href="#3-带参数的请求" class="headerlink" title="3. 带参数的请求"></a>3. 带参数的请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&quot;q&quot;</span>: <span class="hljs-string">&quot;requests&quot;</span>&#125;<br>response = requests.get(<span class="hljs-string">&quot;https://bing.com/search&quot;</span>, params=params, headers=headers)<br><span class="hljs-built_in">print</span>(response.url)<br></code></pre></td></tr></table></figure><h3 id="4-下载图片"><a href="#4-下载图片" class="headerlink" title="4. 下载图片"></a>4. 下载图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">picture = requests.get(<span class="hljs-string">&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;baidu.png&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(picture.content)<br></code></pre></td></tr></table></figure><hr><h2 id="三、Requests-常用方法和属性"><a href="#三、Requests-常用方法和属性" class="headerlink" title="三、Requests 常用方法和属性"></a>三、Requests 常用方法和属性</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>requests.get()</code></td><td>发送 GET 请求</td></tr><tr><td><code>requests.post()</code></td><td>提交表单或登录请求</td></tr><tr><td><code>requests.put()</code> &#x2F; <code>delete()</code> &#x2F; <code>head()</code></td><td>RESTful 请求</td></tr><tr><td><code>response.status_code</code></td><td>返回状态码</td></tr><tr><td><code>response.text</code> &#x2F; <code>response.content</code></td><td>返回响应内容</td></tr><tr><td><code>response.json()</code></td><td>返回 JSON 数据</td></tr><tr><td><code>response.headers</code> &#x2F; <code>cookies</code></td><td>获取响应头和 cookies</td></tr></tbody></table><hr><h2 id="四、编码与响应解析小贴士"><a href="#四、编码与响应解析小贴士" class="headerlink" title="四、编码与响应解析小贴士"></a>四、编码与响应解析小贴士</h2><ul><li><code>response.text</code> 是自动解码为字符串的形式</li><li><code>response.content</code> 返回原始二进制内容，更适合处理文件</li><li>可以手动指定编码方式，如 <code>response.content.decode(&quot;gbk&quot;)</code></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Selenium 更适合需要模拟人类操作的动态页面</li><li>Requests 更适合处理静态网页或 API</li><li>建议熟练掌握两者的基础使用，再逐步深入如 XPath、BeautifulSoup、正则表达式等内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂七杂八的自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>selenium</tag>
      
      <tag>request</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/12/05/test/"/>
    <url>/2022/12/05/test/</url>
    
    <content type="html"><![CDATA[<p>RPC</p><ul><li>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</li><li>步骤：客户端调用-&gt;请求发送(序列化) -&gt; 服务器接受并处理(反序列化) -&gt; 结果返回(序列化) -&gt; 客户端接收结果(反序列化)</li><li>常见的 RPC 框架：gRPC、Thrift、Dubbo</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
