<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2025/05/09/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/09/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><blockquote><p>灵神讲解视频：<a href="https://www.bilibili.com/video/BV1AP41137w7/">https://www.bilibili.com/video/BV1AP41137w7/</a></p></blockquote><h3 id="2-1-基本二分查找"><a href="#2-1-基本二分查找" class="headerlink" title="2.1 基本二分查找"></a>2.1 基本二分查找</h3><blockquote><p>注：以下的写法都是找第一个 &gt;&#x3D; x的下标，其他三种可以转换：</p><p>&gt; x 转换成 &gt;&#x3D; (x + 1)</p><p>&lt;&#x3D; x 转换成 (&gt; x) - 1，注意这种方法找到的是最后一个满足&lt;&#x3D; x 的</p><p>&lt; x 转换成 (&gt;&#x3D; x) - 1，注意这种方法找到的是最后一个满足&lt; x 的</p></blockquote><ul><li><p>左闭右闭写法</p><ul><li>初始化：<code>L = 0, R = n - 1</code></li><li>循环条件：<code>L &lt;= R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M + 1 / R = M - 1</code></li><li>最终答案为 L 或 R + 1（结束时满足L &#x3D; R + 1）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>) nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>左闭右开写法</p><ul><li>初始化：<code>L = 0, R = n</code></li><li>循环条件：<code>L &lt; R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M + 1 / R = M</code></li><li>最终答案为 L 或 R（结束时满足L &#x3D; R）</li></ul></li><li><p>左开右开写法</p><ul><li>初始化：<code>L = -1, R = n</code></li><li>循环条件：<code>L + 1 &lt; R</code>，即区间不为空</li><li>更新L&#x2F;R：<code>L = M / R = M</code></li><li>最终答案为 L + 1 或 R（结束时满足L + 1 &#x3D; R）</li></ul></li></ul><h3 id="2-2-二分答案"><a href="#2-2-二分答案" class="headerlink" title="2.2 二分答案"></a>2.2 二分答案</h3><ul><li>核心思路：题目求什么，就对这个值的范围进行二分查找并<code>check</code></li></ul><h4 id="2-2-1-求最小与求最大"><a href="#2-2-1-求最小与求最大" class="headerlink" title="2.2.1 求最小与求最大"></a>2.2.1 求最小与求最大</h4><ul><li><p>注意「求最小」和「求最大」的二分写法上的区别。</p><ul><li>前面的「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。</li><li>「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。</li></ul></li></ul><ul><li>以开区间二分为例：<ul><li>求最小：<code>check(mid) == true</code> 时更新 <code>right = mid</code>，反之更新 <code>left = mid</code>，最后返回 <code>right</code></li><li>求最大：<code>check(mid) == true</code> 时更新 <code>left = mid</code>，反之更新 <code>right = mid</code>，最后返回 <code>left</code></li></ul></li><li>对于<strong>开区间</strong>写法，简单来说 <code>check(mid) == true</code> 时<strong>更新的是谁最后就返回谁</strong>。相比其他二分写法，开区间写法不需要思考加一减一等细节，<strong>推荐使用开区间写二分</strong>。</li></ul><h4 id="2-2-2-二分间接值"><a href="#2-2-2-二分间接值" class="headerlink" title="2.2.2 二分间接值"></a>2.2.2 二分间接值</h4><ul><li>二分的不是答案，而是一个和答案有关的值（间接值）</li></ul><h4 id="2-2-3-第-K-小-大"><a href="#2-2-3-第-K-小-大" class="headerlink" title="2.2.3 第 K 小&#x2F;大"></a>2.2.3 第 K 小&#x2F;大</h4><ul><li>第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。</li><li>第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口与双指针</title>
    <link href="/2025/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2025/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-滑动窗口与双指针"><a href="#1-滑动窗口与双指针" class="headerlink" title="1. 滑动窗口与双指针"></a>1. 滑动窗口与双指针</h2><h3 id="1-1-滑动窗口"><a href="#1-1-滑动窗口" class="headerlink" title="1.1 滑动窗口"></a>1.1 滑动窗口</h3><h4 id="1-1-1-定长滑动窗口"><a href="#1-1-1-定长滑动窗口" class="headerlink" title="1.1.1 定长滑动窗口"></a>1.1.1 定长滑动窗口</h4><ul><li><p>总结成三步：入-更新-出。</p><p>入：下标为 i 的元素进入窗口，更新相关统计量。如果 i&lt;k−1 则重复第一步。<br>更新：更新答案。一般是更新最大值&#x2F;最小值。<br>出：下标为 i−k+1 的元素离开窗口，更新相关统计量。</p></li></ul><span id="more"></span><ul><li>题目列表：<a href="https://leetcode.cn/circle/discuss/0viNMK/">https://leetcode.cn/circle/discuss/0viNMK/</a></li></ul><h4 id="1-1-2-不定长滑动窗口"><a href="#1-1-2-不定长滑动窗口" class="headerlink" title="1.1.2 不定长滑动窗口"></a>1.1.2 不定长滑动窗口</h4><ul><li>与定长区别在于当窗口右侧新进入的元素破坏限制条件时，需要用一个while循环移动左指针，直到限制条件重新被满足</li><li>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。</li></ul><h4 id="1-1-3-求子数组个数"><a href="#1-1-3-求子数组个数" class="headerlink" title="1.1.3 求子数组个数"></a>1.1.3 求子数组个数</h4><ul><li>这种题型下一般都要求子数组是连续的</li><li>越长越合法<ul><li>一般要写 ans +&#x3D; left。</li><li>滑动窗口的内层循环结束时，右端点固定在 right，左端点在0,1,2,…,left−1 的所有子数组（子串）都是合法的，这一共有 left 个。</li></ul></li><li>越短越合法<ul><li>一般要写 ans +&#x3D; right - left + 1。</li><li>滑动窗口的内层循环结束时，右端点固定在 right，左端点在 left,left+1,…,right 的所有子数组（子串）都是合法的，这一共有 right−left+1 个。</li></ul></li><li>恰好型滑动窗口<ul><li>例如，要计算有多少个元素和恰好等于k 的子数组，可以把问题变成：<ul><li>计算有多少个元素和 ≥k 的子数组。</li><li>计算有多少个元素和 &gt;k，也就是 ≥k+1的子数组。</li></ul></li><li>答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 &gt; 转换成 ≥，从而可以把滑窗逻辑封装成一个函数f，然后用f(k) - f(k + 1)计算，无需写两份滑动窗口代码</li><li>注：也可以把问题变成 ≤k 减去 ≤k−1（两个至多）。可根据题目选择合适的变形方式。</li></ul></li></ul><h3 id="1-2-双指针"><a href="#1-2-双指针" class="headerlink" title="1.2 双指针"></a>1.2 双指针</h3><h4 id="1-2-1-单序列双指针"><a href="#1-2-1-单序列双指针" class="headerlink" title="1.2.1 单序列双指针"></a>1.2.1 单序列双指针</h4><ul><li>相向双指针<ul><li>两个指针 left&#x3D;0, right&#x3D;n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。</li><li>遇到多于两个变量的题（如三数之和、四数之和、有效三角形的个数），对双指针以外的变量用for进行遍历，然后对剩下的部分数组（可以是左侧也可是右侧，具体看情况）进行双指针遍历</li></ul></li><li>同向双指针<ul><li>两个指针的移动方向相同（都向右，或者都向左）</li><li>类似于滑动窗口，通常做法是用for循环枚举一端的端点，然后通过内层while移动另一端端点</li></ul></li><li>背向双指针<ul><li>两个指针从数组中的同一个位置出发，一个向左，另一个向右，背向移动</li></ul></li><li>原地修改<ul><li>一般要对数组元素进行位置交换，通过同向双指针进行遍历（枚举其中一个，元素满足某个条件时移动另一个并进行处理）</li></ul></li></ul><h4 id="1-2-2-双序列双指针"><a href="#1-2-2-双序列双指针" class="headerlink" title="1.2.2 双序列双指针"></a>1.2.2 双序列双指针</h4><ul><li>双指针<ul><li>一般会给两个数组，用两个指针分别同时遍历两个数组</li><li>可能是正序遍历，可能是倒序遍历</li></ul></li><li>判断子序列<ul><li>一般会给两个字符串，判断其中一个是不是另一个的子序列</li><li>对子序列的每一个字母，通过遍历另一个字符串（长的那个）找到该字母后再找下一个字母，一直到其中一个字符串遍历完（子序列先遍历完结果为true，反之为false）</li></ul></li></ul><h4 id="1-2-3-三指针"><a href="#1-2-3-三指针" class="headerlink" title="1.2.3 三指针"></a>1.2.3 三指针</h4><ul><li>一般是遍历其中一个变量，然后对剩下的子问题用（单序列）双指针进行求解</li><li>核心思路是先确定区间的其中一个端点，例如右端点，然后在右端点的左边求合法的左端点。由于左端点的合法取值是一个区间，因此又可以用双指针解决，因此称为三指针</li></ul><h3 id="1-3-分组循环"><a href="#1-3-分组循环" class="headerlink" title="1.3 分组循环"></a>1.3 分组循环</h3><ul><li>适用于按照题目要求，数组会被分割成若干组，且每一组的判断&#x2F;处理逻辑是一样的。</li><li>外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。</li><li>内层循环负责遍历组，找出这一组最远在哪结束。</li><li>一般来说，分组循环的模板如下（可根据题目调整）：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">len</span>(nums)<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; n:<br>    start = i<br>    <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> ...:<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 从 start 到 i-1 是一组</span><br>    <span class="hljs-comment"># 下一组从 i 开始，无需 i += 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动互联网软件工程</title>
    <link href="/2025/01/11/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2025/01/11/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="移动互联网软件工程"><a href="#移动互联网软件工程" class="headerlink" title="移动互联网软件工程"></a>移动互联网软件工程</h1><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><ul><li><p>HMS（HUAWEI Mobile Services，华为移动服务）则是华为公司推出的⼀系列服务的合集</p></li><li><p>HarmonyOS的<strong>核心技术理念</strong>：一次开发，多端部署；可分可合，自由流转；统一生态，原生智能</p></li><li><p>Harmony OS应用支持：1. 需要下载安装的应用，2. 轻量级，具备免安装，即用即走，服务直达，自由流转等关键特征的<strong>元服务</strong>（不支持快应用和Web网站）</p></li><li><p>如果开发者在原生应用版本的基础上，想要提供多种服务给用户，最优选是开发多个元服务，按需组合为一个复杂的应用</p></li><li><p>当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力：<strong>自由流转</strong></p></li></ul><span id="more"></span><ul><li><p>多设备按需分发</p><ul><li><img src="image-20241213125422767.png" alt="image-20241213125422767" style="zoom:67%;" /></li></ul></li><li><p>两种打包上架模式：</p><ul><li>开发态代码共享，应用和服务生命周期完全独立</li><li>开发态代码共享，应用和服务生命周期完全共享</li></ul></li><li><p>系统架构</p><ul><li>HarmonyOS采用分层结构，⼤致可以分为内核层、系统服务层、框架层和应用层</li><li>内核层<ul><li>内核层是整个操作系统的核心，提供操作系统最基础的服务，主要分为内核子系统和驱动子系统</li><li>与Android不同的是，HarmonyOS除了可以支持Linux内核之外，还可以支持多种不同的操作系统，为支持多种不同的设备提供了便利并提高了效率</li><li>对于设备驱动的问题，HarmonyOS则是利用驱动子系统中的硬件驱动框架（HDF，Hardware Driver Framework）提供了统⼀的外设访问能力和驱动开发管理框架</li></ul></li><li>系统服务层：HarmonyOS的核心能力集合，通过框架层对应用程序提供服务<ul><li>系统基础能力子系统：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力。</li><li>基础软件服务子系统：主要是⼀些设备之间公共的、通用的软件服务。</li><li>增强软件服务子系统：提供针对不同设备的、差异化的能力增强型软件服务。</li><li>硬件服务子系统：提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。</li></ul></li><li>框架层：提供了⽤户语⾔框架、Ability框架和UI框架<ul><li>⽤户语⾔框架支持了Java&#x2F;C&#x2F;C++&#x2F;JS等多种编程语⾔</li><li>Ability框架则是对系统服务能力的⼀种抽象的框架</li><li>Harmony的UI框架提供了适⽤于JS语⾔的JS UI框架</li></ul></li><li>应用层：包括系统应用和扩展应用&#x2F;第三方非系统应用</li></ul></li><li><p><strong>一次开发，多端部署</strong></p><ul><li>为了实现这一目的，HarmonyOS需要提供的能力：多端开发环境；多端开发能力；多端分发机制</li><li><img src="image-20241213134025588.png" alt="image-20241213134025588"></li></ul></li><li><p><strong>APP结构</strong> 重要</p><ul><li>在开发态，⼀个应⽤包含⼀个或者多个Module，可以在DevEco Studio⼯程中创建⼀个或者多个Module</li><li>Module是HarmonyOS应用&#x2F;服务的基本功能单元，包含了源代码、资源文件、第三⽅库及应⽤&#x2F;服务配置⽂件，每⼀个Module都可以独⽴进行编译和运行</li><li>Module分为“Ability”和“Library”两种类型，“Ability”类型的Module对应于编译后的HAP（Harmony Ability Package）；“Library”类型的Module对应于HAR（Harmony Archive），或者HSP（Harmony Shared Package）</li><li>HAP：</li></ul><p><img src="image-20241213141643550.png" alt="image-20241213141643550"></p><ul><li><img src="image-20241213141803296.png" alt="image-20241213141803296"></li></ul></li><li><p><strong>stage模型</strong> 重要</p><ul><li><img src="image-20241213142005320.png" alt="image-20241213142005320" style="zoom:67%;" /></li><li>在基于Stage模型开发的应用项目代码下，都存在⼀个app.json5及⼀个或多个module.json5这两种配置文件<ul><li><strong>app.json5</strong>：主要包含应用的全局配置信息，包含应用的包名、开发厂商、版本号等基本信息。特定设备类型的配置信息。</li><li><strong>module.json5</strong>主要包含：<ul><li>Module的基本配置信息，例如Module名称、类型、描述、<strong>支持的设备类型</strong>等基本信息。</li><li>应用组件信息，包含UIAbility组件和ExtensionAbility组件的描述信息。</li><li>应⽤运行过程中所需的<strong>权限信息</strong>。</li></ul></li></ul></li><li>Stage模型原生支持<strong>组应用组件级的跨端迁移和多端协同</strong>，体现在：<strong>Albility与Ul分离</strong>、<strong>UI展示与服务能力合一的Ability组件</strong></li><li>Stage模型支持<strong>多设备形态和多窗口形态</strong>，体现在以下方面：<strong>Ability生命周期定义</strong>、<strong>组件管理和窗口管理解耦</strong></li><li>Stage模型的优势<ul><li><img src="image-20241213144616019.png" alt="image-20241213144616019" style="zoom:67%;" /></li></ul></li></ul></li><li><p><strong>UIAbility生命周期</strong> 重要</p><ul><li><img src="image-20241213142356683.png" alt="image-20241213142356683" style="zoom:67%;" /></li><li><img src="image-20241213142424937.png" alt="image-20241213142424937" style="zoom: 80%;" /></li></ul></li><li><p><strong>UIAbility启动模式</strong> 重要</p><ul><li>singleton（单实例模式）：默认启动模式</li><li>standard（标准实例模式）：每次启动UIAbility组件，都会创建一个新的该类型实例</li><li>specified（指定实例模式）：支持拉起指定标识的实例</li></ul></li><li><p><strong>Want</strong> 重要</p><ul><li><img src="image-20241213143206215.png" alt="image-20241213143206215"></li><li>Want类型<ul><li>显式Want：在启动Ability时指定了abilityName和bundleName的Want称为显式Want。当有明确处理请求的对象时，通过提供目标Ability所在应用的bundleName，并在Want内指定abilityName便可启动目标Ability。显式Want通常用于在当前应用开发中启动某个已知的Ability。</li><li>隐式Want：在启动UIAbility时未指定abilityName的Want称为隐式Want。用于希望调用其他应用的某个服务又不关心是哪个应用提供的该服务，系统将匹配声明支持该请求的所有应用</li></ul></li><li>隐式Want的action和entities<ul><li><img src="image-20241213143956947.png" alt="image-20241213143956947"></li></ul></li></ul></li><li><p>HiLog日志</p><ul><li>HiLog⽇志系统可以让应⽤按照指定类型、指定级别、指定格式字符串打印⽇志内容，帮助开发者了解应用&#x2F;服务的运行状态，更好地调试程序。</li><li>HiLog提供了debug、info、warn、error以及fatal接口，在购物应用中，我们使用hilog打印EntryAbility 、DetailsAbility的⽣命周期。</li></ul></li><li><p>多HAP机制</p><ul><li><p>设计目标</p><ul><li>方便开发者模块化的管理应⽤</li><li>方便开发者将多HAP合理地组合并部署到不同的设备上</li><li>方便开发者按需加载所需模块，减少包大小</li><li>方便应用资源共享，减少程序包大小</li></ul></li><li><p>所有的HAP最终会编译到一个App Pack中</p></li><li><p>多HAP场景下，同一应用的所有HAP的签名证书必须<strong>保持一致</strong></p></li><li><p>开发者可以将⼀个应用的某些HAP配置成按需加载。应用在启动阶段初始用不到的特性，可以配置暂不加载，当用户用到这些特性时，可由应用自动下载这些特性HAP</p></li><li><p>当多HAP如果运行在同一进程，多HAP间组件的通信方式与同一HAP内组件的通信方式<strong>相同</strong></p></li></ul></li><li><p><strong>HAR与HSP</strong> 重要</p><ul><li>OpenHarmony提供了两种共享包，HAR静态共享包和HSP动态共享包，实现代码和资源的共享，包含代码、C++库、资源和配置文件</li><li>HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝</li><li>HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份</li><li>HAR属于编译态复用，HSP属于运行态复用</li></ul></li></ul><h2 id="2-ArkTS"><a href="#2-ArkTS" class="headerlink" title="2. ArkTS"></a>2. ArkTS</h2><ul><li><strong>不考代码，这部分略过</strong></li></ul><h2 id="3-Ark-Compiler-和-Ark-Runtime"><a href="#3-Ark-Compiler-和-Ark-Runtime" class="headerlink" title="3. Ark Compiler 和 Ark Runtime"></a>3. Ark Compiler 和 Ark Runtime</h2><ul><li><strong>类型推导</strong> 重要<ul><li><img src="image-20250103150414765.png" alt="image-20250103150414765" style="zoom:67%;" /></li></ul></li><li><strong>方舟编译运行时</strong> 重要<ul><li><img src="image-20241213175616452.png" alt="image-20241213175616452"></li></ul></li><li>方舟字节码<ul><li>ArkCompiler寄存器要求能够放置对象引用和基本类型，宽度采⽤64位。</li><li>累加寄存器acc，俗称累加器，是⼀个特殊的寄存器，被指令隐含使用。上⼀条指令利用累加器作为结果输出，下⼀条指令将此累加器作为输入，可以有效改善指令密度，减小字节码的尺寸</li><li>ArkCompiler字节码提供对32位（i32）和64位（i64）整型数值的寄存器操作⽀持，8位和16位数值通过扩展到32位来模拟。支持对IEEE-754双精度浮点f64值的寄存器的操作，f32数据类型（IEEE-754单精度）也通过转换为f64值进行模拟。</li><li>ArkCompiler通过特殊的标记值（“Any”）表示动态类型值</li><li>源文件中所有使⽤到的模块命名空间（module namespace）都会被编译进⼀个数组中</li><li>ArkCompiler会把ArkTS&#x2F;TS&#x2F;JS编译为方舟字节码，<strong>运行时直接运行方舟字节码</strong></li><li>方舟字节码中，除<strong>寄存器</strong>和<strong>累加器</strong>之外，还存在4种值存储方式：<strong>全局变量</strong>、<strong>模块命名空间和模块变量</strong>、<strong>词法环境和词法变量</strong>、<strong>补丁变量</strong>。指令可以使用这4种储值位置中的值作为入参</li></ul></li><li><strong>Ark Runtime执行引擎</strong> 重要，看JIT和AOT区别<ul><li>解释器：可直接运行前端编译器输出的字节码</li><li>JIT Compiler（Just-In-Time）：JIT编译器⼀般需要运行时执行代码⼀段时间，Profiler⽣成了profiling数据之后，根据profiling数据即时编译生成高质量的机器码来运行。</li><li>AOT Compiler（Ahead of Time）：AOT编译器则是在运行前根据静态信息直接编译生成高质量的目标机器码在设备上运行，PGO配置文件可以作为AOT Compiler的输入之⼀，给AOT Compiler⼀些指示，比如编译的范围以及编译某个方法时使用哪些优化技术。</li><li><img src="image-20241213180055095.png" alt="image-20241213180055095"></li><li><img src="image-20241213180117663.png" alt="image-20241213180117663" style="zoom:67%;" /></li><li><img src="image-20241213180623319.png" alt="image-20241213180623319"></li></ul></li></ul><h2 id="4-Ark-UI"><a href="#4-Ark-UI" class="headerlink" title="4. Ark UI"></a>4. Ark UI</h2><ul><li><p>基本概念</p><ul><li><strong>装饰器</strong>：用来装饰类、结构体、方法以及变量，赋予其特殊的含义，如上述示例中 @Entry 、 @Component 、 @State 都是装饰器。<ul><li>@Component：装饰struct，结构体在装饰后具有基于组件的能力，需要实现build⽅法来创建UI。</li><li>@Entry： 装饰struct，组件被装饰后作为页面的入口，页面加载时将被渲染显示。</li><li>@Preview：装饰struct， 用@Preview装饰的⾃定义组件可以在DevEco Studio的预览器上进行<strong>实时预览</strong>，加载页面时，将创建并显示@Preview装饰的自定义组件。</li><li><img src="image-20241213185146944.png" alt="image-20241213185146944"></li></ul></li><li>自定义组件：可复用的 UI 单元，可组合其它组件，如上述被 @Component 装饰的 struct Hello。<ul><li>struct：自定义组件可以基于struct实现，不能有继承关系，对于struct的实例化，可以省略new。</li></ul></li><li>UI描述：声明式的方法来描述UI的结构，例如build()方法中的代码块。</li><li>内置组件：ArkTS中默认内置的基本组件和布局组件，开发者可以直接调用，如Column、Text、Divider、Button等。</li><li>属性方法：用于组件属性的配置，统⼀通过属性方法进行设置，如fontSize()、width()、height()、color() 等，可通过链式调用的方式设置多项属性。</li><li>事件方法：用于添加组件对事件的响应逻辑，统⼀通过事件方法进行设置，如跟随在Button后面的onClick()。</li><li><img src="image-20241213181310815.png" alt="image-20241213181310815" style="zoom:70%;" /></li><li><img src="image-20241213181750268.png" alt="image-20241213181750268" style="zoom:67%;" /></li></ul></li><li><p><strong>组件生命周期</strong> 重要</p><ul><li>@Entry装饰的组件才有页面生命周期<ul><li>页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：</li><li>onPageShow：页面每次显示时触发。<ul><li>onPageHide：页面每次隐藏时触发⼀次。</li></ul></li><li>onBackPress：当用户点击返回按钮时触发。</li><li>组件生命周期，即⼀般用@Component装饰的⾃定义组件的生命周期，提供以下生命周期接口：</li><li>aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。<ul><li>aboutToDisappear：在自定义组件即将析构销毁时执行。</li></ul></li><li><img src="image-20241213181849865.png" alt="image-20241213181849865"></li></ul></li></ul></li><li><p><strong>布局结构</strong> 重要</p><ul><li><img src="image-20250103150959721.png" alt="image-20250103150959721" style="zoom:80%;" /></li><li><p>布局元素的组成</p><ul><li><img src="image-20250103151109492.png" alt="image-20250103151109492" style="zoom:80%;" /></li><li><p>组件区域（蓝区⽅块）：组件区域表明组件的大小，width、height属性设置该区域的大小。</p></li><li><p>组件内容区（黄色方块）：组件区域大小减去组件的padding值，组件内容区大小会作为组件内容（或者子组件）进行大小测算时的布局测算限制。</p></li><li><p>组件内容（绿色方块）：组件内容本身占用的大小，比如文本内容占用的大小。组件内容和组件内容区不⼀定匹配，比如设置了固定的width和height，此时组件内容区大小就是设置的width和height减去padding值，但⽂本内容则是通过文本布局引擎测算后得到的大小，可能出现文本真实大小小于设置的组件内容区大小。当组件内容和组件内容区大小不⼀致时，align属性⽣效，定义组件内容在组件内容区的对齐方式，如居中对齐。</p></li><li><p>组件布局边界（虚线部分）：组件通过margin属性设置外边距时，组件布局边界就是组件区域加上margin的大小。</p></li></ul></li></ul></li><li><p><strong>router</strong></p><ul><li>调用router.pushUrl接口，目标页不会替换当前页，而是压入页面栈，保留当前页的状态。此时当前Index页面隐藏，执行页面生命周期Index onPageHide。</li><li>如果调用的是router.replaceUrl，目标页会替换当前页，当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear</li><li>两种实例模式<ul><li>Standard：标准实例模式，也是<strong>默认实例模式</strong>。每次调用都会新建一个目标页并压入栈顶</li><li>Single：单实例模式，如果目标页的url在栈中已经存在，则离栈顶最近的同url页面会被移动到栈顶，并重新加载；如果目标页的url在栈中不存在，则按照标准模式跳转</li></ul></li></ul></li><li><p><strong>For Each</strong></p><ul><li>在ForEach循环渲染过程中，系统会为每个数组元素生成⼀个唯⼀且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建⼀个新的组件</li><li>ForEach必须在容器组件内使用。</li><li>⽣成的子组件应当是允许包含在ForEach父容器组件中的子组件。</li><li>允许子组件生成器函数中包含if&#x2F;else条件渲染，同时也允许ForEach包含在if&#x2F;else条件渲染语句中。</li><li>itemGenerator为数组中的每个元素创建对应的组件，为必选参数；keyGenerator为数据源arr的每个数组项生成唯一且持久的键值，<strong>不是</strong>必选参数</li></ul></li><li><p><strong>Navigation</strong></p><ul><li>⼀般作为页面的根容器，包括<strong>单页面</strong>、<strong>分栏</strong>和<strong>自适应</strong>三种显示模式</li><li><strong>默认显示模式</strong>是自适应模式，自适应模式下，若设备的宽度大于520vp，Navigation组件采用分栏模式，反之采用单页面模式</li></ul></li><li><p><strong>ArkUI框架</strong> 重要</p><ul><li><img src="image-20241213191742663.png" alt="image-20241213191742663" style="zoom: 50%;" /></li><li><p>对于声明式开发范式组件，根据组件从前端到后端的过程，可以将整个框架划分为EtsLoader，JsView, ComPonent,RenderNode四个模块。</p><ul><li>EtsLoader：负责解析ets页面，根据组件的tag标签创建对应的JsView对象，⽣成jsView树。</li><li>JsView：负责处理组件的属性，⽅法和事件。并通过Create函数创建对应的Component树。</li><li>ComPonent：负责将Component树中所有继承自RenderComponent的节点（可绘制节点）创建对应的RenderNode节点，生成对应的RenderNode树</li><li>RenderNode：RenderNode即可绘制的节点，负责组件的最终布局和绘制。</li></ul></li><li><p><strong>Component树、Element树、Render树</strong></p><ul><li><p><strong>Component树</strong>：</p><ul><li><strong>定义</strong>：Component树描述的是应用中所有组件的层级结构。它是由应用中的每一个组件组成的树状结构，每个组件可以包含子组件。</li><li><strong>特点</strong>：它代表了组件的嵌套关系，不包含DOM节点，仅仅是逻辑上的结构，表示组件如何组合和排列。</li><li><strong>作用</strong>：帮助理解组件之间的关系、组件的嵌套结构，以及如何通过父组件和子组件的关系来组织应用。</li></ul><p><strong>Element树</strong>：</p><ul><li><strong>定义</strong>：Element树是从组件的 JSX（React）或模板（Vue）中生成的，包含了组件实例化后的原始元素对象。它是虚拟DOM中的表示，描述了界面中所有的“元素”。</li><li><strong>特点</strong>：Element树是虚拟DOM的一部分，包含每个组件的渲染结果。它的结构和组件树类似，但它是更接近渲染的“表现形式”，也就是说，它包含了实际将会渲染到页面上的元素结构。</li><li><strong>作用</strong>：Element树用于虚拟DOM的比较和更新，帮助决定哪些元素需要更新、添加或删除。</li></ul><p><strong>Render树</strong>：</p><ul><li><strong>定义</strong>：Render树是经过样式计算之后的DOM树的一个表示，包含了所有将要渲染的DOM元素及其样式（包括CSS属性）。</li><li><strong>特点</strong>：它是浏览器内部渲染流程中的一部分，只有经过计算得到的实际渲染样式后，才会被用于渲染最终的页面。它是根据Element树的内容生成的，结合了CSS样式，描述了页面将如何渲染出来。</li><li><strong>作用</strong>：Render树的创建与更新决定了页面的最终视觉展示。浏览器通过它来绘制界面。</li></ul></li></ul></li><li><p>类Web开发范式组件：对于类Web开发范式组件，根据组件从前端到后端的过程，可以将整个框架划分为JsFrameWork，DomNode, ComPonent, RenderNode四个模块。</p><ul><li>JsFrameWork：负责解析前端html和css文件，创建出DomNode树。该树的结构和前端页面是⼀⼀对应的。</li><li>DomNode：负责将Dom树转换为Component树。</li></ul></li><li><p>在开发一款新应用时，推荐采用<strong>声明式开发范式</strong>来构建UI</p></li><li><img src="image-20241213192252463.png" alt="image-20241213192252463" style="zoom:67%;" /></li><li><p>同布局⼀样，绘制也是⼀个深度遍历的过程，遍历调用每个 RenderNode 的 Paint 方法，此时的绘制只是根据布局算出来的大小和位置，在当前绘制的上下文记录每个节点的绘制命令。为了提高性能，这里引入了图层（Layer）的概念。通常绘制会将渲染内容分为多个层进行加速。</p></li><li><p>光栅化合成机制</p><ul><li>UI 线程（UI Thread）在渲染管线中的输出是 LayerTree，它相当于⼀个⽣产者，将⽣产的 LayerTree 添加到渲染队列中。GPU 线程（GPU Thread）的合成器（Compositor）相当于消费者，每个新的渲染周期中，合成器会从渲染队列中获取⼀个 LayerTree 进⾏合成消费。</li><li>对于需要缓存的 Layer,还要执⾏光栅化⽣成 GPU 纹理，所谓光栅化就是将 Layer ⾥⾯记录的命令进⾏回放，⽣成每个实体的像素的过程。像素是存储在纹理的图形内存中。</li><li>合成器会从系统的窗⼝中获取当前的 Surface，将每个 Layer ⽣成的纹理进⾏合成，最终合成到当前 Surface 的图形内存（Graphic Buffer）中。这块内存中存储的就是当前帧的渲染结果内容。最终还需要将渲染结果提交到系统合成器中合成显示。</li></ul></li></ul></li><li><p>大前端框架</p><ul><li><img src="image-20250103151909938.png" alt="image-20250103151909938" style="zoom: 67%;" /></li><li></li></ul></li></ul><h2 id="5-移动互联网应用需求分析"><a href="#5-移动互联网应用需求分析" class="headerlink" title="5. 移动互联网应用需求分析"></a>5. 移动互联网应用需求分析</h2><ul><li><strong>需求分析的层次性</strong> 重要<ul><li>传统信息系统软件需求的分层：业务需求、用户需求、系统需求</li><li>移动互联网领域考虑三个层次<ul><li>战略：起步、发展、成熟、扩展、新业务</li><li>产品：⼀致性的体验、符合战略思路、落实技术功能</li><li>功能</li></ul></li></ul></li><li><strong>涉众分析</strong> 重要<ul><li><img src="image-20241213193655648.png" alt="image-20241213193655648"></li><li>移动互联网应用用户的特点：用户都是大规模，不确定的，易变，更短抉择，随性，常规涉众分析方法不是很有效</li></ul></li><li><strong>需求获取</strong> 重要<ul><li>需求获取的传统方法：面谈、问卷、观察、文档分析、调研、原型、民族志</li><li>移动互联网需求获取<ul><li>“上线”原型法：运营数据分析、数据统计、数据挖掘、用户模拟</li><li>竞品分析：抄袭法</li></ul></li></ul></li><li><strong>移动互联网需求组织方法</strong> 重要：User Story &amp; 技术故事、Behavior Specification</li></ul><h2 id="6-Ability-Kit-Network-Kit-ArkData-ArkWeb"><a href="#6-Ability-Kit-Network-Kit-ArkData-ArkWeb" class="headerlink" title="6. Ability Kit, Network Kit, ArkData, ArkWeb"></a>6. Ability Kit, Network Kit, ArkData, ArkWeb</h2><ul><li>Ability Kit<ul><li>Ability Kit（程序框架服务）提供了应用程序开发和运行的应用模型，是系统为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。</li><li><img src="image-20241214092718741.png" alt="image-20241214092718741"></li><li>UIAbility是系统调度的最小单元。UIAbility的启动分为两种情况：UIAbility<strong>冷启动</strong>和UIAbility<strong>热启动</strong> 重要<ul><li>UIAbility冷启动：指的是UIAbility实例处于完全关闭状态下被启动，这需要完整地加载和初始化UIAbility实例的代码、资源等。</li><li>UIAbility热启动：指的是UIAbility实例已经启动并在前台运行过，由于某些原因切换到后台，再次启动该UIAbility实例，这种情况下可以快速恢复UIAbility实例的状态，只会触发该UIAbility的<strong>onNewWant()</strong> 回调</li></ul></li></ul></li><li>Network Kit<ul><li><img src="image-20241214093451623.png" alt="image-20241214093451623" style="zoom:80%;" /></li><li>使用网络管理模块的相关功能时，需要请求相应的权限：ohos.permission.GET_NETWORK_INFO(允许获取网络连接信息)和ohos.permission.INTERNET(允许程序打开网络套接字进行网络连接)</li><li>request接口开发步骤<ul><li><img src="image-20241214093637938.png" alt="image-20241214093637938" style="zoom:67%;" /></li></ul></li><li><img src="image-20241214093804193.png" alt="image-20241214093804193"  /></li><li>ResponseCode.GONE的值为<strong>410</strong>，表示客户端请求的资源已经不存在</li><li>ResponseCode.NOT_FOUND的值为404，表示服务器无法根据客户端的请求找到资源（网页）</li><li>A : HEAD请求的响应格式与GET请求相同，只是响应主体为空，所以可以用于获取资源的元数据、检查资源是否存在。 B : DELETE请求可以请求服务器删除指定的资源。 C : GET请求可以向服务器获取资源，GET请求<strong>可以携带</strong>参数。 D : POST请求向指定资源提交数据进行处理请求</li><li>A : http请求支持get、post、put等常用的请求方式。 B : 可以使用on(‘headersReceive’)订阅请求响应头。 C : post请求的参数可以在extraData中指定。 D : 执行createHttp成功后，返回一个httpRequest对象，里面包括request、destroy、on和off方法。</li><li>http请求request接口中请求可选参数：A : method B : extraData C : expectDataType D : readTimeout</li></ul></li><li>Ark Data<ul><li>持久化<ul><li><strong>用户首选项（Preferences）</strong> 重要：提供了轻量级配置数据的持久化能力，并支持订阅数据变化的通知能力。<strong>不支持分布式同步</strong>，<strong>不遵循ACID特性</strong>，常用于保存应用配置信息、用户偏好设置等。<ul><li>开发者可以将用户首选项持久化文件的内容加载到Preferences实例，然后使用<strong>flush()方法</strong>写入<strong>持久化文件</strong>中实现数据持久化。<strong>每个文件唯—对应到—个Preferences实例</strong></li><li><strong>使用用户首选项持久化数据的正确流程</strong>：getPreferencesSync()获取用户首选项实例，putSync()方法保存数据到缓存的Preferences实例，flush()持久化数据</li><li>用户首选项Key不可以重复，通过has()方法判断首选项中是否包含指定的key，保证指定的key不会被重复保存</li></ul></li><li>键值型数据管理（KV-Store）：提供了键值型数据库的读写、加密、手动备份以及订阅通知能力。键值型数据库事件回调方法中<strong>不允许进行阻塞操作</strong></li><li>关系型数据管理（RelationalStore）：提供了关系型数据库的增删改查、加密、手动备份以及订阅通知能力。</li></ul></li><li>分布式交互<ul><li>分布式数据对象（DataObject）：独立提供对象型结构数据的分布式能力</li><li>跨应用数据管理（DataShare）：提供了数据提供者provider、数据消费者consumer以及同设备跨应用数据交互的增、删、改、查以及订阅通知等能力。</li><li>统⼀数据管理框架（UDMF）：提供了数据跨应用、跨设备交互标准</li></ul></li><li>数据管理服务（DatamgrService）：提供其它部件的同步及跨应用共享能力</li><li>关系型数据库相关<ul><li>关系型数据库导入的模块是@ohos.data.relationalStore</li><li>RdbStore提供管理关系数据库方法的接口，通过getRdbStore获得一个相关的RdbStore，操作关系型数据库</li><li>ResultSet提供用户调用关系型数据库查询接口之后返回的结果集合</li><li>数据库配置StoreConfig中encrypt指定数据库是否加密，<strong>默认不加密</strong></li></ul></li></ul></li><li>Core File Kit<ul><li>文件类型<ul><li>应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。</li><li>用户文件：文件所有者为登录到该终端设备的用户，包括用户私有的图片、视频、音频、文档等。</li><li>系统文件：与应用和用户⽆关的其它文件，包括公共库、设备文件、系统资源文件等。系统文件及其目录对于应用是只读的</li></ul></li><li>文件系统分类<ul><li>本地文件系统：提供本地设备或外置存储设备（如U盘、移动硬盘）的文件访问能力</li><li>分布式文件系统：提供跨设备的文件访问能力。所谓跨设备，指文件不⼀定存储在本地设备或外置存储设备，而是通过计算机网络与其它分布式设备相连</li></ul></li><li>对于每个应用，系统会在内部存储空间映射出⼀个专属的“应用沙箱目录”，它是“应用文件目录”与⼀部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合，代表应用可见的所有目录范围</li><li>应用之间可以通过分享URI（Uniform Resource Identifier）或文件描述符FD（File Descriptor）的方式，进行文件共享</li><li>用户需要分享文件、保存图片、视频等用户文件时，开发者可以通过系统预置的文件选择器FilePicker，实现该能力。通过Picker访问相关文件，将拉起对应的应用，引导用户完成界面操作，接口本身无需申请权限。picker获取的uri只具有临时权限，获取持久化权限需要通过FilePicker设置永久授权方式获取。包含PhotoViewPicker、DocumentViewPicker、AudioViewPicker</li><li>File Access Framework是一套提供给开发者访问和管理用户文件的基础框架，提供了一套统一访问用户文件的方法和接口</li><li>File Access Helper提供给文件管理器和文件选择器访问用户文件的API接口</li><li>File Access ExtensionAbility提供文件访问框架能力，由<strong>UserFileManager</strong>和<strong>ExternalFileManager</strong>组成</li><li>UserFileManager是<strong>内卡</strong>文件管理服务， ExternalFileManager是<strong>外卡</strong>文件管理服务</li></ul></li><li>Ark Web<ul><li><strong>Web组件生命周期</strong> 重要<ul><li><img src="image-20241214095802013.png" alt="image-20241214095802013" style="zoom:67%;" /></li><li>当Controller成功绑定到Web组件时触发该回调onControllerAttached事件</li><li>当Web组件加载url之前触发onLoadIntercept，默认允许加载</li><li>onInterceptRequest事件用于拦截url并返回响应数据</li><li>onPageEnd事件只在主frame触发</li></ul></li><li>Web组件提供的页面加载方式<ul><li>加载网络页面</li><li>加载本地页面</li><li>加载HTML格式的富文本数据</li></ul></li></ul></li></ul><h2 id="7-移动互联网设计架构"><a href="#7-移动互联网设计架构" class="headerlink" title="7. 移动互联网设计架构"></a>7. 移动互联网设计架构</h2><ul><li><p>架构目标：高可用性、高可扩展性、低成本、多快好省</p></li><li><p>架构组成</p><ul><li><img src="image-20241214100327676.png" alt="image-20241214100327676" style="zoom:67%;" /></li><li><p>业务架构设计原则</p><ul><li>业务平台化</li><li>核心业务、非核心业务分离</li><li>隔离不同类型的业务</li><li>区分主流程、辅流程</li></ul></li><li><p>应用架构设计原则：稳定性原则、解耦&#x2F;拆分、抽象化、松耦合、容错设计</p></li><li><p>数据架构设计原则</p><ul><li><img src="image-20241214100819446.png" alt="image-20241214100819446"></li></ul></li><li><p>技术架构设计原则：</p><ul><li>运行时：可监控；应用可回滚，功能可降级；在线扩容；安全保证；可容错；可故障转移</li><li>部署时</li></ul><img src="image-20241214101039068.png" alt="image-20241214101039068" style="zoom:67%;" /></li></ul></li><li><img src="image-20250103152623253.png" alt="image-20250103152623253" style="zoom:80%;" /></li><li><p><strong>MVC、MVP和MVVM</strong> 重要</p><ul><li><p>MVC模式</p><ul><li>模型：存储内容</li><li>视图：显示内容</li><li>控制器：处理用户输入</li></ul></li><li><p>MVP和MVVM：MVC的改良</p><ul><li><img src="image-20241214104324729.png" alt="image-20241214104324729" style="zoom:67%;" /></li><li><img src="image-20241214104504344.png" alt="image-20241214104504344" style="zoom:67%;" /></li></ul></li><li><p>Functional Reactive Programming （FRP）</p></li></ul></li></ul><h2 id="8-进程与线程"><a href="#8-进程与线程" class="headerlink" title="8. 进程与线程"></a>8. 进程与线程</h2><ul><li><strong>高可用</strong><ul><li>负载均衡与反向代理</li><li>隔离</li><li>限流</li><li>降级</li><li>超时与重试机制</li><li>回滚</li><li>压测和预案</li></ul></li><li><strong>高并发</strong> 和高可用一样，看ppt去吧<ul><li>应用级缓存</li><li>HTTP缓存</li><li>连接池</li><li>异步并发</li><li>扩容</li><li>队列</li></ul></li><li><strong>异步并发</strong> 重要<ul><li>Promise和async&#x2F;await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同⼀时间只有⼀段代码执行，适用于单次I&#x2F;O任务的场景开发</li><li>Promise是⼀种用于处理异步操作的对象，有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）</li></ul></li><li><strong>并发模型</strong> TaskPool和Worker重要<ul><li>并发模型是用来实现不同应用场景中并发任务的编程模型，常见的并发模型分为基于内存共享的并发模型和基于消息通信的并发模型。</li><li>Actor并发模型是基于消息通信并发模型的典型代表</li><li>当前ArkTS提供了<strong>TaskPool和Worker</strong>两种并发能力，TaskPool和Worker都基于Actor并发模型实现<ul><li>运行时间超过3分钟（不包含Promise和async&#x2F;await异步调用的耗时，如网络下载、文件读写）的任务需要使用Worker</li><li>需要设置优先级的任务需要使用TaskPool</li></ul></li></ul></li><li>应用间跳转<ul><li>应用跳转是指从⼀个应用跳转至另外⼀个应用，传递相应的数据、执行特定的功能</li><li>应用跳转的两种类型<ul><li>拉起指定应用：拉起方应用明确指定跳转的目标应用，来实现应用跳转。指向性跳转可以分为指定应用链接、指定Ability两种方式。</li><li>拉起指定类型的应用：拉起方应用通过指定应用类型，拉起垂类应用面板</li></ul></li></ul></li><li><strong>进程模型</strong> 重要<ul><li><img src="image-20250103153557025.png" alt="image-20250103153557025" style="zoom: 80%;" /></li><li><img src="image-20250103153607839.png" alt="image-20250103153607839" style="zoom: 67%;" /></li></ul></li><li>Background Tasks Kit<ul><li>设备返回主界面、锁屏、应用切换等操作会使应用退至后台。系统会对退至后台的应用进行管控，包括进程挂起和进程终止。</li><li>后台任务类型<ul><li>短时任务：适用于实时性要求高、耗时不长的任务，例如状态保存。</li><li>长时任务：适用于长时间运行在后台、用户可感知的任务，例如后台播放音乐、导航、设备连接等，使用长时任务避免应用进程被挂起。</li><li>延迟任务：对于实时性要求不高、可延迟执行的任务，系统提供了延迟任务，即满足条件的应用退至后台后被放入执行队列，系统会根据内存、功耗等统⼀调度。</li><li>代理提醒：代理提醒是指应用退后台或进程终止后，系统会代理应用做相应的提醒。适用于定时提醒类业务，当前支持的提醒类型包括倒计时、日历和闹钟三类。</li></ul></li></ul></li><li>IPC机制<ul><li><img src="image-20250103153720825.png" alt="image-20250103153720825"></li></ul></li></ul><h2 id="9-系统工具库"><a href="#9-系统工具库" class="headerlink" title="9.系统工具库"></a>9.系统工具库</h2><ul><li>Ark UI 的窗口<ul><li>窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。<ul><li>对应用开发者而言，窗口模块提供了界面显示和交互能力。</li><li>对终端用户而言，窗口模块提供了控制应用界面的方式。</li><li>对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。</li></ul></li><li>HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。</li><li><strong>创建应用子窗口后，应先设置子窗口属性，然后加载显示子窗口的具体内容，最后在不需要时销毁子窗口</strong></li><li>实现<strong>沉浸式效果</strong>有两种方式，一是调用 setWindowSystemBarEnable 接口，设置导航栏、状态栏不显示；二是调用 setWindowLayoutFullScreen 接口，设置应用主窗口为全屏布局，再调用 setWindowSystemBarProperties 接口设置相关属性</li></ul></li><li>Basics Service Kit的账号管理<ul><li>应用开发者可以使用应用账号SDK管理本应用的账号数据。</li><li>能力限制：应用卸载场景下，<strong>被卸载应用的账号数据</strong>会被删除；本地账号删除场景下，<strong>被删除本地账号下的所有应用的账号数据</strong>会被删除。</li></ul></li><li>Audio Kit（音频服务）<ul><li>Audio Kit（音频服务）亮点特征包括空间音频、低时延播放、音振协同、低功耗播放等</li><li>音频量化的过程：采样 &gt; 量化 &gt; 编码</li><li>音频播放API<ul><li>AudioRenderer：用于音频输出的ArkTS&#x2F;JS API，<strong>仅支持PCM格式</strong>，需要应用<strong>持续写入音频数据</strong>进行工作。应用可以在输入前添加数据预处理，如设定音频文件的采样率、位宽等，要求开发者具备音频处理的基础知识，<strong>适用于更专业、更多样化的媒体播放应用开发</strong>。</li><li>AudioHaptic：用于音振协同播放的ArkTS&#x2F;JS API，<strong>适用于需要在播放音频时同步发起振动的场景</strong>，如来电铃声随振、键盘按键反馈、消息通知反馈等。</li><li>OpenSL ES：一套跨平台标准化的音频Native API，同样提供音频输出能力，<strong>仅支持PCM格式</strong>，<strong>适用于从其他嵌入式平台移植</strong>，或<strong>依赖在Native层实现音频输出功能</strong>的播放应用使用。</li><li>OHAudio：用于音频输出的Native API，此API在设计上实现归一，同时支持普通音频通路和低时延通路。<strong>仅支持PCM格式</strong>，<strong>适用于依赖Native层实现音频输出功能的场景</strong>。</li><li>AVPlayer：用于音频播放的ArkTS&#x2F;JS API，集成了流媒体和本地资源解析、媒体资源解封装、音频解码和音频输出功能。可用于直接播放mp3、m4a等格式的音频文件，<strong>不支持直接播放PCM格式文件</strong></li><li>SoundPool：低时延的短音播放ArkTS&#x2F;JS API，<strong>适用于播放急促简短的音效</strong>，如相机快门音效、按键音效、游戏射击音效等。</li></ul></li><li><img src="image-20241214153345026.png" alt="image-20241214153345026"></li><li>AudioRenderer 开发步骤，首先应配置音频渲染参数并创建 AudioRenderer 实例，然后调用 on (‘writeData’) 方法订阅监听音频数据写入回调，接着调用 start () 方法开始渲染音频，在需要停止时调用 stop () 方法，最后调用 release () 方法销毁实例</li></ul></li><li><strong>Camera Kit</strong> 重要<ul><li>相机工作流程包括相机<strong>输入设备管理、会话管理和相机输出管理</strong></li><li>拍照模块中，设置拍照参数可以调整闪光灯、变焦、焦距、<strong>照片质量</strong>及旋转角度等信息</li><li>如果开发者仅是需要拉起系统相机拍摄一张照片、录制一段视频，可直接使用<strong>CameraPicker</strong>，无需申请相机权限，直接拉起系统相机完成拍摄。应用可以自行选择媒体类型实现拍照和录制功能。<strong>该类接口需要应用在界面 UIAbility 中调用</strong>。从 <strong>API version 12 开始</strong>，该接口支持在元服务中使用。</li><li><img src="image-20241214153457496.png" alt="image-20241214153457496" style="zoom:67%;" /></li></ul></li><li>Image Kit<ul><li>相关概念<ul><li>图片解码：指将所支持格式的存档图片解码成统一的<strong>PixelMap</strong>，以便在应用或系统中进行图片显示或图片处理。</li><li>PixelMap：指图片解码后无压缩的位图，用于图片显示或图片处理。</li><li>图片编码：指将PixelMap编码成不同格式的存档图片，用于后续处理，如保存、传输等。</li><li>图片处理：指对PixelMap进行相关的操作，如旋转、缩放、设置透明度、获取图片信息、读写像素数据等。</li></ul></li><li>开发过程<ul><li>获取图片：通过应用沙箱等方式获取原始图片。</li><li>创建ImageSource实例：ImageSource是图片解码出来的图片源类，用于获取或修改图片相关信息。</li><li>图片解码：通过ImageSource解码生成PixelMap。</li><li>图片处理：对PixelMap进行处理，更改图片属性实现图片的旋转、缩放、裁剪等效果。然后通过Image组件显示图片。</li><li>图片编码：使用图片打包器类ImagePacker，将PixelMap或ImageSource进行压缩编码，生成一张新的图片。</li></ul></li><li><strong>使用 ImageSource 完成图片解码的步骤</strong>：首先获取 resourceManager 资源管理，然后创建 ImageSource，接着创建 pixelMap，最后释放 pixelMap</li></ul></li><li>ArkGraphics 2D<ul><li>ArkGraphics 2D <strong>能力范围</strong>包括图像处理基本能力、管理色域对象能力、指定帧率能力以及图形绘制与显示相关的 Native 能力。</li><li>使用@ohos.graphics.drawing模块的画布画笔绘制基本的2D图形和文字：<ol><li>创建RenderNode子类。创建RenderNode子类MyRenderNode，并在其中定义绘图函数。RenderNode中包含树结构的操作，以及对绘制属性的操作，其中draw方法会在RenderNode进行绘制时被调用</li><li>构建Path形状。使用path的moveTo，lineTo和close接口构建</li><li>设置画笔和画刷样式。使用Pen接口创建一个画笔实例pen，并设置抗锯齿、颜色、线宽等属性，画笔用于形状边框线的绘制。使用Brush接口创建一个画刷实例brush，并设置填充颜色，画刷用于形状内部的填充。使用canvas中的attachPen和attachBrush接口将画笔画刷的实例<strong>设置到画布实例中</strong></li><li>绘制Path形状。使用canvas中的drawPath接口绘制到画布上</li><li>创建MyRenderNode对象。以上1到4步构建出了MyRenderNode类并在其中定义了绘图的主要函数，接下来创建一个MyRenderNode对象，并设置它的像素格式。</li><li>绘制矩形&#x2F;文字。使用canvas中的drawRect接口绘制矩形，drawTextBlob接口绘制文字</li><li>创建NodeController子类。创建NodeController的子类MyNodeController，并在其中定义创建FrameNode的函数。NodeController定义了节点容器的控制器，控制着容器里在生命周期中的节点。FrameNode定义了节点的基本类型，并包含一个RenderNode。</li><li>创建添加节点的接口。在第7步中创建的MyNodeController类中创建添加RenderNode的接口。</li><li>创建删除节点的接口。在第7步中创建的MyNodeController类中创建删除RenderNode的接口。</li><li>绘制图形和文字。创建MyNodeController实例并将其存入NodeContainer，添加button控件供用户点击，并调用已定义的接口。</li></ol></li></ul></li><li><strong>Sensor Service Kit</strong> 重要<ul><li>Sensor Service Kit（传感器服务）使应用程序能够<strong>从传感器获取原始数据</strong>，并<strong>提供振感控制能力</strong>。包括Sensor（传感器）模块和Vibrator（振动）模块</li><li>传感器运作机制<ul><li><img src="image-20250103154416472.png" alt="image-20250103154416472" style="zoom:67%;" /></li></ul></li></ul></li><li><strong>Form Kit</strong> 重要<ul><li>Form Kit（卡片开发服务）提供一种界面展示形式，可以<strong>将应用的重要信息或操作前置到服务卡片</strong>，以达到<strong>服务直达</strong>、<strong>减少跳转层级</strong>的体验效果。卡片常用于嵌入到其他应用（只支持系统应用，例如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互能力。<strong>支持在卡片中运行逻辑代码</strong>（ArkTS 卡片）</li><li><img src="image-20241214155624545.png" alt="image-20241214155624545"></li><li><strong>卡片使用步骤</strong>：长按 “桌面图标”，弹出操作菜单，点击 “服务卡片” 选项，进入卡片预览界面，再点击 “添加到桌面” 按钮</li></ul></li></ul><h2 id="10-敏捷软件开发"><a href="#10-敏捷软件开发" class="headerlink" title="10. 敏捷软件开发"></a>10. 敏捷软件开发</h2><ul><li>Scrum<ul><li>3个角色<ul><li>产品负责人、Scrum Master、开发团队</li></ul></li><li>三个工件<ul><li>产品Backlog、SprintBacklog、产品增量</li></ul></li><li><h2 id="5个事件"><a href="#5个事件" class="headerlink" title="5个事件  - "></a>5个事件<br>  - <img src="image-20250103155115230.png" alt="image-20250103155115230" style="zoom: 50%;" /></h2></li></ul></li><li>WIP（working in progress）<ul><li>WIP太高，工作闲置</li><li>WIP太低，人员闲置</li></ul></li></ul><h2 id="11-从微服务到云原生"><a href="#11-从微服务到云原生" class="headerlink" title="11. 从微服务到云原生"></a>11. 从微服务到云原生</h2><ul><li>微服务架构的特征<ul><li>通过服务组件化</li><li>围绕业务能力组织：只把业务逻辑强制放在它们会访问的应用程序中</li><li>是产品不是项目：负责产品的整个生命周期，持续关注软件如何帮助用户提升业务能力</li><li>智能端点和哑管道：最常用的两种协议是使用资源API的HTTP请求-响应；在轻量级消息总线上传递消息</li><li>去中心化治理、去中心化数据管理</li><li>基础构建管道</li><li>为失效设计：应用程序需要被设计成能够容忍服务失效</li></ul></li></ul><h2 id="12-高级特性"><a href="#12-高级特性" class="headerlink" title="12. 高级特性"></a>12. 高级特性</h2><ul><li>自动化测试框架<ul><li>自动化测试框架arkxtest，作为工具集的重要组成部分，支持JS&#x2F;TS语言的单元测试框架(JsUnit)及UI测试框架(UiTest)。JsUnit提供单元测试用例执行能力，提供用例编写基础接口，生成对应报告，用于测试系统或应用接口。UiTest通过简洁易用的API提供查找和操作界面控件能力，支持用户开发基于界面操作的自动化测试脚本。</li><li><strong>脚本基础流程运行图</strong><ul><li><img src="image-20250103154658694.png" alt="image-20250103154658694"></li></ul></li></ul></li><li>NDK开发<ul><li>NDK（Native Development Kit）是HarmonyOS SDK提供的Native API、相应编译脚本和编译工具链的集合，方便开发者使用C或C++语言实现应用的关键功能。</li><li>NDK只覆盖了HarmonyOS一些基础的底层能力，如C运行时基础库libc、图形库、窗口系统、多媒体等</li><li><img src="image-20241214192403587.png" alt="image-20241214192403587" style="zoom: 80%;" /></li><li><strong>NAPI对比JNI</strong><ul><li><img src="image-20250103154616244.png" alt="image-20250103154616244"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华为</tag>
      
      <tag>鸿蒙</tag>
      
      <tag>arkts</tag>
      
      <tag>方舟编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式软件系统</title>
    <link href="/2025/01/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/01/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h1><h2 id="1-嵌入式系统概论"><a href="#1-嵌入式系统概论" class="headerlink" title="1. 嵌入式系统概论"></a>1. 嵌入式系统概论</h2><ul><li><strong>嵌入式系统定义</strong><ul><li>“嵌入式系统”实际上是”嵌入式计算机系统”的简称，以下是对嵌入式系统的不同定义。</li><li>IEEE的定义<ul><li>嵌入式系统是用于<strong>控制、监视或者辅助操作机器和设备的装置</strong>。</li><li>此定义是从应用上考虑的，嵌入式系统是软件和硬件的综合体，还可以涵盖机电等附属装置。</li></ul></li><li>国内的定义<ul><li>嵌入式系统是<strong>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</strong>。<ol><li>嵌入式设备是用于特定的设备</li><li>计算机技术为基础，必须要有计算</li><li>软硬件可裁剪:印证了专用设备的特点，将不需要的设备裁剪掉</li></ol></li><li>嵌入式系统就是一个具有特定功能或用途的隐藏在某种设备中的计算机软硬件集合体，没有固定的特征形状。</li><li>嵌入的可以不是设备，而是生产流程，这样的系统也是嵌入式系统</li></ul></li><li>其他的定义<ul><li>看不见的计算机，一般不能被用户编程, 它有一些专用的I&#x2F;O设备, 对用户的接口是应用专用的。</li><li>嵌入式系统是包含在某些较大的设备或产品中的计算机系统，其目的是为该设备提供<strong>监视和控制</strong>服务。</li><li>包括可编程计算机在内但本身<strong>不打算用作通用计算机</strong>的任何设备。</li><li>包含有计算机，但又不是通用计算机的计算机应用系统。</li></ul></li></ul></li></ul><span id="more"></span><ul><li>嵌入式系统示例<ul><li>CPS：信息物理系统，Cyber-Physical System (CPS) ，是计算进程与物理进程的集成</li><li>WSN：无线感知网络，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络。这些装置使用传感器器协作地监控不同位置的物理或环境状况</li><li>传感器:将非电信号转换为电信号，用来感知和度量外部世界，并将其转换为计算机可度量的电信号。比如温湿度、酸碱度传感器等。</li><li>物联网(IoT)是物理设备，车辆(也称为”连接设备”和”智能设备”)，建筑物以及其他嵌入电子设备，软件，传感器，执行器和网络的物品的互连网络 连接性，使这些对象能够收集和交换数据。</li></ul></li><li><img src="image-20241211144341082.png" alt="image-20241211144341082" style="zoom: 67%;" /></li><li><strong>嵌入式系统的组成</strong><ul><li>嵌入式系统一般由<strong>嵌入式硬件和软件</strong>组成</li><li>硬件以<strong>微处理器</strong>为核心集成<strong>存储器</strong>和系统专用的<strong>输入&#x2F;输出设备</strong></li><li>软件包括：<strong>初始化代码及驱动、嵌入式操作系统和应用程序</strong>等，这些软件有机地结合在一起，形成系统特定的一体化软件。</li></ul></li><li><strong>嵌入式系统的特点</strong><ul><li><strong>形式多样、面向特定应用</strong>：一般用于特定的任务，其硬件和软件都必须高效率地设计，可剪裁</li><li><strong>高度制约的环境</strong>：嵌入式系统通常工作在资源高度受限的环境中，这也使得系统设计极具挑战性</li><li><strong>与外部环境的交互，包含传感器和执行器</strong>：与外部环境的交互在很大程度上是无人干预的，需要传感器来接收来自外部环境的数据，通过执行器输出数据到外部环境并控制外部环境</li><li><strong>实时性要求</strong>：一方面大多数实时系统都是嵌入式系统，另一方面嵌入式系统多数有实时性的要求，具有时间约束条件，必须在给定的时间范围内处理完事件</li><li><strong>安全性和可靠性</strong>：某些实时嵌入式系统是安全至上且必须是具有高度的可靠性</li><li><strong>关注成本</strong>：嵌入式系统通常需要注意的成本是系统成本，特别是量大的消费类数字化产品，其成本是产品竞争的关键因素之一</li><li><strong>并发性</strong>：并发性是指在一个系统中将多个计算同时执行并潜在地交互的特性</li></ul></li><li><strong>嵌入式系统的分类</strong><ul><li>按嵌入式处理器的位数来分类：4位、8位、16位、32位、64位</li><li>按应用来分类</li><li>按速度分类：强实时系统、⼀般实时系统、弱实时系统</li><li>按确定性来分类：硬实时、软实时系统</li><li>按嵌入式系统软件复杂程度来分类</li></ul></li></ul><h2 id="2-嵌入式系统设计方法、EMP"><a href="#2-嵌入式系统设计方法、EMP" class="headerlink" title="2. 嵌入式系统设计方法、EMP"></a>2. 嵌入式系统设计方法、EMP</h2><ul><li>设计过程<ul><li><img src="2.png" style="zoom: 50%;" /></li></ul></li><li>硬件组成：CPU、bus、memory、I&#x2F;O devices: 网络，传感器，执行器等。</li><li><strong>嵌入式微处理器(EMP)的分类</strong><ul><li>嵌入式微处理器种类繁多，按位数可分为4位、8位、16位、32位和64位。</li><li>根据功能不同，嵌入式微处理器分为四种：<ol><li>嵌入式微处理单元(MPU)：嵌入式微处理器就是和通用计算机的处理器对应的CPU</li><li>嵌入式微控制器(MCU)：嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM&#x2F;EPROM，RAM，总线，总线逻辑，定时&#x2F;计数器，I&#x2F;O，串行口等各种必要功能和外设</li><li>嵌入式DSP处理器：嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</li><li>嵌入式SoC：系统级芯片，也称为片上系统（System-on-Chip），是追求产品系统最大包容的集成器件，绝大多数系统构件都在一个系统芯片内部</li></ol></li></ul></li><li><strong>嵌入式微处理器特点</strong><ul><li>体积小、重量轻、可靠性高</li><li>功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul></li><li><strong>选择微处理器的准则</strong><ul><li>高效、经济地满足任务的计算需求</li><li>软件开发工具的可用性</li><li>广泛的可用性和可靠的微控制器来源</li></ul></li><li><strong>设备分类</strong><ul><li>根据其能力和性能，物联网设备可以分为三类</li><li>高端设备，车载</li><li>中端物联网设备，包括Rasberry Pi等单板机（SBC）和智能手机</li><li>低端物联网设备，这些设备资源有限，无法运行这些传统的操作系统</li></ul></li></ul><h2 id="3-存储器架构"><a href="#3-存储器架构" class="headerlink" title="3. 存储器架构"></a>3. 存储器架构</h2><ul><li>易失性存储器：随机存取存储器（RAM）<ul><li>SRAM：静态RAM，速度快，面积大</li><li>DRAM：动态RAM，保持数据的时间很短，需要定期刷新，比SRAM更不稳定</li><li><strong>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM</strong></li></ul></li><li>非易失性存储器<ul><li>不需要持续供电来保留存储在计算设备中的数据或程序代码</li><li>只读存储器（ROM），或掩模ROM（Mask ROM）：内容在芯片工厂就已经固定</li><li>电可擦除可编程ROM（Electrically Erasable Programmable ROM，EEPROM）</li><li>快闪存储器（Flash）<ul><li>有比较快的读取时间，但比SRAM和DRAM慢</li><li>写入时间大大超过读取时间，而且写入的次数是有限的</li><li>NOR:(放置固态代码:因为还有XIP)<ol><li>字可读取。</li><li>逐块擦除。</li></ol></li><li>NAND:<ol><li>按页读取(512-4K字节)。</li><li>逐块擦除。</li></ol></li><li>NAND便宜，擦除速度更快，顺序访问时间更短</li></ul></li><li>磁盘存储器</li></ul></li><li><strong>固件和可固化</strong><ul><li>固件（firmware）：一般存储于设备中的电可擦除只读存储器EEPROM 或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级的程序</li><li>可固化（ROMable）：可被编程到ROM芯片中的机器语言</li></ul></li><li><strong>存储器层次结构</strong><ul><li>处理器寄存器</li><li>缓冲存储器：高速缓存Cache、地址转换高速缓存（TLB，也称快表）以及暂存存储器（SPM）。<ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问</li><li>SPM通常和处理器集成在一个芯片上</li></ul></li><li>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在MB到GB之间，并且是易失的</li><li>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案</li></ul></li></ul><h2 id="4-Bus"><a href="#4-Bus" class="headerlink" title="4. Bus"></a>4. Bus</h2><ul><li>可编程I&#x2F;O<ul><li>在通信过程中选择控制寄存器或数据缓冲区的三种方法<ul><li>独立I&#x2F;O端口：I&#x2F;0独立编址，不占用内存空间，但是只能用专门的I&#x2F;0指令，访问端口的方法少</li><li>内存映射I&#x2F;O：在内存映射I&#x2F;O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址</li><li>混合解决方案，混合模型包括内存映射的I&#x2F;O数据缓冲区和用于控制寄存器的独立I&#x2F;O端口</li></ul></li></ul></li><li>I&#x2F;O中断部分：中断向量、中断优先级等内容与OS相同，不再赘述</li><li><strong>可重入</strong><ul><li>定义：一个函数可以同时被多次调用。可重入函数在任何时候都可以被中断，一段时间后继续运行时数据不会丢失。</li><li>在嵌入式世界中，例程必须满足以下条件才能重入:<ul><li>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</li><li>不调用不可重入的函数</li><li>不以非原子的方式使用硬件</li></ul></li></ul></li><li><strong>竞态条件</strong>：设备或系统出现不恰当的执行时序，而得到不正确的结果</li><li>CPU总线<ul><li>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线</li><li>总线协议决定了设备是如何进行通信的</li><li>总线上的设备会经历状态序列：协议是由状态机指定的，协议中的每个参与者都有一个状态机。</li></ul></li><li>分类<ul><li><img src="image-20250104093057527.png" alt="image-20250104093057527" style="zoom: 67%;" /></li><li><img src="image-20250104093134536.png" alt="image-20250104093134536" style="zoom:67%;" /></li></ul></li></ul><h2 id="5-嵌入式软件系统"><a href="#5-嵌入式软件系统" class="headerlink" title="5. 嵌入式软件系统"></a>5. 嵌入式软件系统</h2><ul><li><p>嵌入式软件与桌面软件的对比</p><ul><li><p>内存：有限，影响编程语言的选择以及开发工具的使用(比如编译器优化)</p></li><li><p>CPU处理能力：成本和功耗的考虑，ES不得不采用保守的设计方案，其中的CPU往往只是恰好满足要求。</p></li><li><p>操作系统：OS(Windows&#x2F;Linux)、RTOS、专有OS或裸机</p></li><li><p>实时性</p><ul><li>实时系统不⼀定会运行得很快，但⼀定是可预测的，通常的术语叫做确定性</li><li>实时性的要求对于OS的选择和程序设计都有影响</li></ul></li></ul><ul><li>开发流程<ul><li>ES往往没有足够的资源进行软件开发。交叉开发对于工具的选择有很大影响。<ul><li>开发过程也不同，编辑&#x2F;编译&#x2F;调试的循环是一样的，但执行程序这⼀步却非常复杂，需要把代码转移到目标机上或者在某种环境下运行。</li></ul></li></ul></li><li>执行流程：多数嵌入式设备从开机开始就会运行某个程序，该程序会⼀直运⾏到系统关机。这个程序可能存储在ROM，也可能是从⾮易失性存储器转移到RAM中执行。</li><li>嵌入式软件开发工具<ul><li><img src="image-20241211154237746.png" alt="image-20241211154237746" style="zoom:67%;" /></li></ul></li><li>软件组件<ul><li><img src="image-20241211154350359.png" alt="image-20241211154350359" style="zoom:67%;" /></li></ul></li></ul></li><li><p>嵌入式软件系统层次结构</p><ul><li><img src="image-20250104093329334.png" alt="image-20250104093329334" style="zoom:80%;" /></li></ul></li><li><p>为何要为实时系统建立模型</p><ul><li>辅助测试和完善最终系统</li><li>更重要的是，模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进⼀步研究</li><li>实时工程师使用程序模型来开发软件和硬件，以便能将整个实时系统全盘考虑</li><li>模型使得⼯程师能够预测程序的运行，从而满足系统的性能需求和功能需求</li></ul></li><li><p>嵌入式软件<strong>架构</strong></p><ul><li>分为两部分：业务逻辑、实时依赖硬件的逻辑</li><li><img src="image-20241211154941064.png" alt="image-20241211154941064" style="zoom:50%;" /></li></ul></li><li><p>嵌入式软件<strong>架构模式</strong></p><ul><li>非结构化单体架构：很容易构建，但很难维持规模和移植，与应用层的应用程序紧密耦合</li><li>分层架构<ul><li><img src="image-20241211155159047.png" alt="image-20241211155159047" style="zoom:50%;" /></li></ul></li><li>事件驱动架构<ul><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义</li><li>通常利用中断来立即响应事件</li><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件</li><li>优点：具有相对的可扩展性、软件模块通常具有高内聚性和低耦合性</li><li>缺点：无论何时需要做任何事情，都有额外的开销和复杂性</li></ul></li><li>微服务架构<ul><li>微服务架构将应用程序构建为为业务领域开发的小型自治服务的集合</li><li>微服务本质上是低耦合的，使得微服务易于维护和可测试，开发人员可以快速扩展或移植微服务</li><li>围绕系统的业务逻辑组织，业务逻辑(有时称为业务功能)是系统行为的业务规则和用例</li></ul></li></ul></li><li><p>嵌入式软件<strong>设计模式</strong></p><ul><li>单核、多核、发布和订阅模型、RTOS模式、中断处理和低功耗设计</li><li>轮询<ul><li>从外设收集数据的最直接的设计机制是让应用程序定期轮询外设，以查看是否有任何数据可供管理和处理</li><li><img src="image-20241211155717208.png" alt="image-20241211155717208" style="zoom:50%;" /></li><li>watchdog：<a href="https://blog.csdn.net/shulianghan/article/details/80249185">https://blog.csdn.net/shulianghan/article/details/80249185</a></li></ul></li><li><strong>有限状态机</strong><ul><li>与轮询类似，但只有当前状态被执行.</li><li>每个状态决定下一个状态(非顺序执行)。</li><li>优先级:每个状态确定下一个状态的优先级。</li><li>响应时间:所有任务的总和。</li><li>变更的影响:重大。更改任务的执行时间或添加任务会影响所有其他任务。</li><li>简单性:没有共享数据问题。</li></ul></li><li><strong>中断设计模式</strong><ul><li>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件</li><li>当设计ISR（中断处理服务）时，我们希望中断尽可能快地运行(以最小化中断)</li><li>优先级：中断优先于主循环</li><li>响应时间：所有任务的总和以及中断执行时间</li><li>更改的影响：对于中断服务程序而言意义不大。与轮询作为主循环相同。</li><li>共享数据：必须处理与中断服务程序共享的数据</li><li>是MCU中使用最多的</li></ul></li><li><strong>数据获取&#x2F;存储相关的中断设计模式</strong>：线性数据存储、乒乓缓冲&#x2F;双缓冲、环形&#x2F;循环缓冲区、带有信号量的循环缓冲区、带有事件标志的循环缓冲区、消息队列</li><li>DMA控制器将外设数据传输到循环缓冲区的设计模式<ul><li>DMA，全称Direct Memory Access，即直接存储器访问</li><li>无需CPU的交互情况下在RAM和外设之间以及内部传输数据</li></ul></li><li><strong>RTOS应用程序设计模式</strong><ul><li>在RTOS应用程序中，通常有两种类型的同步</li><li>资源同步：决定了对共享资源的访问是否安全，包括中断锁定（关中断）、抢占锁定（禁用抢占式调度器）和互斥锁</li><li>活动同步：决定执行是否已达到特定状态，用于协调任务执行<ul><li>例如，假设我们正在开发一个获取传感器数据并使用传感器值驱动电机的系统。我们很可能想要向运动任务发出信号，告诉它有新的数据可用，这样任务就不会对陈旧的数据采取行动</li><li>单向同步(任务对任务)：使用二值信号量或事件标志来同步任务</li><li>单向同步(中断到任务)：单向同步还可以在中断和任务之间同步和协调任务执行， 不同之处在于，在ISR给出信号量或事件标志之后，ISR将继续执行，直到完成为止。</li><li>双向同步：两个任务在它们之间的两个方向上进行协调</li><li>同步多个任务之广播设计模式：广播设计模式允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列</li><li>发布和订阅模型：在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题，该设备还可以发布特定的主题</li></ul></li></ul></li><li><img src="image-20241211162121699.png" alt="image-20241211162121699" style="zoom: 67%;" /></li></ul></li></ul><h2 id="6-嵌入式操作系统概述"><a href="#6-嵌入式操作系统概述" class="headerlink" title="6. 嵌入式操作系统概述"></a>6. 嵌入式操作系统概述</h2><ul><li>实时系统：一个实时系统是指计算的正确性不仅取决于程序的逻辑正确性，也取决于结果产生的时间，如果系统的时间约束条件得不到满足，将会发生系统出错<ul><li>确定性（Determinism）：如果一个系统始终会为某个已知输入产生相同的输出，则该系统是确定性的</li><li>截止时限（Deadline）：截止时限就是必须完成某项任务的有限时间窗口，指明计算何时必须结束</li></ul></li><li>实时操作系统（Real-Time Operating System, RTOS）是支持构建实时系统的操作系统</li><li>RTOS与GPOS<ul><li>相似的功能<ul><li>多任务级别</li><li>软件和硬件资源管理</li><li>为应用提供基本的OS服务</li><li>从软件应用抽象硬件</li></ul></li><li>RTOS从GPOS分离出的功能<ul><li>更快的特性</li><li>满足应用需要的剪裁能力</li><li>减少内存需求</li><li>为实时嵌入式系统提供可剪裁的调度策略</li><li>嵌入式应用上下文中具有更好的可靠性</li><li>支持无盘化嵌入式系统，允许从ROM或RAM上引导和运行</li><li>对不同硬件平台具有更好的可移植性</li></ul></li></ul></li><li>为何使用RTOS<ul><li>可被复用的标准软件组件</li><li>灵活性</li><li>响应时间</li></ul></li><li>RTOS关键要求<ul><li>操作系统的时间行为必须是可预测的</li><li>操作系统必须管理线程和进程的调度</li><li>一些系统要求操作系统管理时间</li><li>操作系统必须是快速的</li><li>可靠性</li><li>简洁紧凑</li></ul></li><li>RTOS内核系统服务<ul><li>任务管理</li><li>同步与通信</li><li>内存管理</li><li>时间管理</li><li>IO管理</li><li>异常与中断管理</li></ul></li><li>物联网操作系统的要求<ul><li>内存占用小</li><li>支持异构硬件</li><li>网络连接</li><li>节能</li><li>实时功能</li><li>安全</li></ul></li><li>物联网操作系统分类<ul><li>事件驱动的操作系统<ul><li>该模型的关键思想是，系统上的所有处理都是由(外部)事件触发的，通常由中断发出信号</li><li>这类操作系统包括continki、TinyOS和OpenWSN</li></ul></li><li>多线程OS<ul><li>多线程操作系统通常会引入一些内存开销，这是由于堆栈预留空间造成的，而运行时开销则是由于上下文切换造成的</li><li>属于这一类的操作系统包括RIOT、nuttX、eCos或ChibiOS</li></ul></li><li>纯RTOS<ul><li>在工业&#x2F;商业环境中，RTOS主要关注实现实时保证的目标，正式的验证、认证和标准化通常是至关重要的</li><li>为了允许模型检查和形式化验证，这些操作系统中使用的编程模型通常会对开发人员施加严格的约束</li><li>属于这一类别的物联网设备的操作系统包括FreeRTOS、eCos、RTEMS、ThreadX和一系列其他商业产品(通常是封闭源代码)</li></ul></li></ul></li><li>调度程序分类<ul><li>完全静态调度程序：在系统设计时制定三项决策（分配、排序、定时）</li><li>静态顺序调度程序&#x2F;离线调度程序：在设计时完成任务的分配和排序，但直到任务运行时才确定每个任务的物理执行时间</li><li>在线调度程序<ul><li>静态分配调度程序：在设计时制定任务的分配，其他决策在任务运行时制定</li><li>完全动态调度程序：在任务运行时制定所有的决策</li></ul></li></ul></li><li>任务的周期<ul><li><img src="image-20241212151836995.png" alt="image-20241212151836995" style="zoom:67%;" /></li><li>周期就是一个任务隔这么久会出现一次，同时也是这个任务完成的最晚时间</li></ul></li><li>优先级<ul><li>假设每个任务都有优先级号，调度程序总是执行优先级最高的任务</li><li>固定优先级：任务整个执行过程中其优先级保持不变</li><li>动态优先级：在执行过程中任务的优先级是可变的</li></ul></li><li>非抢占式调度与抢占式调度程序<ul><li>非抢占式优先级调度程序：通过优先级决定当前任务完成之后执行哪个任务，不中断一个正在执行的任务而去执行另外一个</li><li>抢占式优先级调度程序：在任何时刻，支持任务的到达，执行最高优先级的被激活任务。当任何任务改变优先级或激活状态时，内核可以调度一个新任务</li><li>可行调度：所有的任务执行都符合他们的时限</li></ul></li><li><strong>RMS调度算法</strong>：单调速率调度<ul><li>看这篇：<a href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html">https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html</a></li></ul></li><li><strong>EDD调度算法</strong>：最早交货期<ul><li><img src="image-20241212154345902.png" alt="image-20241212154345902" style="zoom:67%;" /></li><li>EDD在最大延迟最小化方面是最优的</li></ul></li><li><strong>EDF调度算法</strong>：最早截止时限优先<ul><li>EDD不支持任务到达，可通过允许任务在任何时刻“到达”(就绪)来扩展EDD</li><li>最早截止时限优先(EDF)：给定n个具有任意到达时间的独立任务集，在<strong>任何时刻</strong>，在<strong>所有到达的任务</strong>中执行<strong>绝对截止时限最早</strong>的任务的算法对于最大延迟最小化上是最优的</li><li>看这篇：<a href="https://blog.csdn.net/Cap220590/article/details/102762190">https://blog.csdn.net/Cap220590/article/details/102762190</a></li></ul></li><li>优先序约束<ul><li><img src="image-20241212155422778.png" alt="image-20241212155422778" style="zoom:67%;" /></li></ul></li><li><strong>LDF调度算法</strong>：最晚时限优先<ul><li><img src="image-20241212160731236.png" alt="image-20241212160731236" style="zoom: 67%;" /></li><li>LDF 在最大延迟最小化方面是最优的</li><li>但是，LDF要求所有任务都是已知的，并且在执行任何任务之前都知道它们的优先序约束</li></ul></li><li>具有优先序的EDF<ul><li><img src="image-20241212160957513.png" alt="image-20241212160957513" style="zoom: 60%;" /></li><li><img src="image-20241212161038698.png" alt="image-20241212161038698" style="zoom:60%;" /></li><li>修改截止时限<ul><li><img src="image-20241212161056264.png" alt="image-20241212161056264" style="zoom:60%;" /></li><li>从叶子往上面算，叶子的<code>di&#39;</code>就等于原来的<code>di</code></li></ul></li></ul></li><li>优先级反转<ul><li><img src="image-20241212161915313.png" alt="image-20241212161915313" style="zoom:67%;" /></li><li>解决方案是优先级继承协议：当任务<code>Ji</code>阻塞一个或多个高优先级任务时，它暂时假定(继承)被阻塞任务的最高优先级</li><li><img src="image-20241212162142431.png" alt="image-20241212162142431" style="zoom:67%;" /></li></ul></li><li>死锁问题的解决<ul><li>优先级上限协议<ul><li>每个锁或信号量都被分配了一个优先级上限，该上限等于可以锁定它的最高优先级任务的优先级</li><li>只有当任务T的优先级严格高于其他任务当前持有的所有锁的优先级上限时，任务T才能获得锁</li></ul></li><li><img src="image-20241212162434797.png" alt="image-20241212162434797" style="zoom:67%;" /></li></ul></li><li>FreeRTOS 支持的调度方法：抢占式、协作式、时间片轮转</li></ul><h2 id="7-实时内核"><a href="#7-实时内核" class="headerlink" title="7. 实时内核"></a>7. 实时内核</h2><ul><li><p>任务和ISR之间的通信方式</p><ul><li>一个任务或ISR可以通过事件控制块ECB（信号量、邮箱或消息队列）向另外的任务发信号</li><li>一个任务还可以等待另一个任务或中断服务子程序给它发送信号，对于处于等待状态的任务，还可以给它指定一个最长等待时间</li><li>多个任务可以同时等待同一个事件的发生，当该事件发生后，在所有等待该事件的任务中，优先级最高的任务得到了该事件并进入就绪状态，准备执行</li></ul></li><li><p>μC&#x2F;OS：一种基于优先级的抢占式多任务实时操作系统，包含了实时内核、任务管理、时间管理、任务间通信同步（信号量，邮箱，消息队列）和内存管理等功能。</p><ul><li>邮箱（MailBox）：一个任务或ISR可以通过邮箱向另一个任务发送一个指针型的变量，该指针指向一个包含了特定“消息”（message）的数据结构；</li><li>消息队列可以使一个任务或ISR向另一个任务发送多个以指针方式定义的变量，实现了任务接收来自其他任务或中断的不固定长度的消息。当队列中的消息是空时， 读取消息的任务将被阻塞</li><li>μC&#x2F;OSII中是实模式存储管理，不划分内核空间和用户空间，整个系统只有一个地址空间，即物理内存空间，应用程序和内核程序都能直接对所有的内存单元进行访问</li><li>μC&#x2F;OS采用的是固定分区的存储管理方法，把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块</li></ul></li><li><img src="image-20241212173144298.png" alt="image-20241212173144298" style="zoom:67%;" /></li><li><p>内存管理方法</p><ul><li><p>静态内存分配（Static Memory Allocation）</p><ul><li>允许用户在编译时为任务和内核对象（如队列、信号量等）分配静态内存</li><li>静态可以保证设备的可靠性但是需要考虑内存上限，内存使用效率低</li></ul></li><li><p>动态内存分配（Dynamic Memory Allocation）</p><ul><li>提供用于动态内存分配的内置函数，允许任务在运行时请求和释放内存</li><li>这种方法对于需要灵活管理内存的应用非常有用，但需要小心避免内存泄漏和碎片化</li></ul></li><li><p>内存池（Memory Pools）</p><ul><li>内存池是在系统初始化时创建的一块内存区域，用于存储固定大小的内存块</li><li>任务可以从内存池中申请内存块，并在使用完毕后将其返回给内存池，这有助于减少内存碎片化</li></ul></li></ul></li><li><img src="image-20241212165513722.png" alt="image-20241212165513722" style="zoom:67%;" /></li></ul><h2 id="8-板级支持包与系统引导"><a href="#8-板级支持包与系统引导" class="headerlink" title="8. 板级支持包与系统引导"></a>8. 板级支持包与系统引导</h2><ul><li>版级支持包 BSP<ul><li>BSP全称“板级支持包”（Board Support Packages），是介于主板硬件和操作系统中驱动层程序之间的一层，一般认为它属于操作系统一部分，主要是实现对操作系统的支持，为上层的驱动程序提供访问硬件设备寄存器的函数包，使之能够更好的运行于硬件主板</li><li>BSP是用于特定硬件平台的一组软件组件，通常包括启动代码、驱动程序和其他与硬件相关的软件库</li><li>组成<ul><li>启动代码：负责系统上电后的硬件初始化，如设置时钟、初始化存储器等</li><li>硬件抽象层（HAL）：介于底层硬件和上层软件之间的一层抽象层，用于隐藏硬件的具体实现细节，提供统一的接口</li><li>设备驱动：针对特定硬件的驱动程序</li></ul></li></ul></li><li>RTOS的引导模式<ul><li>不需要BootLoader的引导模式：时间效率高，系统快速启动，直接在NOR flash或ROM系列非易失性存储介质中运行，但不满足运行速度的要求</li><li>需要BootLoader的引导模式：节省空间，牺牲时间，适用于硬件成本低，运行速度快，但启动速度相对慢</li></ul></li><li>BootLoader：嵌入式系统中的 OS 启动加载程序<ul><li>汇编部分执行简单的硬件初始化</li><li>C语言部分负责复制数据,设置启动参数,串口通信等功能</li></ul></li></ul><h2 id="9-嵌入式系统建模"><a href="#9-嵌入式系统建模" class="headerlink" title="9. 嵌入式系统建模"></a>9. 嵌入式系统建模</h2><ul><li>建模、设计、分析<ul><li>建模是通过模拟加深对系统理解的过程<ul><li>模型是对所研究的系统、过程或概念的一种表达形式</li><li>使用模型的目的是要给出系统的抽象视图，每个模型都表示一组对象以及这些对象之间的相互关系</li><li><img src="image-20241212174232972.png" alt="image-20241212174232972" style="zoom:60%;" /></li></ul></li><li>常见的建模技术<ul><li>面向状态的建模</li><li>面向活动的建模</li><li>面向结构的模型</li><li>面向数据的模型</li><li>异构模型：综合前四种模型特征</li></ul></li></ul></li><li>嵌入式系统模型的用途<ul><li>通过使用现代建模软件工具，可以离线仿真的方式进行设计和执行初始验证</li><li>可以使用模型来作为所有后续开发阶段的基础</li><li>建模（涉及硬件原型设计）将降低出错风险，通过在整个开发过程中执行验证和确认测试来缩短开发周期</li><li>以系统模型为基础，可以更快、更可靠地进行设计评估和预测</li><li>这种迭代方法可以在性能和可靠性方面改进设计</li><li>由于模型的可重用性以及对物理原型的依赖的减少，降低了资源成本</li><li>通过使用代码自动生成技术，可以减少开发错误和开销</li></ul></li><li>建模语言<ul><li><img src="image-20241212174639515.png" alt="image-20241212174639515" style="zoom: 60%;" /></li><li>与编程语言一样，建模语言有明确的定义和标准语法，用于表示结构和功能参与者及其随时间变化的主要关系</li><li>建模语言有多种形式<ul><li>图形、文本</li><li>面向文档、仿真或执行</li><li>专注于体系架构层面内容、实现层面内容</li></ul></li></ul></li><li>何时为嵌入式系统建立模型<ul><li>任务和安全关键型应用</li><li>高度复杂的应用程序和系统</li><li>大型开发团队</li><li>没有其他选择（当没有原型时）</li></ul></li><li><img src="image-20250104102306876.png" alt="image-20250104102306876" style="zoom: 67%;" /></li></ul><h2 id="10-有限状态机FSM"><a href="#10-有限状态机FSM" class="headerlink" title="10. 有限状态机FSM"></a>10. 有限状态机FSM</h2><ul><li>反应式(reactive)系统：指能够持续地与环境进行交互，并且及时地进行响应</li><li>有限状态机：又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型<ul><li>两个重要特性<ul><li>确定性：如果对于每个状态，每个输入值最多可激活一个转移，则称这样的状态机具有确定性，这意味着Φ(S,E)是单一值</li><li>可接受性：如果对于每个状态，每个输入都有至少一个可能的转移，则称这样的状态机为可接受的，定义了每个可能的状态和输入值</li></ul></li><li>Moore状态模型：意味着输出完全由当前状态决定，与输入信号的当前值无关</li><li>Mealy状态模型：意味着输出既依赖于当前状态，也与输入信号的当前值有关</li></ul></li><li>状态表FSM<ul><li><img src="image-20241212202222625.png" alt="image-20241212202222625" style="zoom:67%;" /></li><li><img src="image-20241212202534873.png" alt="image-20241212202534873" style="zoom: 80%;" /></li><li><img src="image-20241212203247392.png" alt="image-20241212203247392"></li></ul></li><li>层次有限状态机<ul><li>是由多个嵌套到层次结构中的有限状态机（fsm）组成的</li><li><img src="image-20241212203533406.png" alt="image-20241212203533406"></li><li><img src="image-20241212203719583.png" alt="image-20241212203719583" style="zoom:60%;" /></li><li><img src="image-20241212203853827.png" alt="image-20241212203853827" style="zoom:67%;" /></li><li><img src="image-20241212203908295.png" alt="image-20241212203908295" style="zoom:67%;" /></li><li><img src="image-20241212204208529.png" alt="image-20241212204208529" style="zoom:67%;" /></li></ul></li><li>行为树BTs<ul><li>行为树是一种分层的决策树，通常用于实现复杂的行为逻辑</li><li>将各种行为组织成节点，并通过条件来控制节点的执行顺序</li><li><img src="image-20241212204525140.png" alt="image-20241212204525140" style="zoom:67%;" /></li><li><img src="image-20241212204744527.png" alt="image-20241212204744527"></li><li><img src="image-20241212205219193.png" alt="image-20241212205219193"></li><li><img src="image-20241212204856981.png" alt="image-20241212204856981"></li><li><img src="image-20241212204840254.png" alt="image-20241212204840254"></li><li><img src="image-20241212204905925.png" alt="image-20241212204905925"></li><li><img src="image-20241212204916227.png" alt="image-20241212204916227"></li></ul></li></ul><h2 id="11-嵌入式系统设计方法"><a href="#11-嵌入式系统设计方法" class="headerlink" title="11. 嵌入式系统设计方法"></a>11. 嵌入式系统设计方法</h2><ul><li>嵌入式系统设计所面临的挑战<ul><li>需要多少硬件？</li><li>如何满足时限要求，如何处理多项功能在时间上的协调一致关系？</li><li>如何降低系统的功耗？</li><li>如何设计以保证系统可升级？</li><li>如何保证系统可靠地工作？</li></ul></li><li>设计目标：成本、性能、功耗、尺寸、可伸缩性和可重用性、容错</li><li>传统的嵌入式系统的设计过程的基本流程<ul><li><img src="image-20250104102652866.png" alt="image-20250104102652866" style="zoom:67%;" /></li></ul></li><li>软硬件的划分<ul><li>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现</li><li>硬件和软件具有双重性</li><li>软硬件变动对系统的决策造成影响</li><li>划分和选择需要考虑多种因素</li><li>硬件和软件的双重性是划分决策的前提</li></ul></li></ul><h2 id="12-物联网"><a href="#12-物联网" class="headerlink" title="12. 物联网"></a>12. 物联网</h2><ul><li>定义<ul><li>物联网，Internet of Things (IoT) ，通过射频识别(RFID)、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念</li><li>物联网是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互</li><li><strong>设备</strong>：在物联网中，具有强制性通信能力和选择性传感、激励、数据捕获、数据存储和数据处理能力的设备</li><li><strong>物</strong>：在物联网中，“物”指物理世界（物理装置）或信息世界（虚拟事物）中的对象，可以被标识并整合入通信网</li></ul></li><li>IOT特征<ul><li>智能：从生成的数据中提取知识</li><li>架构：一个支持许多其他架构的混合架构</li><li>复杂的系统：一组动态变化的对象</li><li>规模：可伸缩性</li><li>时间：数十亿并行和同时发生的事件</li><li>空间：定位</li><li>一切都是服务：将资源作为服务消费</li></ul></li><li>IoT的优势<ul><li>技术优化：物联网技术有助于技术的改进和提高</li><li>改进的数据采集：传统的数据采集有其局限性，设计为被动使用，物联网促进了对数据的即时行动</li><li>减少浪费：物联网提供实时信息可使资源被有效的管理</li><li>提高客户参与度：物联网允许你通过发现问题和改进流程来改善客户体验</li></ul></li><li>IoT的不足<ul><li>安全：物联网技术创造了一个连接设备的生态系统，尽管有足够的安全措施，但系统可能缺乏足够的认证控制</li><li>隐私：物联网的使用，在没有用户积极参与的情况下，暴露大量的个人数据，这就产生了很多隐私问题</li><li>灵活性：主要涉及到与另一个系统的集成，在这个过程中涉及到许多不同的系统</li><li>复杂性：物联网系统的设计也相当复杂，此外部署和维护也不是很容易</li><li>合规性：物联网有自己的一套规则和法规，然而，由于法规遵循的复杂性，其任务是相当具有挑战性的</li></ul></li><li>IoT应用<ul><li>智能家居类：智能灌溉、智能车库门、智能门锁、智能灯、智能恒温器和智能安全系统</li><li>可穿戴设备类：健康和运动跟踪器、智能服装&#x2F;可穿戴设备</li><li>宠物类：宠物定位系统、智能狗狗门</li></ul></li><li>物联网体系结构<ul><li><img src="image-20250104105137310.png" alt="image-20250104105137310" style="zoom: 67%;" /></li></ul></li><li>物联网软件、硬件、连接<ul><li>物联网软件：若干物联网技术已接近成熟，包括边缘人工智能、基于物联网的流分析、监督和非监督机器学习</li><li>物联网硬件：现有物联网技术被归类为相当成熟或主流包括cpu、mcu、gpu、安全芯片、FPGA和边缘网关</li><li>物联网连接：eSIM、mesh网络、5G和Wi-Fi 6，接近成熟</li></ul></li></ul><h2 id="13-IOT平台"><a href="#13-IOT平台" class="headerlink" title="13. IOT平台"></a>13. IOT平台</h2><ul><li>概念<ul><li>物联网平台是一种多层技术，能够在物联网领域中直接提供、管理和自动化连接设备</li><li>对于开发者来说，物联网平台提供了一套随时可用的功能，极大地加快了联网设备应用程序的开发，同时兼顾了可扩展性和跨设备兼容性</li><li>物联网平台起源于物联网<strong>中间件</strong>的形式，其目的是充当硬件层和应用层之间的中介，主要任务包括通过不同的协议和网络拓扑从设备收集数据、远程设备配置和控制、设备管理和空中固件更新</li></ul></li><li>物联网平台覆盖功能领域<ul><li>使设备连接管理简单</li><li>接收、存储和发送数据</li><li>帮助企业可视化设备数据并提供关键的见解</li><li>提供特定于应用程序的支持和数据</li><li>是否有知识渊博、反应灵敏的支持团队‍ 提供健壮的安全</li><li>提供支持物联网解决方案特定需求的定制</li><li>一致的产品交付和平台更新</li></ul></li><li>设备管理<ul><li>设备管理服务, 可以帮助对所有连接的设备, 在全球范围内进行规模化的注册、查看及远程管理</li><li>物模型（Thing Model）是对设备在云端的功能描述，包括设备的属性、数据、服务和事件</li><li>物联网平台提供设备影子功能，用于缓存设备状态，是一个 JSON 文档</li><li>数字孪生，是充分利用物理模型、传感器更新、运行历史等数据，集成多学科、多物理量、多尺度、多概率的仿真过程，在虚拟空间中完成映射，从而反映相对应的实体装备的全生命周期过程</li></ul></li><li>通信协议<ul><li>应用层协议<ul><li><img src="image-20250104152205962.png" alt="image-20250104152205962" style="zoom:67%;" /></li></ul></li><li>多协议接入方案<ul><li>通过协议转换网关实现泛协议设备接入</li><li><img src="image-20250104152301276.png" alt="image-20250104152301276" style="zoom:67%;" /></li></ul></li></ul></li></ul><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><ul><li>Arduino为什么流行<ul><li>跨平台的</li><li>简单，清晰的编程环境</li><li>开放源码和可扩展软件</li><li>开源和可扩展硬件</li><li>便宜</li></ul></li><li>ROS<ul><li>ROS 是一个适用于机器人的开源的元操作系统，提供了操作系统应有的服务，包括硬件抽象、底层设备控制、常用函数的实现、进程间消息传递、以及包管理</li><li>ROS的核心是提供一个消息传递系统，通常称为“中间件”或“管道”</li><li>为什么使用<ul><li>ROS生态系统具有丰富的机器人软件</li><li>ROS项目的目标是不断降低构建机器人应用程序的门槛</li><li>ROS社区是一个庞大、多样和全球性的社区</li></ul></li></ul></li><li>PID<ul><li><strong>反馈控制</strong>是指将系统的输出信息返送到输入端，与输入信息进行比较，并利用二者的偏差进行控制的过程</li><li><strong>开环控制</strong>：open loop control，又称“开环控制系统”，是指在一个控制系统中系统的输入信号不受输出信号影响的控制系统, 也就是，不将控制的结果反馈回来影响当前控制的系统</li><li><strong>闭环控制</strong>：是指作为被控的输出量以一定方式返回到作为控制的输入端，并对输入端施加控制影响的一种控制关系，即带有反馈信息的系统控制方式</li><li><strong>PID</strong>：在过程控制中，按偏差的比例（P）、积分（I）和微分（D）进行控制的PID控制器（亦称PID调节器）是应用最为广泛的一种自动控制器</li></ul></li><li>传感器<ul><li><strong>温度漂移（温漂）</strong>：传感器在不同温度条件下，输出信号发生的变化。由于传感器的材料、结构以及电子元件的温度依赖性，随着环境温度的变化，传感器的灵敏度、零点和其他性能可能发生变化。</li><li><strong>零点漂移（零漂）</strong>：传感器在没有输入信号（例如，温度、压力、加速度等）时，输出信号发生的变化。理想情况下，当输入信号为零时，传感器应该输出零值，但实际情况中，传感器可能会在无输入的情况下产生一个非零的输出，称为零点漂移。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件工程</title>
    <link href="/2025/01/09/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2025/01/09/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务的软件工程"><a href="#面向服务的软件工程" class="headerlink" title="面向服务的软件工程"></a>面向服务的软件工程</h1><h2 id="1-服务和服务系统"><a href="#1-服务和服务系统" class="headerlink" title="1. 服务和服务系统"></a>1. 服务和服务系统</h2><ul><li><p>什么是服务</p><ul><li>服务是一种时间易逝的、无形的体验，为客户提供，客户在其中扮演共同生产者的角色。</li></ul></li><li><p>IT和非IT服务</p><ul><li><p><strong>共同特征</strong></p><ul><li>相同的服务生命周期原则</li><li>相同的一组服务系统元素</li></ul></li><li><p><strong>主要区别</strong></p><ul><li>关键绩效指标（KPI）</li><li>需求管理</li><li>变更的速度</li></ul></li></ul></li></ul><span id="more"></span><ul><li><p>搞清楚服务和制造的区别</p><ul><li><img src="image-20241209203750488.png" alt="image-20241209203750488"></li></ul></li></ul><h2 id="2-服务生态系统与面向服务的计算"><a href="#2-服务生态系统与面向服务的计算" class="headerlink" title="2. 服务生态系统与面向服务的计算"></a>2. 服务生态系统与面向服务的计算</h2><ul><li><p>基于构件的泛型：</p><ul><li>构件：模块化的、可部署、可替换的软件系统组成部分，它封装了内部的具体实现并对外提供统一接口</li><li>以构件的创建、构件的管理以及复用已有构件组装形成应用为基本活动</li></ul></li><li><p>服务组合：由多个装配在一起的服务构成，用以提供对业务任务或过程进行实现的功能</p></li><li><img src="image-20250106101340146.png" alt="image-20250106101340146" style="zoom:67%;" /></li><li><p>服务库存</p><ul><li><img src="image-20241209204405894.png" alt="image-20241209204405894" style="zoom: 67%;" /></li><li><img src="image-20250106101237009.png" alt="image-20250106101237009" style="zoom: 67%;" /></li><li><img src="image-20250106101301206.png" alt="image-20250106101301206" style="zoom:67%;" /></li></ul></li><li><p><strong>服务生态系统</strong></p><ul><li>垂直服务：可以被同时、独立调用的用于满足消费者需求的服务</li><li>水平服务：构成垂直服务的可重用的跨领域的公共服务</li><li>垂直服务与水平服务不互斥</li><li><img src="image-20241209204537993.png" alt="image-20241209204537993" style="zoom:67%;" /></li></ul></li><li><p>面向服务的计算</p><ul><li><img src="image-20241209205310814.png" alt="image-20241209205310814" style="zoom: 67%;" /></li><li><img src="image-20241209205205405.png" alt="image-20241209205205405" style="zoom:67%;" /></li></ul></li><li><p><strong>面向服务和面向对象的差异</strong>（第四张表为设计角度）</p><ul><li><img src="image-20241209205352653.png" alt="image-20241209205352653" style="zoom:67%;" /></li><li><img src="image-20241209205403408.png" alt="image-20241209205403408" style="zoom:67%;" /></li><li><img src="image-20241209205416096.png" alt="image-20241209205416096" style="zoom:67%;" /></li><li><img src="image-20241209205431280.png" alt="image-20241209205431280" style="zoom:67%;" /></li></ul></li></ul><h2 id="3-面向服务的架构和Web-Service"><a href="#3-面向服务的架构和Web-Service" class="headerlink" title="3. 面向服务的架构和Web Service"></a>3. 面向服务的架构和Web Service</h2><ul><li><p>SOA：面向服务的架构</p><ul><li><img src="image-20241209210107082.png" alt="image-20241209210107082" style="zoom: 67%;" /></li></ul></li><li><p>SOA的好处</p><ul><li>IT视角：<ul><li>松耦合，消除假依赖 —— 复用</li><li>服务间接寻址 —— 灵活</li></ul></li><li>企业视角：<ul><li>保护企业投资，提升现有IT资源的作用，促进IT资源的复用</li><li>提高企业灵敏度</li><li>支持企业外包管理模式</li></ul></li></ul></li><li><p>SOA分层：</p><ul><li>业务层、过程层、中间件层、编程层</li><li><img src="image-20241209210907280.png" alt="image-20241209210907280"></li></ul></li><li><p>服务簇</p><ul><li>一类从概念上服务于同一个业务功能的服务集合</li><li>服务簇中的服务可以由不同的服务提供者发布，并在具体特性上有差异</li><li>例如微软和IBM的天气预报服务</li></ul></li><li><p>编排和编导</p><ul><li>编排：存在一个作为中心协调者的复合服务用于组织其他服务</li><li><img src="image-20241209212152725.png" alt="image-20241209212152725" style="zoom: 67%;" /></li><li>编导：每个服务持有自己的脚本来指导自己的运作</li><li><img src="image-20241209212207465.png" alt="image-20241209212207465" style="zoom:67%;" /></li></ul></li><li><p>水平层与垂直层</p><ul><li><img src="image-20250106101936146.png" alt="image-20250106101936146" style="zoom:80%;" /></li><li><p>水平层实现功能性需求</p><ul><li><img src="image-20241209212414535.png" alt="image-20241209212414535" style="zoom: 67%;" /></li></ul></li><li><p>垂直层</p><ul><li><img src="image-20241209212500725.png" alt="image-20241209212500725" style="zoom: 67%;" /></li><li><img src="image-20241209212519820.png" alt="image-20241209212519820" style="zoom:67%;" /></li></ul></li></ul></li><li><p>Web Service内容</p><ul><li><img src="image-20241209212804179.png" alt="image-20241209212804179" style="zoom: 67%;" /></li><li><img src="image-20241209212929307.png" alt="image-20241209212929307" style="zoom: 67%;" /></li></ul></li><li><p>Web Service协议栈</p><ul><li><img src="image-20241209205941119.png" alt="image-20241209205941119" style="zoom:80%;" /></li></ul></li></ul><h2 id="4-XML及相关协议"><a href="#4-XML及相关协议" class="headerlink" title="4. XML及相关协议"></a>4. XML及相关协议</h2><ul><li><p>什么是信息交换</p><ul><li>在执行领域（业务）相关功能时，各式各样采用电子信息方式编码的信息，在软件单元间的移动</li></ul></li><li><p>为什么用XML</p><ul><li>平台中立</li><li>语言中立</li><li>基于文本结构</li><li>能够表达复杂数据结构</li></ul></li><li><p>服务合约</p><ul><li>建立了与服务交互有关的术语</li><li>提供了技术限制和需求，及服务的拥有者希望对外公布的所有语义信息</li><li><img src="image-20241209213316284.png" alt="image-20241209213316284"></li></ul></li><li><img src="image-20241210091936034.png" alt="image-20241210091936034" style="zoom: 67%;" /></li><li><p><strong>XML声明规则</strong>（符合5+1原则为<strong>格式良好</strong>的XML文档，<strong>合法</strong>的XML文档还需要基于一个词汇表用DTD或XML schema定义结构）</p><ul><li>单根元素：所有XML文档只能有一个根元素</li><li>元素标签规则：元素以一个开始标签和一个结束标签进行包装</li><li>元素嵌套规则：在元素的以开始标签和结束标签之间可以嵌套任意数量的子元素或数据</li><li>元素规则：包括命名规则、元素内容（PCDATA和CDATA）</li><li>元素属性：属性是一个键值对，必须有值</li><li>[可选]XML声明：出现在第一行，version为必选属性</li></ul></li><li><p>名称空间</p><ul><li>为避免冲突，将元素或属性名用URI + 名称表示</li><li><img src="image-20241210094427956.png" alt="image-20241210094427956" style="zoom: 67%;" /></li><li>QNames：包含前缀部分和本地部分（如<a href="books:title">books:title</a>）</li></ul></li><li><p>XML Schema</p><ul><li><img src="image-20250106103144223.png" alt="image-20250106103144223" style="zoom:80%;" /></li></ul></li><li><p>DOM Parser、SAX Parser、XSL、XPath、XSLT的选择</p><ul><li><p><strong>DOM Parser</strong>:</p><ul><li>适用于需要完整加载和操作 XML 文档的情况。</li><li>优点：支持随机访问和修改 XML 树结构，适合处理小型 XML 文件。</li><li>缺点：内存消耗大，处理大型文档性能较差。</li><li><strong>场景</strong>：需要反复读取、修改 XML 数据时使用。</li></ul></li><li><p><strong>SAX Parser</strong>:</p><ul><li>适用于逐行解析 XML 文档的情况，不需要加载完整文档。</li><li>优点：占用内存少，处理速度快，适合处理大型文档。</li><li>缺点：仅支持顺序读取，无法随机访问或修改数据。</li><li><strong>场景</strong>：只需一次性读取或过滤部分数据时使用。</li></ul></li><li><p><strong>XSL (Extensible Stylesheet Language)</strong>:</p><ul><li>适用于通过样式定义 XML 数据的展示方式。</li><li>包括 <strong>XSLT</strong>（转换部分）和 <strong>XSL-FO</strong>（格式化部分）。</li><li><strong>场景</strong>：需要定义复杂的 XML 文档样式或转换文档为不同的输出格式时使用。</li></ul></li><li><p><strong>XSLT (XSL Transformations)</strong>:</p><ul><li>专注于将 XML 文档转换为其他格式（如 HTML、XML、JSON 等）。</li><li>基于模板的转换语言，可通过规则匹配实现结构变换。</li><li><strong>场景</strong>：需要从一个 XML 文档生成另一种格式的输出时使用。</li></ul></li><li><p><strong>XPath (XML Path Language)</strong>:</p><ul><li>用于从 XML 文档中提取节点和数据。</li><li>适合精确定位或过滤特定数据。</li><li><strong>场景</strong>：需要从 XML 数据中快速提取某些字段或执行条件查询时使用。</li></ul></li><li><p>宏观选择的依据</p><p>| <strong>工具&#x2F;技术</strong> | <strong>适用场景</strong>                                        |<br>| ————- | ————————————————— |<br>| DOM Parser    | 操作整个 XML 树，支持随机访问和修改，适合小型文档。 |<br>| SAX Parser    | 顺序读取 XML，适合大型文档和高效处理需求。          |<br>| XSL           | 定义 XML 的展示样式或格式化输出。                   |<br>| XSLT          | 转换 XML 为其他格式（HTML、JSON 等）。              |<br>| XPath         | 查询、提取 XML 中的特定节点或数据。                 |</p></li></ul></li></ul><h2 id="5-Web-Service核心"><a href="#5-Web-Service核心" class="headerlink" title="5. Web Service核心"></a>5. Web Service核心</h2><h3 id="5-1-SOAP"><a href="#5-1-SOAP" class="headerlink" title="5.1 SOAP"></a>5.1 SOAP</h3><ul><li><p>什么是SOAP</p><ul><li><img src="image-20241210101319810.png" alt="image-20241210101319810" style="zoom:67%;" /></li></ul></li><li><p>SOAP的结构</p><ul><li><img src="image-20241210101633042.png" alt="image-20241210101633042" style="zoom:67%;" /></li><li><img src="image-20250106103832269.png" alt="image-20250106103832269" style="zoom:80%;" /></li><li>Envelope 元素：必须元素，根元素，标识此 XML 文档为一条 SOAP 消息；可以包含命名空间和声明额外的属性。如果出现额外属性，则必须使用命名空间修饰。</li><li>Header 元素：可选元素，有关 SOAP 消息的应用程序专用信息（比如认证、支付等）。</li><li>Body 元素：必须元素，包含所有的调用和响应信息。</li><li>Fault 元素：可选元素，提供有关在处理此消息所发生的错误的信息</li></ul></li><li><p>SOAP处理模型</p><ul><li>用 XML 打包请求：<ol><li>将接口名作为根节点</li><li>方法和参数作为节点</li></ol></li><li>将请求发给服务器：<ol><li>不创建自己的 TCP&#x2F;IP 信息，利用 HTTP</li><li>将请求封装成 HTTP POST 请求格式发出</li></ol></li><li>服务器收到请求，解码 XML，处理请求，以 XML 格式返回响应<ol><li>与请求比较，方法的节点名字变为请求的方法名后缀 <code>Response</code>（例如，<code>find-&gt;findResponse</code>）</li><li>客户程序自己调用了哪个方法，根据方法名后缀 <code>Response</code> 寻找调用方法的返回值</li></ol></li></ul></li><li><p>SOAP 通信的两种典型模型：</p><ol><li><strong>点对点通信</strong>：直接从发送方到接收方的简单模型。</li><li><strong>多跳通信</strong>：消息在多个中间节点间传递，最后到达目标接收者的复杂模型。过程中能够在不同网络协议（如 HTTP、SMTP、JMS 等）上进行</li></ol></li><li><p>文档导向和远程调用的区别</p><ul><li><strong>文档导向模式</strong></li></ul></li></ul><ul><li>一种<strong>异步</strong>交互方式<ul><li>发送一个完整的 XML 文档，并等待通知。结果会在处理完成后发送回来。</li><li>适用于复杂业务流程（如订单处理、报表生成），结果不要求实时返回。</li><li><strong>远程过程调用模式</strong><ul><li>一种<strong>同步</strong>的请求&#x2F;响应交互方式</li><li>发送具体的函数调用及其参数，请求并等待响应。</li><li>适用于简单任务或需要实时响应的场景（如查询某个数据）。</li></ul></li></ul></li></ul><ul><li>SOAP Fault机制<ul><li>SOAP 提供了一种模型，用于处理消息处理过程中出现的错误情况。</li><li>SOAP 区分了导致错误的条件和向错误消息的发起者或其他节点通知该错误的能力。</li><li>通知错误的能力取决于所使用的消息传输机制，而 SOAP 在绑定到底层协议的规范中，其中一个方面就是规定如何通知错误（如果支持的话）。</li><li>SOAP 的错误模型要求所有与 SOAP 相关的错误和与应用程序相关的错误都必须通过一个特殊的元素 <strong>Fault</strong> 来报告，并且该元素包含在 <strong>Body</strong> 元素中。</li><li>env:Fault元素包含两个子元素：env:code和env:reason</li></ul></li><li>NotUnderstood Message<ul><li>在处理 SOAP 消息的过程中，如果某个必需的头部元素无法被理解，或者其中包含的信息无法被处理，则可能会产生一个错误。<br>处理头部块时的错误同样会通过 <strong>env:Fault</strong> 元素在 <strong>env:Body</strong> 中进行通知，但不会使用 <strong>Detail</strong> 子元素。<br>相反，SOAP 错误命名空间中一个特殊的头部元素 <strong>Misunderstood</strong> 会被用来标识引发错误的头部。</li></ul></li></ul><h3 id="5-2-Web-Service接口定义语言WSDL"><a href="#5-2-Web-Service接口定义语言WSDL" class="headerlink" title="5.2 Web Service接口定义语言WSDL"></a>5.2 Web Service接口定义语言WSDL</h3><ul><li><p>WSDL的概念</p><ul><li><strong>功能</strong>：WSDL 对服务能力、服务中使用的数据结构以及传输绑定给出定义和描述；提供了一种基于 XML 的标准接口定义语言&#x2F;服务能力定义语言，用以在服务的提供者&#x2F;调用者&#x2F;服务注册之间，交换必要的有关的 web service 的信息。<strong>WSDL 的核心是描述 Web 服务的接口和操作，以及如何访问这些操作的消息格式和传输协议。</strong></li><li><img src="image-20241210103612279.png" alt="image-20241210103612279" style="zoom:67%;" /></li></ul></li><li><p><strong>WSDL结构</strong></p><ul><li><img src="image-20241210104015754.png" alt="image-20241210104015754" style="zoom:67%;" /></li><li><p>以 description 元素为根节点。</p></li><li><p>import、include：拼装不同部门&#x2F;组织定义的文档，形成完整的 WSDL 语义</p><p>| 特性         | import                                 | include                               |<br>| ———— | ————————————– | ————————————- |<br>| <strong>命名空间</strong> | 用于导入<strong>不同命名空间</strong>的定义         | 用于包含<strong>相同命名空间</strong>的定义        |<br>| <strong>用途</strong>     | 重用其他命名空间的 WSDL 或 XSD 定义    | 拆分当前命名空间内的 WSDL 或 XSD 文件 |<br>| <strong>属性</strong>     | 必须包含 <code>namespace</code> 和 <code>location</code>     | 只需包含 <code>location</code>                   |<br>| <strong>常见场景</strong> | 引入外部服务接口或跨命名空间的数据结构 | 拆分 WSDL 定义以简化管理              |</p></li><li><p>抽象部分：</p><ol><li>Types：使用到的数据结构或者叫数据格式范式，独立于语言和平台</li><li>Interface : operation 的集合，即服务能力的集合，描述服务能力。operation : input、output、infault、outfault</li></ol></li><li><p>具体部分：</p><ol><li>Binding：特定端口类型的具体协议和数据格式规范的绑定，即把抽象消息格式转化为具体的消息格式（Interface关注服务具体内容，Binding关注如何转换）</li><li>Service：对服务整体的抽象，包含若干个 endpoint。endpoint：在binding和interface间创建映射</li></ol></li></ul></li><li><p><strong>MEP：消息交换模式</strong></p><ul><li>8种预定义，四种基本</li><li><img src="image-20241210105203594.png" alt="image-20241210105203594" style="zoom:67%;" /></li><li><img src="image-20250106110600885.png" alt="image-20250106110600885" style="zoom:80%;" /></li></ul></li><li><p><strong>Message Dispatch</strong>：是一种与 SOAP 消息交换模式相关的机制，用于根据消息内容或格式将请求路由到正确的服务端处理逻辑。它本质上描述了 Web 服务如何根据消息的结构和类型来分发和处理请求。</p></li><li><img src="image-20241210105902896.png" alt="image-20241210105902896" style="zoom:67%;" /></li></ul><h2 id="6-Web-Service-扩展"><a href="#6-Web-Service-扩展" class="headerlink" title="6. Web Service 扩展"></a>6. Web Service 扩展</h2><h3 id="6-1-UDDI"><a href="#6-1-UDDI" class="headerlink" title="6.1 UDDI"></a>6.1 UDDI</h3><ul><li>概念<ul><li>UDDI被用来提供发布和查找Web Service的元服务。它可以用来针对丰富的元信息进行查找</li><li>UDDI采用XML格式，来存放注册Web Service的描述信息</li></ul></li><li><strong>UDDI结构</strong><ul><li><img src="image-20241210110514067.png" alt="image-20241210110514067" style="zoom:67%;" /></li><li><img src="image-20241210110625890.png" alt="image-20241210110625890" style="zoom:67%;" /></li></ul></li><li><strong>WSDL与UDDI的对应关系</strong><ul><li><img src="image-20241210110753583.png" alt="image-20241210110753583" style="zoom:67%;" /></li></ul></li><li>UDDI的使用<ul><li>对于分类、编目和管理Web服务，UDDI注册库提供了一个标准方式，以便于能够发现和使用这些Web服务<ul><li>业务和提供者可以按标准方式使用UDDI来表示Web服务信息</li><li>UDDI使用SOAP作为它的传输层</li></ul></li><li>UDDI API是一个接口，可以接受封装在SOAP信封中的XML消息<ul><li>所有的UDDI交互都使用请求&#x2F;响应模式</li><li>可以使用出查询API来搜索和读取UDDI注册库中的数据，并可使用发布API来添加、更新和删除UDDI注册库中的数据</li></ul></li><li>UDDI发布API<ul><li><img src="image-20241210111134770.png" alt="image-20241210111134770" style="zoom: 50%;" /></li></ul></li><li>UDDI查询API<ul><li><img src="image-20241210111338423.png" alt="image-20241210111338423" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h3 id="6-2-WS-协议"><a href="#6-2-WS-协议" class="headerlink" title="6.2 WS-*协议"></a>6.2 WS-*协议</h3><ul><li><strong>BPEL</strong>：采用标准协议的XML脚本描述服务组合方式</li><li><strong>Web-Addressing</strong>：用于消息分发<ul><li>请求消息<ul><li><img src="image-20241210122420047.png" alt="image-20241210122420047" style="zoom:67%;" /></li><li>元数据中包含WSDL，WSDL包含action以确定要调用的服务，SOAP消息中包含一个全局唯一的会话标记ID和FROM&#x2F;TO信息</li></ul></li><li>响应消息（右下）与请求消息（左上）对应关系<ul><li><img src="image-20241210122647438.png" alt="image-20241210122647438" style="zoom:67%;" /></li></ul></li></ul></li><li>WSRF : Web Service 资源框架，用于实现带状态的服务</li><li>WS-Sercurity：通过在SOAP头块中进行相关定义来实现安全性需求<ul><li><img src="image-20241210123713915.png" alt="image-20241210123713915" style="zoom:67%;" /></li></ul></li><li>WS-Coordination：主要包括WSAT（原子事务）和WSBA（商业活动）<ul><li><img src="image-20241210123805065.png" alt="image-20241210123805065" style="zoom: 80%;" /></li><li><img src="image-20241210123831641.png" alt="image-20241210123831641" style="zoom: 80%;" /></li></ul></li></ul><h2 id="7-服务生态系统的构建"><a href="#7-服务生态系统的构建" class="headerlink" title="7. 服务生态系统的构建"></a>7. 服务生态系统的构建</h2><ul><li><p>服务生命周期的基本阶段：面向服务的分析、设计，服务的开发、测试、部署、管理</p></li><li><p>业务逻辑：源于企业业务领域，业务需求的文档化实现</p></li><li><p>应用逻辑：组织成不同技术解决方案的业务逻辑的自动化实现</p></li><li><p>服务的层次</p><ul><li>最上层：编排层</li><li>中层：服务接口层<ul><li>应用服务：对底层的应用逻辑进行封装的服务</li><li>业务服务：用于满足服务调用者的业务需求的服务<ul><li>以任务为核心的（业务）服务</li><li>实体服务</li><li><img src="image-20241210200635130.png" alt="image-20241210200635130" style="zoom:67%;" /></li></ul></li><li>编排服务（可选）：对业务服务进行组合形成的新服务</li></ul></li><li><img src="image-20241210195306037.png" alt="image-20241210195306037" style="zoom: 80%;" /></li><li><img src="image-20241210195538392.png" alt="image-20241210195538392" style="zoom:67%;" /></li></ul></li><li><p><strong>业务服务与编排</strong></p><ul><li>编排能够组合以任务为核心的业务服务及以实体为核心的业务服务</li><li>基本的业务模型由以实体为核心的服务来表示</li><li>与业务逻辑相关的任务由以任务为核心的服务来表示</li><li>在不影响业务服务和应用服务的前提下进行业务规则和业务逻辑的变更</li></ul></li><li><p><strong>面向服务的交付策略</strong></p><ul><li>自顶向下：分析优先<ul><li>定义企业范围的相关本体（领域知识的概念及其关联）</li><li>将相关的业务模型（包括实体模型）与新的或修订后的本体匹配</li><li>进行面向服务的分析</li><li>进行面向服务的设计</li><li>开发所需服务</li><li>测试和部署服务</li></ul></li><li>自底向上：按需交付，封装并集成遗留系统优先<ul><li>对所需的应用服务进行建模，多为混合（应用）服务，即合并业务服务与应用服务。</li><li>设计所需的应用服务</li><li>开发所需的应用服务</li><li>测试和部署服务</li></ul></li><li><img src="image-20241210200118926.png" alt="image-20241210200118926" style="zoom: 67%;" /></li><li><img src="image-20241210200134384.png" alt="image-20241210200134384" style="zoom:67%;" /></li></ul></li><li><p>面向服务的设计</p><ul><li><p>在面向服务设计的过程中，通过从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中</p></li><li><p>设计过程</p><ul><li><p>组合SOA</p><ul><li>选择服务层</li><li>定位核心的SOA 标准</li><li>选择SOA 扩展</li></ul></li><li><p>设计服务</p></li></ul></li></ul></li></ul><ul><li>设计以实体为核心的业务服务<ul><li>设计应用服务</li></ul></li><li>设计以任务为核心的业务服务<ul><li>设计面向服务业务过程</li></ul></li></ul><h2 id="8-服务设计原则"><a href="#8-服务设计原则" class="headerlink" title="8. 服务设计原则"></a>8. 服务设计原则</h2><h4 id="标准化服务合约"><a href="#标准化服务合约" class="headerlink" title="标准化服务合约"></a>标准化服务合约</h4><ul><li>概念：使用形式化或者标准化的合约</li><li>服务合约设计的相关风险<ul><li>版本化：底层逻辑越是可复用，那些需要消费它的程序的数量和消费频率就会越大，拓展难度大，从而导致发布新的服务版本的要求</li><li>技术依赖：操作性系统层（编程语言和开发平台）的技术性变化导致服务合约变化</li><li>开发工具缺陷：使用开发工具自动生成合约可能产生非标准化的服务合约</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>标准化服务合约与服务松散耦合<ul><li>消费者和服务之间存在对服务合约中技术接口的依赖<ul><li>技术服务合约越详细，越内容丰富，消费者和服务之间的依赖关系越强</li><li>两个服务之间所达到的松散耦合程度直接与在服务合约中的依赖关系数量相关</li></ul></li><li>标准化的合约将会有助于提高服务之间的一致性和耦合质量</li></ul></li><li>标准化服务合约与服务抽象<ul><li>服务抽象原则要求简化合约：非核心信息都被隐藏</li><li>服务合约的设计决定了抽象的程度：在合约中的内容越仔细，服务中被抽象的信息就越少</li></ul></li><li>标准化服务合约与服务可复用性<ul><li>服务可复用性原则常常侧重于服务封装的逻辑是否足够一般和通用</li><li>可复用方案逻辑与数据交换之间的关系最终要由服务合约是如何设计的来决定</li><li>服务合约越是通用、灵活和可扩展，服务的长远复用潜力就越大</li></ul></li><li>标准化服务合约与服务可发现性<ul><li>服务合约越是得到一致的标注和结构化，对于那些需要使用它们的人来说就越是可以预测的</li><li>服务合约越是标准化，元信息的技术接口细节提供得越是充分，服务的可发现性就越高</li></ul></li><li>标准化服务合约与服务可组合性<ul><li>服务的可组合性需求常常与服务合约表达其能力的粒度有关</li><li>粗粒度的操作拥有更高的效率，但常常不适应于需要参与到更大规模组合中的服务</li></ul></li></ul><h4 id="服务松散耦合"><a href="#服务松散耦合" class="headerlink" title="服务松散耦合"></a>服务松散耦合</h4><ul><li>概念：调节技术合约内容的数量和复杂度，从而最小化消费者依赖需求</li><li>服务合约耦合类型<ul><li>“逻辑-合约”耦合(积极)：首先设计合约，然后再设计底层的方案逻辑。允许对底层逻辑进行微调以支持服务合约</li><li>“合约-逻辑”耦合(消极)：从现有的方案逻辑当中生成Web Services</li><li>“合约-技术”耦合(消极)：有的时候服务是作为传统专用组件存在的，这就需要服务合约与服务相关的通信技术紧密地耦合</li><li>“合约-实现”耦合(消极)：实现相关的特性和细节在服务合约的内容中体现出来</li><li>“合约-功能”耦合(消极)：由一个服务所封装的逻辑被专门设计为支持服边界之外的功能体</li></ul></li><li>服务消费者耦合的类型<ul><li>“消费者-实现”耦合(消极)：绕过服务合约，直接使用其他入口访问服务</li><li>“消费者-合约”耦合(积极)：采用合约集中化，将对服务的访问控制在合约内</li></ul></li><li>可能的风险<ul><li>“逻辑-合约”耦合的限制<ul><li>同一底层逻辑对应两个或者多个合约，从而建立多个入口，每一入口向不同类型的消费者暴露不同的服务能力</li></ul></li><li>Schema 耦合太“松散”：<ul><li>为了强调服务的兼容性演化能力，通过过分简化服务合约，追求减少消费者依赖，仅确定了一些非常通用的数据类型（弱类型）</li><li>验证并处理弱类型，增加服务所需的性能要求</li><li>服务合约发布的信息越少，消费者程序就需要知道越多关于服务实现逻辑的信息，从而产生消极耦合</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务松散耦合与标准化服务合约<ul><li>松散耦合鼓励调节技术合约内容的数量和复杂度，从而最小化消费者依赖需求、最大化服务所有者的自由度，在不影响现有消费者的情况下随着时间演化和改变服务</li></ul></li><li>服务松散耦合与服务抽象<ul><li>创建更低耦合的消费者关系，明确地要求应用良好定义的功能和技术抽象级别</li></ul></li><li>服务松散耦合与服务可复用性<ul><li>减少依赖关系可以使服务更容易被组合、演化甚至扩充以支持不断变化的业务需求和方向</li></ul></li><li>服务松散耦合与服务自治<ul><li>减少消极耦合类型的程度，会为运行时和设计时的更高自治级别提供支持</li><li>服务消费者具有越多的跨服务依赖，它所具有的自主权就越少（服务消费者可能同时担任复合服务中的服务协调者）</li></ul></li><li>服务松散耦合与服务可发现性<ul><li>服务松散耦合有助于元数据的调节</li></ul></li><li>服务松散耦合与服务可组合性<ul><li>在服务组合中，避免消极形式的耦合<ul><li>“合约-逻辑”耦合 如果服务合约是自动生成的，就很有可能在被其他服务使用时不符合标准。因此需要在它和其他组成成员之间进行转换</li><li>“合约-技术”耦合 如果同一个组合中的不同部分同时使用开放与专用服务技术，就会需要在本地实现技术转化层</li><li>“合约-实现”耦合 当一个服务合约与底层实现特性之间产生耦合时，就会最终把这些性质强加到作为一个整体的组合之上</li></ul></li></ul></li></ul><h4 id="服务抽象"><a href="#服务抽象" class="headerlink" title="服务抽象"></a>服务抽象</h4><ul><li>概念：获得信息隐藏的正确平衡点，即对哪一部分服务信息进行隐藏，哪一部分公开</li><li>可能的风险<ul><li>多消费者耦合的需求：不同消费者可能需要不同的技术接口细节，所需的抽象程度也不尽相同</li><li>人为误判<ul><li>过于抽象的服务合约导致曲解或不能充分理解一个服务。从而丧失潜在的复用机会</li><li>过于具体的服务合约导致对服务的行为作出与服务实现相关的假设，从而导致实现耦合</li></ul></li><li>安全和隐私的考虑：服务合约可能暴露私有或者敏感信息</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务抽象与标准化服务合约<ul><li>服务抽象出来并对外界可用的信息就是服务合约，服务抽象原则的应用影响到服务合约</li><li>服务合约的设计标准也会影响到功能、技术和逻辑抽象的等级</li></ul></li><li>服务抽象与服务松散耦合<ul><li>抽象的程度对可能耦合的程度有直接的关系</li><li>少量的高度详细的技术接口约束会导致比大量含糊或开放的数据约束更多的紧密耦合需求<ul><li>耦合的程度一般由被抽象的信息数量和信息本身的属性的组合来决定</li><li>最终由服务合约的粒度加以体现</li></ul></li></ul></li><li>服务抽象与其他原则<ul><li>其他的服务设计原则，如服务可复用性、服务可组合性和服务可发现性等原则都鼓励创建更多的、关于服务的元信息</li><li>而服务的抽象原则要求在发布这些元信息前评估其必要程度</li></ul></li></ul><h4 id="服务可复用性"><a href="#服务可复用性" class="headerlink" title="服务可复用性"></a>服务可复用性</h4><ul><li>概念：尽可能让服务被更多地复用</li><li><strong>可能的风险</strong><ul><li>文化上的考虑<ul><li>当项目团队被要求遵守特定可重用服务的逻辑集中化时，会出现常见的文化问题</li></ul></li><li>治理上的考虑<ul><li>面向服务将相互无关的逻辑单元抽象为服务，与业务流程、应用程序或用户基础都没有任何直接联系</li></ul></li><li>可靠性上的考虑<ul><li>可复用服务的单点失效会导致多个业务流程的失</li><li>通过对关键服务的多重复用来解决</li></ul></li><li>安全上的考虑<ul><li>在不同应用场景中的安全性要求不同</li><li>安全级别可能和信息交换的方式直接相关，甚至可能和服务合约所暴露的功能类型相关</li></ul></li><li>商业设计需求上的考虑<ul><li>领域专家在进行服务分析和建模阶段中引入的风险和问题</li></ul></li><li>敏捷交付上的考虑<ul><li>在需要以敏捷开发方法来解决短期和战术上的业务目标时，提倡服务的可复用性是非常困难的</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可复用性与标准化服务合约<ul><li>可复用的服务需要足够的灵活性来支持带有不同交互需求的消费者</li><li>导致降低合约验证约束（尤其是那些易变的）的设计标准</li></ul></li><li>服务可复用性与服务抽象<ul><li>合约的自描述性与简洁之间的平衡</li><li>元信息的抽象程度反映这一平衡</li></ul></li><li>服务可复用性与服务松散耦合<ul><li>一个服务的依赖需求越小，复用它就越简单</li><li>当追求服务逻辑的可复用性时，总是有一种减少服务合约约束的趋势</li></ul></li><li>服务可复用性与其他原则<ul><li>服务自治<ul><li>自治是对可复用服务潜在高性能和并行使用的保证</li></ul></li><li>服务无状态<ul><li>通过最小化状态管理责任，提高一个服务的可用性，从而提高有效扩展的能力</li></ul></li><li>服务可发现性<ul><li>可复用服务必需可发现、可解释</li></ul></li><li>服务可组合性<ul><li>可组合是复用的一种形式，可复用潜能越大，服务被反复组装的机会就越大</li></ul></li></ul></li></ul><h4 id="服务自治"><a href="#服务自治" class="headerlink" title="服务自治"></a>服务自治</h4><ul><li>概念：服务的自治，表现了它可以独立执行自身核心服务逻辑的能力</li><li>分类<ul><li>共享自治</li><li>部分隔离服务：只共享数据库、目录等资源</li><li>完全自治<ul><li>功能隔离：服务构件和物理数据模型是专用的，但是服务位于一个与其他服务共享的服务器上</li><li>绝对隔离：服务构件和相关的数据模型都位于专用服务器上</li><li>设计时隔离：从设计开始，就对服务设计、数据模型和宿主环境等，拥有完全的管理权</li></ul></li></ul></li><li>可能的风险<ul><li>错误地判断服务的范围</li><li>包装服务和遗留逻辑封装：无法改变的自动化系统无法回避自治问题</li><li>对服务需求的过高估计：过于追求高自治</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务自治与标准化服务合约<ul><li>服务合约自治直接与服务合约紧密相连</li><li>规范化的考虑会影响到合约如何形成，以及如何与其他服务协调</li><li>在服务合约上有越大的控制权，服务合约能被更好地定制和标准化，越能够确保底层实现可以在遵循既定自治级别的前提下，被独立设计</li></ul></li><li>服务自治与服务松散耦合<ul><li>由于同样期望将服务之间的依赖最小化，服务自治在很大程度上支持服务松散耦合原则<ul><li>积极耦合会直接导致设计时自治的增加；设计时自治的增加，又能更好地增强和优化服务的实现，从而持运行时的自治</li></ul></li></ul></li><li>服务自治与服务抽象<ul><li>将一个服务的自治级别作为整个服务合约的一部分来发布</li><li>服务自治的信息是服务质量信息抽象的一个例子</li></ul></li><li>服务自治与服务可复用性<ul><li>自治的增加提高了一个服务的复用潜力</li><li>通过增强服务的可靠性和提高服务行为的可预测性，其逻辑可以更加容易地适应多个服务消费者的需求</li><li>更好地支持服务运行环境的演化，从而应对复用所带来的并发要求</li></ul></li><li>服务自治与服务无状态性<ul><li>实现高级别的服务自治可以直接支持服务无状态性程度的增加</li></ul></li><li>服务自治与服务可组合性<ul><li>服务组合的整体自治性取决于它的所有组成成员自身的自治性</li><li>服务有越好的可靠性和可预侧性就越能组成更高效的大型服务组合</li></ul></li></ul><h4 id="服务无状态性"><a href="#服务无状态性" class="headerlink" title="服务无状态性"></a>服务无状态性</h4><ul><li>概念：服务要尽量减少对状态信息的保存，从而减少资源消耗，满足尽可能多的消费者程序的需要</li><li><strong>可能的风险</strong><ul><li>对于架构的依赖<ul><li>要建立服务设计和一个外部状态延迟选项的相互依赖关系</li><li>需要权衡这种依赖关系和延迟状态所带来的好处</li></ul></li><li>增加的运行时性能需求<ul><li>在从无状态到有状态进行切换时，可能会需要找回、解析然后再在服务中执行状态数据，引入额外的性能开销</li></ul></li><li>低估交付代价<ul><li>特定于活动的数据需要在运行过程中被接收、解析、处理和延迟，包含复杂的算法和例程。这不仅会带来额外的设计考虑，还伴随着确保该服务能够处理大量可能的情况和大量的活动数据所需要的编程和测试的代价</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务无状态性与服务可复用性<ul><li>减少活动相关逻辑使一个服务变得更加无关（而无关服务具有更好的可复用性）</li><li>提高服务的可扩展性和可用性使得它们可以在更多的服务组合中被更多的服务消费者复用</li></ul></li><li>服务无状态性与服务自治<ul><li>状态信息的本质通常是特定于一个给定的活动或者业务流程的，通过在服务边界外改变状态管理机制和流程的职责，就可以降低服务逻辑依赖于更大的业务任务的可能性。这使得服务能够更加自给自足，并且能够被定位成技术环境的一个独立部分，因而直接增加其整体自治性</li><li>另一方面，由环境架构所提供的状态管理延迟选项可要求服务形成在其边界外的一个直接依赖。这种类型的外部实现耦合会影响到一个服务的整体自治</li></ul></li></ul><h4 id="服务可发现性"><a href="#服务可发现性" class="headerlink" title="服务可发现性"></a>服务可发现性</h4><ul><li>概念：帮助调用方确定得要完成的自动化需求是否已经存在于服务库存中</li><li>可能的风险<ul><li>可发现性在实施后的应用<ul><li>在服务定义完毕后，再记录元数据，甚至由其他人员来加以记录，从而导致发现性和可解释性元数据的质量的损失</li><li>应当在设计阶段，早于服务最初发布时，就把那些元信息添加到文档中</li></ul></li><li>由不擅交流的人员来应用本原则<ul><li>如果可发现性信息仅仅是由业务或者技术专家创建的，那么它很可能不足以应付其他的项目组成员的使用</li></ul></li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可发现性与标准化服务合约<ul><li>使服务更加容易可发现和可解释会影响服务合约的内容</li><li>服务可发现性会直接地影响功能表达设计标准的确定</li></ul></li><li>服务可发现性与服务抽象<ul><li>服务抽象的原则需要减少合约当中所发布的信息数量；服务可发现性则要求提供更多的信息；两者之间需要取得平衡</li><li>一旦实现了可发现性和抽象之间的适当的平衡，那么随后实现的服务的可发现性将基于那些已发布的（而不是被抽象的）元信息</li></ul></li><li>服务可发现性与服务可复用性<ul><li>强调服务可发现性的主要目的是支持服务可复用性</li><li>当表述可复用功能时，应当应用可发现性相关的设计标准，以保证能通过实际的技术合约把服务的目的和能力尽可能清楚地表述出来</li></ul></li><li>服务可发现性与服务可组合性<ul><li>潜在的组合成员应当容易定位和识别，以避免在无意间创建冗余的服务逻辑</li><li>当服务组合为了适应上层业务流程的变化或者为了增加整体的业务需求实现而发生演变时，需要查找从组合的原始版本创建以来，新加入的服务和功能</li></ul></li></ul><h4 id="服务可组合性"><a href="#服务可组合性" class="headerlink" title="服务可组合性"></a>服务可组合性</h4><ul><li>概念：让服务可以被其他服务组合，或通过组合其他服务来实现设计需求</li><li>可能的风险<ul><li>组合成员成为单点失效的源头</li><li>组合成员成为性能瓶颈</li><li>对于组合中“过度复用”所带来的治理强度</li></ul></li></ul><p><strong>和其他原则的关系</strong></p><ul><li>服务可组合性与标准化服务合约<ul><li>服务可组合性的应用强调服务间需要一致的合约标准</li><li>由服务可组合性原则引起的考虑可以用来帮助形成服务合约设计标准，以便支持特定于组合（尤其是复杂的组合）的需求。</li></ul></li><li>服务可组合性与服务松散耦合<ul><li>服务所具有的依赖关系会造成一些根本性的约束，直接制约服务能够达到的可组合性级别</li></ul></li><li>服务可组合性与服务抽象<ul><li>当抽象被应用到复杂组合被隐藏的程度时，对这些组合高效可靠地执行的要求被大大放大。作为回报，组合所有者可以更好地控制如何改进组合配置。</li></ul></li><li>服务可组合性与服务可复用性<ul><li>当一个成熟的服务库存建立起来的时候，服务组合就成为最常用的服务复用方式<ul><li>可复用但不可组合（参与多个点对点活动）</li><li>可组合但不可复用（很高的“服务-消费者”耦合）</li></ul></li></ul></li><li>服务可组合性与服务自治<ul><li>这两个原则之间是“整体-部分”的关系</li><li>控制器服务在组合其他服务时需要牺牲其自治性（等价于对所有涉及的服务组合成员的自治性的综合度量结果）</li><li>服务自治性的提高有助于产生高效的组合成员</li></ul></li><li>服务可组合性与服务无状态性<ul><li>尽可能地减轻每个组合成员在状态管理方面的责任，可以更精细、更优化地执行整体的组合实例</li><li>为了能够在同一个服务库存中重复地装配出高效的服务组合，服务之间需要能够通过一致并且有效的方式共享状态数据</li></ul></li><li>服务可组合性与服务可发现性<ul><li>作为组合控制器的服务能力可以负责描述它所封装的整个组合逻辑，并达到服务抽象原则所允许的任意程度</li></ul></li></ul><h2 id="9-Web开发部分"><a href="#9-Web开发部分" class="headerlink" title="9. Web开发部分"></a>9. Web开发部分</h2><ul><li><img src="image-20250106151751982.png" alt="image-20250106151751982" style="zoom:80%;" /></li><li><p><img src="image-20250106152417263.png" alt="image-20250106152417263"></p></li><li><p>JAXB如何做类型映射和操作XML？</p><ul><li>JAXB是 Java 提供的一个框架，用于将 Java 对象与 XML 数据相互转换（即序列化和反序列化）。它通过自动生成的映射类和注解来简化操作 XML 的过程。</li><li>Java到XML的映射<ul><li>使用 <strong>JAXB 注解</strong> 来控制映射细节</li><li><img src="image-20250106151941714.png" alt="image-20250106151941714" style="zoom:80%;" /></li></ul></li></ul></li><li><p>JAX-WS的三种开发模式</p><ul><li>Start from Java<ul><li>这是最简单的开发方式，先编写 Java 类，然后通过工具生成 Web Service 和 WSDL 文件。</li></ul></li><li>Start from WSDL</li><li>这种模式是先定义服务契约（WSDL 文件），然后生成 Java 代码。</li><li>Start from WSDL and Java<ul><li>从 WSDL 和 Java 混合开发</li><li>需要在服务契约和业务逻辑之间找到平衡，既要对 WSDL 进行自定义，又希望减少开发工作量。</li></ul></li></ul></li><li><p>CLient端和Server端的exception</p><ul><li><p>客户端（Client）端的两种异常</p><ol><li><strong><code>SOAPFaultException</code></strong><ul><li>这是客户端在调用服务端时收到的 SOAP 错误响应。</li><li>发生场景：当服务端返回的响应中包含了 SOAP 的 <code>Fault</code> 元素时，会在客户端抛出该异常。</li><li>特点：<ul><li>表示服务端处理请求时发生的逻辑或应用级错误。</li><li>客户端通过 <code>getFaultCode()</code> 和 <code>getFaultString()</code> 方法可以获取错误的详细信息。</li></ul></li></ul></li><li><strong><code>WebServiceException</code></strong><ul><li>是 JAX-WS 中的通用异常，表示客户端无法成功调用 Web 服务。</li><li>发生场景：<ul><li>通信错误（例如无法连接服务端、超时等）。</li><li>SOAP 消息格式错误。</li><li>客户端处理响应时遇到错误。</li></ul></li><li>特点：<ul><li>是一个运行时异常（RuntimeException）。</li><li>可以通过 <code>getMessage()</code> 方法查看异常的描述信息。</li></ul></li></ul></li></ol></li><li><p>服务端（Server）端的三种异常</p><ol><li><strong><code>SOAPFaultException</code></strong><ul><li>服务端主动创建并返回给客户端的异常，表示服务端在逻辑处理时遇到了问题。</li><li>发生场景：服务端检测到业务逻辑问题或其他错误，需要向客户端返回详细的 SOAP 错误信息。</li><li>特点：<ul><li>服务端在代码中可以主动抛出 <code>SOAPFaultException</code>。</li><li>在响应中以 SOAP 的 <code>Fault</code> 元素返回。</li></ul></li></ul></li><li><strong><code>ProtocolException</code></strong><ul><li>表示通信协议（如 HTTP 或 HTTPS）层出现问题。</li><li>发生场景：<ul><li>服务端接收到的请求在传输层有问题（例如 HTTP 头错误）。</li><li>服务端响应消息的协议部分不符合规范。</li></ul></li><li>特点：<ul><li>这种异常可能不会明确反馈给客户端，而是在服务端日志中捕获。</li></ul></li></ul></li><li><strong><code>WebServiceException</code></strong><ul><li>服务端的通用异常，表示服务端处理请求时遇到了不可恢复的错误。</li><li>发生场景：<ul><li>内部逻辑错误（例如数据库连接失败）。</li><li>服务端无法解析客户端的请求。</li><li>服务端配置错误。</li></ul></li><li>特点：<ul><li>也是一个运行时异常。</li><li>通常会被框架捕获，或者通过 SOAP <code>Fault</code> 元素反馈给客户端。</li></ul></li></ul></li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XML</tag>
      
      <tag>面向服务架构</tag>
      
      <tag>Web Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础</title>
    <link href="/2024/07/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据管理基础"><a href="#数据管理基础" class="headerlink" title="数据管理基础"></a>数据管理基础</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li><p>数据(Data)</p><ul><li>是数据库中存储的基本对象</li><li>定义：描述事物的符号记录</li><li>数据的含义称为数据的语义，数据与其语义是不可分的。</li></ul></li><li><p>数据库</p><ul><li>定义：是<strong>长期</strong>储存在计算机内、有<strong>组织</strong>的、可<strong>共享</strong>的<strong>大量</strong>数据的集合</li></ul></li><li><p>数据库管理系统（Database Management System ，简称 DBMS）</p><ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul></li></ul><span id="more"></span><ul><li><p>数据库系统（Database System ，简称 DBS）</p><ul><li><p>在计算机系统中引入数据库后的系统构成</p></li><li><p>构成</p><img src="image-20240309103511321.png" alt="image-20240309103511321" style="zoom:50%;" /></li></ul></li></ul><h3 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h3><ul><li><p>数据模型：对现实世界数据特征的抽象，用以抽象、表示和处理</p><ul><li>概念模型&#x2F;信息模型：按用户的观点来对数据和信息建模，用于数据库设计</li><li>逻辑模型：按计算机系统的观点对数据建模，用于 DBMS 实现</li><li>物理模型：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。</li><li>数据模型的组成：数据结构、数据操作、数据的完整性约束条件</li></ul></li><li><p>概念模型</p><ul><li>实体(Entity)：客观存在并可相互区别的事物</li><li>属性(Attribute)：实体所具有的某一特性</li><li>码(Key)：唯一标识实体的属性集</li><li>实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li><li>实体集(Entity Set)：同一类型实体的集合称为实体集</li><li>联系(Relationship)：界中反映为实体(型)内部的联系和实体(型)之间的联系。</li></ul></li><li><p>逻辑模型</p><ul><li><img src="image-20240309105048278.png" alt="image-20240309105048278" style="zoom:50%;" /></li><li>关系模型<img src="image-20240309105243092.png" alt="image-20240309105243092" style="zoom:50%;" /></li><li>关系的完整性约束条件<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul></li><li><p>数据库系统结构</p><ul><li>模式(Schema)：数据库逻辑结构和特征的描述，是型的描述，不涉及具体值，相对稳定</li><li>实例(Instance)：反映数据库某一时刻的状态，同一个模式可以有很多实例，随数据库中的数据的更新而变动</li></ul></li><li><p>三级模式结构</p><ul><li><img src="image-20240309105725766.png" alt="image-20240309105725766" style="zoom: 50%;" /></li><li>模式(也称逻辑模式)<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>与数据的物理存储细节和硬件环境无关</li><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li></ul></li><li>外模式(也称子模式或用户模式)<ul><li>数据库用户(包括应用程序员和最终用户)使用的<strong>局部</strong>数据的逻辑结构和特征的描述</li><li>模式与外模式的关系：一对多</li><li>外模式通常是模式的子集，反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li><li>内模式(也称存储模式)<ul><li>是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式</li><li>一个数据库只有一个内模式</li></ul></li><li>二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换：外模式／模式映像、模式／内模式映像</li></ul></li><li><p>数据库系统人员</p><ul><li>最终用户(交互式用户)<ul><li>临时用户(用SQL语句访问DBMS的用户)</li><li>缺乏经验的用户(通过菜单访问DBMS的用户)</li></ul></li><li>应用管理员(编写菜单程序的程序员)</li><li>数据库管理员(DBA):在数据库系统中，负责数据库的设计、建立、日常管理和运行维护的人员。</li></ul></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-关系模型"><a href="#1-关系模型" class="headerlink" title="1.关系模型"></a>1.关系模型</h3><table><thead><tr><th>关系数据库管理系统</th><th>关系模型</th><th>文件系统</th></tr></thead><tbody><tr><td>表</td><td>关系</td><td>记录文件</td></tr><tr><td>列</td><td>属性</td><td>域</td></tr><tr><td>行</td><td>元组</td><td>记录</td></tr><tr><td>表头</td><td>模式</td><td>记录类型</td></tr></tbody></table><ul><li><p>关系规则</p><ul><li>关系模型不允许有多值属性</li><li>只能基于内容存取行规则</li><li>行唯一性规则</li><li>实体完整性规则</li></ul></li><li><p>域：一组具有相同数据类型的值的集合</p></li><li><p>笛卡尔积：<img src="image-20240309150243038.png" alt="image-20240309150243038" style="zoom:50%;" /></p></li><li><p>元组(Tuple)：笛卡尔积中每一个元素叫作一个n元组或简称元组，每个值叫做一个分量</p><img src="image-20240309150407183.png" alt="image-20240309150407183" style="zoom: 67%;" /></li><li><p>基数：笛卡尔积的基数为每个子域基数的乘积</p></li><li><p>笛卡尔积的表示方法</p><ul><li><p>笛卡尔积可表示为一张二维表</p></li><li><p>表中的每行对应一个元组，表中的每列对应一个域</p></li></ul></li><li><p>关系：</p><ul><li><img src="image-20240309151216804.png" alt="image-20240309151216804" style="zoom:50%;" /></li></ul></li></ul><ul><li>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域<ul><li>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li><li>不同的列可出自同一个域，行列顺序无所谓</li></ul></li></ul><ul><li><p>码</p><ul><li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</li><li>主码：若一个关系有多个候选码，则选定其中一个为主码</li><li>主属性：候选码的诸属性称为主属性，不包含在任何侯选码中的属性称为非主属性或非码属性</li><li>任意两个元组的候选码不能相同</li></ul></li><li><p>关系模式是型，关系是值，关系模式是对关系的描述</p><ul><li><img src="image-20240309152157704.png" alt="image-20240309152157704" style="zoom:50%;" /></li><li>关系模式和关系往往笼统称为关系</li></ul></li></ul><h3 id="2-关系的完整性"><a href="#2-关系的完整性" class="headerlink" title="2.关系的完整性"></a>2.关系的完整性</h3><ul><li><p>实体完整性</p><ul><li>若属性A是基本关系R的主属性，则属性 A 不能取空值</li><li>空值就是<strong>不知道</strong>或<strong>不存在</strong>或<strong>无意义</strong>的值</li></ul></li><li><p>关系间的引用</p><ul><li><p>在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用</p></li><li><img src="image-20240309154348254.png" alt="image-20240309154348254" style="zoom:50%;" /></li><li><img src="image-20240309154400798.png" alt="image-20240309154400798" style="zoom:50%;" /></li><li><img src="image-20240309154421325.png" alt="image-20240309154421325" style="zoom:50%;" /></li><li><p>外码</p><ul><li><p>引用的其他关系的码，引用其他关系码的关系叫参照关系，被引用的码对应的关系叫被参照关系</p></li><li><p>外码并不一定要与相应的主码同名</p></li><li><p>目标关系S的主码Ks和参照关系的外码F必须定义在同一个（或一组）域上</p></li><li><img src="image-20240309154814760.png" alt="image-20240309154814760" style="zoom:50%;" /></li><li><img src="image-20240309154825229.png" alt="image-20240309154825229" style="zoom:50%;" /></li><li><img src="image-20240309154839012.png" alt="image-20240309154839012" style="zoom:50%;" /></li></ul></li></ul></li><li><p>参照完整性</p><ul><li><img src="image-20240309155511079.png" alt="image-20240309155511079" style="zoom:50%;" /></li><li><img src="image-20240309155609399.png" alt="image-20240309155609399" style="zoom:50%;" /></li></ul></li><li><p>用户定义的完整性</p><ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li><li><img src="image-20240309160436720.png" alt="image-20240309160436720" style="zoom: 50%;" /></li></ul></li></ul><h3 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3.关系代数"></a>3.关系代数</h3><ul><li>常用的关系操作<ul><li>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</li><li>数据更新：插入、删除、修改</li><li>选择、投影、并、差、笛卡尔积是 5 种基本操作</li></ul></li><li><img src="image-20240309160909071.png" alt="image-20240309160909071" style="zoom:50%;" /></li><li>交、并、差<ul><li>具有相同的目n，即两个关系都有n个属性</li><li>相应的属性取自同一个域</li><li><img src="image-20240309161025335.png" alt="image-20240309161025335" style="zoom:50%;" /></li><li><img src="image-20240309161629768.png" alt="image-20240309161629768" style="zoom:50%;" /></li><li><img src="image-20240309161721956.png" alt="image-20240309161721956" style="zoom:50%;" /></li></ul></li><li>笛卡尔积<ul><li><img src="image-20240309161837485.png" alt="image-20240309161837485" style="zoom:50%;" /></li><li>相当于把元组当作集合元素的笛卡尔积</li></ul></li><li>使用的符号<ul><li>t∈R： 元组t是关系R的一个元组</li><li>t[Ai]：表示元组t中相应于属性Ai的一个分量</li><li>若A&#x3D;{Ai1, Ai2, … Aik}}，则 A 称为属性列或属性组。</li><li>t[A]表示元组t在属性列A上诸分量的集合。</li><li>A上加一横表示{A1，A2，An}中去掉 {Ai1，Ai2，Aik}后剩余的属性组。</li><li><img src="image-20240309163005502.png" alt="image-20240309163005502" style="zoom:50%;" /></li></ul></li><li>象集Zx<ul><li>给定一个关系R(X, Z)，X和Z为属性组</li><li><img src="image-20240309163337725.png" alt="image-20240309163337725" style="zoom:50%;" /></li><li>它表示R中属性组X上值为x的诸元组在Z上分量的集合</li><li><img src="image-20240309163429087.png" alt="image-20240309163429087" style="zoom:50%;" /></li></ul></li><li>选择<ul><li><img src="image-20240309163557761.png" alt="image-20240309163557761" style="zoom:50%;" /></li><li>例：<strong>σ</strong>Sage&lt;20(student)，查找年龄小于20的学生</li></ul></li><li>投影<ul><li>从R中选择出若干属性列组成新的关系</li><li><img src="image-20240309164614781.png" alt="image-20240309164614781" style="zoom: 50%;" /></li><li>投影之后不仅取消了原关系中的某些列 而且还可能取消某些元组，避免重复行</li><li>从列的角度运算</li></ul></li><li>连接<ul><li>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</li><li><img src="image-20240309164810532.png" alt="image-20240309164810532" style="zoom:50%;" /></li><li>等值连接：θ 为 的连接运算称为等值连接</li><li>自然连接：一种特殊的等值连接<ul><li>两个关系中进行比较的分量必须是相同的属性组</li><li>在结果中把重复的属性列去掉</li></ul></li><li>从行的角度运算</li></ul></li><li>悬浮元组<ul><li>两个关系 R 和 S 在做自然连接时，关系 R 中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为<strong>悬浮元组</strong></li><li>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值 (Null)，就叫做外连接</li><li>左外连接：只保留左边关系R中的悬浮元组</li><li>右外连接：只保留右边关系S中的悬浮元组</li><li><img src="image-20240309165611271.png" alt="image-20240309165611271" style="zoom:50%;" /></li><li><img src="image-20240309165555485.png" alt="image-20240309165555485" style="zoom:50%;" /></li></ul></li><li>除<ul><li><img src="image-20240309193501435.png" alt="image-20240309193501435" style="zoom:50%;" /></li><li><img src="image-20240309193528303.png" alt="image-20240309193528303" style="zoom:50%;" /></li><li><img src="image-20240309194107688.png" alt="image-20240309194107688" style="zoom:50%;" /></li><li>可以简记为只留下公共属性相同或包含的（能除尽）</li></ul></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="1-SQL简述"><a href="#1-SQL简述" class="headerlink" title="1. SQL简述"></a>1. SQL简述</h3><ul><li>SQL特点<ul><li>综合统一：可以独立完成数据库生命周期中的全部活动</li><li>高度非过程化：存取路径的选择以及 SQL 的操作过程由系统自动完成。</li><li>面向集合的操作方式：非关系数据模型采用面向记录操作方式，操作对象是一条记录，采用集合操作方式</li><li>以同一种语法结构提供两种使用方法：既是独立的语言，能够独立地用于联机交互的使用方式，又是嵌入式语言，能够嵌入到高级语言中</li><li>语言简洁，易学易用</li></ul></li><li>SQL与关系数据库三级模式<ul><li><img src="image-20240312193355315.png" alt="image-20240312193355315" style="zoom: 50%;" /></li><li><img src="image-20240312193427315.png" alt="image-20240312193427315" style="zoom:50%;" /></li></ul></li><li>层次化的数据库对象命名机制<ul><li>一个关系数据库管理系统的实例（ Instance ）中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul></li></ul><h3 id="2-SQL数据定义"><a href="#2-SQL数据定义" class="headerlink" title="2. SQL数据定义"></a>2. SQL数据定义</h3><ul><li>SQL 的数据定义功能 :<ul><li>模式定义</li><li>表定义</li><li>视图和索引的定义</li><li><img src="image-20240312194043087.png" alt="image-20240312194043087" style="zoom: 50%;" /></li></ul></li><li>定义模式<ul><li>定义模式实际上定义了一个命名空间，在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</li><li>在 CREATE SCHEMA 中可以接受 CREATE TABLE，CREATE VIEW 和 GRANT 子句。</li><li><img src="image-20240312194212360.png" alt="image-20240312194212360" style="zoom:50%;" /></li><li><img src="image-20240312194629532.png" alt="image-20240312194629532" style="zoom:50%;" /></li></ul></li><li>删除模式<ul><li>DROP SCHEMA &lt; 模式名 &gt; &lt;CASCADE|RESTRICT&gt;</li><li>CASCADE：级联<ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul></li><li>RESTRICT 限制<ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</li><li>仅当该模式中没有任何下属的对象时才能执行。</li></ul></li><li>例： DROP SCHEMA ZHANG CASCADE</li></ul></li></ul><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h3><ul><li>定义基本表<ul><li><img src="image-20240312194913028.png" alt="image-20240312194913028" style="zoom:50%;" /></li><li>&lt;列级完整性约束条件 &gt;：涉及相应属性列的完整性约束条件，例如某列为主码</li><li>&lt;表级完整性约束条件 &gt;：涉及一个或多个属性列的完整性约束条件，例如有多列组合起来作为主码</li><li>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则列级和表级都可</li><li><img src="image-20240312195151400.png" alt="image-20240312195151400" style="zoom: 40%;" /></li></ul></li><li>数据类型<ul><li><img src="image-20240321193939685.png" alt="image-20240321193939685"></li></ul></li><li>修改数据类型<ul><li><img src="image-20240321194346149.png" alt="image-20240321194346149" style="zoom: 50%;" /></li><li>ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</li><li>DROP COLUMN 子句用于删除表中的列</li><li>DROP CONSTRAINT 子句用于删除指定的完整性约束条件</li><li>ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型</li><li><img src="image-20240321194522455.png" alt="image-20240321194522455" style="zoom:50%;" /></li></ul></li><li>删除基本表<ul><li>DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]</li><li>RESTRICT：欲删除的基本表不能被其他表的约束所引用</li><li>CASCADE ：删除该表没有限制，在删除基本表的同时，相关的依赖对象一起删除</li></ul></li><li>建立索引<ul><li>CREATE [UNIQUE] [INDEX] &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;&lt;次序&gt;, &lt;列名&gt;&lt;次序&gt;···)</li><li>索引：可以建立在该表的一 列或多列上，各列名之间用逗号分隔</li><li>次序 指定索引值的排列次序。升序：ASC；降序：DESC。缺省值：ASC。</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li><li><img src="image-20240321195529416.png" alt="image-20240321195529416" style="zoom:50%;" /></li></ul></li><li>修改&#x2F;删除索引<ul><li><img src="image-20240321195513699.png" alt="image-20240321195513699" style="zoom:50%;" /></li></ul></li></ul><h3 id="4-查询"><a href="#4-查询" class="headerlink" title="4.查询"></a>4.查询</h3><h4 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h4><ul><li>基本语法<ul><li><img src="image-20240321195644829.png" alt="image-20240321195644829" style="zoom:50%;" /></li></ul></li><li>查询经过计算的值<ul><li>SELECT * FROM [表名]：查询所有列</li><li>SELECT 子句的目标列表达式不仅可以为表中的属性列，也可以是表达式，如2014-Sage</li><li>LOWER()：表示转换成小写</li><li>SELECT和列名之间默认为ALL，可使用DISTINCT去掉重复行</li><li><img src="image-20240321200124811.png" alt="image-20240321200124811" style="zoom:50%;" /></li></ul></li><li>条件查询<ul><li><img src="image-20240321200604266.png" alt="image-20240321200604266" style="zoom:50%;" /></li><li>比较大小：WHERE Sdept &#x3D;‘ CS’；WHERE Sage &lt; 20；</li><li>确定范围：[NOT] BETWEEN … AND</li><li>确定集合：IN &lt;值表&gt;, NOT IN &lt;值表&gt;，例如 WHERE Sdept IN ((‘CS’,’MA’,’IS’）</li><li>字符匹配<ul><li>谓词：[NOT] LIKE ‘&lt;匹配串&gt;’ [ ESCAPE ‘换码字符‘ ]</li><li>匹配串 可以是一个完整的字符串，也可以含有通配符%(（)任意长度且长度可以为0的字符串)和 _ (任意单个字符)</li><li><img src="image-20240321201139317.png" alt="image-20240321201139317" style="zoom:50%;" /></li><li><img src="image-20240321201156766.png" alt="image-20240321201156766" style="zoom:50%;" /></li></ul></li><li>涉及空值的查询：IS NULL 或 IS NOT NULL，IS不能用 ’&#x3D;‘代替</li><li>多重条件查询：用AND和OR，且AND优先级更高，可用括号改变优先级</li></ul></li><li>对查询结果排序<ul><li>ORDER BY 子句<ul><li>可以按一个或多个属性列排序</li><li>升序：ASC；降序：DESC；缺省值为升序</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul></li><li><img src="image-20240321201836656.png" alt="image-20240321201836656" style="zoom:50%;" /></li></ul></li><li>聚集函数<ul><li>统计元组个数：COUNT(*)</li><li>统计一列中值的个数：COUNT( [DISTINCT | ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）：SUM( [DISTINCT | ALL] &lt;列名&gt;)</li><li>计算一列值的平均值（此列必须为数值型）：AVG( [DISTINCT | ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值：MAX( [DISTINCT | ALL] &lt;列名&gt;)      MIN( [DISTINCT | ALL] &lt;列名&gt;)</li><li><img src="image-20240321202208049.png" alt="image-20240321202208049" style="zoom:50%;" /></li></ul></li><li>对查询结果分组<ul><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li><li><img src="image-20240321202346616.png" alt="image-20240321202346616" style="zoom:50%;" /></li></ul></li></ul><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><ul><li><p>连接</p><ul><li><p>连接查询：同时涉及两个以上的表的查询</p></li><li><p>连接条件或连接谓词：用来连接两个表的条件</p></li><li><img src="image-20240325164121305.png" alt="image-20240325164121305" style="zoom:50%;" /></li><li><p>连接字段：连接谓词中的列名称，连接条件中的各连接字段类型必须是可比的，但名字不<br>必相同</p></li><li><img src="image-20240325164426187.png" alt="image-20240325164426187" style="zoom:50%;" /></li><li><p>连接操作执行过程</p><ul><li>嵌套循环法：首先在表1中找到第一个元组，然后从头开始扫描表 2 ，逐一查找满足连接件的元<br>组，找到后拼接起来形成结果表中一个元组。</li><li>排序合并法（常用于&#x3D;连接）：先按连接属性进行排序，当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</li><li>索引连接：对表2按连接字段建立索引，对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组后将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</li></ul></li><li><p>同时进行选择和连接</p><ul><li><img src="image-20240325165907620.png" alt="image-20240325165907620" style="zoom:50%;" /></li><li>过程：先选择，再连接</li></ul></li><li><p>自身连接</p><ul><li><p>一个表与其自己进行连接</p></li><li><p>需要给表起别名以示区别</p></li><li><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p></li><li><img src="image-20240325170019101.png" alt="image-20240325170019101" style="zoom:50%;" /></li></ul></li><li><p>外连接</p><ul><li><img src="image-20240325170445001.png" alt="image-20240325170445001" style="zoom:50%;" /></li></ul></li><li><p>多表连接：用AND组合连接条件</p></li></ul></li></ul><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ul><li><p>定义</p><ul><li>一个 SELECT FROM WHERE 语句称为一个查询块</li><li>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</li><li>上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询</li><li>允许多层嵌套查询</li></ul></li><li><p>相关子查询</p><ul><li>不相关子查询：子查询的查询条件不依赖于父查询</li><li>相关子查询：子查询的查询条件依赖于父查询<ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若 WHERE 子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组，重复这一过程，直至外层表全部检查完为止</li></ul></li></ul></li><li><p>嵌套查询的转化</p><ul><li><p>带有IN谓词的：可用连接查询转化</p><img src="image-20240325191322025.png" alt="image-20240325191322025" style="zoom:50%;" /></li><li><p>带有比较运算符的</p><img src="image-20240325191505302.png" alt="image-20240325191505302" style="zoom:50%;" /></li><li><p>带有ANY、SOME或 ALL谓词的子查询</p><ul><li><img src="image-20240325191545636.png" alt="image-20240325191545636" style="zoom:50%;" /></li><li><img src="image-20240325191728446.png" alt="image-20240325191728446" style="zoom:50%;" /></li><li><img src="image-20240325191750839.png" alt="image-20240325191750839" style="zoom:50%;" /></li></ul></li><li><p>带有EXISTS谓词的查询</p><ul><li>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false</li><li>由 EXISTS 引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS 的子查询只返回真值或假值，给出列名无实际意义</li><li>一些带 EXISTS 或 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换</li><li>所有带 IN 谓词、比较运算符、 ANY 和 ALL 谓词的子查询都能用带 EXISTS 谓词的子查询等价替换</li><li><img src="image-20240325193002970.png" alt="image-20240325193002970" style="zoom:50%;" /></li><li><img src="image-20240325193511253.png" alt="image-20240325193511253" style="zoom:50%;" /></li><li><img src="image-20240325193041283.png" alt="image-20240325193041283" style="zoom:50%;" /></li></ul></li></ul></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>并<ul><li>UNION：将多个查询结果合并起来时，系统自动去掉重复元组</li><li>UNION ALL ：将多个查询结果合并起来时，保留重复元组</li></ul></li><li>交<ul><li>INTERSECT：对多个查询结果求交集</li></ul></li><li>差<ul><li>EXCEPT：对多个查询结果求差集</li></ul></li></ul><h4 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h4><ul><li>子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM子句中，这时子查询生成的临时派生表（ Derived Table ）成为主查询的查询对象</li><li><img src="image-20240325195306327.png" alt="image-20240325195306327" style="zoom:50%;" /></li><li>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询 SELECT 子句后面的列名为其缺省属性。</li></ul><h3 id="5-插入"><a href="#5-插入" class="headerlink" title="5.插入"></a>5.插入</h3><ul><li>语法<ul><li><img src="image-20240325195347713.png" alt="image-20240325195347713" style="zoom: 67%;" /></li><li>INTO子句中属性列的顺序可与表定义中的顺序不一致；若没有指定属性列，则表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致；若指定部分属性列，则插入的元组在其余属性列上取空值</li><li>VALUE子句提供的值必须与 INTO 子句匹配</li></ul></li><li>插入子查询结果<ul><li><img src="image-20240325195754200.png" alt="image-20240325195754200" style="zoom:50%;" /></li><li>SELECT 子句目标列必须与 INTO 子句匹配</li><li><img src="image-20240325195812803.png" alt="image-20240325195812803" style="zoom:50%;" /></li></ul></li></ul><h3 id="6-修改"><a href="#6-修改" class="headerlink" title="6.修改"></a>6.修改</h3><ul><li>语法<ul><li><img src="image-20240326160952560.png" alt="image-20240326160952560" style="zoom:50%;" /></li><li>修改指定表中满足 WHERE 子句条件的元组</li><li>SET 子句给出 表达式 的值用于取代相应的属性列</li><li>如果省略 WHERE 子句，表示要修改表中的所有元组</li><li>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则</li><li><img src="image-20240326161546782.png" alt="image-20240326161546782" style="zoom:50%;" /></li></ul></li></ul><h3 id="7-删除"><a href="#7-删除" class="headerlink" title="7.删除"></a>7.删除</h3><ul><li><p>语法</p><ul><li><img src="image-20240326161447700.png" alt="image-20240326161447700" style="zoom:50%;" /></li><li>删除指定表中满足 WHERE 子句条件的元组</li><li>WHERE子句指定要删除的元组，缺省表示要删除表中的全部元组，表的定义仍在字典中</li><li><img src="image-20240326161559709.png" alt="image-20240326161559709" style="zoom:50%;" /></li></ul></li></ul><h3 id="8-空值"><a href="#8-空值" class="headerlink" title="8.空值"></a>8.空值</h3><ul><li>空值的情形<ul><li><img src="image-20240326161655973.png" alt="image-20240326161655973" style="zoom:50%;" /></li><li>有 NOT NULL 约束条件的不能取空值</li><li>加了 UNIQUE 限制的属性不能取空值</li><li>码属性不能取空值</li></ul></li><li>空值的运算<ul><li>判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示</li><li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li><li>空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN</li><li><img src="image-20240326162106406.png" alt="image-20240326162106406" style="zoom:50%;" /></li></ul></li></ul><h3 id="9-视图"><a href="#9-视图" class="headerlink" title="9.视图"></a>9.视图</h3><ul><li><p>特点</p><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li><strong>基表</strong>中的数据发生变化，从<strong>视图</strong>中查询出的数据也随之改变</li></ul></li><li><p>定义视图</p><ul><li><img src="image-20240326162300009.png" alt="image-20240326162300009" style="zoom:50%;" /></li><li><p>组成视图的属性列名：全部省略或全部指定</p><ul><li><p>全部省略：由子查询中 SELECT 目标列中的诸字段组成</p></li><li><p>需要指定的情况：</p><img src="image-20240326162401519.png" alt="image-20240326162401519" style="zoom:50%;" /></li></ul></li><li><p>关系数据库管理系统执行 CREATE VIEW 语句时只是把视图<strong>定义</strong>存入数据字典，并不执行其中的 SELECT 语句。（即不将视图作为表存储，与创建基本表对比）</p></li><li><img src="image-20240326162523957.png" alt="image-20240326162523957" style="zoom:50%;" /></li><li><p>视图可以作为子查询对象再次创建视图</p></li></ul></li><li><p>删除视图</p><ul><li>DROP VIEW &lt;视图名 &gt; [CASCADE]</li><li>该语句从数据字典中删除指定的视图定义</li><li>如果该视图上还导出了其他视图，使用CASCADE 级联删除语句，把该视图和由它导出的视图一起删除</li><li>删除<strong>基表</strong>时，由该基表导出的所有视图定义都必须<strong>显式</strong>地使用 DROP VIEW 语句删除</li></ul></li><li><p>查询视图</p><ul><li>用户角度：查询视图与查询基本表相同</li><li>关系数据库管理系统实现视图查询的方法：<strong>视图消解法</strong></li><li><img src="image-20240326163020522.png" alt="image-20240326163020522" style="zoom:50%;" /></li><li>有些情况下，视图消解法不能生成正确的查询</li></ul></li><li><p>更新视图</p><ul><li><img src="image-20240326191436608.png" alt="image-20240326191436608" style="zoom:50%;" /></li><li>允许对行列子集视图进行更新</li><li>对其他类型视图的更新不同系统有不同限制</li><li>一个不允许更新的视图上定义的视图也不允许更新</li></ul></li><li><p>视图的作用</p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul></li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="1-数据库安全性"><a href="#1-数据库安全性" class="headerlink" title="1.数据库安全性"></a>1.数据库安全性</h3><ul><li>数据库安全性<ul><li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li><li>系统安全保护措施是否有效是数据库系统主要的性能指标之一</li><li><img src="image-20240326194009321.png" alt="image-20240326194009321" style="zoom:50%;" /></li><li><img src="image-20240326194023731.png" alt="image-20240326194023731" style="zoom:50%;" /></li></ul></li><li>计算机系统的安全模型<ul><li>计算机系统中，安全措施是一级一级层层设置</li><li>系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统</li><li>数据库管理系统还要进行存取控制，只允许用户执行合法操作</li><li>操作系统有自己的保护措施</li><li>数据以密码形式存储到数据库中</li><li><img src="image-20240326194126976.png" alt="image-20240326194126976" style="zoom: 67%;" /></li></ul></li></ul><h3 id="2-存取控制"><a href="#2-存取控制" class="headerlink" title="2.存取控制"></a>2.存取控制</h3><ul><li><p>概念</p><ul><li>定义用户权限， 并将用户权限登记到数据字典中</li><li>合法权限检查</li><li>用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</li></ul></li><li><p>自主存取控制</p><ul><li>C2 级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li><li>通过 SQL 的 GRANT 语句和 REVOKE 语句实现</li><li>用户权限组成：数据库对象、操作类型</li><li><img src="image-20240326194456443.png" alt="image-20240326194456443" style="zoom:50%;" /></li></ul></li><li><p>GRANT语句</p><ul><li><img src="image-20240326194525154.png" alt="image-20240326194525154" style="zoom:67%;" /></li><li>语义：将对指定操作对象的指定操作权限授予指定的用户</li><li>发出 GRANT：数据库管理员、数据库对象创建者、拥有该权限的用户</li><li>按受权限的用户：一个或多个具体用户、PUBLIC（全体用户）</li><li>WITH GRANT OPTION 子句：指定则可以再授予，没有指定则不能传播</li><li><img src="image-20240326194721666.png" alt="image-20240326194721666" style="zoom:50%;" /></li></ul></li><li><p>REVOKE语句</p><ul><li><img src="image-20240326194802843.png" alt="image-20240326194802843" style="zoom:50%;" /></li><li><img src="image-20240326194815389.png" alt="image-20240326194815389" style="zoom:50%;" /></li></ul></li><li><p>创建用户</p><ul><li><img src="image-20240326195740507.png" alt="image-20240326195740507" style="zoom:67%;" /></li><li>CREATE USER 不是 SQL标准，各个系统的实现相差甚远</li><li>新创建的数据库用户有三种权限：CONNECT 、 RESOURCE 和 DBA</li><li><img src="image-20240326195810621.png" alt="image-20240326195810621" style="zoom:50%;" /></li></ul></li><li><p>数据库角色</p><ul><li>被命名的一组与数据库操作相关的权限</li><li>角色是权限的集合，可以为一组具有相同权限的用户创建一个角色</li><li>语法：CREATE ROLE &lt;角色名&gt;</li><li>给角色授权：GRANT &lt;权限&gt; [&lt;权限&gt;]…<br>ON &lt;对象类型&gt; 对象名<br>TO &lt;角色&gt; [&lt;角色&gt;]…</li><li><img src="image-20240407161503630.png" alt="image-20240407161503630" style="zoom:67%;" /></li><li><img src="image-20240407161517661.png" alt="image-20240407161517661" style="zoom:50%;" /></li><li>只有角色的创建者和拥有ADMIN OPTION的角色可以revoke</li><li><img src="image-20240407161621046.png" alt="image-20240407161621046" style="zoom: 67%;" /></li></ul></li><li><p>强制存取控制 MAC</p><ul><li>每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li><li>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</li><li>主体：系统中的活动实体，如数据库管理系统所管理的实际用户、代表用户的各进程</li><li>客体：系统中的被动实体，受主体操纵，如文件、基本表、索引、视图</li><li>对于主体和客体， DBMS 为它们每个实例（值）指派一个敏感度标记（ Label）</li><li><img src="image-20240407162315453.png" alt="image-20240407162315453" style="zoom:50%;" /></li><li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时，该主体才能<strong>读取</strong>相应的客体；仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</li></ul></li></ul><h3 id="3-审计"><a href="#3-审计" class="headerlink" title="3.审计"></a>3.审计</h3><ul><li>概念<ul><li>启用一个专用的审计日志将用户对数据库的<strong>所有操作</strong>记录在上面</li><li>审计员利用审计日志 监控数据库中的各种行为 ，找出非法存取数据的人、时间和内容</li></ul></li><li>审计事件<ul><li>服务器事件：审计数据库服务器发生的事件<ul><li>系统权限：对系统拥有的结构或模式对象进行操作的审计</li><li>要求该操作的权限是通过系统权限获得的</li></ul></li><li>语句事件<ul><li>对 SQL 语句，如 DDL 、 DML 、 DQL 及 DCL 语句的审计</li></ul></li><li>模式对象事件<ul><li>对特定模式对象上进行的 SELECT 或 DML 操作的审计</li></ul></li></ul></li><li>审计功能<ul><li>提供多种审计查阅方式，审计分析和报表功能</li><li>多套审计规则：一般在初始化设定</li><li>审计日志管理功能：<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录 不允许任何用户新增和修改审计记录等</li></ul></li><li>提供查询审计设置及审计记录信息的专门视图</li></ul></li><li>审计级别<ul><li>用户级审计：任何用户可设置的审计，主要是用户针对自己创建的数据库表和视图进行审计</li><li>系统级审计：只能由数据库管理员设置，监测成功或失败的登录要求、监测授权和收回操作，以及其他数据库级权限下的操作</li></ul></li><li>语法<ul><li><img src="image-20240407164222082.png" alt="image-20240407164222082" style="zoom: 50%;" /></li></ul></li></ul><h3 id="4-数据加密"><a href="#4-数据加密" class="headerlink" title="4.数据加密"></a>4.数据加密</h3><ul><li><p>概念</p><ul><li>防止数据库中数据在存储和传输中失密的有效手段</li><li>根据一定的算法将原始数据(明文)变换为不可直接识别的格式( 密文)</li><li>加密方法：存储加密、传输加密</li></ul></li><li><p>存储加密分类</p><ul><li><p>透明存储加密</p><ul><li>内核级加密保护方式，对用户完全透明</li><li>将数据在写到磁盘时对数据进行加密 授权用户读取数据时再对其进行解密</li><li>内核级加密方法：性能较好，安全完备性较高</li></ul></li><li><p>非透明存储加密：通过多个加密函数实现</p></li></ul></li><li><p>传输加密</p><ul><li>链路加密：传输信息由报头和报文两部分组成，报文和报头均加密</li><li>端到端加密：在发送端加密，接收端解密，只加密报文不加密报头</li></ul></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="1-数据库完整性"><a href="#1-数据库完整性" class="headerlink" title="1.数据库完整性"></a>1.数据库完整性</h3><ul><li>概念<ul><li>数据的正确性：数据符合现实世界语义，反映了当前实际状况</li><li>数据的相容性：数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul></li><li>完整性机制<ul><li>提供定义完整性约束条件的机制<ul><li>完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件</li><li>SQL标准使用了一系列概念描述完整性，包括关系模型的实体完整性、参照完整性、用户定义完整性</li><li>这些完整性一般由 SQL 的数据定义语言语句来实现</li></ul></li><li>提供完整性检查的方法<ul><li>数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。</li><li>一般在 INSERT 、 UPDATE 、 DELETE 语句执行后开始检查，也可以在事务提交时检查</li></ul></li><li>违约处理<ul><li>数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作</li><li>拒绝执行该操作</li><li>级连执行其他操作</li></ul></li></ul></li><li>实体完整性<ul><li>定义<ul><li>关系模型的实体完整性：用码表示，单属性构成的码可以用列级或表级约束条件说明，多属性必须用表级</li><li><img src="image-20240407165743929.png" alt="image-20240407165743929" style="zoom:50%;" /></li></ul></li><li>检查与处理<ul><li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括检查主码值是否唯一和检查主码的各个属性是否为空，不满足则拒绝插入和修改</li><li>检查时为了避免全局扫描，一般会建立索引</li></ul></li></ul></li><li>参照完整性<ul><li>定义<ul><li>在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码</li><li>用 REFERENCES 短语指明这些外码参照哪些表的主码</li><li><img src="image-20240407170035297.png" alt="image-20240407170035297" style="zoom:60%;" /></li></ul></li><li>参照完整性检查<ul><li>一个参照完整性将两个表中的相应元组联系起来，对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</li><li><img src="image-20240407170136140.png" alt="image-20240407170136140" style="zoom: 50%;" /></li></ul></li><li>违约处理<ul><li>拒绝执行</li><li>级联操作</li><li>设置为空值</li><li><img src="image-20240407170245921.png" alt="image-20240407170245921" style="zoom:57%;" /></li></ul></li></ul></li><li>用户定义的完整性<ul><li>定义<ul><li>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求，包括属性上的和元组上的关系</li><li>数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</li><li><img src="image-20240407170427707.png" alt="image-20240407170427707" style="zoom: 50%;" /></li><li><img src="image-20240407170447271.png" alt="image-20240407170447271" style="zoom:50%;" /></li></ul></li><li>完整性约束创建子句<ul><li>CONSTRAINT &lt; 完整性约束条件名&gt; &lt;完整性约束条件&gt;</li><li>完整性约束条件 包括 NOT NULL 、 UNIQUE 、PRIMARY KEY 短语、 FOREIGN KEY 短语、 CHECK 短语等</li><li>修改完整性约束:使用 ALTER TABLE 语句修改表中的完整性限制，如：ALTER TABLE Student  DROP CONSTRAINT C4;</li><li><img src="image-20240407170639819.png" alt="image-20240407170639819" style="zoom:60%;" /></li></ul></li></ul></li></ul><h3 id="2-断言"><a href="#2-断言" class="headerlink" title="2.断言"></a>2.断言</h3><ul><li>定义<ul><li>用于指定更具有一般性的约束</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言<strong>不为真值</strong>的操作都会被<strong>拒绝执行</strong></li></ul></li><li>语法<ul><li>创建断言：CREATE ASSERTION&lt; 断言名 &gt;&lt;CHECK&gt; 子句</li><li>删除断言：DROP ASSERTION &lt;断言名&gt;</li><li><img src="image-20240407171225042.png" alt="image-20240407171225042" style="zoom:40%;" /></li></ul></li></ul><h3 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3.触发器"></a>3.触发器</h3><ul><li>定义<ul><li>触发器是用户定义在关系表上的一类由事件驱动的特殊过程</li><li>触发器保存在数据库服务器中，任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</li><li>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</li></ul></li><li>语法<ul><li>定义触发器：<img src="image-20240407171731071.png" alt="image-20240407171731071" style="zoom:50%;" /></li><li>删除触发器：DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</li><li>当特定的系统事件发生时，对规则条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作</li></ul></li><li>触发器类型<ul><li>语句级触发器：只针对一整条SQL语句</li><li>行级触发器：执行SQL语句过程中每查询一行元组都会检查触发器</li><li><img src="image-20240407172322105.png" alt="image-20240407172322105" style="zoom:50%;" /></li></ul></li><li>激活触发器<ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序：<ul><li>执行该表上的 BEFORE 触发器</li><li>激活触发器的 SQL 语句</li><li>执行该表上的 AFTER 触发器</li></ul></li></ul></li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="1-关系模式及范式"><a href="#1-关系模式及范式" class="headerlink" title="1.关系模式及范式"></a>1.关系模式及范式</h3><ul><li>关系模式由五部分组成，是一个五元组：(R, U, D, DOM, F)<ul><li>关系名 R 是符号化的元组语义</li><li>U 为一组属性</li><li>D 为属性组 U 中的属性所来自的域</li><li>DOM 为属性到域的映射</li><li>F 为属性组 U 上的一组数据依赖</li><li>由于D、DOM与模式设计关系不大，因此可以把关系模式看作一个三元组： R&lt;U, F&gt;</li></ul></li><li>数据依赖<ul><li>内涵：是一个关系内部属性与属性之间的一种约束关系，现实世界属性间相互联系的抽象，数据内在的性质，语义的体现</li><li>分类：函数依赖、多值依赖</li><li>函数依赖<ul><li>普遍存在于现实生活中</li><li>一个属性可由一个函数被另一个属性唯一确定</li><li><img src="image-20240416195138006.png" alt="image-20240416195138006" style="zoom:50%;" /></li></ul></li><li>多值依赖见第五小节</li></ul></li><li>范式<ul><li>范式是符合某一种级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式</li><li><img src="image-20240416195545966.png" alt="image-20240416195545966" style="zoom:50%;" /></li><li>高等级的范式包含于低等级的，例如2NF ∈ 1NF</li><li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></li></ul></li></ul><h3 id="2-函数依赖与码"><a href="#2-函数依赖与码" class="headerlink" title="2.函数依赖与码"></a>2.函数依赖与码</h3><ul><li><p>函数依赖</p><ul><li><p>定义</p><img src="image-20240416195934292.png" alt="image-20240416195934292" style="zoom: 67%;" /></li><li><img src="image-20240416195955459.png" alt="image-20240416195955459" style="zoom: 60%;" /></li><li><p>函数依赖不是指关系模式 R 的某个或某些关系实例满足的约束条件，而是指 R 的<strong>所有</strong>关系实例均要满足的约束条件。</p></li><li><p>数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。</p></li></ul></li><li><p>平凡函数依赖与非平凡函数依赖</p><ul><li>如果 X→Y ，但 Y不∈X ，则称 X→Y 是非平凡的函数依赖</li><li>如果 X→Y ，且Y∈X ，则称 X→Y 是平凡的函数依赖</li></ul></li><li><p>完全函数依赖与部分函数依赖</p><ul><li><img src="image-20240416202632255.png" alt="image-20240416202632255" style="zoom: 50%;" /></li></ul></li><li><p>传递函数依赖</p><ul><li><img src="image-20240416202747822.png" alt="image-20240416202747822" style="zoom:55%;" /></li><li><img src="image-20240416202832055.png" alt="image-20240416202832055" style="zoom: 50%;" /></li></ul></li><li><p>码</p><ul><li><img src="image-20240416203026034.png" alt="image-20240416203026034" style="zoom:50%;" /></li><li>若关系模式 R 有多个候选码，则选定其中的一个作为主码</li><li>主属性与非主属性<ul><li>包含在任何一个候选码中的属性 ，称为主属性</li><li>不包含在任何码中的属性称为非主属性或非码属性</li><li>全码：整个属性组是码，称为全码</li></ul></li><li>外码：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码或外码</li></ul></li></ul><h3 id="3-1NF，2NF，3NF"><a href="#3-1NF，2NF，3NF" class="headerlink" title="3. 1NF，2NF，3NF"></a>3. 1NF，2NF，3NF</h3><ul><li>1NF<ul><li>如果一个关系模式 R 的所有属性都是不可分的基本数据项，则 R∈1NF 。</li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</li><li>1NF的缺点<ul><li>数据冗余：每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。</li><li>更新异常：某系更换系主任后，必须修改与该系学生有关的每一个元组。</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。</li><li>删除异常：如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</li><li>解决方案：将其分解为多个关系</li></ul></li><li><img src="image-20240416203642322.png" alt="image-20240416203642322" style="zoom:50%;" /></li></ul></li><li>2NF<ul><li>若关系模式 R∈1NF ，并且每一个非主属性都完全函数依赖于任何一个候选码，则 R∈2NF</li><li>如果不是2NF，会引发插入异常、删除异常、修改复杂</li><li>解决方法：将关于候选码完全函数依赖的非主属性和部分函数依赖的非主属性分成两类，分别与它对应的候选码成为一张新表</li></ul></li><li>3NF<ul><li><img src="image-20240416204023800.png" alt="image-20240416204023800" style="zoom:50%;" /></li><li>非3NF修改方法：将每个传递依赖的每一环节拆分成新的表</li></ul></li></ul><h3 id="4-BNF"><a href="#4-BNF" class="headerlink" title="4. BNF"></a>4. BNF</h3><ul><li>BCNF<ul><li>定义<ul><li><img src="image-20240420101602827.png" alt="image-20240420101602827" style="zoom: 50%;" /></li></ul></li><li>性质<ul><li>所有非主属性都完全函数依赖于每个候选码</li><li>所有主属性都完全函数依赖于每个不包含它的候选码</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li><li><img src="image-20240420101811662.png" alt="image-20240420101811662" style="zoom: 50%;" /></li></ul></li></ul><h3 id="5-多值依赖与4NF"><a href="#5-多值依赖与4NF" class="headerlink" title="5. 多值依赖与4NF"></a>5. 多值依赖与4NF</h3><ul><li>多值依赖<ul><li>定义<ul><li><img src="image-20240420102125572.png" alt="image-20240420102125572" style="zoom:50%;" /></li><li><img src="image-20240420102140744.png" alt="image-20240420102140744" style="zoom:50%;" /></li></ul></li><li>平凡与非平凡多值依赖<ul><li><img src="image-20240420102221888.png" alt="image-20240420102221888" style="zoom:50%;" /></li></ul></li><li><img src="image-20240420102244697.png" alt="image-20240420102244697" style="zoom:50%;" /></li></ul></li><li>多值依赖的对称性<ul><li>按照语义对于 W 的每一个值 Wi，S 有一个完整的集合与之对应而不问C 取何值。所以 W-&gt;-&gt;S</li><li>而相对的，对于 W 的每一个值 Wi，C也有一个完整的集合与之对应，它与S对称</li><li><img src="image-20240420102507629.png" alt="image-20240420102507629" style="zoom:60%;" /></li><li>多值依赖具有对称性，即若X-&gt;-&gt;Y ，则 X-&gt;-&gt;Z ，其中 Z&#x3D;U-X-Y</li><li>函数依赖是多值依赖的特殊情况。即若 X-&gt;Y ，则X-&gt;-&gt;Y</li><li>多值依赖在当前属性集的子集上一定成立，但超集不一定</li><li><img src="image-20240420103110238.png" alt="image-20240420103110238" style="zoom:50%;" /></li></ul></li><li>4NF<ul><li>定义<ul><li><img src="image-20240420103131532.png" alt="image-20240420103131532" style="zoom:50%;" /></li></ul></li><li>4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。 4NF 所允许的非平凡多值依赖实际上是函数依赖。</li></ul></li></ul><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1.数据库设计概述"></a>1.数据库设计概述</h3><ul><li>概念<ul><li>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li><li><img src="image-20240408102211841.png" alt="image-20240408102211841" style="zoom:50%;" /></li></ul></li><li>数据库设计方法<ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良（ New Orleans ）方法</li><li>基于 E-R 模型的数据库设计方法</li><li>3NF （第三范式）的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（ UML ）方法</li></ul></li></ul></li><li>数据库设计阶段<ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li><li><img src="image-20240408102648166.png" alt="image-20240408102648166" style="zoom:50%;" /></li><li>需求分析和概念设计独立于任何数据库管理系统</li><li>逻辑设计和物理设计与选用的数据库管理系统密切相关</li></ul></li><li>参与数据库设计的人员<ul><li>系统分析人员和数据库设计人员</li><li>数据库管理员和用户代表</li><li>应用开发人员</li></ul></li></ul><h3 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h3><ul><li>需求分析任务<ul><li>详细调查现实世界要处理的对象</li><li>充分了解原系统（手工系统或计算机系统）工作概况</li><li>明确用户的各种需求</li><li>在此基础上确定新系统的功能</li><li>新系统必须充分考虑今后可能的扩充和改变</li><li>调查的重点是数据和处理 ，获得用户对数据库的要求<ul><li>信息要求</li><li>处理要求</li><li>安全性与完整性要求</li></ul></li><li>第一阶段收集的基础数据（用数据字典来表达）是下一步进行概念设计的基础。</li></ul></li><li>需求分析方法<ul><li>调查清楚用户的实际需求并进行初步分析</li><li>与用户达成共识</li><li>分析与表达这些需求</li></ul></li><li><img src="image-20240408104024219.png" alt="image-20240408104024219" style="zoom: 67%;" /></li><li>数据字典<ul><li>概念<ul><li>数据字典是关于数据库中数据的描述，即元数据，不是数据本身</li><li>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善</li><li>数据字典是进行详细的数据收集和数据分析所获得的主要结果</li><li>注意和关系数据库管理系统中数据字典的区别和联系</li></ul></li><li>内容<ul><li>数据项、数据结构、数据流、数据存储、处理过程</li><li>数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构</li><li>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</li></ul></li><li>数据项<ul><li><img src="image-20240408104538786.png" alt="image-20240408104538786" style="zoom:50%;" /></li></ul></li><li>数据结构<ul><li>数据结构反映了数据之间的组合关系</li><li>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</li><li><img src="image-20240408104615628.png" alt="image-20240408104615628" style="zoom:50%;" /></li></ul></li><li>数据流<ul><li><img src="image-20240408104632175.png" alt="image-20240408104632175" style="zoom:50%;" /></li></ul></li><li>数据存储<ul><li><img src="image-20240408104649695.png" alt="image-20240408104649695" style="zoom:50%;" /></li></ul></li><li>处理过程<ul><li><img src="image-20240408104707751.png" alt="image-20240408104707751" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="3-概念模型和E-R模型"><a href="#3-概念模型和E-R模型" class="headerlink" title="3.概念模型和E-R模型"></a>3.概念模型和E-R模型</h3><ul><li><p>概念模型</p><ul><li>定义：将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计</li><li>描述概念模型的工具：E-R模型</li></ul></li><li><p>实体型之间的联系</p><ul><li>两个实体型间联系<ul><li>一对一联系(1 : 1)</li><li>一对多联系(1 : n)</li><li>多对多联系(m : n)</li><li><img src="image-20240408105949171.png" alt="image-20240408105949171" style="zoom:50%;" /></li></ul></li><li>两个以上的实体型之间的联系<ul><li>一般地，两个以上的实体型之间也存在着一对一、一对多、多对多联系</li><li>同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系</li><li><img src="image-20240408110105704.png" alt="image-20240408110105704" style="zoom: 25%;" /></li><li><img src="image-20240408110118388.png" alt="image-20240408110118388" style="zoom:33%;" /></li></ul></li></ul></li><li><p>E-R模型</p><ul><li>概念<ul><li>联系的度：参与联系的实体型的数目</li><li>2 个实体型之间的联系度为 2 ，也称为二元联系</li><li>3 个实体型之间的联系度为 3 ，称为三元联系</li><li>N 个实体型之间的联系度为 N ，也称为 N 元联系</li></ul></li><li>图例<ul><li>实体型：用矩形表示，矩形框内写明实体名</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（联系可以具有属性）</li><li><img src="image-20240408110344356.png" alt="image-20240408110344356" style="zoom: 25%;" /></li></ul></li></ul></li><li><p>ISA联系</p><ul><li><p>有的实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系</p><img src="image-20240412195628567.png" alt="image-20240412195628567" style="zoom: 60%;" /></li><li><p>分类属性：分类属性是父实体型的一个属性，它的值把父实体型中的实体分派到子实体型中</p><img src="image-20240412195732030.png" alt="image-20240412195732030" style="zoom:67%;" /></li><li><p>不相交约束：描述父类中的一个实体不能同时属于多个子类中的实体集。即一个父类中的实体最多属于一个子类实体集。</p><p><img src="image-20240412195759245.png" alt="image-20240412195759245"></p></li><li><p>描述父类中的一个实体是否必须是某一个子类中的实体。如果是，则叫做完全特化，用父类到子类的双线连接来表示；否则叫做部分特化，用父类到子类的单线连接来表示。</p><p><img src="image-20240412195910036.png" alt="image-20240412195910036"></p></li><li><p>基数约束</p><ul><li>min&#x3D;1 的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系</li><li>min&#x3D;0 的约束叫做非强制参与约束，被施加基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系</li></ul><p><img src="image-20240412195952226.png" alt="image-20240412195952226"></p></li><li><p>弱实体型和独占联系</p><ul><li>如果一个实体型的存在依赖于其它实体型的存在，则这个实体型叫做弱实体型否则叫做强实体型。</li><li>用弱实体类型和识别联系来表示独占联系双矩形表示弱实体型，用双菱型表示识别联系。</li><li><img src="image-20240412200428721.png" alt="image-20240412200428721" style="zoom: 67%;" /></li></ul></li><li><p>Part-of 联系</p><ul><li>描述某个实体型是另外一个实体型的一部分</li><li>非独占的Part-of联系，简称非独占联系：整体实体如果被破坏，另一部分实体仍然可以独立存在</li><li>独占的Part-of联系，简称独占联系：整体实体如果被破坏，另一部分实体不可以独立存在</li><li>用非强制参与联系表示非独占的 Part of 联系</li><li>用弱实体类型和识别联系来表示独占联系编号编号</li></ul></li></ul></li></ul><h3 id="4-概念结构设计"><a href="#4-概念结构设计" class="headerlink" title="4.概念结构设计"></a>4.概念结构设计</h3><ul><li><p>方法</p><ul><li>自顶向下：首先定义全局概念结构的框架，然后逐步细化</li><li>自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构</li><li>逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构</li><li>混合策略：将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构<ul><li>自顶向下地进行需求分析</li><li>自底向上地设计概念结构</li><li><img src="image-20240412200949513.png" alt="image-20240412200949513" style="zoom:50%;" /></li></ul></li></ul></li><li><p>概念结构设计的步骤</p><ul><li><img src="image-20240412201846050.png" alt="image-20240412201846050" style="zoom: 60%;" /></li></ul></li><li><p>实体与属性的划分</p><ul><li>为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待</li><li>两条准则：<ol><li>作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。</li><li>属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。</li></ol></li><li><img src="image-20240412202047285.png" alt="image-20240412202047285" style="zoom:50%;" /></li></ul></li><li><p>E-R图的集成</p><ul><li><p>步骤</p><ul><li>合并。解决各分E-R 图之间的冲突，将分E-R图合并起来生成初步E-R图。</li><li>修改和重构。消除不必要的冗余，生成基本E-R图。</li></ul></li><li><p>子系统E-R图之间的冲突主要有三类：属性冲突、命名冲突、结构冲突</p></li><li><p>属性冲突</p><ul><li>属性域冲突，即属性值的类型、取值范围或取值集合不同</li><li>属性取值单位冲突</li></ul></li><li><p>命名冲突</p><ul><li>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字</li><li>异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字</li></ul></li><li><p>结构冲突</p><img src="image-20240412202452411.png" alt="image-20240412202452411" style="zoom: 67%;" /></li><li><p>第二步：消除不必要的冗余，设计基本E-R图</p><ul><li>所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。</li><li>消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。</li><li><img src="image-20240412202612581.png" alt="image-20240412202612581" style="zoom:50%;" /><img src="image-20240412202936024.png" alt="image-20240412202936024"></li><li><img src="image-20240412202936024.png" alt="image-20240412202936024" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="5-逻辑结构设计"><a href="#5-逻辑结构设计" class="headerlink" title="5.逻辑结构设计"></a>5.逻辑结构设计</h3><ul><li>概念<ul><li>任务：把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构</li><li>内容：<ul><li>E-R图由实体型、实体的属性和实体型之间的联系三个要素组成</li><li>关系模型的逻辑结构是一组关系模式的集合</li><li>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</li></ul></li></ul></li><li>实体型<ul><li>一个实体型转换为一个关系模式</li><li>关系的属性：实体的属性</li><li>关系的码：实体的码</li></ul></li><li>1:1联系<ul><li>一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</li><li>转换为一个独立的关系模式：<ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的候选码：每个实体的码均是该关系的候选码</li></ul></li><li>与某一端实体对应的关系模式合并<ul><li>合并后关系的属性：加入对应关系的码和联系本身的属性</li><li>合并后关系的码：不变</li></ul></li></ul></li><li>1:n联系<ul><li>一个 1:n 联系可以转换为一个独立的关系模式，也可以与<strong>n端</strong>对应的关系模式合并。</li><li>转换为一个独立的关系模式<ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：n端实体的码</li></ul></li><li>与n端对应的关系模式合并<ul><li>合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性</li><li>合并后关系的码：不变</li><li>可以减少系统中的关系个数</li></ul></li></ul></li><li>m:n联系<ul><li>一个 m:n 联系转换为一个关系模式</li><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合</li><li><img src="image-20240416193525525.png" alt="image-20240416193525525" style="zoom: 40%;" /></li></ul></li><li>多元联系<ul><li>三个或三个以上实体间的一个多元联系转换为一个关系模式。</li><li>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合</li></ul></li><li>关系模式的合并<ul><li>具有相同码的关系模式可合并</li><li>目的：减少系统中的关系个数</li><li>合并方法：<ul><li>将其中一个关系模式的全部属性加入到另一个关系模式中</li><li>然后去掉其中的同义属性（可能同名也可能不同名）</li><li>适当调整属性的次序</li></ul></li></ul></li><li>E-R图的转换<ul><li><img src="image-20240416193843520.png" alt="image-20240416193843520" style="zoom: 60%;" /></li></ul></li><li>数据模型的优化<ul><li>得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。</li><li>关系数据模型的优化通常以<strong>规范化理论</strong>为指导</li><li><img src="image-20240416194242050.png" alt="image-20240416194242050" style="zoom: 50%;" /></li><li>并不是规范化程度越高的关系就越优：当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算，而连接运算代价高，因此在这种情况下，第二范式甚至第一范式也许是适合的。对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定</li></ul></li><li>关系模式的分解<ul><li>水平分解<ul><li>把基本关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</li><li>对符合80&#x2F;20原则 的，把经常被使用的数据（约20%）水平分解出来，形成一个子关系。</li></ul></li><li>垂直分解<ul><li>把关系模式 R 的属性分解为若干子集合，形成若干子关系模式。</li><li>垂直分解的原则：经常在一起使用的属性从 R 中分解出来形成一个子关系模式</li><li>垂直分解的适用范围：取决于分解后 R 上的所有事务的总效率是否得到了提高</li></ul></li></ul></li><li>设计用户子模式<ul><li>定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：<ul><li>使用更符合用户习惯的别名</li><li>针对不同级别的用户定义不同的视图，以保证系统的安全性</li><li>简化用户对系统的使用</li></ul></li></ul></li></ul><h3 id="6-物理结构设计"><a href="#6-物理结构设计" class="headerlink" title="6.物理结构设计"></a>6.物理结构设计</h3><ul><li>设计步骤<ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li><li>若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ul></li><li>设计内容<ul><li>为关系模式选择存取方法</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul></li><li>数据库管理系统常用存取方法<ul><li>B+ 树索引存取方法</li><li>Hash 索引存取方法</li><li>聚簇存取方法</li></ul></li><li>B+树索引存取方法<ul><li>选择索引存取方法的一般规则<ul><li>如果一个（组）属性经常在查询条件中出现，则考虑在这个（组）属性上建立索引（或组合索引）</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个（组）属性经常在连接操作的连接条件中出现，则考虑在这个（组）属性上建立索引</li></ul></li><li>关系上定义的索引数过多会带来较多的额外开销（维护、查找）</li></ul></li><li>Hash 存取方法<ul><li>如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一<ul><li>该关系的大小可预知，而且不变</li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态 Hash存取方法</li></ul></li></ul></li><li>聚簇<ul><li>定义：为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。</li><li>聚簇的用途：大大提高按聚簇属性进行查询的效率</li><li>聚簇存储方法的选择<ul><li>选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系</li><li>一个数据库可以建立<strong>多个</strong>聚簇，一个关系只能加入<strong>一个</strong>聚簇。</li><li><img src="image-20240420105643741.png" alt="image-20240420105643741"></li></ul></li><li>聚簇的局限性<ul><li>聚簇只能提高某些特定应用的性能</li><li>建立与维护聚簇的开销相当大</li><li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时可以使用聚簇</li></ul></li></ul></li><li>确定数据库的存储结构<ul><li>确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等</li><li>确定数据的存放位置基本原则：根据应用情况将易变部分与稳定部分分开存放，经常存取部分与存取频率较低部分分开存放</li><li>确定系统配置<ul><li><img src="image-20240420105904442.png" alt="image-20240420105904442" style="zoom:50%;" /></li></ul></li></ul></li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="1-数据库的实施和维护"><a href="#1-数据库的实施和维护" class="headerlink" title="1. 数据库的实施和维护"></a>1. 数据库的实施和维护</h3><ul><li>数据的载入和应用程序的调试<ul><li>数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。</li><li>数据装载方法：人工方法、计算机辅助数据入库</li><li>在组织数据入库的同时还要调试应用程序</li></ul></li><li>数据库的试运行<ul><li>应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。</li><li>主要工作：功能测试、性能测试</li><li>数据库的试运行的注意事项：<ul><li>数据的分期入库</li><li>数据库的转储和恢复</li></ul></li></ul></li><li>数据库的运行和维护<ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改进</li><li>数据库的重组织与重构造</li></ul></li><li>数据库的转储和恢复<ul><li>数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。</li><li>一旦发生故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。并尽可能减少对数据库的破坏。</li></ul></li><li>数据库的安全性、完整性控制<ul><li>初始定义：数据库管理员根据用户的实际需要授予不同的操作权限，根据应用环境定义不同的完整性约束条件</li><li>修改定义：当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制；由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求</li></ul></li><li>数据库性能的监督、分析和改进<ul><li>在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进性能的方法。</li><li>利用监测工具获取系统运行过程中一系列性能参数的值</li><li>通过仔细分析这些数据，判断当前系统是否处于最佳运行状态</li><li>如果不是，则需要调整参数或对数据库进行重组织或重构造</li></ul></li><li>数据库的重组织<ul><li>原因：数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。</li><li>重组织的形式：全部重组织、部分重组织（只对频繁增删的表）</li><li>重组织的工作：重新安排存储位置、回收垃圾、减少指针链</li></ul></li><li>数据库的重构造<ul><li>原因：数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求</li><li>重构造的主要工作：根据新环境调整数据库的模式和内模式<ul><li>增加或删除某些数据项</li><li>改变数据项的类型</li><li>增加或删除某个表</li><li>改变数据库的容量</li><li>增加或删除某些索引</li></ul></li><li>重构造数据库的程度是有限的，若变化太大或重构代价太高，则需要重新设计新数据库</li></ul></li></ul><h3 id="2-面向驱动的数据库编程"><a href="#2-面向驱动的数据库编程" class="headerlink" title="2. 面向驱动的数据库编程"></a>2. 面向驱动的数据库编程</h3><ul><li>考试不考，见PPT</li></ul><h3 id="3-过程化SQL"><a href="#3-过程化SQL" class="headerlink" title="3. 过程化SQL"></a>3. 过程化SQL</h3><ul><li>概念<ul><li>SQL的扩展</li><li>增加了过程化语句功能</li><li>基本结构是块</li></ul></li><li>过程化SQL的块结构<ul><li>定义<ul><li><img src="image-20240426124403855.png" alt="image-20240426124403855" style="zoom:67%;" /></li></ul></li><li>执行部分<ul><li><img src="image-20240426124436809.png" alt="image-20240426124436809" style="zoom:67%;" /></li></ul></li></ul></li><li>变量和常量的定义<ul><li><img src="image-20240426124638813.png" alt="image-20240426124638813" style="zoom: 60%;" /></li></ul></li><li>流程控制<ul><li>条件控制<ul><li><img src="image-20240426124742104.png" alt="image-20240426124742104" style="zoom:50%;" /></li></ul></li><li>循环控制<ul><li><img src="image-20240426124804628.png" alt="image-20240426124804628" style="zoom: 50%;" /></li></ul></li><li>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</li></ul></li></ul><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><ul><li>过程化SQL块类型<ul><li>命名块：编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li><li>匿名块：每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li><li>存储过程<ul><li>定义：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只需要调用</li><li>优点：运行效率高，降低了客户机与服务器的通信量，方便实施企业规则</li></ul></li><li>存储过程的用户接口<ul><li>创建存储过程<ul><li><img src="image-20240426125312310.png" alt="image-20240426125312310" style="zoom:50%;" /></li></ul></li><li>执行存储过程<ul><li><img src="image-20240426125409322.png" alt="image-20240426125409322" style="zoom:50%;" /></li></ul></li><li>修改和删除<ul><li><img src="image-20240426125428974.png" alt="image-20240426125428974" style="zoom:50%;" /></li></ul></li></ul></li><li>函数<ul><li><img src="image-20240426125452183.png" alt="image-20240426125452183" style="zoom:50%;" /></li></ul></li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h3><ul><li>概念<ul><li>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事务是恢复和并发控制的基本单位</li></ul></li><li>定义事务<ul><li><img src="image-20240430140603082.png" alt="image-20240430140603082"></li><li>隐式方式：当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务</li><li><img src="image-20240430140732623.png" alt="image-20240430140732623"></li></ul></li><li>事务的ACID特性<ul><li>原子性<ul><li>事务是数据库的逻辑工作单位</li><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li><li>一致性<ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>一致性状态：数据库中只包含成功事务提交的结果</li></ul></li><li>隔离性<ul><li>一个事务的执行不能被其他事务干扰</li><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul></li><li>持续性（永久性）<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响</li></ul></li><li>保证事务ACID特性是事务处理的任务</li><li>破坏事务ACID特性的因素<ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul></li></ul></li></ul><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="1-故障和数据库恢复"><a href="#1-故障和数据库恢复" class="headerlink" title="1. 故障和数据库恢复"></a>1. 故障和数据库恢复</h3><ul><li>故障<ul><li>分类<ul><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li><li>各类故障，对数据库的影响有两种可能性：<ul><li>一是数据库本身被破坏</li><li>二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。</li></ul></li></ul></li><li>事务故障<ul><li>分类<ul><li>运算溢出</li><li>并发事务发生死锁而被选中撤销该事务</li><li>违反了某些完整性限制而被终止等</li></ul></li><li><strong>事务故障仅指这类非预期的故障</strong></li><li>事务故障意味着：<ul><li>事务没有达到预期的终点 (COMMIT 或者显式的ROLLBACK)</li><li>数据库可能处于不正确状态。</li></ul></li><li>事务故障的恢复：事务撤消<ul><li>强行回滚（ ROLLBACK ）该事务</li><li>撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样</li></ul></li></ul></li><li>系统故障<ul><li>系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如 CPU 故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。</li><li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<ul><li>恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（ UNDO ）所有未完成事务</li></ul></li><li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失<ul><li>恢复策略：系统重新启动时，恢复程序需要重做所有已提交的事务</li></ul></li></ul></li><li>介质故障<ul><li>介质故障，称为硬故障，指外存故障</li><li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务</li></ul></li><li>计算机病毒<ul><li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li><li>数据库一旦被破坏仍要用恢复技术把数据库加以恢复</li></ul></li><li>恢复<ul><li><img src="image-20240430144104099.png" alt="image-20240430144104099"></li></ul></li></ul><h3 id="2-数据转储和日志文件"><a href="#2-数据转储和日志文件" class="headerlink" title="2. 数据转储和日志文件"></a>2. 数据转储和日志文件</h3><ul><li>数据转储<ul><li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本（后援副本）</li><li>数据库遭到破坏后可以将后备副本重新装入</li><li>重装后备副本只能将数据库恢复到转储时的状态</li><li>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</li></ul></li><li>转储方法<ul><li>静态转储<ul><li>在系统中无运行事务时进行的转储操作</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>优点：实现简单</li><li>缺点：降低了数据库的可用性</li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存取或修改</li><li>利用动态转储得到的副本进行故障恢复：需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件，后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态</li></ul></li><li>海量转储：每次转储全部数据库</li><li>增量转储 : 只转储上次转储后更新过的数据</li></ul></li><li>日志文件<ul><li>日志文件是用来记录事务对数据库的更新操作的文件</li><li>日志文件的格式：<ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul></li><li>以记录为单位的日志文件内容<ul><li>各个事务的开始标记 (BEGIN）</li><li>各个事务的结束标记 (COMMIT 或 ROLLBACK)</li><li>各个事务的所有更新操作</li></ul></li><li>以记录为单位的日志文件，每条日志记录的内容<ul><li>事务标识（标明是哪个事务）</li><li>操作类型（插入、删除或修改）</li><li>操作对象（记录内部标识）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言 , 此项为空值）</li></ul></li><li>以数据块为单位的日志文件，每条日志记录的内容<ul><li>事务标识</li><li>被更新的数据块</li></ul></li><li>日志文件的作用<ul><li><img src="image-20240430152027383.png" alt="image-20240430152027383"></li></ul></li><li>登记日志文件原则<ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul></li></ul></li></ul><h3 id="3-恢复策略"><a href="#3-恢复策略" class="headerlink" title="3. 恢复策略"></a>3. 恢复策略</h3><ul><li><p>事务故障的恢复</p><ul><li>恢复方法：由恢复子系统利用日志文件撤消此事务已对数据库进行的修改</li><li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li><li>步骤<ul><li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中更新前的值写入数据库。</li><li>重复前两步，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ul></li></ul></li><li><p>系统故障的恢复</p><ul><li>恢复方法<ul><li>Undo 故障发生时未完成的事务（反向扫描日志）</li><li>Redo 已完成的事务（正向扫描日志）</li></ul></li><li>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li></ul></li><li><p>介质故障的恢复</p><ul><li><p>介质故障的恢复的工作</p><ul><li>重装数据库</li><li>重做已完成的事务</li></ul></li><li><p>介质故障的恢复需要数据库管理员介入，但具体的恢复操作仍由数据库管理系统完成</p></li><li><p>数据库管理员的工作</p><ul><li>重装最近转储的数据库副本和有关的各日志文件副本</li><li>执行系统提供的恢复命令</li></ul></li></ul></li></ul><h3 id="4-具有检查点的恢复步骤"><a href="#4-具有检查点的恢复步骤" class="headerlink" title="4. 具有检查点的恢复步骤"></a>4. 具有检查点的恢复步骤</h3><ul><li>概念<ul><li>恢复的两个问题：<ul><li>搜索整个日志将耗费大量的时间</li><li>重做处理：重新执行，浪费了大量时间</li></ul></li><li>具有检查点的恢复技术<ul><li>在日志文件中增加<strong>检查点记录</strong>(checkpoint)</li><li>增加<strong>重新开始文件</strong></li><li>恢复子系统在登录日志文件期间动态地维护日志</li></ul></li><li>检查点记录的内容<ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul></li><li>重新开始文件的内容：记录各个检查点记录在日志文件中的地址</li></ul></li><li>动态维护日志文件的方法<ul><li>周期性地执行如下操作：建立检查点，保存数据库状态。</li><li><img src="image-20240430153706620.png" alt="image-20240430153706620"></li></ul></li><li>建立检查点<ul><li>恢复子系统可以定期或不定期地建立检查点，保存数据库状态</li><li>定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点</li><li>不定期：按照某种规则，如日志文件已写满一半建立一个检查点</li></ul></li><li>利用检查点的恢复策略<ul><li>使用检查点方法可以改善恢复效率<ul><li>当事务T在一个检查点之前提交， T对数据库所做的修改已写入数据库</li><li>写入时间是在这个检查点建立之前或在这个检查点建立之时</li><li>在进行恢复处理时，没有必要对事务T执行重做操作</li></ul></li><li><img src="image-20240430153944163.png" alt="image-20240430153944163"></li><li>恢复步骤<ul><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li><li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单(ACTIVE LIST)<ul><li><img src="image-20240430154130957.png" alt="image-20240430154130957" style="zoom: 67%;" /></li></ul></li><li>从检查点开始<strong>正向</strong>扫描日志文件，直到日志文件结束<ul><li><img src="image-20240430154145401.png" alt="image-20240430154145401" style="zoom:67%;" /></li></ul></li><li>对UNDO LIST中的每个事务执行UNDO操作；对REDO LIST中的每个事务执行REDO操作</li></ul></li></ul></li></ul><h3 id="5-数据库镜像"><a href="#5-数据库镜像" class="headerlink" title="5. 数据库镜像"></a>5. 数据库镜像</h3><ul><li>概念<ul><li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li><li>数据库管理系统自动保证镜像数据与主数据的一致性</li><li>每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li><li>在实际应用中用户往往只选择对关键数据和日志文件镜像</li></ul></li><li>用途<ul><li>出现介质故障时<ul><li>可由镜像磁盘继续提供使用</li><li>同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复</li><li>不需要关闭系统和重装数据库副本</li></ul></li><li>没有出现故障时<ul><li>可用于并发操作</li><li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁</li></ul></li></ul></li></ul><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="1-并发控制"><a href="#1-并发控制" class="headerlink" title="1. 并发控制"></a>1. 并发控制</h3><ul><li>事务并发<ul><li>多用户数据库系统，允许多个用户同时使用的数据库系统</li><li>特点：在同一时刻并发运行的事务数可达数百上千个</li><li>事务并发执行带来的问题<ul><li>会产生多个事务同时存取同一数据的情况</li><li>可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性</li></ul></li><li>数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一</li></ul></li><li>多事务执行方式<ul><li>串行执行<ul><li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li><li>不能充分利用系统资源，发挥数据库共享资源的特点</li></ul></li><li>交叉并发<ul><li>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</li><li>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率</li></ul></li><li>同时并发<ul><li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li><li>最理想的并发方式，但受制于硬件环境</li><li>更复杂的并发方式机制</li></ul></li></ul></li><li>并发控制<ul><li>事务是并发控制的基本单位</li><li>并发控制机制的任务<ul><li>对并发操作进行正确调度</li><li>保证事务的隔离性</li><li>保证数据库的一致性</li></ul></li><li>并发操作带来的数据不一致性<ul><li>丢失修改</li><li>不可重复读</li><li>读脏数据</li></ul></li></ul></li><li>丢失修改<ul><li>两个事务 T1 和 T2 读入同一数据并修改， T2的提交结果破坏了 T1提交的结果，导致 T1的修改被丢失</li><li><img src="image-20240507163437064.png" alt="image-20240507163437064" style="zoom:50%;" /></li></ul></li><li>不可重复读<ul><li>不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使T1 无法再现前一次读取结果</li><li><img src="image-20240507163512940.png" alt="image-20240507163512940" style="zoom: 50%;" /></li><li><img src="image-20240507163528614.png" alt="image-20240507163528614" style="zoom:50%;" /></li></ul></li><li>读脏数据<ul><li>概念<ul><li>事务 T1 修改某一数据，并将其写回磁盘</li><li>事务 T2 读取同一数据后， T1 由于某种原因被撤销</li><li>这时 T1 已修改过的数据恢复原值， T2 读到的数据就与数据库中的数据不一致</li><li>T2 读到的数据就为 脏 数据，即不正确的数据</li></ul></li><li><img src="image-20240507165156396.png" alt="image-20240507165156396" style="zoom:50%;" /></li></ul></li><li>并发控制方式<ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul></li></ul><h3 id="2-封锁"><a href="#2-封锁" class="headerlink" title="2. 封锁"></a>2. 封锁</h3><ul><li>概念<ul><li>封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象</li><li>基本封锁类型<ul><li>排它锁&#x2F;写锁（简记为X锁或W锁）</li><li>共享锁&#x2F;读锁（简记为S锁或R锁）</li></ul></li></ul></li><li>排他锁与共享锁<ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</li><li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到 T 释放A上的S锁</li></ul></li><li>封锁协议<ul><li>在运用 X 锁和 S 锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议<ul><li>何时申请 X 锁或 S 锁</li><li>持锁时间</li><li>何时释放</li></ul></li><li>一级封锁协议<ul><li>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放</li><li>一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。</li><li>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读脏数据。</li></ul></li><li>二级封锁协议<ul><li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁</li><li>二级封锁协议可以防止丢失修改和读脏数据</li><li>在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它不能保证可重复读</li></ul></li><li>三级封锁协议<ul><li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li><li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。</li><li><img src="image-20240507170014737.png" alt="image-20240507170014737" style="zoom:50%;" /></li></ul></li></ul></li><li>活锁与死锁<ul><li>活锁<ul><li><img src="image-20240507170258593.png" alt="image-20240507170258593" style="zoom:50%;" /></li><li>避免活锁：采用先来先服务的策略</li></ul></li><li>死锁<ul><li><img src="image-20240507170338505.png" alt="image-20240507170338505" style="zoom:50%;" /></li><li>简单来说就是等待形成闭环</li></ul></li><li>死锁的预防<ul><li>一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li>顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li></ul></li><li>死锁的诊断<ul><li>超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li><li>等待图法， 并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</li><li><img src="image-20240507170526998.png" alt="image-20240507170526998" style="zoom:50%;" /></li></ul></li><li>死锁的解除<ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul></li></ul></li></ul><h3 id="3-事务调度"><a href="#3-事务调度" class="headerlink" title="3. 事务调度"></a>3. 事务调度</h3><ul><li><p>并发调度的可串行性</p><ul><li>概念：执行结果等价于串行调度的调度是正确的，称为可串行化调度</li><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul></li><li><p>冲突可串行化</p><ul><li>冲突操作：是指不同的事务对同一数据的读写操作和写写操作</li><li>其他操作是不冲突操作</li><li>不能交换的动作<ul><li>同一事务的两个操作</li><li>不同事务的冲突操作</li></ul></li><li><img src="image-20240512101532738.png" alt="image-20240512101532738" style="zoom:50%;" /></li><li>冲突可串行化调度是可串行化调度的<strong>充分条件</strong>，<strong>不是必要条件</strong>。还有不满足冲突可串行化条件的可串行化调度。</li></ul></li><li><p>两段锁协议</p><ul><li>概念：所有事务必须分两个阶段对数据项加锁和解锁</li><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li><li>两段锁协议中事务分为两个阶段：第一阶段是获得封锁，也称为扩展阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁；第二阶段是释放封锁，也称为收缩阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li><li>事务遵守两段锁协议是可串行化调度的<strong>充分条件</strong>，而<strong>不是必要条件</strong>。</li><li><img src="image-20240512102104179.png" alt="image-20240512102104179" style="zoom:50%;" /></li></ul></li></ul><h3 id="4-封锁粒度"><a href="#4-封锁粒度" class="headerlink" title="4. 封锁粒度"></a>4. 封锁粒度</h3><ul><li><p>封锁粒度</p><ul><li>封锁对象的大小称为封锁粒度</li><li>封锁的对象：逻辑单元，物理单元<ul><li>逻辑单元 : 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li><li>物理单元：页（数据页或索引页）、物理记录等</li></ul></li><li>封锁粒度与系统的并发度和并发控制的开销密切相关<ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li><li>封锁的粒度越小，并发度较高，但系统开销也就越大</li></ul></li><li>多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择<ul><li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li><li>需要处理大量元组的用户事务：以关系为封锁单元</li><li>只处理少量元组的用户事务：以元组为封锁单位</li></ul></li></ul></li><li><p>多粒度树</p><ul><li>以树形结构来表示多级封锁粒度</li><li>根结点是整个数据库，表示最大的数据粒度</li><li>叶结点表示最小的数据粒度</li><li><img src="image-20240512103213720.png" alt="image-20240512103213720" style="zoom:50%;" /></li></ul></li><li><p>多粒度封锁协议</p><ul><li>允许多粒度树中的每个结点被独立地加锁</li><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li><li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul><li>显式封锁 : 直接加到数据对象上的封锁</li><li>隐式封锁 是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li></ul></li><li>系统检查封锁冲突时，既要检查显式封锁，还要检查隐式封锁</li><li>对某个数据对象加锁，系统要检查：<ul><li>该数据对象有无显式封锁与之冲突</li><li>所有上级结点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突</li><li>所有下级结点：看上面的显式封锁是否与本事务的隐式封锁</li></ul></li></ul></li><li><p>意向锁</p><ul><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li><li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li><li>例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</li></ul></li><li><p>常用意向锁</p><ul><li><img src="image-20240512103701784.png" alt="image-20240512103701784" style="zoom:50%;" /></li><li><img src="image-20240512103715836.png" alt="image-20240512103715836" style="zoom:50%;" /></li><li><img src="image-20240512103812734.png" alt="image-20240512103812734" style="zoom:50%;" /></li><li><img src="image-20240512104014765.png" alt="image-20240512104014765" style="zoom:50%;" /></li></ul></li><li><p>具有意向锁的多粒度封锁方法</p><ul><li>申请封锁时应该按自上而下的次序进行</li><li>释放封锁时则应该按自下而上的次序进行</li><li><img src="image-20240512104306067.png" alt="image-20240512104306067" style="zoom: 50%;" /></li></ul></li></ul><h3 id="5-查询处理"><a href="#5-查询处理" class="headerlink" title="5. 查询处理"></a>5. 查询处理</h3><ul><li><img src="image-20240512104658699.png" alt="image-20240512104658699" style="zoom:50%;" /></li><li>查询分析<ul><li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析</li><li>词法分析：从查询语句中识别出正确的语言符号</li><li>语法分析：进行语法检查</li></ul></li><li>查询检查<ul><li>根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效</li><li>如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作</li><li>根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查</li><li>检查通过后把 SQL 查询语句转换成内部表示，即等价的关系代数表达式。</li></ul></li><li>查询优化<ul><li>查询优化：选择一个高效执行的查询处理策略</li><li>查询优化分类<ul><li>代数优化&#x2F;逻辑优化：指关系代数表达式的优化</li><li>物理优化：指存取路径和底层操作算法的选择</li></ul></li><li>查询优化的选择依据<ul><li>基于规则</li><li>基于代价</li><li>基于语义</li></ul></li></ul></li><li>查询执行<ul><li>依据优化器得到的执行策略生成查询执行计划</li><li>两种执行方法<ul><li>自顶向下</li><li>自底向上</li></ul></li></ul></li><li>各种操作的实现<ul><li>选择操作<ul><li>全表扫描方法（适合小表）：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出</li><li>索引扫描方法(适合于选择条件中的属性上有索引，例如B+树索引或Hash索引)：通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li></ul></li><li>连接操作<ul><li><img src="image-20240512105946194.png" alt="image-20240512105946194" style="zoom:50%;" /></li><li><img src="image-20240512110042019.png" alt="image-20240512110042019" style="zoom:50%;" /></li><li><img src="image-20240512110054804.png" alt="image-20240512110054804" style="zoom:50%;" /></li><li><img src="image-20240512110112932.png" alt="image-20240512110112932" style="zoom:50%;" /></li><li><img src="image-20240512110123324.png" alt="image-20240512110123324" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="6-查询优化"><a href="#6-查询优化" class="headerlink" title="6. 查询优化"></a>6. 查询优化</h3><ul><li><p>概述</p><ul><li>关系查询优化是影响关系数据库管理系统性能的关键因素</li><li>非关系系统中用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的</li><li>目标：关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案</li><li><img src="image-20240514162847443.png" alt="image-20240514162847443" style="zoom: 67%;" /></li><li>分为代数优化和物理优化</li></ul></li><li><p>代数优化</p><ul><li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率，E1 ≡ E2表示两个表达式等价</li><li>常用的等价变换规则<ul><li><img src="image-20240514163149780.png" alt="image-20240514163149780" style="zoom: 50%;" /></li><li><img src="image-20240514163200443.png" alt="image-20240514163200443" style="zoom:50%;" /></li><li><img src="image-20240514163210003.png" alt="image-20240514163210003" style="zoom:50%;" /></li><li><img src="image-20240514163300627.png" alt="image-20240514163300627" style="zoom:50%;" /></li></ul></li><li>典型的启发式规则<ul><li>选择运算应尽可能先做</li><li>把投影运算和选择运算同时进行</li><li>把投影同其前或其后的双目运算结合起来</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算</li><li>找出公共子表达式</li></ul></li><li>查询树的启发式优化算法见PPT</li></ul></li><li><p>物理优化</p><ul><li><p>概述</p><ul><li>代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</li><li>对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的</li><li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</li></ul></li><li><p>物理优化方法</p><ul><li>基于规则的启发式优化</li><li>基于代价估算的优化</li><li>两者结合的优化方法</li></ul></li><li><p>选择操作的启发式规则</p><ul><li><p>对于小关系，使用全表顺序扫描，即使选择列上有索引</p></li><li><p>对于大关系，启发式规则有：</p><img src="image-20240514172111501.png" alt="image-20240514172111501" style="zoom: 67%;" /></li><li><p>连接操作的启发式规则</p><ol><li>如果 2 个表都已经按照连接属性排序：选用排序-合并算法</li><li>如果一个表在连接属性上有索引：选用索引连接算法</li><li>如果上面 2 个规则都不适用，其中一个表较小：选用 hash join 算法</li><li>可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数 (较少的表，作为外表 外循环的表 )</li></ol></li></ul></li><li><p>基于代价估算的优化</p><ul><li>启发式规则优化是定性的选择，适合解释执行的系统</li><li>编译执行的系统中查询优化和查询执行是分开的</li><li>基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关</li><li><img src="image-20240514173200353.png" alt="image-20240514173200353" style="zoom: 60%;" /></li><li>代价估算方法<ol><li><img src="image-20240514173238431.png" alt="image-20240514173238431"></li><li><img src="image-20240514173248991.png" alt="image-20240514173248991"></li></ol></li></ul></li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><span id="more"></span><h2 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h2><ul><li>Thompson算法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110195743">编译原理: Thompson 构造法（正则表达式 转 NFA）_thompson构造法-CSDN博客</a></li><li><img src="image-20240611150213632.png" alt="image-20240611150213632"></li><li><img src="image-20240611150228916.png" alt="image-20240611150228916"></li><li><img src="image-20240611150236987.png" alt="image-20240611150236987"></li><li><img src="image-20240611150247191.png" alt="image-20240611150247191" style="zoom:50%;" /></li><li><img src="image-20240611150257922.png" alt="image-20240611150257922" style="zoom:67%;" /></li><li><img src="image-20240611150306204.png" alt="image-20240611150306204" style="zoom:67%;" /></li><li><img src="41.png"></li></ul></li><li>子集构造法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110213913">编译原理: Subset Construction 子集构造法(幂集构造)(NFA转DFA)_编译原理nfa转dfa-CSDN博客</a></li><li><img src="image-20240611150549771.png" alt="image-20240611150549771"></li><li><img src="image-20240611150602989.png" alt="image-20240611150602989" style="zoom:67%;" /></li><li>解释：先把初始状态和它通过无条件转移能到达的并为一个状态，然后一步步根据不同输入扩展，知道所有状态在所有输入情况下的目标状态都已定义</li></ul></li><li>DFA最小化算法<ul><li><img src="image-20240611152632268.png" alt="image-20240611152632268"></li><li><img src="image-20240611152648720.png" alt="image-20240611152648720" style="zoom:50%;" /></li><li>解释：先把非接受状态和接受状态分成两类，再在每个等价类内部判断每个成员是否会转移到其他等价类，如果是就把它拎出去单独成一个等价类，直到最后只剩最小闭包。</li><li>合并等价状态时注意只把它们之间的状态转移去掉，但它们自己到自己的边和与外界相连的边要保留</li></ul></li></ul><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><ul><li>上下文无关文法<ul><li><img src="image-20240611154021569.png" alt="image-20240611154021569"></li><li><img src="image-20240611155045696.png" alt="image-20240611155045696" style="zoom:67%;" /></li><li>在最左推导中，每一步总是替换字符串中最左边的非终结符。具体过程如下（最右推导相反）：<ol><li>从起始符号（开始符号）S开始。</li><li>在每一步推导中，选择当前字符串中最左边的非终结符，并使用某个产生式规则进行替换。</li><li>重复步骤2，直到得到仅由终结符组成的字符串。</li></ol></li><li><img src="image-20240611155322088.png" alt="image-20240611155322088"></li><li>文法G 的语言L(G) 是它能推导出的所有句子构成的集合</li></ul></li></ul><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><ul><li><p>FIRST与FOLLOW求解</p><ul><li><p><a href="https://blog.csdn.net/jianbai_/article/details/106367466">编译原理：LL(1)文法-构造预测分析表_ll(1)分析表-CSDN博客</a></p></li><li><p>示例看这篇：<a href="https://blog.csdn.net/qq_40741513/article/details/106036849">编译原理LL(1)预测分析表的构造_构造文法l(1)l预测分析表-CSDN博客</a></p></li><li><p>First(α) 是可从α 推导得到的句型的首终结符号的集合，Follow(A) 是可能在某些句型中紧跟在A 右边的终结符的集合</p></li><li><p>注意，FIRST和FOLLOW都是针对单个非终结符的，预测分析表的行也是单个非终结符，也就是说不存在类似FIRST(ABC)</p></li><li><img src="28.png" style="zoom: 50%;" /></li><li><img src="29.png" style="zoom:50%;" /></li><li><p>对文法G的每个产生式A-&gt;α 执行如下步骤：</p></li></ul><p>  （1）对每个a∈First(α)，把 A-&gt;α 加入M[A,a]</p><p>  （2）若 ε∈First(α)，则对任何b∈Follow(A) ,把 A-&gt; ε加至M[A,b]中</p></li><li><p>判断某文法是否为LL(1)</p><ul><li><a href="https://blog.csdn.net/weixin_44162921/article/details/103482452">编译原理——判断是否为LL（1）文法及构造分析表_请写出ll(1)文法应满足的条件。-CSDN博客</a></li><li><img src="image-20240611193206421.png" alt="image-20240611193206421" style="zoom:80%;" /></li><li>另一种方式：检查预测分析表是否无冲突，即检查是否有一个单元格中是否有有超过一个表达式，如果有则不是LL(1)</li></ul></li></ul><h3 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a>LR(0)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105554383">编译原理学习笔记（七）~LR(0)分析-CSDN博客</a></li><li>画自动机<ul><li>先对文法增广</li><li>通过初始状态得到I0</li><li>一步步对每个点不在最右边的情况生成新的状态，计算项集时注意每一条点不在最右边的要把点后非终结符的规则加进来</li><li>直到最后不再有新的状态出现</li></ul></li><li>画分析表<ul><li>根据自动机填表</li><li>非终结符部分有三种（移入s，规约r，接受acc），终结符部分直接写数字表示状态跳转</li><li>注意需要规约的状态无论看到什么输入都进行规约</li></ul></li><li>关注栈的状态<ul><li>移入动作代表入栈</li><li>入栈的同时也带来新的状态</li><li>出栈时状态回到该句柄入栈前的状态</li></ul></li></ul><h3 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a>SLR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105596980">编译原理学习笔记（九）~SLR分析-CSDN博客</a></li><li>如果文法G 的SLR(1) 分析表是无冲突的, 则G 是SLR(1) 文法。</li><li><img src="image-20240612154526804.png" alt="image-20240612154526804"></li><li>新的自动机：在规约项后加上FOLLOW集中的元素，表示只有下一个输入符号为这些之一才规约，否则移入</li><li><img src="image-20240612155521083.png" alt="image-20240612155521083"></li></ul><h3 id="LALR-1"><a href="#LALR-1" class="headerlink" title="LALR(1)"></a>LALR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105599118">编译原理学习笔记（十一）~LALR分析法-CSDN博客</a></li><li>LALR(1) : 合并具有相同核心LR(0)项的状态(忽略不同的向前看符号)</li><li><img src="image-20240612160005965.png" alt="image-20240612160005965"></li></ul><h2 id="ANTLR优先级上升算法"><a href="#ANTLR优先级上升算法" class="headerlink" title="ANTLR优先级上升算法"></a>ANTLR优先级上升算法</h2><ul><li>优先级确定：根据原文法从下往上每条规则优先级从1递增</li><li>非左递归规则改写：<ul><li>放在开头，用( )包裹，两条规则中间用|隔开</li><li>若包含递归规则，分为含运算符和不含运算符两种</li><li>不含运算符（如<code>( expr )</code>）则传参数0</li><li>若含右结合单操作数运算符（如<code>&#39;-&#39; expr</code>），则传参等于此条规则优先级</li></ul></li><li>左递归规则改写：<ul><li>用( )包裹，最后有*</li><li>每条规则前有优先级判断（如<code>(5 &gt;= $_P)?</code>）</li><li>非终结符调用递归规则，若运算符为左结合（包括单操作数，如阶乘 !）则传参为该规则优先级+1，若运算符为右结合（如指数运算2^5，规则前要加一条<code>&lt;assoc = right&gt;</code>）则传参为该规则优先级</li><li>优先级升高原因：使优先级等于或高于当前节点的能在当前节点下展开，小于的回到上一级展开</li></ul></li><li>示例<ul><li><img src="image-20240621092049848.png" alt="image-20240621092049848"></li><li><img src="image-20240621092105593.png" alt="image-20240621092105593" style="zoom: 50%;" /></li><li><img src="image-20240621092118737.png" alt="image-20240621092118737"></li><li><img src="image-20240621092141481.png" alt="image-20240621092141481"></li><li><img src="80a9dcf969d7026c3dda87a88cb61c40-1718933855431.png" alt="img" style="zoom:50%;" /></li></ul></li></ul><h2 id="语法制导翻译SDT"><a href="#语法制导翻译SDT" class="headerlink" title="语法制导翻译SDT"></a>语法制导翻译SDT</h2><ul><li><img src="image-20240611195505703.png" alt="image-20240611195505703" style="zoom:50%;" /></li><li>综合属性<ul><li><img src="image-20240611195633623.png" alt="image-20240611195633623" style="zoom:50%;" /></li><li>在LL 语法分析器中, 递归下降函数A 返回时,计算相应节点A 的综合属性值</li><li>综合属性用returns定义！</li></ul></li><li>继承属性<ul><li><img src="image-20240611195804291.png" alt="image-20240611195804291" style="zoom:50%;" /></li><li><img src="image-20240611200431868.png" alt="image-20240611200431868" style="zoom:50%;" /></li><li>继承属性用参数定义！</li></ul></li><li>L属性<ul><li><img src="image-20240611195917546.png" alt="image-20240611195917546" style="zoom:50%;" /></li><li>直观来说就是继承属性只能从上往下、从左往右传递</li><li><img src="image-20240611200751148.png" alt="image-20240611200751148" style="zoom:50%;" /></li></ul></li><li><img src="image-20240611200549503.png" alt="image-20240611200549503" style="zoom:50%;" /></li><li>例子<ul><li><img src="image-20240621094922672.png" alt="image-20240621094922672"></li><li><img src="image-20240621095154487.png" alt="image-20240621095154487"></li><li><img src="image-20240621095217714.png" alt="image-20240621095217714"></li><li><img src="image-20240621095309194.png" alt="image-20240621095309194"></li><li><img src="image-20240621101202137.png" alt="image-20240621101202137"></li></ul></li></ul><h2 id="中间代码翻译"><a href="#中间代码翻译" class="headerlink" title="中间代码翻译"></a>中间代码翻译</h2><ul><li>表达式<ul><li><img src="image-20240612141832786.png" alt="image-20240612141832786" style="zoom:50%;" /></li></ul></li><li>数组引用<ul><li><img src="image-20240612143015988.png" alt="image-20240612143015988" style="zoom:67%;" /></li></ul></li><li>控制流语句翻译中的地址回填技术<ul><li><img src="image-20240612143619019.png" alt="image-20240612143619019" style="zoom: 50%;" /></li><li>祖先节点通过综合属性收集子节点中具有相同目标的跳转指令</li><li>综合属性B.truelist 保存需要跳转到B.true 标签的指令</li><li>综合属性B.falselist 保存需要跳转到B.false 标签的指令</li><li>综合属性S&#x2F;L.nextlist 保存需要跳转到S&#x2F;L.next 标签的指令</li><li><img src="image-20240612144545716.png" alt="image-20240612144545716"></li></ul></li><li>控制流语句<ul><li>简单模式：只使用综合属性，为布尔表达式B 计算逻辑值(假设保存在临时变量t1 中)，if、while 等语句根据 B 的结果改变控制流</li><li>困难模式：父节点为子节点准备跳转指令的目标标签，子节点通过继承属性确定跳转目标</li><li><img src="image-20240612145711859.png" alt="image-20240612145711859"></li><li><img src="image-20240612145745468.png" alt="image-20240612145745468"></li></ul></li></ul><h2 id="RISC-V指令集"><a href="#RISC-V指令集" class="headerlink" title="RISC-V指令集"></a>RISC-V指令集</h2><ul><li>寄存器<ul><li>ra：返回地址</li><li>t0 - t6：临时寄存器</li><li>pc：程序计数器</li></ul></li><li>指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>one: .word 1 # int one = 1; 32位下word4字节，byte1字节，doubleword8字节<br>result: .word 0<br>msg: .string &quot;hello&quot; # 自带\0的字符串，.ascii是不带\0的<br>array: .word 10, 20, 30, 40 # 每个数字占一个word<br><br>.text<br>li t0, 200 # 立即数加载，伪指令<br>addi t0, zero, 200 # 立即数加法，实现li<br>add t2, t0, t1 # t2 = t0 + t1<br>sub t2, t0, t1 # t2 = t0 - t1<br>mul t2, t0, t1 # t2 = t0 * t1<br>slli t2, t0, 2 # t2 = t0 &lt;&lt; 2<br><br># 系统调用<br>li a7, 1 # 系统调用号存入a7, 1是输出单字，4输出字符串<br>add a0, t0, zero # 传参到a0 - a6<br>mv a0, t0 # 伪指令，a0 &lt;- t0<br>ecall # 触发系统调用<br><br># 从内存中存取数据<br>la t0, one<br>lw t0, 0(t0) # load word，加载一个字节(也有lb)，0是offset，t0是基址<br><br>la t1, result<br>sw t0, 0(t1) # save word，与lw对应，但是注意方向相反：t0 -&gt; 0(t1)<br># 等价于lw t0, one和sw t0, result, t2伪指令<br><br># 访问数组<br>la t0, array<br>lw t1, 12(t0) # 访问array[3]<br><br># 条件判断<br>bge t0, t1, label1 # branch if t0 &gt;= t1<br>bltz t0, label1 # branch if t0 &lt; 0<br>beqz t0, label1 # branch if t0 = 0<br>j label1 # jump<br><br># 函数调用<br>jal ra, max # 调用max函数，把max首条指令地址存入pc，并把下条指令地址存入ra<br># 可以缩写成jal max或call max，默认用ra存<br><br>jalr zero, 0(ra) # 被调用方用，返回0(ra)的地址，并将当前下一条指令存入第一个参数(用zero表示丢弃)<br># 可以缩写成jr ra或ret<br><br>#栈操作<br>addi sp, sp, -8 # 腾出8字节栈空间<br>sw a0, 4(sp) # 将需要保存的寄存器值存入栈空间<br>sw ra, 0(sp) # 注意，ra在多层调用时一定要保存<br># 此处省略函数调用，如递归<br>mv t0, a0 # 把返回值存入t0，防止丢失<br>lw a0, 4(sp)<br>lw ra, 0(sp)<br>addi sp, sp, 8<br></code></pre></td></tr></table></figure><h2 id="寄存器分配算法"><a href="#寄存器分配算法" class="headerlink" title="寄存器分配算法"></a>寄存器分配算法</h2><ul><li><img src="image-20240621110136179.png" alt="image-20240621110136179" style="zoom: 50%;" /></li><li><img src="image-20240621110531657.png" alt="image-20240621110531657" style="zoom: 67%;" /></li><li><img src="image-20240621110653715.png" alt="image-20240621110653715" style="zoom:50%;" /></li><li>线性扫描分配算法<ul><li>三大关键操作: 占用、释放、溢出</li><li><img src="image-20240621110903961.png" alt="image-20240621110903961" style="zoom:50%;" /></li><li>发生溢出时，比较右端点，把最远的放入内存，腾出来的寄存器给新变量</li><li><img src="image-20240621111514563.png" alt="image-20240621111514563" style="zoom:50%;" /></li><li>解决方案一：生成代码时, 使用临时物理寄存器实现临时变量</li><li>解决方案二: 预留若干物理寄存器, 作为溢出处理时所需的临时寄存器</li><li>分支指令问题<ul><li><img src="image-20240621111658512.png" alt="image-20240621111658512" style="zoom:50%;" /></li><li><img src="image-20240621111710530.png" alt="image-20240621111710530" style="zoom:50%;" /></li><li><img src="image-20240621111722291.png" alt="image-20240621111722291"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II</title>
    <link href="/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/"/>
    <url>/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="软工II整理"><a href="#软工II整理" class="headerlink" title="软工II整理"></a>软工II整理</h1><h2 id="01-软件工程基础"><a href="#01-软件工程基础" class="headerlink" title="01.软件工程基础"></a>01.软件工程基础</h2><ul><li><p>软件的特性</p><ul><li>软件与现实世界关系更加密切，对需求的规格化更加困难</li><li>软件⽐硬件容易修改的多，并且不需要昂贵的⽣产线复制产品</li><li>软件没有损耗</li><li>软件不可见</li></ul></li></ul><span id="more"></span><ul><li><p>云原生</p><ul><li><img src="image-20240311210317505.png" alt="image-20240311210317505" style="zoom: 67%;" /></li></ul></li><li><p>软件类别</p><ul><li>系统软件：操作系统、数据库、数据仓库、嵌⼊式设备、安全</li><li>编程软件：IDE、测试、持续集成、建模、度量</li><li>应用软件：商业、政府、休闲、医疗、教育、国防、 个⼈、专业、科学</li></ul></li><li><p>应⽤软件</p><ul><li>应⽤软件被开发的⽬的和意图来源于现实世界的问题。</li><li>应⽤软件必须基于现实才能解决问题。</li><li>软件最终要被⽤于现实并改进现实。</li><li><img src="image-20240311210345790.png" alt="image-20240311210345790" style="zoom:67%;" /></li></ul></li><li><p>工程</p><ul><li>定义：创造性地应用科学原理，设计或开发结构、机器、仪器或制造工艺，或单独或组合使用它们的工程；或在充分了解它们的设计的情况下建造或操作它们；或在特定操作条件下预测它们的行为；就预期功能、运行的经济性或生命财产安全而言</li><li><strong>CCSE - About Engineer 关于工程师的介绍</strong><ul><li>工程师通过⼀系列的<strong>讨论决策</strong>，仔细评估项⽬的可选活动，并在每个决策点选择⼀种在当前环境中适合工当前任务的⽅法进⾏工作。可以通过对成本和收益进⾏折衷分析调整相应策略。</li><li>工程师需要对某些对象进⾏度量，有时需要定量的工作；他们要校准和确认度量⽅法，并根据经验和实验数据进⾏估算。</li><li>软件工程师强调<strong>项目设计过程的纪律性</strong>，这是团队⾼效工作的条件。</li><li>工程师可胜任研究、开发、设计、⽣产、测试、构造、操作、管理，以及销售、咨询和培训等<strong>多种角色</strong>。</li><li>工程师们需要在某些过程中使⽤工具，选择和使用合适的工具是工程的关键要素。</li><li>工程师们通过专业协会发展和确认原理、标准和最佳实践⽅法，并提⾼个⼈能⼒。</li><li>工程师们能够重用设计和设计制品。</li></ul></li><li><img src="image-20240311210400691.png" alt="image-20240311210400691" style="zoom:50%;" /></li></ul></li><li><p>工程的要素</p><ul><li>具有解决实际问题的动机</li><li>应⽤科学知识指导⼯程活动</li><li>以成本效益比有效为基本条件</li><li>构建机器或事物</li><li>以服务⼈类为最终⽬的</li></ul></li><li><p>软件工程定义</p><ol><li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</li><li>对(1)中各种方法的研究。</li></ol></li><li><p>软件工程特点</p><ul><li>软件⼯程是⼀种⼯程活动</li><li>软件⼯程的动机是解决实际问题</li><li>软件⼯程是科学性、实践性和⼯艺性并重的</li><li>软件⼯程追求⾜够好，不是最好</li><li>软件⼯程真正的产品是基于虚拟计算机的软件⽅案</li><li>软件⼯程的最终⽬的是要促进整个社会的进步</li></ul></li><li><p>软件工程技术域</p><ul><li><img src="image-20240311210414779.png" alt="image-20240311210414779" style="zoom:67%;" /></li><li><img src="image-20240311210434034.png" alt="image-20240311210434034" style="zoom:67%;" /></li><li>软件工程管理知识域：<img src="image-20240311210446065.png" alt="image-20240311210446065"></li></ul></li><li><p>角色分工</p><ul><li>需求工程师，⼜被称为需求分析师：承担需求开发任务。软件产品的需求开发⼯作通常由多个需求工程师来完成，他们共同组成⼀个需求工程师⼩组，在⾸席需求工程师的领导下开展⼯作。通常⼀个团队只有⼀个需求工程师⼩组。</li><li>软件体系结构师：承担软件体系结构设计任务。通常也是由多⼈组成⼀个小组，并在首席软件体系结构师的领导下开展⼯作。通常⼀个团队只有⼀个软件体系结构师小组。</li><li>软件设计师：承担详细设计任务。在软件体系结构设计完成之后，可以将其部件分配给不同的开发小组。开发小组中负责所分配部件详细设计工作的⼈员就是软件设计师。⼀个团队可能有⼀个或多个开发小组。 ⼀个小组可能有⼀个或多个软件设计师。</li><li>程序员：承担软件构造任务。程序员与软件设计师通常是同⼀批⼈，也是根据其所分配到的任务开展⼯作。</li><li>⼈机交互设计师：承担⼈机交互设计任务。⼈机交互设计师与软件设计师可以是同⼀批⼈，也可以是不同⼈员。在有多个小组的软件工程团队中，可以有⼀个单独的人机交互设计师小组，也可以将⼈机交互设计师分配到各个小组。</li><li>软件测试⼈员：承担软件测试任务。软件测试⼈员通常需要独⽴于其他的开发⼈员⻆⾊。⼀个团队可能有⼀个或多个测试⼩组。⼀个⼩组可能有⼀个或多个软件测试⼈员。</li><li>项⽬管理⼈员：负责计划、组织、领导、协调和控制软件开发的各项⼯作。相⽐于传统意义上的管理者，他们不完全是监控者和控制者，更多得是协调者。通常⼀个团队只有⼀个项⽬管理⼈员。</li><li>软件配置管理⼈员：管理软件开发中产⽣的各种制品，具体⼯作是对重要制品进⾏标识、变更控制、状态报告等。通常⼀个团队只有⼀个软件配置管理⼈员。</li><li>质量保障⼈员：在⽣产过程中监督和控制软件产品质量的⼈员。通常⼀个团队有⼀个质量保障⼩组，由⼀个或多个⼈员组成。</li><li>培训和⽀持⼈员：负责软件移交与维护任务。他们可以是其他开发⼈员的⼀部分，也可以是独立的⼈员。</li><li>⽂档编写⼈员：专⻔负责写作软件开发各种⽂档的⼈员。他们的存在是为了充分利⽤部分宝贵的⼈⼒资源(例如需求工程师和软件体系结构师)，让这些⼈⼒资源从繁杂的⽂档化⼯作中解放出来。</li></ul></li></ul><h2 id="02-项目启动"><a href="#02-项目启动" class="headerlink" title="02.项目启动"></a>02.项目启动</h2><h3 id="项目和项目管理"><a href="#项目和项目管理" class="headerlink" title="项目和项目管理"></a>项目和项目管理</h3><ul><li>项目的定义<ul><li>具有⼀个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul></li><li>项目管理的目标<ul><li>在限定时间内</li><li>在⼀定的成本内</li><li>在要求的质量水平上</li><li>高效使用资源</li><li>获得客户认可</li></ul></li><li>过程组：项目启动、项目计划、项目执⾏，项目跟踪与控制和项目收尾</li><li>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</li></ul><h3 id="团队组织与管理"><a href="#团队组织与管理" class="headerlink" title="团队组织与管理"></a>团队组织与管理</h3><ul><li>团队定义：为了⼀致的目的、绩效标准、⽅法⽽共担责任并且技能互补的少数⼈。</li><li>团队结构<ul><li><strong>主程序员团队</strong>：决策需要由主程序员进行制定<ul><li>效率高，如果完成把握大，并且需要时间紧迫，可以优先考虑</li><li>一个人的决断容易影响整个团队，如果项目复杂，主程序员会成为瓶颈。</li><li>适用于把握性大，时间要求紧的情况</li></ul></li><li><strong>民主团队</strong>：没有集中的瓶颈，成员发挥能动性，工作效率降低，冲突解决。敏捷+较有挑战性的项目</li><li><strong>开放团队</strong><ul><li>为了创新而存在的。黑箱管理，问题在于项目进展没有可视度。</li><li>相对于前两个团队的需求明确，团队的需求并不明确</li><li>管理者主要负责清除出现的障碍。</li><li>开放团队是为了<strong>创新</strong>而存在</li></ul></li></ul></li><li>团队建设(高凝聚力的团队被称为胶冻团队)<ul><li><strong>建立团队章程</strong>：建立明确的团队章程，统一团队成员的目标，对团队成员进行一定的约束。经验：有必要指定一定的章程，约束团队成员之间的行为，比如开会请假必须得到其他三人的同意，又如一旦某项决策做出，不同意者不能再后续阶段违反等</li><li><strong>持续成功</strong>：设置小里程碑，每隔一段时间让团队体验成功。每次作业的检查结果一定程度上肯定了每个小阶段的工作。</li><li><strong>和谐沟通</strong>：和谐沟通：建立持续有效的沟通机制，相互尊重，管道畅通，开放透明，坦诚真实。开会频率保持在每周一次左右为宜，在工作量大的时候，需要集体工作，当面沟通，另外吵架可以，但是需要达成一致。</li><li><strong>不断总结</strong>：不断总结上一阶段的工作成果，运用项目评审等手段，进行反思回顾，指导后续阶段的开发。每个阶段都会有启动会议对上个阶段进行回顾，评审会议对此阶段进行评审。</li><li><strong>避免团队杀手</strong>：需要对别人的工作全心全意的信任，尽管评审是必要的。产品质量的降低会使凝聚力下降</li></ul></li></ul><h3 id="软件质量保障"><a href="#软件质量保障" class="headerlink" title="软件质量保障"></a>软件质量保障</h3><ul><li><p>质量属性</p><ul><li>⼈们通常会选⽤系统的某些质量要素进行量化处理，建⽴质量特征，这些特征被称为<strong>质量属性</strong></li><li>为了根据质量属性描述和评价系统的整体质量，⼈们从很多质量属性的定义当中选择了⼀些能够相互配合、相互联系的特征集，它们被称为<strong>质量模型</strong></li></ul></li><li><p>质量模型</p><ul><li>因素</li><li>功能性</li><li>可靠性</li><li>易用性:人机交互</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li><p>质量保障</p><ul><li><img src="3.png" style="zoom:50%;" /></li><li><img src="image-20240312201645433.png" alt="image-20240312201645433" style="zoom:50%;" /></li><li><p>度量产生自统计控制思想。</p></li><li><p>测度就是为了描述软件产品而提供的定量指标，如代码行数</p></li><li><p>进行测度的活动被称为测量</p></li><li><p>度量是软件产品在特定属性上的量化测度程度</p></li></ul></li><li><p>评审</p><ul><li><img src="5.png" style="zoom:50%;" /></li><li>在<strong>规划</strong>阶段，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与⼈员、审查内容等等。</li><li>在<strong>总体部署</strong>阶段，向所有参与审查会议的⼈员描述待审查材料的内容、审查的⽬标以及⼀些假设，并分发⽂档。</li><li>在<strong>准备</strong>阶段，审查⼈员各⾃独⽴执⾏检查任务。在检查的过程当中，他们可能会被要求使⽤检查清单、场景等检查⽅法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集 ⼈员。</li><li>在<strong>审查会议</strong>阶段，通过会议讨论，识别、确认、分类发现的错误。</li><li>在**返⼯**阶段，修改发现的缺陷。</li><li>在<strong>跟踪</strong>阶段，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</li></ul></li><li><p>软件配置管理的动机</p><ul><li>在软件开发活动中，除了最终产品之外，还会产⽣很多<strong>中间制品</strong>，例如需求规格说明、需求分析模型、软件体系结构设计模型、详细设计模型等。这些制品是不同阶段、不同角色、不同软件开发活动进行协同的基础。</li><li>在复杂软件系统开发中，产⽣的制品数量众多，以⾄于开发者需要维护⼀个清单才能清楚项目所处的状态，理解已经完成的⼯作和将要进行的⼯作。</li><li>某个制品发⽣变化带来的最大挑战是如何确保其使用者能够得到最新的制品，避免开发协同出现问题</li></ul></li><li><p>配置管理</p><ul><li>IEEE定义：用技术的和管理的指导和监督方法，来标识和说明<strong>配置项</strong>的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的⼀致性</li><li><strong>配置项</strong>：置于软件配置管理之下的软件配置的各种有关项⽬，包括各类管理文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等</li><li><strong>基线</strong>：基线是指通过了评审和验证，可以作为后续开发工作基础而进入协同工作过程，需要纳入配置管理和执行变更控制的制品</li><li><strong>配置管理活动</strong>：<ul><li>标识配置项版本管理：确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单</li><li>配置审计：验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告：反映当前的配置状态。</li><li>软件发布管理：将配置项发布到开发活动之外，例如发布给客户。</li><li><img src="image-20240312203602358.png" alt="image-20240312203602358" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h3 id="管理实践"><a href="#管理实践" class="headerlink" title="管理实践"></a>管理实践</h3><ul><li>投入<ul><li>⼈员的成本：这是最重要的一部分投⼊。 除了开发⼈员外，还要计算项目管理⼈员和其他相应⽀持⼈员的费用</li><li>工具的购买：包括计算机及其周围配套设备等硬件，也包括开发⼯具、办公套件等软件。</li><li>培训的费用：开发⼈员接受培训，获得开发项⽬所需技能的费⽤。</li><li>差旅费：拜访客户，参加会议等的费⽤。</li><li>维护的费用：定时的数据备份、系统监控、系统维修和升级等引起的费⽤。</li><li>生产停顿的损失：因为项⽬调试引起正常⼯作业务停顿的损失。</li><li>市场和服务的费用：推⼴软件产品所要的⼴告费用、参加展览会的费用等。</li><li>机会成本：因为投资该项目，而不能投资别的项目或者放银行收取利息的机会成本。</li></ul></li><li>产出<ul><li>节约商业活动成本：只要是和无新软件系统时候比较，将节省的时间和原材料折算成量化的数字。例如，开发了新的库存管理系统后，加快了流通并减少了库存浪费。</li><li>创新商机增加销售：指由于使用新软件带来的盈利，可能是软件产品本身的销售，也可能是软件项目带来的营业成⻓。</li><li>提高品牌含金量： 提高质量和客户满意度，可以带来品牌含金量的提高。这比较虚⼀点，但也可以像企业的无形资产⼀样估算。</li></ul></li></ul><h3 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h3><ul><li><p>为实践项目组建你的团队：</p><ul><li>选择技能互补的成员组成团队，明确分工；</li><li>根据成员特点，选择团队结构；(建议使用民主团队)</li><li>建立团队章程；</li><li>明确团队的交流沟通⼿段。</li><li>需要保留开发过程，用来确保可查</li></ul></li><li><p>配置管理</p><ul><li>所有产物都通过Gitlab来管理</li><li>建立Group</li><li>⽂档采用MD文件</li></ul></li></ul><h2 id="03-需求基础"><a href="#03-需求基础" class="headerlink" title="03.需求基础"></a>03.需求基础</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><ul><li><p>需求工程的概念：所有需求处理活动的总和。它<strong>收集</strong>信息、<strong>分析</strong>问题、<strong>整合</strong>观点、记录需求并<strong>验证</strong>其正确性，最终描述出软件被应用后与其环境互动形成的<strong>期望效应</strong>。</p></li><li><p>三个主要任务：</p><ul><li>需求工程必须说明软件系统将被应用的应用环境及其<strong>目标</strong>，说明用来达成这些目标的软件功能，也即要同时说明软件”需要<strong>做什么</strong>“和”<strong>为什么</strong>需要做”。</li><li>需求⼯程必须将⽬标和功能反映到软件系统当中，映射为<strong>可行的软件行为</strong>，并对软件⾏为进行准确的<strong>规格说明</strong>。</li><li>现实世界是<strong>不断变化</strong>的世界，因此需求⼯程还需要妥善处理⽬标和功能随着时间演化的变动情况。</li></ul></li><li><p>需求工程活动</p><ul><li><img src="image-20240313121004338.png" alt="image-20240313121004338" style="zoom:50%;" /></li></ul></li><li><p>需求开发</p><ul><li><img src="image-20240313121025278.png" alt="image-20240313121025278" style="zoom:50%;" /></li><li><p>需求获取</p><ul><li>从<strong>人、文档或者环境</strong>当中获取需求的过程</li><li>要利⽤各种方法和技术来<strong>发现</strong>需求</li><li>目标分析：1. 根据问题确定目标:发现用户的期望和现实之间的差距 2. 通过分析利害关系人确定目标</li><li>需求获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型、民族志、竞品分析</li><li>问题与解决方案<ol><li>用户和开发⼈员的背景不同，⽴场不同：消除默认知识</li><li>普通用户缺乏概括性、综合性的表述能力：专业的需求人员</li><li>⽤户存在认知困境：原型(做一个原型帮助用户理解的草图模型)</li><li>⽤户越俎代庖：需求是开发人员开发出来的，不是⽤户提出来的；协商</li><li>缺乏用户参与：为用户参与提供⽅便</li></ol></li></ul></li><li><p>需求分析</p><ul><li>通过<strong>建模</strong>来整合各种信息，以使得人们更好的理解问题。</li><li>为问题定义出⼀个需求集合，这个集合能够为问题界定⼀个有效的<strong>解决方案</strong>。</li><li><strong>检查</strong>需求当中存在的错误、遗漏、不⼀致等各种缺陷，并加以修正</li><li>边界分析<ol><li>定义项目的范围。系统边界之内定义的是系统需要对外提供的功能</li><li>系统边界的定义要保证系统能够和周围环境形成有效的互动</li><li>系统用例图、上下文图通常被用来定义系统的边界</li></ol></li></ul></li><li><p>需求规格说明</p><ul><li>在系统用户之间<strong>交流需求信息</strong></li><li>要简洁、精确、⼀致和易于理解</li><li>需求工程师在这个阶段的重要工作包括:<ol><li>定制文档模版，提高效率</li><li>编写文档(模型语言和自然语言两种)</li></ol></li></ul></li><li><p>需求验证</p><ul><li>需求规格说明文档至少要满足下面几个标准:<ol><li>文档内每条需求都<strong>正确、准确</strong>的反映了用户的意图；</li><li>文档记录的需求集在整体上具有<strong>完整性和⼀致性</strong>；</li><li>文档的组织方式和需求的书写方式具有<strong>可读性</strong>和<strong>可修改性(方便保证版本简化)</strong>。</li></ol></li><li>需求验证的方法：同级评审、原型、模拟等</li></ul></li></ul></li><li><p>需求管理</p><ul><li>保证需求作用的持续、稳定和有效发挥：在需求开发活动之后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展⼯作</li><li>进行变更控制：纳入和实现合理的变更请求，拒绝不合理的变更请求，控制变更的成本和影响范围</li></ul></li></ul><h3 id="需求基础"><a href="#需求基础" class="headerlink" title="需求基础"></a>需求基础</h3><ul><li>IEEE对需求的定义：<ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对1或2中的一个条件或一种能力的一种文档化表述。</li></ol></li><li>需求开发的目标<ul><li><img src="4.png" style="zoom: 67%;" /></li></ul></li><li>问题域<ul><li>现实世界运行规律的一种反映</li><li>需求的<strong>产生域</strong>，也是需求的<strong>解决地</strong>。</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄⾃修改现实世界的实际情况。</li></ul></li></ul></li><li>规格说明<ul><li>软件产品的方案描述，它以软件产品的运行机制为主要内容。</li><li>它不是需求但实现需求，不是问题域但需要与问题域互动。</li><li>规格说明要以关注<strong>对外交互</strong>的⽅式描述软件解决⽅案，它既需要从软件产品的⻆度⽽不是⽤户的⻆度进⾏描述，⼜不能太多地涉及软件产品的内部构造机制。</li><li>为什么描述的是交互？因为交互对我们而言是一个对外的重要展示。</li></ul></li><li>需求、问题域、规格说明三者要进行区分<ul><li><img src="image-20240313122311441.png" alt="image-20240313122311441" style="zoom: 60%;" /></li></ul></li><li>需求层次性<ul><li>三种需求层次:业务需求、用户需求、系统级需求</li><li>业务需求(目标，解决方案与系统特性)<ul><li>业务需求是<strong>高层次</strong>的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。</li><li>为什么是系统特性？因为还没有到细节的部分</li><li>特性说明了系统为用户提供的各项功能，它限定了系统的<strong>范围</strong>(Scope)</li><li>例：在系统使用3个月后，销售额度应该提⾼20%</li></ul></li><li>用户需求(任务，问题域知识)<ul><li>问题域知识：执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么<ol><li>直接用户</li><li>间接用户(<strong>通用软件的销售人员和售后支持人员</strong>)</li></ol></li><li>问题域知识：是需要了解到期望所来源的背景知识。</li><li><strong>特性</strong><ol><li>模糊、不清晰(允许适度的用形容词和副词)</li><li>多特性混杂 (功能和⾮功能的混杂)</li><li>多逻辑混杂 (⼀个任务需要多次系统交互才能完成)</li></ol></li><li>例：系统应该允许客户经理添加、修改或者删除会员个⼈信息</li></ul></li><li>系统级需求<ul><li>需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的⼀个实现细节</strong>(和用户需求有着很大的区别)</li><li>描述了开发人员<strong>需要实现什么</strong></li><li>将用户需求转化为系统需求的过程是⼀个复杂的过程<ol><li>首先需要分析<strong>问题领域</strong>及其特性，从中发现问题域和计算机系统的共享知识，建⽴系统的知识模型；</li><li>然后将⽤户需求<strong>部署到系统模型</strong>当中，即定义系列的系统⾏为，让它们联合起来实现⽤户需求，每⼀个系统⾏为即为⼀个系统需求。</li><li>该过程就是需求⼯程当中最为重要的需求分析活动，⼜称<strong>建模与分析活动</strong>。</li></ol></li><li>系统级需求还可能会补充一些与软件实现相关的细节</li><li>例：在客户经理输⼊会员的客户编号时，系统要提供该会员的个⼈信息</li></ul></li><li><img src="image-20240313122823522.png" alt="image-20240313122823522" style="zoom: 67%;" /></li></ul></li></ul><h3 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h3><ul><li><p>需求图谱</p><ul><li><img src="image-20240313163053020.png" alt="image-20240313163053020" style="zoom:50%;" /></li><li>项目需求(<strong>人的数量、计划成本、时间</strong>)：项目的成本要控制在60万元⼈⺠币以下、项目要在6个月内完成</li><li>过程需求(<strong>人的分工、合作、方法、工具</strong>)：如在开发中，开发者要提交软件需求规格说明文档、设计描述⽂档和测试报告；项目要使用持续集成⽅法进行开发</li></ul></li><li><p>需求的分类（IEEE）</p><ul><li><strong>功能需求</strong>：和系统主要共作相关的需求，即在不考虑物理约束的情况下，⽤户希望系统所能够执行的活动，这些活动可以帮助⽤户完成任务。<strong>功能需求主要表现为系统和环境之间的⾏为交互</strong>。</li><li><strong>性能需求</strong>：系统整体或系统组成部分应该拥有的性能特征，包括速度、容量、吞吐量、负载、实时性</li><li><strong>质量属性</strong>：系统完成工作的质量，即系统需要在⼀个”好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。</li><li><strong>对外接口</strong>：系统和环境中其他系统之间需要建⽴的接口，包括硬件接口、软件接口、数据库接口等等。</li><li><strong>约束</strong>：进行系统构造时需要遵守的约束，例如<strong>编程语言、硬件设施</strong>等</li></ul></li><li><p>功能需求</p><ul><li>功能需求是最常见、最主要和最重要的需求，是能够为用户带来业务价值的系统⾏为</li><li><strong>最需要按照三个抽象层次进行展开</strong>，说明了关系</li><li>软件产品产生价值的基础，需求检查最重要的部分</li><li>比如:在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息</li></ul></li><li><p>数据需求</p><ul><li><strong>功能需求</strong>的补充：如果在功能需求部分明确定义了<strong>相关的数据结构</strong>，那么就不需要再行定义数据需求</li><li>数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：<ul><li>各个功能使⽤的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li></ul></li></ul></li><li><p>性能需求</p><ul><li><img src="image-20240313165138780.png" alt="image-20240313165138780" style="zoom: 67%;" /></li></ul></li><li><p>质量属性</p><ul><li>系统为了满足<strong>规定的及隐含</strong>的所有要求而需要具备的要素称为质量</li><li>质量属性是为了度量质量要素而选用的特征</li><li>质量模型就是能够为质量需求的描述和评价提供工作基础的特征集及特征之间的联系</li></ul></li><li><p>常见质量属性</p><ol><li><strong>可靠性</strong>(Reliability)：在规格时间间隔内和规定条件下，系统或部件执⾏所要求能⼒的能⼒。<ul><li>在进⾏数据的下载和上传中，如果⽹络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复。</li></ul></li><li><strong>可用性</strong>(Availability)：软件系统在投⼊使⽤时可操作和可访问的程度或能实现其指定系统功能的概率。<ul><li>系统的可⽤性要达到98%。</li></ul></li><li><strong>安全性</strong>(Security)：软件阻止对其程序和数据进行未授权访问的能力，未授权的访问可能是有意，也可能是无意的。<ul><li>VIP顾客只能查看自己的个人信息和购买记录；</li><li>收银员只能查看，不能修改、删除VIP顾客的信息。</li></ul></li><li><strong>可维护性</strong>(Maintainability)：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。<ul><li>如果系统要增加新的特价类型，要能够在2个⼈⽉内完成。</li></ul></li><li><strong>可移植性</strong>(Portability)：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。<ul><li>集中服务器要能够在1⼈⽉内从Window 7操作系统更换到Solaris 10操作系统。</li></ul></li><li><strong>易用性</strong>(Usability)：与⽤户使⽤软件所花费的努⼒及其对使⽤的评价相关的特性。<ul><li>使用系统1个⽉的收银员进⾏销售处理的效率要达到10件商品&#x2F;分钟。</li></ul></li></ol></li><li><p>对外接口</p><ul><li><strong>解系统和其他系统</strong>之间的软硬件接⼝:包括硬件接口、软件接口、数据库接口等<ul><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li></ul></li><li>用户界面</li></ul></li><li><p>约束</p><ul><li>总体上限制了开发⼈员设计和构建系统时的选择范围</li><li><strong>系统开发及运行的环境</strong><ul><li>包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等</li><li>例：系统要使用Java语言进行开发。</li></ul></li><li><strong>问题域内的相关标准</strong><ul><li>包括法律法规、⾏业协定、企业规章等。</li></ul></li><li><strong>商业规则</strong><ul><li>⽤户在任务执⾏中的⼀些潜在规则也会限制开发⼈员设计和构建系统的选择范围</li></ul></li></ul></li></ul><h2 id="04-需求分析基础"><a href="#04-需求分析基础" class="headerlink" title="04.需求分析基础"></a>04.需求分析基础</h2><h3 id="需求分析基础"><a href="#需求分析基础" class="headerlink" title="需求分析基础"></a>需求分析基础</h3><ul><li>需求分析的任务<ul><li>建立<strong>分析模型</strong>，达成开发者和用户对需求信息的共同理解:分析将复杂的系统分解为简单的部分以及它们之间的联系，确定本质特征，抛弃次要特征。</li><li>依据共同的理解，<strong>发挥创造性</strong>，创建软件系统解决方案:分析可以将一个问题分解为独立的、更简单的和易于管理的子问题来帮助寻找解决方案</li></ul></li><li>模型<ul><li>模型是对事物的抽象，帮助⼈们在创建一个事物之前可以有更好的理解</li><li>为了更好地理解需求获取所得到的复杂信息，需要集中关注问题的计算特性(数据、功能、规则等)，建立相关的软件模型</li></ul></li><li>建模<ul><li>建模的目标是建立系统的一个表示，这个表示以精确⼀致的方式描述系统，使得系统的使用更加容易</li><li><strong>抽象</strong>和<strong>分解</strong>是建模最为常用的两种手段</li></ul></li><li>需求分析模型<ul><li><img src="image-20240314102113872.png" alt="image-20240314102113872" style="zoom:50%;" /></li></ul></li></ul><h3 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h3><ul><li><p>面向对象分析过程</p><ul><li><img src="image-20240314102240131.png" alt="image-20240314102240131" style="zoom:67%;" /></li></ul></li></ul><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><ul><li><p>用例</p><ul><li>定义：在系统(或者子系统或者类)和外部对象的交互当中所执行的行为序列的描述,包括各种不同的序列和错误的序列,它们能够联合提供⼀种有价值的服务</li><li>用例描述了在不同条件下系统对某一用户的请求的响应。根据用户的请求和请求时的系统条件,系统将执行不同的行为序列, 每⼀ 个行为序列被称为⼀个场景。⼀个用例是多个场景的集合。</li><li>用例图的建立：目标分析与解决方向的确定、寻找参与者、寻找用例、细化用例</li></ul></li><li><p>用例图基本元素：用例、参与者、关系、系统边界</p><ul><li>用例：椭圆<ul><li>以用例的形式表达需求。</li><li>用例表示有助于构建、关联和理解基本需求的典型场景集。</li><li>场景是对系统在实践中如何使用的描述：用户与计算机系统之间的典型交互</li><li>一般会用动宾短语，加上actor作为主语就是句子了</li></ul></li><li>参与者：小人<ul><li>参与者是用户或其他系统对要开发的系统所扮演的角色。</li><li>用例图中的单个参与者可以表示多个用户(或系统)。</li><li>单个用户(或系统)也可以扮演多个角色。</li><li>参与者不需要是人，例如，需要来自当前系统的某些信息的外部系统也是参与者。</li></ul></li><li>关系：简单的就是一条直线<ul><li>有关</li><li>泛化关系，指向的是被泛化的。</li><li>包含关系</li><li>继承关系</li></ul></li><li>系统边界：是一个框<ul><li>强调重点是什么是要详细的，什么不是。</li><li>系统边界隐式存在于没有显式表示的系统边界的图中</li><li>参与者总是在边界之外，用例总是在边界之内。</li><li>系统边界是指一个系统所包含的系统成分与系统外事务的分界线</li></ul></li></ul></li><li><p>目标分析</p><ul><li>问题目标的解决方案</li><li>×××连锁商店是一家刚刚发展起来的小型连锁商店，其前身是⼀家独立的小百货门面店。<ul><li>首先是随着商店规模的扩大，顾客量大幅增长，手工作业销售迟缓，顾客购物排队现象严重，导致流失客源。</li><li>其次是商店的商品品种增多，无法准确掌握库存，商品积压、缺货和报废的现象上升明显。</li><li>再次是商店面临的竞争比以前更⼤，希望在降低成本，吸引顾客，增强竞争力的同时，保持盈利水平</li></ul></li><li>业务需求<ol><li>BR1：在系统使⽤6个月后，商品积压、缺货和报废的现象要减少50%</li><li>BR2：在系统使⽤3个月后，销售⼈员⼯作效率提⾼50%</li><li>BR3：在系统使⽤6个月后，运营成本要降低15%<ul><li>范围：⼈力成本和库存成本</li><li>度量：检查平均员工数量和平均每10,000元销售额的库存成本</li></ul></li><li>BR4：在系统使⽤6个月后，销售额度要提高20%</li></ol></li><li>系统功能<ol><li>SF1：分析商品库存，发现可能的商品积压、缺货和报废现象</li><li>SF2：根据市场变化调整销售的商品</li><li>SF3：制定促销手段，处理积压商品</li><li>SF4：与生产厂家联合进行商品促销</li><li>SF5：制定促销手段进行销售竞争</li><li>SF6：掌握员工变动和授权情况</li><li>SF7：处理商品入库与出库</li><li>SF8：发展会员，提高顾客回头率</li><li>SF9：允许积分兑换商品和赠送吸引会员的礼品，提高会员满意度</li><li>SF10：帮助收银员处理销售与退货任务</li></ol></li></ul></li><li><p>寻找参与者与用例</p><ul><li>每个用户的任务(目标)都是⼀个独立用例</li><li><img src="image-20240314104447968.png" alt="image-20240314104447968" style="zoom: 67%;" /></li><li><img src="image-20240314104544180.png" alt="image-20240314104544180" style="zoom: 67%;" /></li></ul></li><li><p>细化用例</p><ul><li>如果用例的粒度不合适就需要进⾏细化和调整。</li><li>判断标准是：⽤例描述了为应对<strong>一个业务事件</strong>，由<strong>一个用户</strong>发起，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务</li><li>产品具体的细化（例子）<ol><li>特价策略制定、赠送策略制定两个用例的业务目的、发起源和过程基本相同，仅仅是业务数据不同，所以可以合并为⼀个用例销售策略制定。</li><li>会员管理用例有两个明显不同的业务事件，可以被细化为发展会员和礼品赠送2个更细粒度的用例。</li><li>客户经理的库存管理用例也有三个不同的业务⽬标：出库、⼊库和库存分析，所以也应该细化为三个用例商品出库、商品⼊库和库存分析，其中库存分析⽤例与总经理的库存分析⽤例相同。</li></ol></li><li><img src="image-20240314105045573.png" alt="image-20240314105045573" style="zoom:67%;" /></li></ul></li><li><img src="13.png" style="zoom: 80%;" /></li></ul><h4 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h4><ul><li><p>概念</p><ul><li>概念类图又被称为”领域模型”(Domain Model)</li><li>类图是面向对象分析方法的核心：类图描述类(对象)和这些类(对象)之间的关系</li><li>概念类图和<strong>设计类图</strong>的不同点：关注系统与外界的交互，⽽不是软件系统的内部构造机制</li><li><strong>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</strong></li><li>类图只有类和类名，没有包含方法。</li><li>用例不是概念类，同一个用例可能产生多个概念类</li></ul></li><li><p>概念类图基本元素</p><ul><li>对象<ul><li>标识符：对象自治、对象请求写作</li><li>状态：存储数据，如密码、名称</li><li>行为：利用数据做什么</li></ul></li><li>类:对象集合的抽象</li><li>链接<ul><li>对象之间的互相协作的关系</li><li>描述了对象之间的物理或业务联系</li></ul></li><li>关联<ul><li>对象之间链接的抽象</li><li>聚合(空心菱形)与组合(实心菱形)</li></ul></li><li>继承：泛化关系</li><li><img src="image-20240428112931962.png" alt="image-20240428112931962"></li></ul></li><li><p>建立概念类图的步骤</p><ul><li>对每个用例文本描述，尤其是场景描述，建立<strong>局部</strong>的概念类图<ul><li>识别候选类(名词分析法)</li><li><strong>确定概念类</strong> (看是否满足既有状态又有行为)<ol><li>既需要维持一定的状态，又需要依据状态表现一定的行为：确定为一个概念类</li><li>如只需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，却需要表现行为：首先重新审视需求是否有遗漏，因为没有状态支持的对象无法表现行为；如果确定没有需求的遗漏，就需要剔除该候选类，并将行为转交给具备状态支持能力的其他概念类</li><li>既不需要维护状态，又不需要表现行为：应该被完全剔除</li></ol></li><li>识别关联(文本中提取出”名词＋动词＋名词”的结构)：第一标准是满足需求的要求，第二标准是现实状况</li><li>识别重要属性：协作的必要信息，通过分析用例的描述，补充问题域信息发现。</li></ul></li><li>将所有用例产⽣的局部概念类图进行合并，建⽴软件系统的整体概念类图</li><li>自己注:先画关联关系，再添加类的属性</li><li><img src="image-20240410205025063.png" alt="image-20240410205025063" style="zoom: 60%;" /></li><li><img src="image-20240410205400576.png" alt="image-20240410205400576"></li></ul></li></ul><h4 id="顺序图（交互图）"><a href="#顺序图（交互图）" class="headerlink" title="顺序图（交互图）"></a>顺序图（交互图）</h4><ul><li>概念<ul><li>行为模型显示了对象之间的交互，以产生一些特定的系统行为，这些行为被指定为一个用例</li><li>UML中的序列图(或协作图)用于<strong>建模对象之间的交互</strong></li><li>分析阶段，主要是利用<strong>系统顺序图</strong>，表达系统和外部参与者之间的交互行为：务必要严格谨慎的界定系统</li></ul></li><li>图例<ul><li><img src="image-20240421171223317.png" alt="image-20240421171223317" style="zoom:67%;" /></li></ul></li><li>系统顺序图<ul><li><img src="image-20240421171303355.png" alt="image-20240421171303355" style="zoom: 80%;" /></li><li>画外部和内部之间的交互应当仔细辨别系统和系统(也就是系统边界)</li><li>不同框的含义:<ol><li>alt一定要选(多选一):<strong>注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[ ]里面。</strong></li><li>opt一定要选(选择0或者1)</li><li>loop:表示循环，在旁边使用[]书写循环条件</li></ol></li><li>步骤:<ol><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加消息</li></ol></li></ul></li></ul><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><ul><li>概念<ul><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ul></li><li><img src="31.png" style="zoom:50%;" /></li><li><img src="image-20240428223753527.png" alt="image-20240428223753527"></li><li><strong>创建状态图的步骤</strong><ul><li>确定上下文环境<ul><li>状态图是立足于状态快照进行行为描述的，因此建立状态图时首先要搞清楚<strong>状态的主体</strong>，确定状态的上下文环境。常见的状态主体有：类、用例、多个用例和整个系统。</li><li>状态应该是相对较多，比较复杂的。</li></ul></li><li>识别<strong>状态</strong><ul><li>状态主体会表现出⼀些稳定的状态，它们需要被识别出来，并且标记出其中的初始状态和结束状态集。在有些情况下，可能会不存在确定的初始状态和结束状态。</li></ul></li><li>建立<strong>状态转换</strong><ul><li>根据需求所描述的系统行为，建⽴各个稳定状态之间可能存在的转换。</li></ul></li><li>补充<strong>详细信息</strong>，完善状态图<ul><li>添加转换的触发事件、转换行为和监护条件等详细信息</li></ul></li></ul></li></ul><h3 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h3><ul><li>方法<ul><li>自顶向下分解</li><li>各种图<ul><li>数据流图</li><li>实体关系图</li><li>状态转移图</li></ul></li></ul></li><li>结构图<ul><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li></ul></li></ul><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><ul><li>数据流图<ul><li>数据流图将系统看做是过程的集合，其中一些由人来执行，另一些由软件系统来执行。</li><li><strong>过程的执行就是对数据的处理：它接收输入，进行数据转换，输出结果。</strong></li><li>数据流图主要是展示了数据在通过系统如何进行了变化。</li><li>可能需要和软件系统外的实体尤其是<strong>人</strong>进行交互</li><li>数据的变化包括：<strong>被转换、被存储、或者被分布</strong></li><li><img src="41.png" style="zoom: 80%;" /></li><li>外部实体：数据的产生或者消耗者，是待构建软件系统之外的人、组织、设备或者其他软件系统，它们不受系统控制，开发者不能以任何方式操纵它们</li><li>过程：<ul><li>将数据从输入转换到输出：示例：计算税金，确定面积，格式报告，显示图形必须始终以某种方式处理数据以实现系统功能</li><li>过程是指施加于数据的动作或者行为，它使得数据发生变化，包括被转换、被存储或者被分布</li></ul></li><li>数据流：数据流是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。</li><li>数据存储：软件系统需要在内部手机、保存，以供日后使用的数据集合。</li><li>数据流图分为三种图：上下文图、0层图和N层图<ul><li>上下文图是DFD的最高层次的图，是系统功能的最高抽象。上下文将整个系统看做一个过程，这个过程实现系统的所有功能</li><li>0层图通常被用作整个系统的功能概图为了概述整个系统的功能，建立0层图时需要分析需求获取的信息，归纳出系统的主要功能</li><li>N层图：父过程为被分解的过程，子图为分解后产生的揭示更多细节的图</li><li>具体见ppt</li></ul></li></ul></li></ul><h4 id="实体关系图"><a href="#实体关系图" class="headerlink" title="实体关系图"></a>实体关系图</h4><ul><li><p>实体关系图</p><ul><li><p>传统实体</p><ul><li>实体并不是孤立存在的，相互交互相互影响</li><li>参与关系的每个实体都针对关系拥有最大基数和最小基数</li><li>最大基数:对关系中任意的其他实体实例，该实体可能参与关系的最大数量。最大基数为1，表示为One，否则为Many</li><li>最小基数:对关系中任意的其他实体实例，该实体可能参与关系的最小数量。实体在关系中的最小基数被标记为Optional,最小基数为1时，实体在关系中的最小基数被标记为mandatory</li></ul></li></ul></li></ul><ul><li><p>关系</p><ul><li>系统必须记住的事实，不能或不能计算或推导出来<ul><li>关系的几个实例可以存在</li><li>实体可以以多种方式关联</li><li><img src="37.png" style="zoom: 67%;" /></li></ul></li><li>键：实体的⼀个或者多个属性能够唯⼀确定和标示每个实例，这些属性或者属性组合就被称为实体的标示符，或者键</li></ul></li><li><p>建立实体关系图的步骤</p><ul><li>第1级-对所有数据对象(实体)及其相互之间的”连接”建模</li><li>第2级-对所有实体和关系建模<ul><li>第3级-对所有实体、关系和属性建模，以提供进一步的深度</li></ul></li><li><img src="38.png" style="zoom: 67%;" /></li></ul></li></ul><h3 id="使用需求分析方法细化和明确需求"><a href="#使用需求分析方法细化和明确需求" class="headerlink" title="使用需求分析方法细化和明确需求"></a>使用需求分析方法细化和明确需求</h3><ul><li><p>为什么要细化</p><ul><li>用户需求的描述的模糊性和系统设计所需要的严谨性之间的矛盾</li></ul></li><li><p>如何细化</p><ul><li>需求分析建模</li><li>发现其中的遗漏、冲突、冗余和错误</li><li>迭代(获取、分析、获取、分析······)</li></ul></li><li><p>系统顺序图有助于发现交互性的缺失</p><ul><li><img src="image-20240327204341393.png" alt="image-20240327204341393" style="zoom: 80%;" /></li></ul></li><li><p>概念类图有助于发现</p><ul><li><p>部分信息的使用不准确</p></li><li><p>部分信息不明确</p></li><li><p>遗漏了重要内容</p></li><li><img src="image-20240327204359767.png" alt="image-20240327204359767" style="zoom:80%;" /></li></ul></li><li><p>状态图有助于发现页面的跳转</p><ul><li><img src="image-20240327204629398.png" alt="image-20240327204629398" style="zoom: 67%;" /></li></ul></li><li><p>建立系统需求</p><ul><li>8种规格说明：<ul><li>by mode 功能需求分类</li><li>by user class</li><li>by object</li><li>by feature</li><li>by stimulus</li><li>by functional hierarchy</li><li>multiple organization</li></ul></li><li>不同的分析⽅法适合不同的规格说明</li></ul></li></ul><h2 id="05-需求文档化与验证"><a href="#05-需求文档化与验证" class="headerlink" title="05.需求文档化与验证"></a>05.需求文档化与验证</h2><h3 id="用例文档"><a href="#用例文档" class="headerlink" title="用例文档"></a>用例文档</h3><ul><li>为什么文档化需求<ul><li>方便团队工作和沟通</li><li>方便项目管理</li><li>更加明确的体系架构</li><li>方便软件设计</li><li>方便编码</li><li>方便维护</li></ul></li><li>为什么建立需求规格说明？结合试验说明（<strong>重要</strong>）<ul><li>方便交流，软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以在软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li>需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li>在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化。</li></ul></li><li>用例文档<ul><li>在用户的角度以用例文本为主描述软件系统与外界的交互</li><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li><li><img src="image-20240331164631718.png" alt="image-20240331164631718" style="zoom:67%;" /></li><li>用例图等描述图可以更加直观的了解这部分</li></ul></li></ul><h3 id="软件需求规格说明文档（SRS）"><a href="#软件需求规格说明文档（SRS）" class="headerlink" title="软件需求规格说明文档（SRS）"></a>软件需求规格说明文档（SRS）</h3><ul><li>概念<ul><li>在软件产品的⻆度以系统级需求列表的⽅式描述软件系统解决方案</li><li><img src="image-20240331172611622.png" alt="image-20240331172611622" style="zoom: 67%;" /></li></ul></li><li>模板<ul><li><img src="3-1746703874907.png" style="zoom:67%;" /></li></ul></li></ul><h3 id="文档化需求"><a href="#文档化需求" class="headerlink" title="文档化需求"></a>文档化需求</h3><ul><li><p>注意事项</p><ul><li>简洁:动词名词+辅助词，不要使用复杂长句、形容词和副词。</li><li>精确:不能产生起义或无法理解。</li><li>易读(查询)：有效使用引言、目录、索引等能够增强文档易读性的方法；使用系统化的方式组织内容信息，提供文档内容的可读性。</li><li>易修改：使用相同的语句格式组织相关联或相似的信息；使用列表组织独立、并列的信息；使用编号表达繁杂信息之间的关系。引用而不是重复</li></ul></li><li><p>系统化的方式</p><ul><li>使用<strong>相同</strong>的语句格式来描述相似、关联的信息。</li><li>使用<strong>列表或者表格</strong>来组织独立、并列的信息。</li><li>使用<strong>编号</strong>来表达繁杂信息之间的关系,包括顺序关系、嵌套关系和层次关系。<ul><li>对图、表进行编号</li><li>对⽂档的章节进行编号</li><li>对信息内容进行标识和编号</li></ul></li></ul></li><li><p>需求书写要点</p><ul><li>需求书写要点<ul><li>使用用户术语:不要使用计算机术语(导致用户无法理解)</li><li>可验证：不可验证的需求一般是因为描述模糊或者过于抽象</li><li>可行性：需求必须能够在系统及其运行环境的已知条件和约束下实现。要考虑在限定成本、时间和人力约束内，实现需求的可能性</li></ul></li><li>需求规格说明文档书写要点<ul><li>充分利用标准的文档模版，保持所有内容位置得当</li><li>保持⽂档内的需求集具有完备性和⼀致性。</li><li>为需求划分优先级(可以分为高中低、也可以分为1-10等分)</li></ul></li></ul></li><li><p>验证需求文档</p><ul><li>评审<ul><li>评审的人员不能仅由技术人员组成，必须包括客户和用户</li><li>在评审中使用线索，⽤户对场景与线索表现出了最⼤的兴趣</li><li>使用需求检查列表</li></ul></li><li>开发系统测试用例<ul><li>基于用例描述，可以为销售处理确定测试用例套件</li><li>测试用例套件是测试用例的集合，将有关测试用例集合在一起</li></ul></li><li>建立测试用例<ul><li>主要是基于规格的技术，设计测试场景的输⼊与输出数据</li><li>不断地添加测试用例来完成测试</li></ul></li></ul></li><li><p>度量需求功能点</p><ul><li><p>度量需求</p><ul><li>用例的数量<ul><li>平均每个用例中的场景数量</li><li>平均用例行数</li><li>在一个尺度下进行分析</li></ul></li><li>软件需求数量</li><li>非功能需求数量</li><li>功能点数量</li></ul></li><li><p>度量的意义</p><ul><li>如果平均的用例场景<strong>数量过低</strong>，那么就可能存在对<strong>异常流程考虑不周</strong>的可能。</li><li>如果<strong>平均用例行数过大或者过小</strong>，那么可能对⽤例的细分粒度过⼤或者过小。</li><li>用例数量、软件需求数量和功能点数量应该是相对比例均衡的，如果三者之间有着**⾮常大的差距**，那么可能会有需求的遗漏。</li></ul></li><li><p>功能点度量</p><ul><li><p>用于估算和度量软件系统规模与复杂度的抽象单位</p></li><li><img src="image-20240331191831646.png" alt="image-20240331191831646" style="zoom:67%;" /></li><li><p>功能点测度总数：</p><img src="8.png" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="08-软件设计基础"><a href="#08-软件设计基础" class="headerlink" title="08.软件设计基础"></a>08.软件设计基础</h2><h3 id="什么是软件设计"><a href="#什么是软件设计" class="headerlink" title="什么是软件设计"></a>什么是软件设计</h3><ul><li>概念<ul><li>软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。</li><li>软件设计活动以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。</li><li>软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性。</li></ul></li><li>软件设计的核心思想<ul><li>软件设计方法的核心问题：控制系统复杂度</li><li>分解与抽象是软件设计的核心思想，两者都是由层次性的，彼此之间可以嵌套使用。<ol><li>分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象:在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度。</li></ol></li><li><img src="image-20240408111022715.png" alt="image-20240408111022715" style="zoom:50%;" /></li><li><img src="1.png" style="zoom: 67%;" /></li></ul></li><li>设计<ul><li>定义<ul><li>设计(名词):⼀个对象的规格说明。它由⼈创造,有明确的⽬标,适⽤于特殊的环境,由⼀些基础类型构件组成,满⾜⼀个需求集合,受⼀定的限制条件约束。</li><li>设计(动词):在⼀个环境中创建对象的规格说明</li></ul></li><li>设计经常需要⼀个设计师考虑⼀个对象或过程的<strong>审美、功能以及其他方面</strong>，这通常需要进⾏相当的研究、思考、建模、交互调整和重新设计。</li><li>分类<ul><li>工程设计和艺术设计</li><li>理性主义和经验主义</li><li>具体见PPT</li></ul></li></ul></li><li>软件设计的演化性<ul><li>需求是外部表现，需求和内部结构是有鸿沟的。</li><li>非功能需求(质量需求)</li><li>始终进行迭代</li><li><img src="6.png" style="zoom:50%;" /></li></ul></li><li>设计的决策<ul><li><img src="image-20240408111756337.png" alt="image-20240408111756337" style="zoom:50%;" /></li><li>决策的约束性<ul><li>需求；环境；资源；技术 …</li><li>最初的需求确定了对设计情况的最基本的约束和要求。</li><li>通常，在设计工作本身中最终会发现更多的约束。</li><li>约束既适用于设计的工件，也适用于设计活动中涉及的流程和参与者</li></ul></li><li><img src="7.png" style="zoom:60%;" /></li></ul></li></ul><h3 id="软件设计的分层（重要）"><a href="#软件设计的分层（重要）" class="headerlink" title="软件设计的分层（重要）"></a>软件设计的分层（重要）</h3><ul><li><img src="image-20240408112055301.png" alt="image-20240408112055301" style="zoom:50%;" /></li><li>低层设计<ul><li>将基本的语言单位(类型与语句)，组织起来，建立高质量的数据结构+算法</li><li>常见设计场景：<ul><li>数组的使用，链表的使用，内存的使用，遍历算法，递归算法…</li><li>一次问相对比较大的内存，然后我们自己在进行的内存的分配</li></ul></li><li>经典场景：<ul><li>堆栈，队列，树，排序算法，查找算法…</li></ul></li><li>数据结构与算法审美：简洁、结构清晰，坚固(可靠、高效、易读)</li><li>低层设计本质：屏蔽程序中复杂数据结构与算法的实现细节</li><li><img src="image-20240408120816682.png" alt="image-20240408120816682" style="zoom:50%;" /></li><li>模块划分<ul><li>1970s：函数的成熟与模块的出现</li><li>模块划分：将系统分成简单片段：⽚段有名字，可以被反复使用</li><li>名字和使⽤⽅法称为<strong>模块的抽象与接⼝</strong></li><li>模块内部的程序⽚段为精化与实现</li></ul></li></ul></li><li>中层设计<ul><li>开始：模块划分<strong>隐藏</strong>⼀些程序片段(数据结构+算法)的细节，暴露接口于外界</li><li><img src="image-20240408121107687.png" alt="image-20240408121107687" style="zoom:67%;" /></li><li>模块化的目标：完全独立性</li><li>方法：模块化、信息隐藏、抽象数据类型、封装</li></ul></li><li>高层设计：体系结构<ul><li><strong>部件</strong>承载了系统主要的<strong>计算与状态</strong></li><li><strong>连接件</strong>承载部件之间的<strong>交互</strong></li><li>部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，配置将它们的实例连接起来</li><li><img src="image-20240408122354610.png" alt="image-20240408122354610" style="zoom:50%;" /></li></ul></li></ul><h3 id="软件设计过程、方法和模型、描述"><a href="#软件设计过程、方法和模型、描述" class="headerlink" title="软件设计过程、方法和模型、描述"></a>软件设计过程、方法和模型、描述</h3><ul><li>软件设计过程的主要活动<ul><li><img src="image-20240408122621390.png" alt="image-20240408122621390" style="zoom: 80%;" /></li></ul></li><li>软件设计的模型和方法<ul><li>结构化设计方法</li><li>面向对象设计</li><li>数据为中心设计:有一些项目是做数据仓库等的，数据爬取操作和读取。</li><li>基于构件的设计:调用构件和库</li><li>形式化方法设计</li></ul></li><li>描述软件设计的模型，通常可以分为两类:<ul><li>静态模型<ul><li>静态模型是通过快照 的方式对系统中时间不变的属性进行描述。通常描述的是状态,而不<br>是行为。</li></ul></li><li>动态模型：动态模型通常描述的是系统行为和状态转移。</li><li><img src="image-20240408123041801.png" alt="image-20240408123041801" style="zoom: 67%;" /></li></ul></li><li>软件设计描述<ul><li><img src="image-20240408123255930.png" alt="image-20240408123255930" style="zoom:45%;" /></li><li><img src="image-20240408123336074.png" alt="image-20240408123336074" style="zoom:50%;" /></li></ul></li></ul><h2 id="09-软件体系结构基础"><a href="#09-软件体系结构基础" class="headerlink" title="09.软件体系结构基础"></a>09.软件体系结构基础</h2><ul><li>软件体系结构发展历史略</li></ul><h3 id="理解软件体系结构"><a href="#理解软件体系结构" class="headerlink" title="理解软件体系结构"></a>理解软件体系结构</h3><ul><li><p>概念</p><ul><li>软件体系结构：现代系统组件和子系统相互作用形成系统的结构和组织，以及最好在系统级别设计和分析的系统属性。</li><li>软件体系结构包含有关以下方面的重要决策<ul><li>软件系统的<strong>组织</strong></li><li>选择组成系统的<strong>结构元素及其接口</strong>，以及这些元素之间的协作所指定的<strong>行为</strong>，</li><li>将这些元素组成越来越大的<strong>子系统</strong>，</li><li>指导该组织，这些元素及其界面，协作和组成的结构元素及其接口。</li></ul></li><li>软件体系结构&#x3D;{部件(Component),连接件(Connector),配置(Configuration)}<ul><li><strong>部件</strong>是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;</li><li><strong>连接件</strong>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;</li><li><strong>配置</strong>是对”形式”的发展,定义了”部件”以及”连接件”之间的关联方式,将它们组织成系统的总体结构。</li></ul></li></ul></li><li><p>物理与逻辑</p><ul><li>模块<ul><li>逻辑：⼀个模块调用另⼀个模块</li><li>物理实现<ol><li>基本：接口调用</li><li>需要传递数据对象怎么办？</li></ol></li><li>逻辑：⼀个模块给另⼀个模块传递数据流</li><li>物理实现：读写共享数据、pipe…</li></ul></li><li>物理实现的载体<ul><li>低层：基本类型+基本控制结构</li><li>中层：OO编程语言机制<ol><li>类声明、实例创建与撤销、实例⽣命期管理</li><li>类权限控制机制</li><li>复杂机制：继承…</li></ol></li><li>高层：导⼊导出和名称匹配</li></ul></li></ul></li><li><p>高层抽象(体系结构 &#x3D; 部件 + 连接件 + 配置) <strong>重要</strong></p><ul><li><p>概念</p><ul><li><strong>组件</strong>是计算和状态的聚合</li><li><strong>连接件</strong>是组件之间的关系的聚合</li><li><img src="8-1746703902687.png"></li><li>连接件是⼀个与部件平等的单位。</li><li>部件与连接件是比类、模块等软件单位更高层次的抽象</li></ul></li><li><p>部件</p><ul><li>封装系统架构中的处理和数据的元素称为软件组件</li><li>件通常提供特定于应用程序的服务</li></ul><p><img src="9.png"></p><ul><li>部件承载系统主要功能，包括处理和数据</li></ul></li><li><p>原始部件和复合部件</p><ul><li><p>部件可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。</p></li><li><p>原始类型的部件可以直接被实现为相应的软件实现机制。</p></li><li><p>复合部件则由<strong>更细粒度</strong>的<strong>部件和连接件</strong>组成,复合部件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</p></li><li><img src="11.png" style="zoom:67%;" /></li></ul></li><li><p>连接件</p><ul><li>在复杂的系统中，交互可能比单个组件的功能更重要和更具挑战性</li><li>连接件定义了部件间的交互，是连接的抽象表示</li><li>与部件相似,在实现上连接件也可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。原始类型的连接件可以直接被实现为相应的软件实现机制。</li><li>复合连接件则由更细粒度的<strong>部件和连接件</strong>组成,复合连接件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</li><li><img src="image-20240410120546268.png" alt="image-20240410120546268" style="zoom: 67%;" /></li></ul></li><li><p>配置</p><ul><li>组件和连接器以给定系统体系结构中的特定方式构成，以实现该系统的目标</li><li>为了对软件体系结构进行更严格、准确的描述，人们建立了体系结构描述语言(ADL)，用于描述软件体系结构的形式化模型语言。</li><li>配置定义了部件和连接件之间的关联方式，将他们组织成系统的总体结构。</li></ul></li><li><p>高层抽象优点</p><ul><li>直观，便于理解</li><li>验证正确性</li><li>关注度分离，降低复杂度</li></ul></li></ul></li></ul><h3 id="体系结构风格初步"><a href="#体系结构风格初步" class="headerlink" title="体系结构风格初步"></a>体系结构风格初步</h3><ul><li><p>这部分需要重要掌握每一种风格的优点缺点和画图</p></li><li><p>分类</p><ul><li><img src="image-20240417154959514.png" alt="image-20240417154959514"></li></ul></li><li><p>主程序子进程风格</p><ul><li>组件：程序、函数和模块</li><li>连接件：在上述三个组件之间相互调用</li><li><img src="12.png" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>基于声明–使用(程序调用)关系建立连接件,以层次分解的方式建立系统部件, 共同组成层次结构。</li><li>每⼀个上层部件可以”使用”下层部件，但下层部件不能”使用”上层部件，即不允许逆方向调用。(层次性分解，基于定义使用关系)</li><li>系统<strong>单线程</strong>执行。主程序部件拥有初的执⾏控制权，并在”使用”中将控制权转移给下层子程序。</li><li>子程序只能够通过上层转移来获得控制权,可以在执⾏中将控制权转交给下层的子程序,并在自身执行完成之后必须将控制权还交给上层部件。</li><li>隐含子系统结构。</li></ul></li><li>实现<ul><li>主要实现机制:模块实现。</li><li>功能分解</li><li>集中控制</li><li>每个构件⼀个模块实现：主要是<strong>单向依赖</strong></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li>优点：流程清晰,易于理解；强控制性</li><li>缺点：程序调用是⼀种<strong>强耦合</strong>的连接方式,非常依赖交互方的接口规格,这会使得系统难以修改和复用；程序调用的连接方式限制了各部件之间的数据交互,可能会使得不同部件使用隐含的共享数据交流,产⽣不必要的公共耦合</li></ul></li></ul></li><li><p>面向对象风格</p><ul><li>组件：对象或模块(调用方法)</li><li>连接件：函数或者调用</li><li><img src="image-20240417165216134.png" alt="image-20240417165216134" style="zoom:67%;" /></li><li>设计决策及约束<ul><li>依照对数据的用情况,用<strong>信息内聚</strong>的标准,为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口,并隐藏内部数据的表示。</li><li>基于方法调用(Method Invocation)机制建立连接件,将对象部件连接起来。</li><li>每个对象负责维护其自身数据的⼀致性与完整性,并以此为基础对外提供”正确”的服务。</li><li>每个对象都是⼀个自治单位,不同对象之间是平级的,没有主次、从属、层次、分解等关系。</li></ul></li><li>实现<ul><li>主要实现机制：模块实现</li><li>任务分解</li><li>(委托式)分散式控制</li><li>每个构件⼀个模块实现<ol><li>使用接口将双向依赖转换为单向依赖</li><li>将每个构件分割为多个模块，以保证单向依赖</li><li>每个模块内部可以是基于面向对象方法，也可以基于结构化</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>面向对象式风格的优点有：<ul><li>内部实现的可修改性。</li><li>易开发、易理解、易复用的结构组织。</li></ul></li><li>面向对象式风格的缺点有:<ul><li>接口的耦合性。</li><li>标识的耦合性。</li><li>副作用</li></ul></li></ul></li><li><p>分层风格</p><ul><li>组件：通常是过程或对象的集合。</li><li>连接件：通常在受限可见性下进行过程调用或方法调用。</li><li><img src="image-20240417165555108.png" alt="image-20240417165555108" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>从低层到高层,部件的抽象层次逐渐提升。每个下层为邻接上层提供服务, 每个上层将邻接下层作为基础设施使用。也就是说,在程序调用机制中上层调用下层。</li><li>两个层次之间的连接要遵守特定的交互协议,该交互协议应该是<strong>成熟、稳定和标准化</strong>的。也就是说,只要遵守交互协议,不同部件实例之间是可以互相替换的。</li><li>跨层次的连接是禁止的，不允许第 I 层直接调用 I+N(N&gt;1)层的服务。(也就是必须逐层进行调用)</li><li>逆向的连接是禁止的，不允许第 I 层调⽤第 J(J &lt; I)层的服务</li></ul></li><li>实现<ul><li>关注点分离(每层逐次抽象)</li><li>层间接口使用固定协议(固定控制)</li><li>每层⼀或多个模块实现<ol><li>单向依赖</li><li>层间数据传递建立专门模块</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li><img src="image-20240417170546313.png" alt="image-20240417170546313" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>Model-View-Controller Style MVC风格</p><ul><li><p>子系统模型被设计的不用依赖任何一种视图或者控制子系统</p></li><li><p>任何他们状态的修改都会被传播给显示子系统</p></li><li><p><img src="22.png"></p></li><li><p>组件</p><ol><li>模型组件负责保持问题域知识和确认视图层的修改</li><li>视图组件负责显示信息给用户并且将用户的行为传递给控制器</li><li>控制器<ol><li>修改模型的状态：将用户的行为和模型的更新映射起来</li><li>选择用来反映的视图</li></ol></li></ol></li><li><p>连接件：方法调用，信息，事件</p></li><li><p>设计决策和约束</p><ul><li>模型、视图、控制是分别是关于<strong>业务逻辑</strong>、<strong>表现</strong>和<strong>控制</strong>的三种不同内容抽象。</li><li>如果视图需要持续地显示某个数据的状态,那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更,模型会主动通知视图,然后再由视图查询数据的更新情况。</li><li>视图只能使用模型的数据查询服务,只有控制部件可以调用可能修改模型状态的程序。</li><li>用户行为虽然由视图发起,但是必须转交给控制部件处理。对接收到的用户行为, 控制部件可能会执行两种处理中的⼀种或两种：调用模型的服务,执行业务逻辑;提供下⼀个业务展现。</li><li>模型部件相对独立,既不依赖于视图,也不依赖于控制。虽然模型与视图之间存在⼀个”通知变更”的连接,但该连接的交互协议是⾮常稳定的,可以认为是非常弱的依赖。</li></ul></li><li><p>实现</p><ul><li>模型-视图-控制风格需要为模型、视图和控制的每个部件实例建立模块实现,各模块间存在导⼊&#x2F;导出关系,程序调用连接件不需要显式的实现。</li><li>特定技术实现，通常专用于WEB<ol><li>Model与Controller单向</li><li>Controller与View双向</li><li>Model与View双向</li></ol></li><li>典型实现<ol><li>View： JSP，HTML</li><li>Controller： Servlet</li><li>Model： JavaBean</li></ol></li></ul></li><li><p>效果</p><ul><li><img src="image-20240417171043461.png" alt="image-20240417171043461"></li></ul></li><li><p>分层与MVC</p><ul><li><img src="image-20240417171101444.png" alt="image-20240417171101444"></li></ul></li></ul></li><li><p>判断题：</p><ul><li>按照功能分解的方式进行模块分割能够实现高内聚的软件设计：<strong>√</strong></li><li>体系结构设计是软件非功能性的实现，而详细设计主要是软件功能性的实现。：<strong>√</strong></li></ul></li></ul><h2 id="10-软件体系结构设计与构建"><a href="#10-软件体系结构设计与构建" class="headerlink" title="10.软件体系结构设计与构建"></a>10.软件体系结构设计与构建</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><ul><li><p>步骤（重要）</p><ul><li>分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。</li><li>通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。</li><li>进行软件体系结构逻辑(抽象)设计：产生逻辑包图</li><li>依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图</li><li>完善体系结构设计：关键类图，持久化数据格式的定义等</li><li>添加构件接口：包、重要文件的创建，定义接口</li><li>迭代过程3-6</li></ul><blockquote><ol><li>步骤1-3是逻辑设计，步骤4-7是物理设计</li><li>接下来的部分将要按照这个思路进行下去</li></ol></blockquote></li><li><p>第一步：分析关键需求和项目约束</p><ul><li><p>一般来说，体系结构设计的输入要素主要由两个来源：</p><ol><li>软件需求规格说明</li><li>项目约束</li></ol></li><li><p>体系结构设计必须落实所有的功能性需求和非功能性需求</p></li></ul></li><li><p>第二步：通过选择体系结构风格</p><ul><li>例：分层风格<ul><li>协议不变情况下易于修改</li><li>能够促进并行开发</li></ul></li></ul></li><li><p>第三步：进行软件体系结构逻辑(抽象)设计</p><ul><li>将需求分配到子系统和模块<ol><li>考虑功能的相同性：不同任务，但是相同功能</li><li>考虑可复用性：结构、数据、行为的可复用性</li></ol></li><li>使⽤非功能性需求与项⽬约束评价和改进初始设计<ul><li>能够满足项目约束</li><li>无法满足安全需求和网络分布约束，所以需要改进</li></ul></li></ul></li><li><p>包设计原则</p><ul><li>复用发布等价原则(REP)：复用的粒度就是发布的粒度</li><li>共同封闭原则(CCP)：包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。</li><li>共同重用原理(CRP)：一个包中的所有类应该是能够共同重用的。</li><li>无环依赖原则(ADP)：在包的依赖关系图中不能存在环。</li><li>稳定依赖原则(SDP)：朝着稳定的方向进行依赖<ul><li>包的稳定性度量</li><li><img src="image-20240417194311104.png" alt="image-20240417194311104" style="zoom:50%;" /></li><li><img src="image-20240417194328157.png" alt="image-20240417194328157" style="zoom:50%;" /></li></ul></li><li>稳定抽象原则(SAP)：包的抽象程度应该和其稳定程度一致</li><li>前三条描述的是依赖性，后三条描述的是耦合性</li></ul></li><li><p>包设计过程</p><ul><li>迭代的过程:先用 CCP 原则对把可能⼀同变化的类组织成包进行发布</li><li>随着系统的不断增长,我们开始关注创建可重用的元素,于是开始使⽤ CRP 和 REP 来指导包的组合。</li><li>后使用 ADP、SDP、SAP 对包图进行度量，去掉不好的依赖。(修改设计)</li></ul></li><li><p>第四步：依赖逻辑设计进行软件体系结构(实现)设计</p><ul><li>内容<ul><li>开发包(构件)设计</li><li>运行时的进程</li><li>物理部署</li></ul></li><li>具体细节见PPT</li></ul></li><li><p>第五步：完善体系结构设计</p><ul><li>完善启动和网络链接<ul><li>失败业务的现场保护问题</li><li>网络连接断开的恢复问题</li><li>除了细化职责建立关键类图之后，模块传递的数据对象也需要被明确定义，因为他们是模块建接口的重要部分，必须严格、准确。</li></ul></li><li>细化模块</li><li>数据定义<ul><li>接口的数据对象、关键类的重要数据结构、Value Object (VO)、Persistent Object(PO)</li><li>Java 实体<ul><li>实体是一个可以代表一个临时的业务实体的对象，比如一个账单或者用户</li><li>没有逻辑业务方法(行为)</li><li>实体必须在使用它们的会话或事务之间持久存在。</li><li>实体是存储在文件或者数据库中的</li><li>实体是一个Beans</li></ul></li><li>Value Objects(逻辑层向展示层传递数据)<ul><li>价值对象(VO)包含一个或多个公共领域中实体的属性。</li><li>在层之间传递值对象，而不是实体。</li><li><strong>应该考虑实现Serializable</strong></li><li>值对象可以更新和创建实体。</li><li>实体可以创建价值对象。</li></ul></li></ul></li></ul></li><li><p>第六步：添加构件接口</p><ul><li>构件初步设计<ul><li>根据分配的需求确定模块对外接口</li><li>初步设计关键类</li><li>编写接口规范</li></ul></li></ul></li><li><p>体系结构的原型构建</p><ul><li>包的创建</li><li>重要文件的创建</li><li>定义构件之间的接口</li><li>关键需求的实现</li></ul></li><li><p>体系结构集成与测试</p><ul><li>当体系结构中原型各个模块的代码都编写完成并经过单元测试之后,需要将所有模块组合起来形成整个软件原型系统, 这就是集成。</li><li>集成的<strong>目的</strong>是为了逐步让各个模块合成为⼀个系统来⼯作,从而验证整个系统的功能、性能、可靠性等需 求。对于被集成起来的系统，⼀般主要通过其暴露出来的接口，伪装⼀定的参数和输入，进行黑盒测试。</li><li>Stub 桩程序：为了完成程序的编译和连接而使用的暂时代码</li><li>根据从模块之间集成的先后顺序,⼀般有下列几种常见的集成策略：<ul><li>大爆炸式(所有放在一起，看能不能过)</li><li>增量式：自顶向下式、自底向上式、三明治式、持续集成</li></ul></li><li>大爆炸式：将所有模块一次性组合在一起，可以在短时间内迅速完成集成，但一次运行成功可能性不高，不容易发现bug</li><li>自顶向下：先集成和测试上层的测模块，下层的模块用伪装的具体接口的桩程序</li><li>自底向上集成：先底层组件，对底层组件较早进行验证，桩的工作量少，但高层设计的错误不会被很快的发现</li><li>持续集成：一种增量集成方法,但它提倡尽早集成和频繁集成。尽早集成是指不需要总是等待⼀个模块开发完成才把它集成起来；频繁集成是指开发者每次完成⼀些开发任务之后,就可以用开发结果替换 Stub 中的相应组件,进行集成与测试</li></ul></li><li><p>体系结构评审</p><ul><li><p>评审的角度</p><ul><li>设计方案正确性、先进性、可行性;</li><li>系统组成、系统要求及接口协调的合理性;</li><li>对于功能模块的输⼊参数、输出参数的定义是否明确;</li><li>系统性能、可靠性、安全性要求是否合理;</li><li>⽂档的描述是否清晰、明确。</li></ul></li><li><p>体系结构评审的方法</p><ul><li>对结果的评审：Checklist(动态更新的)</li><li>对设计决策的评审</li></ul></li><li><p>软件体系结构设计文档的Checklist</p><p><img src="image-20240418164336573.png" alt="image-20240418164336573"></p></li></ul></li></ul><h2 id="11-人机交互设计"><a href="#11-人机交互设计" class="headerlink" title="11.人机交互设计"></a>11.人机交互设计</h2><h3 id="什么是人机交互"><a href="#什么是人机交互" class="headerlink" title="什么是人机交互"></a>什么是人机交互</h3><ul><li>概念<ul><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li><li>良好的HCI界面设计可鼓励用户与系统之间轻松，自然且引人入胜的交互</li></ul></li><li>HCI的重要组成：可用性<ul><li>可用性不是用户界面单一的一维属性，它包含以下维度：<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验</li></ol></li></ul></li></ul><h3 id="人机交互的三个要素"><a href="#人机交互的三个要素" class="headerlink" title="人机交互的三个要素"></a>人机交互的三个要素</h3><ul><li><p>人</p><ul><li>概念<ul><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ul></li><li>特性<ul><li>短期记忆有限</li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ul></li><li>精神模型 <strong>重要</strong><ul><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ul></li><li>发现精神模型<ul><li>找到用户在尝试去做什么——目标</li><li>用户，目标，结果任务的需求</li><li><strong>仅在确定有助于解决任务的功能时才应添加功能</strong></li><li>与用户个人资料相关的任务的频率</li></ul></li><li>差异性<ul><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进行业务导航，尽量避免出错。如果⼀个系统的⼤多数用户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是长时间使用软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家用户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计人机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新手用户提供易学性高的⼈机交互机制(图形界面)</li><li>又为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ul></li></ul></li><li><p>计算机</p><ul><li>⼈机交互设备<ul><li>输入设备</li><li>输出设备</li></ul></li><li>常见界面类型<ul><li><img src="image-20240418195946335.png" alt="image-20240418195946335"></li></ul></li><li>交互方式<ul><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ul></li></ul></li><li><p>交互</p><ul><li>导航 <strong>重要</strong><ul><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉用户，这个就是导航。</li><li>导航的目的就是为用户提供⼀个很好的完成任务的入口，好的导航会让这个入口非常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给不同的用户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给用户提供导航</li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据</li></ul></li><li>反馈 <strong>重要</strong><ul><li>一定要有反馈，避免进行错误的操作</li><li>用户喜欢较短的响应时间；</li><li>较长的响应时间(&gt;15秒)具有破坏性；</li><li>用户会根据响应时间的变化调整自己的工作方式；</li><li>较短的响应时间导致了较短的用户思考时间；</li><li>较快的节奏可能会提高效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间</li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间</li></ul></li><li>协作式设计 <strong>重要</strong><ul><li>人和计算机是人机交互的两方，其中人的因素比较固定，⼀定时期内不会发生大的变化，所以要让⼆者交互顺畅，就需要让计算机更多地适应人的因素，这也是人机交互设计以用户为中心的根本原因</li><li>这种调整计算机因素以更好地适应并帮助用户的设计方式被称为协作式设计</li></ul></li><li>人机交互设计原则<ul><li>简洁设计(7±2原则)</li><li>一致性设计</li><li>低出错率设计</li><li>易记性设计<ul><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ul></li><li>可视化设计要点</li></ul></li></ul></li></ul><h3 id="人机交互设计流程"><a href="#人机交互设计流程" class="headerlink" title="人机交互设计流程"></a>人机交互设计流程</h3><ul><li>设计过程<ul><li><img src="image-20240418204112209.png" alt="image-20240418204112209"></li><li>导航设计：建立多次交互之间的逻辑衔接结构</li><li>页面设计：设计交互中的具体界面的细节</li><li>页面原型化：使用界面原型工具</li><li>页面的评估与修改：用户进行评估</li></ul></li><li>页面设计<ul><li><img src="17.png"></li></ul></li></ul><h3 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h3><ul><li>内容<ul><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ul></li><li>关键点<ul><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ul></li><li>常见的GUI元素<ul><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ul></li><li>Check List<ul><li>数据输入界面</li><li>可定制的视觉设计</li><li>搜索和检索界面</li><li>附加的用户功能</li><li>控制用户访问</li><li>与其他集合的互操作性</li></ul></li><li>评估GUI<ul><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如”可用性检查”或”启发式评估”)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ul></li></ul><h2 id="12-详细设计"><a href="#12-详细设计" class="headerlink" title="12. 详细设计"></a>12. 详细设计</h2><h3 id="详细设计基础"><a href="#详细设计基础" class="headerlink" title="详细设计基础"></a>详细设计基础</h3><ul><li><p>概念</p><ul><li><p><img src="1-1746703946905.png"></p><blockquote><ol><li>高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。</li><li>中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。</li><li>低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。</li></ol></blockquote></li><li><p>软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息</p></li><li><p>细节设计通过细节设计机制实现模块</p><ol><li>中级：(子调制)-&gt; OO-&gt;类指定</li><li>低级：DS. + ALG. -&gt;实现类</li></ol></li><li><p>细节设计要求设计者考虑模块的美观，功能和许多其他方面</p><ol><li>详细设计中的质量要求：修改，维护，性能……</li></ol></li><li><img src="3-1746703948594.png" style="zoom: 80%;" /></li></ul></li><li><p>详细设计的出发点</p><ul><li>上下文<ul><li>模块的规格：导出&#x2F;导入接口</li><li>职责分配：<ol><li>有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图</li><li>其他一些来自实施决策</li></ol></li><li>在详细设计文档中需要明确定义:<ol><li>模块结构及其接口(如果有更细的模块分解)</li><li>类结构、类协作、类接口(面向对象分析方法)</li><li>控制结构与函数接口(结构化分析方法)</li><li>重要的数据结构和算法逻辑(如果必要的话)</li></ol></li></ul></li><li><img src="image-20240428111557004.png" alt="image-20240428111557004" style="zoom:67%;" /></li></ul></li></ul><h3 id="面向对象详细设计"><a href="#面向对象详细设计" class="headerlink" title="面向对象详细设计"></a>面向对象详细设计</h3><h4 id="设计模型建立"><a href="#设计模型建立" class="headerlink" title="设计模型建立"></a>设计模型建立</h4><ul><li>面向对象设计的思想：职责<ul><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ul><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作</li></ul></li><li>职责驱动的分解<ul><li>职责可以在不同的抽象层次上陈述。</li><li>职责可以分解。</li><li>可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ul></li><li>职责启发法<ul><li>很好地分配职责有助于实现高凝聚力和低耦合。(高内聚)</li><li>确保模块职责不重叠。</li><li><strong>仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。</strong></li></ul></li><li>委托：其中一个模块将职责交给另一个模块</li></ul></li><li>面向对象设计的思想：协作<ul><li>概念<ul><li>一个应用程序可以分解为许多不同的行为。</li><li>每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践</li><li>每次协作，无论大小，都保证实现应用程序的行为</li><li>将面向对象的应用程序想象成通过关系连接的对象网络。</li><li>协作是通过网络追求特定行为的<strong>消息模式</strong></li><li>协作分布在对象网络中，因此在任何地方都不存在</li></ul></li></ul></li><li>面向对象详细设计的过程<ul><li><img src="image-20240428112704867.png" alt="image-20240428112704867"></li></ul></li></ul><h4 id="通过职责建立静态设计模型"><a href="#通过职责建立静态设计模型" class="headerlink" title="通过职责建立静态设计模型"></a>通过职责建立静态设计模型</h4><ul><li>抽象类的职责<ul><li>类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图</li><li>职责分类<ol><li>属性职责:对象的状态</li><li>行为职责:对象的行为</li></ol></li></ul></li><li>类之间的关系<ul><li><img src="image-20240428112903745.png" alt="image-20240428112903745"></li></ul></li><li>GRASP原则<ul><li>General Responsibility Assignment Software Patterns（一般职责分配软件模式）</li><li>不是”设计模式”，而是对象设计的基本原理</li><li>专注于对象设计的最重要方面之一：为类分配职责</li><li>强调适用性：并不是一个普适的</li><li>常见的一些特点:<ol><li>低耦合：分配一个职责要保证低耦合度</li><li>高内聚：分配一个职责的时候要保持类的高聚合度</li><li>信息专家：将一个职责分配给专家-履行职责所必须的信息的类</li><li>创建者：创建规则在后面</li><li>控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一)</li></ol></li></ul></li><li>拇指原则：当存在替代设计选择时，请仔细研究替代方案的<strong>凝聚力和耦合含义</strong>，并可能对替代方案的未来发展压力。选择具有良好内聚性，耦合性和稳定性的替代方案。</li><li>信息专家<ul><li>问题：在面向对象设计中分配职责的最基本原则是什么？</li><li>解决方案：将职责分配给具有完成任务所必需的信息的类。</li><li>维护信息封装</li><li>促进低耦合</li><li>促进高内聚类</li><li>例子见PPT</li></ul></li><li>添加辅助类<ul><li>分类：接口类、记录类(数据类)、启动类、控制器类、实现数据类型的类、容器类</li></ul></li></ul><h4 id="通过协作创建动态设计模型"><a href="#通过协作创建动态设计模型" class="headerlink" title="通过协作创建动态设计模型"></a>通过协作创建动态设计模型</h4><ul><li><p>抽象对象之间协作</p><ul><li>从小到大,将对象的小职责聚合形成大职责;</li><li>从大到小,将大职责分配给各个小对象。</li><li>这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。</li><li>可以用顺序图表示对象之间的协作</li><li>除了顺序图，我们还可以通过状态图来表达软件的动态模型</li></ul></li><li><p>创建者（creator）</p><ul><li>如果有以下情况，则由创建者分配B类创建A类实例的职责：<ol><li>B 聚集了 A 对象</li><li>B 包含了 A 对象</li><li>B 记录了 A 的实例</li><li>B 要经常使用 A 对象</li></ol></li><li><img src="image-20240428224003187.png" alt="image-20240428224003187"></li></ul></li><li><p>控制器（controller）</p><ul><li><p>如果程序从图形界面以外的来源接收事件，添加事件类以将事件源与实际处理事件的对象分离</p></li><li><p>Controller本身不是面向对象的，它包含很多复杂的逻辑</p></li><li><p>使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为</p></li><li><p>控制器对象可能变得高耦合和职责上低内聚</p></li><li><p>将处理系统事件消息的职责分配给代表以下选项之一的类：</p><ol><li>整个组织的业务(立面控制器)。</li><li>整个系统(外观控制器)。</li><li>在问题域中真实操作解决问题的人(角色控制器)。</li><li>自动化解决用例的模块(用例控制器)。</li></ol></li></ul></li><li><p>选择合适的控制风格</p><ul><li>控制风格：系统行为的逻辑在对象(组件)网络之间分布的方式</li><li><img src="image-20240428224338297.png" alt="image-20240428224338297"></li><li>集中式控制风格<ul><li>几个控制器记录所有系统行为的逻辑</li><li>优点：容易找到做出决定的地方，易于查看如何制定决策以及如何更改决策流程</li><li>缺点：控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库（增加耦合、破坏信息隐藏）</li></ul></li><li>委托式控制风格<ul><li>通过对象网络分配决策，由几个控制器进行主要决策</li><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ul></li><li>分散式控制风格<ul><li>所有系统行为都通过对象网络广泛传播</li><li>其特点是拥有许多组件，几乎没有数据，职责也很少。</li><li>缺点：很难理解控制流；组件无法独自完成很多工作，从而增加了耦合；隐藏信息是很难的；内聚性通常很差；很少有模块化原则可以满足。</li><li>完全靠对象自治的方式来实现自己的职责</li></ul></li><li>控制器设计启发<ul><li>避免大多数消息都来自单个组件的交互设计</li><li>保持组件较小</li><li>确保并非仅将全部职责分配给几个组件</li><li><strong>确保操作职责与数据职责一致</strong></li><li>避免要求每个组件发送许多消息的交互</li></ul></li></ul></li></ul><h3 id="为类间协作开发集成测试用例"><a href="#为类间协作开发集成测试用例" class="headerlink" title="为类间协作开发集成测试用例"></a>为类间协作开发集成测试用例</h3><ul><li>详细设计的集成测试<ul><li>类间协作的集成测试<ul><li>重点针对复杂逻辑(交互比较多)</li><li>自顶向下或者自底向上的集成</li><li><img src="image-20240429093620217.png" alt="image-20240429093620217"></li></ul></li><li>Mock Object（不是stub）<ul><li><img src="image-20240429093541455.png" alt="image-20240429093541455" style="zoom:50%;" /></li></ul></li><li>测试用例</li></ul></li></ul><h3 id="结构化详细设计"><a href="#结构化详细设计" class="headerlink" title="结构化详细设计"></a>结构化详细设计</h3><ul><li>结构化设计的思想<ul><li>分解是降低复杂度的一种方法</li><li>按算法的分解：自然的分解想法，分而治之</li><li>从数据流图向结构图的转换</li></ul></li><li>降低复杂度的方法<ul><li>分解：同一层次</li><li>抽象：从低层次抽象出高层次</li></ul></li><li>结构化设计<ul><li>结构化设计的重心：从数据流图到结构图</li><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li><li>转化过程:<ul><li>寻找到输入的最高抽象点和输出的最高抽象点</li><li>根据输入、输出的最高抽象点，对模块进行划分</li><li>然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图</li></ul></li><li>详细参考课本(201页)</li><li>例子<ul><li><img src="image-20240429094505931.png" alt="image-20240429094505931"></li><li><img src="image-20240429094516376.png" alt="image-20240429094516376"></li></ul></li></ul></li></ul><h3 id="详细设计文档描述和评审"><a href="#详细设计文档描述和评审" class="headerlink" title="详细设计文档描述和评审"></a>详细设计文档描述和评审</h3><ul><li>评审<ul><li><img src="image-20240429094834998.png" alt="image-20240429094834998"></li></ul></li><li>度量<ul><li>模块化度量</li></ul></li><li>测试<ul><li>协作测试</li></ul></li></ul><h2 id="13-模块化与信息隐藏"><a href="#13-模块化与信息隐藏" class="headerlink" title="13. 模块化与信息隐藏"></a>13. 模块化与信息隐藏</h2><h3 id="模块化与信息隐藏思想"><a href="#模块化与信息隐藏思想" class="headerlink" title="模块化与信息隐藏思想"></a>模块化与信息隐藏思想</h3><ul><li><strong>内聚和耦合</strong><ul><li>内聚（越高越好）：内聚表达的是一个模块内部的联系的紧密型：包括信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。</li><li><img src="image-20240429103022348.png" alt="image-20240429103022348"></li><li>耦合（越低越好）：耦合描述的是两个模块之间关系的复杂程度，包括内容耦合，公共耦合，重复耦合，控制耦合，印记耦合，数据耦合</li><li><img src="15.png"></li></ul></li><li>模块化<ul><li>模块定义：模块是一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标识符。</li><li>为什么要将系统进行模块化<ul><li>管理：分而治之</li><li>演进：分离系统的各个部分，以便将一个部分的更改与其他部分的更改隔离开<ol><li>直接性原则(将需求明确分配到模块，理想情况下一个或多个需求映射到一个模块)</li><li>连续性&#x2F;局部性原则(需求的微小变化仅触发对一个模块的更改)</li></ol></li><li>理解：促使我们的系统更加容易被理解<ol><li>作为思维大小的块的组成，例如7±2规则</li><li>一部分只有一个问题，例如本地性原则，封装，关注点分离</li></ol></li><li>关键问题：模块化使用什么标准？-&gt;<strong>信息隐藏</strong></li></ul></li><li>最有可能被改变的设计域<ul><li>硬件依赖</li><li>输入输出格式</li><li>非标准语言特点和库路径</li><li>复杂设计和实现</li><li>复杂数据结构</li><li>复杂逻辑</li><li>全局变量</li><li>数据规模限制</li></ul></li></ul></li><li>信息隐藏<ul><li>目的：为了使可能的改动本地化</li><li>过程<ul><li>最常见的隐藏是您认为可能会更改的设计决策。</li><li>然后，您可以通过将每个设计秘密分配给自己的类，子例程或其他设计单元来分离它们。</li><li>接下来，您隔离(封装)每个机密，这样，如果它确实发生了更改，则更改不会影响程序的其余部分。</li></ul></li><li>接口与实现<ul><li>接口：用户对模块的看法，仅描述用户使用模块需要知道的内容</li><li>原则<ol><li>显式接口：使模块之间的所有依赖关系明确(无隐藏的耦合)</li><li>低耦合-接口少：最小化模块之间的依赖性</li><li>接口规模小：将大型接口分为几个接口</li><li>高内聚：一个模块应该封装一些定义良好的，连贯的功能(稍后会详细介绍)</li></ol></li><li>耦合与内聚<ol><li>内聚力是模块之间的一致性的度量。</li><li>耦合是模块之间的交互程度。</li><li>需要高内聚和低耦合</li></ol></li></ul></li></ul></li><li>KWIC例子<ul><li>具体见PPT</li><li>第一种模块化：处理过程中的每个主要步骤都是一个模块</li><li>第二种模块化：<ol><li>信息隐藏：每个模块都有一个或多个”隐藏”<ol><li>行：字符&#x2F;行的存储方式</li><li>循环位移：旋转算法，旋转存储</li><li>字符表化：alpha的算法，alpha的惰性</li><li>每个模块都以其对设计决策的了解为特征，而对其他所有决策则都不了解。</li></ol></li></ol></li></ul></li></ul><h3 id="结构化的模块化"><a href="#结构化的模块化" class="headerlink" title="结构化的模块化"></a>结构化的模块化</h3><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><ul><li>概念<ul><li>耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。<ul><li>连接有多复杂：全局变量，范围；与其他模块的连接</li><li>连接是指模块本身还是模块内部的东西</li><li>应该对外提供什么和接收什么</li></ul></li></ul></li><li>耦合强度1——连接有多复杂<ul><li>原则1：全局变量是被认为是有害的<ul><li>封装减少耦合：抽象和分解<ul><li>将潜在的共享元素细分成组</li><li>将每个组的访问权限限制为最小的模块子集</li></ul></li></ul></li><li>原则二：如果没有特殊要求，让代码清晰一点</li><li>原则三：不要重复</li></ul></li><li>耦合强度2——连接是指模块本身还是模块内部的东西<ul><li>以其名称寻址或整体引用一个模块的连接产生的耦合，比引用另一个模块内部元素的连接产生的耦合低(整体连接的耦合程度低于模块内部元素连接的耦合)</li><li>原则四：面向接口编程</li></ul></li><li>耦合强度3——应该对外提供什么和接收什么<ul><li>数据耦合：发送必要数据的耦合</li><li>印记耦合：发送数据比刚好需要的多</li><li>控制耦合：除了数据还有控制信号</li><li>内容耦合：数据和控制元素的耦合</li><li>显然，印记耦合可以实现更多的数据耦合</li><li>控制耦合比数据耦合还耦合更多：信息隐藏</li></ul></li></ul><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><ul><li>概念<ul><li>实现独立模块的方式<ul><li>减少不在同一模块中的元素之间的关系</li><li>增加同一模块中元素之间的关系</li><li>内聚程度的度量：绑定</li></ul></li><li>内聚度(绑定的类型)<ul><li>偶然内聚 &lt; 逻辑内聚 &lt; 临时内聚 &lt; 交流内聚 &lt; 功能内聚 &lt; 信息内聚</li></ul></li></ul></li></ul><h3 id="模块化思想的应用"><a href="#模块化思想的应用" class="headerlink" title="模块化思想的应用"></a>模块化思想的应用</h3><ul><li>低耦合处理<ul><li>软件体系结构的分层设计中<ul><li>不同层的模块之间仅能通过程序调用与数据传递实现交互，不能共享数据(例如 Model 层建立⼀个数据对象并将引用传递给 Logic 层使用)否则会导致公共耦合。</li></ul></li><li>软件体系结构的逻辑包设计中<ul><li>依据功能的特点将三个层次进⼀步划分为更小的包，而不是只使用 Presentation、Logic和 Model 三个包，可以通过包分割实现接口最小化，这能去除不必要的耦合。</li></ul></li><li>软件体系结构的物理包设计中<ul><li>将不同包的重复内容独立为单独的包以消除重复，避免产生隐式的重复耦合</li></ul></li><li>详细设计中对象创建者的选择<ul><li>如果两个对象 A、B 间已有比较高的耦合度了, 那么使用 A 创建 B 或者反之就不会带来额外的耦合度</li></ul></li></ul></li><li>高内聚处理<ul><li>软件体系结构的分层设计中:<ul><li>三个层次都是高内聚的,⼀个处理交互任务, ⼀个处理业务逻辑,⼀个处理数据持久化。</li></ul></li><li>软件体系结构的逻辑包设计中:<ul><li>将三个层次进⼀步划分为更小的包,可以实现每个更小的包都是高内聚的。</li></ul></li><li>详细设计中抽象类的职责:<ul><li>要求状态与方法紧密联系就是为了达到高内聚 (信息内聚)。</li></ul></li><li>详细设计中使用控制风格:<ul><li>控制风格分离了控制逻辑，可以实现业务逻辑对象的高内聚(功能内聚)。因为封装了控制逻辑，所以控制器对象承载了不可避免的顺序内聚、通信内聚和逻辑内聚，这就要求控制器对象必须是受控的，也是它们为什么倾向于对外委托而不是自己进行业务计算的原因。</li></ul></li></ul></li></ul><h3 id="结构化的信息隐藏"><a href="#结构化的信息隐藏" class="headerlink" title="结构化的信息隐藏"></a>结构化的信息隐藏</h3><ul><li>Module Guide<ul><li>模块的主要秘密：主要秘密描述的是这个模块所要实现的<strong>用户需求</strong>。是设计者对用户需求的实现的⼀次职责分配。有了这个描述以后，我们可以利⽤它检查我们是否完成所有的⽤户需求，还可以利⽤它和需求优先级来决定开发的次序。</li><li>模块的次要秘密：次要秘密描述的是这个模块在实现职责时候所涉及的具体的<strong>实现细节</strong>。包括数据结构，算法，硬件平台等信息。</li><li>模块的角色：描述了独立的模块在整个系统中所承担的角色，所起的作用以及与哪些模块有相关联的关系</li><li>模块的对外接口：模块提供给别的模块的接口</li></ul></li><li>信息隐藏思想的应用<ul><li><img src="image-20240429183633558.png" alt="image-20240429183633558"></li><li><img src="image-20240429183643021.png" alt="image-20240429183643021"></li></ul></li></ul><h2 id="14-面向对象的模块化"><a href="#14-面向对象的模块化" class="headerlink" title="14. 面向对象的模块化"></a>14. 面向对象的模块化</h2><ul><li>模块化的原则(总结)<ul><li><img src="1-1746703986798.png" style="zoom: 67%;" /></li><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ul></li></ul><h3 id="面向对象中的模块和耦合"><a href="#面向对象中的模块和耦合" class="headerlink" title="面向对象中的模块和耦合"></a>面向对象中的模块和耦合</h3><ul><li>耦合中的结构方法与面向对象方法<ul><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ul></li><li>降低耦合的设计原则<ul><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ul></li></ul><h3 id="访问耦合"><a href="#访问耦合" class="headerlink" title="访问耦合"></a>访问耦合</h3><ul><li><img src="image-20240508093021579.png" alt="image-20240508093021579"></li><li>隐式耦合：Cascading Message 级联调用问题<ul><li>解决方案<ol><li>引入局部变量，避免隐式耦合，变为显式耦合，降低耦合度</li><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ol></li></ul></li><li>组件耦合原理<ul><li>原则四：面向接口编程<ul><li>编写所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块&#x2F;类约定：所需方法&#x2F;提供的方法</li><li>方法约定：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li></ul></li><li>原则五：迪米特法则<ul><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li></ul></li><li>原则六：接口隔离原则(ISP)&#x2F;也叫接口最小化原则<ul><li>面向更简单的接口编程</li><li>许多客户端专用接口比一个通用接口要好</li><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li></ul></li></ul></li></ul><h3 id="继承耦合"><a href="#继承耦合" class="headerlink" title="继承耦合"></a>继承耦合</h3><ul><li><p><img src="image-20240508093924254.png" alt="image-20240508093924254"></p></li><li><p>修改继承耦合</p><ul><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ul></li><li><p>精化继承耦合</p><ul><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母的引用，则需要整个父母和子女的修饰</li></ul></li><li><p>扩展继承耦合</p><ul><li>最好的继承耦合</li><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ul></li><li><p>降低继承耦合的方法</p><ul><li><p>原则七：里氏替换原则</p><ul><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。”</li><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ul></li><li><p>原则八：组合代替继承</p><ul><li><p>组合优于继承</p></li><li><p>使用继承实现多态</p></li><li><p>使用委托时不要继承复用代码</p></li><li><p>例子：</p><ul><li><img src="16.png" style="zoom: 67%;" /><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><img src="17-1746703995843.png" style="zoom: 67%;" /><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li><li><img src="18.png" style="zoom:50%;" />- Person持有Role，Passenger和Agent实现抽象接口PersonRole- Role可以是一个List</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="内聚-1"><a href="#内聚-1" class="headerlink" title="内聚"></a>内聚</h3><ul><li>衡量标准<ul><li>方法和属性保持一致<ul><li><img src="image-20240508101030667.png" alt="image-20240508101030667" style="zoom:67%;" /></li></ul></li><li>属性之间是否体现一个职责<ul><li><img src="image-20240508101047791.png" alt="image-20240508101047791"></li></ul></li><li>属性间是否可以抽象<ul><li><img src="image-20240508101511363.png" alt="image-20240508101511363"></li></ul></li></ul></li><li>方法内聚<ul><li>一个类中的方法是普通耦合</li><li>所有方法服务于一个职责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ul></li><li>原则九：单一责任原则(SRP)<ul><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的</li></ul></li></ul><h3 id="耦合和内聚的度量"><a href="#耦合和内聚的度量" class="headerlink" title="耦合和内聚的度量"></a>耦合和内聚的度量</h3><ul><li><p>类之间的耦合度量</p><ul><li>第一种度量:CBO(方法调用耦合)<ul><li>对象类之间的耦合(CBO)</li><li>CBO &#x3D; 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ul></li><li>第二种度量:DAC(数据抽象耦合)<ul><li>DAC &#x3D; 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ul></li><li>第三种度量:Ca和Ce(有效和)<ul><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ul></li><li>第四种度量:DIT 继承树的深度<ul><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性。</li></ul></li><li>第五种度量 Number of children (NOC) 子类的数量<ul><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ul></li></ul></li><li><p>类内聚程度衡量</p><ul><li><p>Lack of cohesion in methods (LCOM)</p></li><li><p><img src="28.png"></p><ul><li><p>交集为空则在P中，交集不为空则在Q中</p></li><li><p>值越低越好</p></li><li><p>还定义了许多其他版本的LCOM</p></li><li><p>如果LCOM&gt;&#x3D; 1，则应将类划分</p></li></ul></li></ul></li><li><p>Summary:Principles from Modularization 模块化的原则</p><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol></li></ul><h2 id="15-面向对象的信息隐藏"><a href="#15-面向对象的信息隐藏" class="headerlink" title="15. 面向对象的信息隐藏"></a>15. 面向对象的信息隐藏</h2><h3 id="封装类的职责"><a href="#封装类的职责" class="headerlink" title="封装类的职责"></a>封装类的职责</h3><ul><li><p>结构化中的信息隐藏</p><ul><li>每一个模块都隐藏了这个模块中关于重要设计决策的实现，以至于只有这个模块的每一个组成部分才能知道具体的细节</li><li>最重要的细节：职责的变更</li><li>次要的细节：实现的变更</li></ul></li><li><p>类的职责</p><ul><li><p>职责是类或对象维护一定的状态信息，并基于状态履行行为职能的能力</p></li><li><p>职责的体现：封装</p></li></ul></li><li><p>类的封装</p><ul><li>封装：一个模块应该通过稳定的接口对外体现其所承载的要求，而隐藏它对需求的内部实现细节</li><li>封装将数据和行为同时包含在类中，分离对外接口与内部实现</li><li>接口是模块的可见部分：描述了一个类中的暴露到外界的可见特征</li><li>实现被隐藏在模块之中：隐藏实现意味着只能在类内操作，更新数据，而不意味着隐藏接口数据</li><li>面向对象中的接口通常包含的部分<ul><li>对象之间交互的消息(方法名)</li><li>消息中的所有参数</li><li>消息返回结果的类型</li><li>与状态无关的不变量(前置条件和后置条件)</li><li>需要处理的异常</li></ul></li><li>封装实现的细节<ul><li>封装数据和行为</li><li>封装内部结构</li><li>封装其他对象的引用</li><li>封装类型信息</li><li>封装隐藏变更</li></ul></li><li>原则十：最小化类和成员的可访问性<ul><li>抽象化：抽象集中于对象的外部视图，并将对象的行为与其实现分开</li><li>封装形式：类不应公开其内部实现细节</li><li>权限最小化原则</li></ul></li></ul></li></ul><h3 id="为变更而设计"><a href="#为变更而设计" class="headerlink" title="为变更而设计"></a>为变更而设计</h3><ul><li><p>OCP (开闭原则，Open&#x2F;Close Principle) <strong>重要</strong></p><ul><li><p>修改很复杂，修改后需要重新编译，有一定代价</p></li><li><p>解决方案：使用多态依赖完成</p></li><li><p>例子（图一为修改前，图二为修改后）：</p><ul><li><img src="1-1746704008602.png" style="zoom:67%;" /></li><li><img src="17-1746704010148.png" style="zoom: 67%;" /></li></ul></li><li><p>开闭原则(OCP)：软件实体应该开放进行扩展，而封闭以进行修改</p><ul><li>对<strong>扩展</strong>开放：模块的行为可以被扩展，比如新添加一个子类</li><li>对<strong>修改</strong>关闭：模块中的源代码不应该被修改</li></ul></li><li><p>RTTI：运行时类型信息是丑陋并且危险的</p><ul><li><p>RTTI &#x3D; Run-Time Type Information RTTI &#x3D; 运行时类型信息</p></li><li><p>如果模块尝试将基类指针动态转换为多个派生类，则每次扩展继承层次结构时，都需要更改模块</p></li><li><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSquare</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        <span class="hljs-comment">//这里写法不合适</span><br>        <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Square) &#123;<br>            ((Square) shape).drawSquare();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Circle) &#123;<br>            ((Circle) shape).drawCircle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>都有draw方法，应该将draw放到shape里面</p></li></ul></li></ul></li><li><p>多态</p><ul><li>多态是指针对类型的语言限定，指的是不同类型的值能够通过统一的接口来操纵</li><li><img src="image-20240514200706623.png" alt="image-20240514200706623" style="zoom:67%;" /></li><li>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        shape.draw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>原则十二：DIP (Dependency Inversion Principle) 依赖倒置原则</p><ul><li>高级模块不应依赖于低级模块，两者都应依赖抽象；抽象不应该依赖细节，详细信息应取决于抽象</li><li>将接口从实现中分离出来 —— 抽象<ul><li>设计接口，而不是实现！</li><li>使用继承来避免直接绑定到类</li><li>实现依赖于接口</li></ul></li><li>例子：<ul><li><img src="23.png"></li><li>抽象：Writer，扩展的时候只需要被扩展类实现Writer</li></ul></li><li>抽象类&#x2F;接口：<ol><li>倾向于不经常改变</li><li>抽象是”铰接点”，在此更易于扩展&#x2F;修改</li><li>不必修改代表抽象(OCP)的类&#x2F;接口</li></ol></li><li>例外情况<ol><li>有些类很不可能修改<ol><li>因此对插入抽象层没有什么好处</li><li>示例：字符串类</li></ol></li><li>在这种情况下可以直接使用具体的类：在这种情况下可以直接使用具体的类…</li></ol></li><li>符合DIP的分层设计图参考课本256页</li></ul></li></ul><h2 id="16-设计模式"><a href="#16-设计模式" class="headerlink" title="16. 设计模式"></a>16. 设计模式</h2><h3 id="可修改性及其基本实现机制"><a href="#可修改性及其基本实现机制" class="headerlink" title="可修改性及其基本实现机制"></a>可修改性及其基本实现机制</h3><ul><li><p>可修改性</p><ul><li>实现的<strong>可修改性</strong>：涉及到大的场景的修改<ol><li>对已有实现的修改</li><li>例如：修改现有促销策略</li></ol></li><li>实现的<strong>可扩展性</strong>(DIP &amp; OCP)<ol><li>对新的实现的扩展</li><li>例如：增加一条新的促销策略(策略模式)</li></ol></li><li>实现的<strong>灵活性</strong><ol><li>对实现的动态配置</li><li>例如：动态修改更改某商品对应促销策略</li></ol></li></ul></li><li><p>可修改性的实现</p><ul><li><p>接口与实现的分离</p><ul><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。</li></ul></li><li><p>继承的优点</p><ul><li>虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。</li><li>子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。</li></ul></li><li><p>继承的缺点</p><ul><li>继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。</li><li>而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改。</li></ul></li><li><p>组合</p><ul><li><p>利用接口的组成关系，能在实现接口和实现的前提下，体现更好的灵活性。</p></li><li><p>优点</p><ol><li>前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。</li><li>后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。</li></ol></li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>概念<ul><li>设计模式：抽象一个重复的设计结构</li><li>包含类和&#x2F;或对象</li><li>提炼设计经验</li><li><strong>设计模式重点掌握类图</strong></li></ul></li><li>分类<ul><li>策略模式：减少耦合、依赖倒置。</li><li>抽象工厂模式：职责抽象、接口重用。</li><li>单件模式：信息隐藏、职责抽象。</li><li>迭代器模式：减少耦合、依赖倒置。</li></ul></li><li>策略模式<ul><li>策略模式：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li><li>参与者<ul><li>上下文（Context）:<ol><li>被配置了具体策略Concrete Strategy</li><li>拥有Strategy对象的一个引用</li><li>实现了一些方法以供Strategy访问其数据</li></ol></li><li>策略（Strategy）: 声明了所支持策略的接口。Context利用这些被Concrete Strategy定义的接口。</li><li>具体策略（Concrete Strategy）: 实现了Strategy声明的接口，给出了具体的实现。</li></ul></li><li>应用场景<ul><li>当很多相关类只在它们的行为的实现上不一样。策略模式提供了一个很好的方式来配置某个类，让其具有上述多种实现之一。</li><li>当我们需要同一个行为的不同实现（变体）的时候。策略模式可以用作实现这些变体。</li><li>算法需要用到一些数据，而这些数据不应该被客户知道。我们可以通过策略模式隐藏复杂的算法和数据接口。</li><li>一个类定义了很多行为，这些行为作为一个switch选择语句的分支执行部分。策略模式可以消除这些分支选择。</li></ul></li><li>类图<ul><li><img src="image-20240516152505556.png" alt="image-20240516152505556"></li></ul></li></ul></li><li>抽象工厂模式<ul><li>工厂模式就是为对象的创建提供一个接口，将具体创建的实现封装在接口之下，这样具体创建的实现的改变就不会对客户代码Client类产生影响。从而降低了Client类和多个具体类的耦合。</li><li><img src="image-20240516152625441.png" alt="image-20240516152625441" style="zoom:50%;" /></li><li>应用场景<ul><li>抽象工厂模式可以帮助系统独立于如何对产品的创建、构成、表现。</li><li>抽象工厂模式可以让系统灵活配置拥有某多个产品族中的某一个。</li><li>一个产品族的产品应该被一起使用，抽象工厂模式可以强调这个限制。</li><li>如果你想提供一个产品的库，抽象工厂模式可以帮助暴露该库的接口，而不是实现。</li></ul></li><li><img src="image-20240516152357093.png" alt="image-20240516152357093" style="zoom:67%;" /></li><li>类图<ul><li><img src="image-20240516152522467.png" alt="image-20240516152522467" style="zoom: 50%;" /></li></ul></li><li>工厂接口可以通过抽象工厂模式的专门的接口来实现，另外也可以通过父类的工厂方法，来让子类继承相应的工厂接口，这就是工厂方法模式</li></ul></li><li>单件模式<ul><li>在有些场景中，对于某个类，在内存中只希望有唯一一个对象存在。每次想得到这个类的一个对象的引用的时候，都指向唯一的那个对象。无论我创建多少次这个类的对象，其实总共还是只创建了一个对象。</li><li>类图<ul><li><img src="image-20240516152916693.png" alt="image-20240516152916693" style="zoom:50%;" /></li></ul></li><li>设计分析<ul><li><img src="image-20240516153424625.png" alt="image-20240516153424625"></li></ul></li></ul></li><li>迭代器模式<ul><li>当需要接受某个参数（如链表、散敛表）并对其进行迭代，将参数类型设为Collection</li><li>类图<ul><li><img src="image-20240516153154670.png" alt="image-20240516153154670" style="zoom:50%;" /></li></ul></li><li>参与者：<ul><li>迭代器（Iterator）： 迭代器定义访问和遍历元素的接口</li><li>具体迭代器（ConcreteIterator）：具体迭代器实现迭代器接口。对该聚合遍历时跟踪当前位置。</li><li>聚合（Aggregate）：聚合定义创建相应迭代器对象的接口。</li><li>具体聚合(ConcreteAggregate)：具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</li></ul></li><li>应用场景：<ul><li>访问一个聚合对象的内容而无需暴露它的内部实现。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ul></li></ul></li></ul><h2 id="17-软件构造"><a href="#17-软件构造" class="headerlink" title="17. 软件构造"></a>17. 软件构造</h2><ul><li>概述<ul><li>定义：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，⽣产可⼯作的、有意义的软件的详细创建过程。</li><li>软件构造是设计的延续<ul><li>设计是<strong>规划软件构造方法</strong>的过程，实现是依据<strong>规划的软件构造方案建造真正产品</strong>的过程</li><li>源程序是软件构建方案的<strong>最后一个规划</strong>，不是产品本身，真正的产品是运行于计算机上的由二进制代码组成的可执行程序。</li><li>源程序的生产过程-编程，属于设计活动，编译器完成的编译和链接才是依据规划建造软件产品的实现活动。</li><li><strong>编程不是一个简单的活动，核心是编码的设计</strong>。</li></ul></li><li>软件构造活动包含详细设计、编程、测试、调试、代码评审、集成与构建、构造与管理</li></ul></li></ul><h3 id="软件构造活动"><a href="#软件构造活动" class="headerlink" title="软件构造活动"></a>软件构造活动</h3><ul><li>详细设计<ul><li>概述<ul><li>有些项目会将主要的详细设计工作分配在软件构造阶段完成。</li><li>无论是哪种项目，在软件构造阶段都不可避免的会设计到详细设计的调整工作。因为编程语言是软件设计的一个重要约束，随着编程工作的进行和约束，人们可能会发现与预想不一致的情况和更多的约束，这个时候就需要在软件构造阶段修改详细设计方案。</li><li>软件构造阶段详细设计使用的方法与技术与软件设计阶段是一样的，只是应用在<strong>更小</strong>的规模上。</li><li>详细设计已经包含实际的代码实现了，不同编程语言的代码行数不同。</li></ul></li><li>程序代码的典型质量<ul><li>易读性：让软件更容易开发，尤其是易于调试；可以使的程序更加容易维护，减少理解代码的难度和成本：降低交流的成本，自己写完之后要修正代码使其易读。</li><li>易维护性:要求代码易读、易修改，增量开发，关键业务流程应该是易于扩展的</li><li>可靠性：执行正确，并能妥善处理故障。</li><li>性能：高性能，包括时间性能和空间性能，需要设计数据结构和算法设计。</li><li>安全性：不留系统漏洞，不出现重要信息的泄露(内存数据区泄露)</li></ul></li></ul></li><li>编程的主要技术<ul><li><img src="1-1746704036532.png" style="zoom:80%;" /></li></ul></li><li>测试、调试<ul><li>通常来说，程序员每修改⼀次程序就会进行最少⼀次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到了要求，没有程序错误。集成测试⼀般在单元测试之后，用来测试多个单元之间的接口是否编程正确。</li><li>调试过程可以分为三个部分：重现问题、诊断缺陷和修复缺陷。</li><li>重现问题的方法<ul><li><img src="4-1746704038583.png" style="zoom:80%;" /></li></ul></li><li>寻找和定位缺陷的方法<ul><li>灵活使用编译器提示。</li><li>持续缩小嫌疑代码的范围。</li><li>检查刚刚修改过的部分。</li><li>警惕已出现缺陷和常见缺陷。</li><li>利用工具。</li></ul></li><li><img src="6-1746704040318.png" style="zoom: 67%;" /></li><li>修复缺陷注意点<ul><li>⼀次只修复⼀个缺陷。</li><li>修改前保留旧版本的备份，如果项目使用了配置管理系统，这个工作会由配置管理工具完成，否则就需要由程序员手动完成。</li><li>使用测试和评审验证修复的有效性。</li><li>检查和修复类似的缺陷，这可以在代码搜索、程序切片等工具的帮助下进行。</li></ul></li></ul></li><li>代码评审<ul><li>代码评审对代码的系统检查，通常是通过同行专家评审来完成的。通过评审会议可以发现并修正之前忽略的代码错误，从而同时提高软件的质量和开发者的技巧。</li><li>代码评审⼀般分为正式评审、轻量级评审和结对编程。</li></ul></li><li>集成与构建<ul><li><img src="10.png" style="zoom: 80%;" /></li></ul></li><li>构造与管理<ul><li><img src="11-1746704043879.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="实践方法"><a href="#实践方法" class="headerlink" title="实践方法"></a>实践方法</h3><ul><li>重构<ul><li>概念：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。</li><li>重构的时机：<ul><li>增加新的功能时</li><li>发现了缺陷进行修复时</li><li>进行代码评审时</li></ul></li><li>代码的“坏味道”<ul><li><img src="image-20240528210426534.png" alt="image-20240528210426534"></li></ul></li><li>详见课本290页</li></ul></li><li>测试驱动开发<ul><li>测试驱动开发又被称为测试优先（Test First）的开发，随着极限编程方法的普遍应用而得到普及。</li><li>测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。测试代码通常由测试工具自动装载执行，也可以由程序员手工执行。完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性。</li><li><img src="image-20240528210620336.png" alt="image-20240528210620336" style="zoom: 67%;" /></li></ul></li><li>结对编程<ul><li>概念<ul><li>两位程序员并排工作，在相同的设计，算法，代码或测试上进行协作</li><li>一个程序员(驱动程序)可以控制键盘&#x2F;鼠标并主动执行程序</li><li>另一个程序员(观察员)不断观察驾驶员的工作，以发现战术上的(语法上的，拼写的等)缺陷，并从战略上考虑工作的方向</li><li>根据需要，两位程序员可以集思广益解决任何难题</li><li>两位程序员定期切换角色，他们平等地合作开发软件</li></ul></li><li>为什么结对编程有效？<ul><li>双压力：彼此保持专注并专注于任务</li><li>配对思考：为任务带来不同的先前经验</li><li>配对中继：每个人依次为自己的知识和能力做出最大贡献，然后坐下来思考，而他们的伴侣继续奋斗</li><li>配对审查<ol><li>持续的设计和代码审查</li><li>极高的缺陷去除效率</li><li>消除程序员对评论的厌恶</li><li>在所有(单独)程序员中，有80％都不定期或根本不这样做</li><li>预防缺陷总是比消除缺陷更有效</li></ol></li><li>配对调试：成对谈论问题可能会导致解决方案变得显而易见</li><li>配对学习：持续审核-&gt;向合作伙伴学习技术，语言知识，领域等。</li></ul></li></ul></li><li>有建设性的想法（具体见PPT）<ul><li>十年的软件建设进展</li><li>现代软件建设的十个现实情况</li><li>1990年代和2000年代最糟糕的建筑思想</li></ul></li></ul><h2 id="18-代码设计"><a href="#18-代码设计" class="headerlink" title="18. 代码设计"></a>18. 代码设计</h2><ul><li><p>设计易读的代码</p><ul><li>布局格式<ul><li>用缩进与对齐表达逻辑结构</li><li>将相关逻辑组织在一起（成员变量声明、构造方法和析构方法、public方法……）</li><li>将空行分隔逻辑(将大规模的逻辑划分的片段进行分隔)</li><li>将语句进行分隔(将过长的语句分隔到几行中进行显示)</li></ul></li><li>命名<ul><li>使用有意义的名称进行命名</li><li>名称要与实际内容相符</li><li>如果存在惯例，命名时要遵守惯例</li><li>临时变量命名要符合常规</li><li>不要使用太长的名称</li><li>不要使用易混字符进行命名</li><li>不要仅仅使用不易区分的多个名称（例如Sales与Sale）</li><li>不要使用没有任何逻辑的字母缩写进行命名</li></ul></li><li>注释<ul><li>语句注释（&#x2F;&#x2F;）</li><li>标准注释(&#x2F;* *&#x2F;)</li><li>文档注释(&#x2F;** *&#x2F;)</li><li>注释要有意义，不要简单重复代码的含义</li><li>重视对数据类型的注释</li><li>重视对复杂控制结构的注释</li></ul></li><li>javadoc<ul><li><img src="image-20240530104046105.png" alt="image-20240530104046105" style="zoom: 60%;" /></li><li><img src="image-20240530104115367.png" alt="image-20240530104115367" style="zoom:50%;" /></li></ul></li></ul></li><li><p>设计易维护的代码</p><ul><li><p>小型任务</p><ul><li>要让程序代码可修改，就要控制代码的复杂度。这首先要求每个函数或⽅法的代码应该是内聚的，恰好完成⼀个功能与⽬标。</li><li>如果内聚的代码本身比较简单，复杂性可控，那么它就具有比较好的可维护性。反之，内聚的代码也可以比较复杂，典型表现是完成⼀个功能需要多个步骤、代码比较长，那么就需要将其进⼀步分解为多个高内聚、低耦合的小型任务。</li></ul></li><li><p>复杂决策</p><ul><li><p>使用新的布尔变量简化复杂决策</p><img src="image-20240530104850436.png" alt="image-20240530104850436" style="zoom:50%;" /></li><li><p>使用有意义的名称封装复杂决策</p><img src="image-20240530104804574.png" alt="image-20240530104804574" style="zoom:50%;" /></li><li><p>表驱动编程</p><ul><li><img src="image-20240530105007694.png" alt="image-20240530105007694" style="zoom: 67%;" /></li><li><img src="image-20240530105028512.png" alt="image-20240530105028512"></li></ul></li></ul></li><li><p>数据使用</p><ul><li><img src="image-20240530105101590.png" alt="image-20240530105101590"></li></ul></li><li><p>明确依赖关系</p><ul><li>类之间模糊的依赖关系会影响到代码的理解与修改，非常容易导致修改时产生未预期的连锁反应</li></ul></li></ul></li><li><p>设计可靠的代码</p><ul><li>契约式设计——异常方式<ul><li><img src="image-20240530105257449.png" alt="image-20240530105257449" style="zoom:67%;" /></li></ul></li><li>契约式设计——断言方式<ul><li><img src="image-20240530105323619.png" alt="image-20240530105323619"></li><li><img src="image-20240530105351501.png" alt="image-20240530105351501" style="zoom: 50%;" /></li></ul></li><li>防御式编程<ul><li>防御式编程的基本思想是：在⼀个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害。</li><li>异常和断言都可以⽤来实现防御式编程，两种实现方式的差异与契约式设计的实现⼀样</li></ul></li></ul></li><li><p>使用模型辅助设计复杂代码</p><ul><li>决策表<ul><li><img src="image-20240530105808943.png" alt="image-20240530105808943" style="zoom:50%;" /></li><li><img src="image-20240530105821325.png" alt="image-20240530105821325"></li></ul></li><li>伪代码<ul><li><img src="image-20240530105846470.png" alt="image-20240530105846470"></li></ul></li><li>程序流程图<ul><li><img src="image-20240530105908073.png" alt="image-20240530105908073"></li></ul></li></ul></li><li><p>为代码开发单元测试用例</p><ul><li>为方法开发测试用例<ul><li><img src="image-20240530112339238.png" alt="image-20240530112339238" style="zoom: 50%;" /></li><li><img src="image-20240530112541314.png" alt="image-20240530112541314"></li></ul></li><li>为类开发测试用例<ul><li>在复杂类中，常常有着多变的状态，每次⼀个方法的执行改变了类状态时，都会给其他方法带来影响，也就是说复杂类的多个方法间是互相依赖的。</li><li>所以，除了测试类的每⼀个方法之外，还要测试类不同方法之间的互相影响情况。</li><li><img src="image-20240530112523161.png" alt="image-20240530112523161"></li></ul></li></ul></li><li><p>代码复杂度度量</p><ul><li>程序复杂度是造成各种编程困难的主要原因。为了帮助程序员处理程序复杂度，人们提出了<br>很多程序复杂度的度量手段，其中McCabe的圈复杂度[McCabe1976]得到了比较大的关注</li><li><img src="image-20240530113030652.png" alt="image-20240530113030652" style="zoom:50%;" /></li><li><img src="image-20240530113043738.png" alt="image-20240530113043738" style="zoom:50%;" /></li><li><img src="image-20240530113136053.png" alt="image-20240530113136053" style="zoom: 50%;" /></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>关闭隐式声明</li><li>声明全部的变量</li><li>遵循某种命名规则</li><li>检查变量名</li></ul></li><li>变量初始化<ul><li><img src="image-20240530192031434.png" alt="image-20240530192031434" style="zoom: 50%;" /></li></ul></li><li>作用域<ul><li>使变量应用局部化（空间）</li><li>尽可能缩短变量的存活时间（时间）</li></ul></li><li>持续性<ul><li>在程序中加⼊调试代码或者断言来检查那些关键变量的合理取值</li><li>编写代码时要假设数据并没有持续性</li></ul></li><li>数值理论<ul><li>避免使用“神秘数值”</li><li>如果需要，可以使用硬编码的0和1</li><li>预防除0的错误</li><li>避免混合类型的比较</li><li>使类型转换变得明显</li></ul></li></ul></li><li><p>⼀般控制问题</p><ul><li>布尔表达式<ul><li>用true和false做布尔判断</li><li>简化复杂的表达式</li><li>编写肯定形式的布尔表达式（isEmpty）</li><li><img src="image-20240530192745794.png" alt="image-20240530192745794" style="zoom:50%;" /></li></ul></li><li>复合语句<ul><li>把括号对⼀起写出</li><li>y6括号被条件表达清楚</li></ul></li><li>空语句<ul><li><img src="image-20240530193054565.png" alt="image-20240530193054565" style="zoom:50%;" /></li></ul></li><li>驯服危险的深层嵌套<ul><li><img src="image-20240530193149087.png" alt="image-20240530193149087" style="zoom:50%;" /></li></ul></li></ul></li></ul><h2 id="19-软件测试"><a href="#19-软件测试" class="headerlink" title="19. 软件测试"></a>19. 软件测试</h2><ul><li>概念<ul><li>软件正确性：在且仅在以下情况下，才根据规范S考虑程序P：对于每个有效输入，P的输出均符合规范S</li></ul></li><li>V&amp;V<ul><li>Verification: 验证，检查开发者是否正确地使用技术建立系统，确保系统能够在于其的环境中按照技术要求正确地运行。例如：“检查需求文档中的书写错误”，“发现设计思路的不完善”</li><li>Validation: 确认，检查开发者是否建立了正确的系统，确保最终产品符合规格。例如：“需求文档能否反应用户真实意图”，“代码是否按照需求与设计要求编写”</li><li>V＆V通常是指试图确保软件按要求运行的任何活动，差异无关紧要。(见课本320页,重要，会考V&amp;V)</li><li>软件开发的验证与确认主要有两种手段：<strong>静态分析</strong>与<strong>动态测试</strong></li><li><img src="image-20240611161053160.png" alt="image-20240611161053160" style="zoom: 50%;" /></li></ul></li><li>静态分析<ul><li>仅基于(手动或自动)检查软件模型和代码的项目文档以及有关需求和设计的其他相关信息，通常会产生有效的结果，但精度可能较弱。容易产生误报，因为多态的存在导致很多只能在运行的时候才报错。</li><li>评审是最常用的静态分析手段</li><li>传统静态技术–大量手动操作，容易出错，耗时<ol><li>软件检查–根据已编译的常见和历史缺陷清单，对生成的文档(可交付成果)进行逐步分析</li><li>软件评审–将工作产品的不同方面呈现给项目人员(经理，用户，客户等)和其他感兴趣的涉众以征求意见或批准的过程</li><li>阅读代码–对生成的代码进行桌面分析，以发现不违反样式或语法的键入错误</li><li>算法分析和跟踪–可以得出所用算法的复杂性以及最坏情况，平均情况和概率分析评估的过程</li></ol></li></ul></li><li>动态测试<ul><li>在软件运行时考察软件运行时的表现，完成验证与确认</li><li>动态分析技术<ul><li>测试：基于对有价输入的代码执行(必要时必须包括表征系统状态的参数和环境条件的定义)</li><li>性能分析：程序配置文件记录了一组受控执行过程中某些感兴趣的实体出现的次数</li></ul></li></ul></li><li>软件测试<ul><li>目的<ul><li>向开发者和用户展示软件满足了需求，表明软件产品是一个合格的产品</li><li>找出软件中的缺陷和不足</li></ul></li><li>测试用例<ul><li><img src="image-20240611161633280.png" alt="image-20240611161633280" style="zoom: 33%;" /></li></ul></li><li>桩与驱动<ul><li>桩程序是被测试部件的交互环境，他扮演被测试部件需要调用的其他系统部件。桩程序对其他系统部件的扮演仅限于规格相同，内部代码要简单的多，通常是直接返回固定数据或者按照固定规则返回数据。</li><li>驱动程序负责创建被测试部件的执行环境，并驱动和监控被测试部件执行测试用例的过程，判定测试用例的执行结果。</li><li><img src="image-20240611161721076.png" alt="image-20240611161721076" style="zoom: 33%;" /></li></ul></li><li>测试层次<ul><li><img src="image-20240611162004576.png" alt="image-20240611162004576" style="zoom: 80%;" /></li><li>开发者主要是进行单元测试，可以进行一定程度上的集成测试和系统测试</li><li>看一下α和β测试</li></ul></li><li>单元测试<ul><li><img src="image-20240611162115903.png" alt="image-20240611162115903" style="zoom: 33%;" /></li><li>在过程化编程中，一个单元就是一个函数与过程。</li><li>在面向对象编程中，一个单元就是类的一个方法。</li><li>发现技术缺陷和代码缺陷</li></ul></li><li>集成测试<ul><li><img src="image-20240611162205907.png" alt="image-20240611162205907" style="zoom: 60%;" /></li><li><img src="image-20240611162226820.png" alt="image-20240611162226820" style="zoom:60%;" /></li></ul></li><li>系统测试：关注不符合需求的缺陷和需求自身的内在缺陷。根据测试目标的不同，有很多不同类型的系统测试：功能测试、非功能性测试、验收测试、安装测试等等。</li></ul></li><li>软件测试技术<ul><li>随机测试：根据软件工程师的技能、直觉和对类似程序的经验，从所有可能的输入值中选择输⼊子集，建立测试用例。</li><li>黑盒测试：将测试对象作为一个黑盒子，完全基于输入和输出数据来判断测试对象的正确性。<ul><li>把所有可能的输入数据，即程序的输入域划分为若干部分(子集)，从每个子集中选取少量具有代表性的数据作为测试用例。</li><li>等价类划分：将输入域分为有效等价类和无效等价类。有效等价类指对系统规格说明来说合理的输入，无效等价类与之相反。设计测试用例时要同时考虑两种等价类。</li><li>边界值分析：对定价类划分的补充，错误容易发生在各个等价类的边界上，而不是等价类的内部，因此针对边界情况设计测试用例，可以发现更多的缺陷。</li><li>决策表是为复杂逻辑判断设计测试用例的技术。决策表是由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。（具体见18代码设计或者书P311）</li><li>状态转换是针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定。状态转换包含有效转换和无效转换，只有在复杂情况和可靠性要求较高的情况下才会为无效转换设计测试用例。</li></ul></li><li>白盒测试：将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。<ul><li>语句覆盖：设计测试用例的标准是确保被测试对象的每⼀行程序代码都⾄少执行⼀次。</li><li>条件覆盖：设计测试用例的标准是确保程序中每个判断的每个结果都⾄少满足⼀次</li><li>路径覆盖：测试用例的标准是确保程序中每条独立执行路径都⾄少执行⼀次</li></ul></li><li>特定测试技术和面向对象的测试技术略</li></ul></li><li>测试活动（P332）<ul><li>测试计划:在开始具体的软件测试活动之前，必须首先进行测试计划，以明确测试的工作范围、资源与成本、基本策略、进度安排等。</li><li>测试设计:测试的成功取决于有效设计的测试用例</li><li>测试执行:执行测试前需要选择好测试工具</li><li>测试评价:在测试完成后，必须评价测试结果</li></ul></li><li>测试度量<ul><li>缺陷数据：分类汇总测试过程中发现的缺陷</li><li>测试覆盖率<ul><li>需求覆盖率&#x3D;被测试的需求数量&#x2F;需求总数</li><li>模块覆盖率&#x3D;被测试的模块数量&#x2F;模块总数</li><li>代码覆盖率&#x3D;被测试的代码行&#x2F;代码行数</li></ul></li></ul></li></ul><h2 id="20-软件交付"><a href="#20-软件交付" class="headerlink" title="20. 软件交付"></a>20. 软件交付</h2><ul><li>概念<ul><li>软件交付是软件项目的结束阶段，标志着软件开发任务的完成</li><li>软件交付是软件开发与软件维护两个既连续又不同的软件产品生存状态的分水岭。</li><li>只有做好软件交付工作，才是真正地完成整个项目。</li></ul></li><li>安装<ul><li>概念：安装是软件交付的最常见形式，现在大多数产品都通过安装的形式交付，它要求开发团队创建一个安装包，用户可以通过的执行将软件产品部署到工作环境。</li><li>创建安装包的步骤<ul><li>确定安装环境<ol><li>确定安装包需要<strong>支持的操作系统</strong>，这既需要考虑当前用户的工作环境，又需要考虑产品未来的市场规划；</li><li>确定软件产品的语言支撑环境，例如使用Java语言开发的软件产品就需要安装JDK；</li><li>确定软件产品需要的软件支持，例如数据库系统、网络系统等；</li><li>确定硬件等其他要求，例如有些软件产品可能会要求扫描仪、视频卡、通信设备等特殊硬件。</li></ol></li><li>列举安装清单<ol><li>要根据软件产品的实现情况，结合所需的环境支撑，列举需要安装的文件、初始化数据、注册表等清单信息，要清楚<strong>标明它们在安装后将会出现的位置</strong>。</li><li>在考虑安装位置时要遵守一致性，标记名称的使用要意义清楚，让用户能便利地找出相应文件。</li></ol></li><li>设计和建立安装包：要对安装包进行详细的设计，包括一个渐进的安装步骤，各步骤的人机交互方式等等。完成设计后就可以使用安装工具创建安装包。</li><li>测试安装包：安装包需要在目标环境中进行安装测试，以发现可能的问题。必须以用户的工作环境为<strong>目标环境</strong>进行测试，因为用户使用的机器环境与开发者的机器环境有很大的不同</li></ul></li></ul></li><li>部署<ul><li>背景：在软件产品比较复杂时，仅仅通过一个安装包无法完成软件交付任务，这时可以使用另一种常见的软件交付方式——部署。</li><li>概念：部署通常是由开发人员直接操纵软件产品的目标环境，使得软件产品能够在目标环境中正常运行。</li><li>部署的步骤<ul><li>确定部署环境：需要对目标环境进行调查分析，搞清楚部署前的环境细节，然后才能与软件产品需要的环境细节进行比较，明确需要执行的部署任务。具体来说，软件部署需要了解服务器与网络拓扑、安全控制与权限管理、软硬件系统的配置信息等。</li><li>确定部署任务：将软件产品需要的目标环境与部署前的环境进行比较，分析二者之间的差距，并将其确立为部署的任务。确定任务之后，还需要以渐进的方式安排任务之间的执行次序。</li><li>完成部署准备：有些部署工作可以完全依靠现场执行，但多数的部署任务需要进行一定的事前准备，尤其是要综合考虑部署工作可能出现的各种情况，制定完备的应对方案。</li><li>执行部署任务</li></ul></li></ul></li><li>培训与文档支持<ul><li>培训<ul><li>培训主要是教会用户使用软件产品的功能来完成其工作和任务。依据任务的不同，要为不同的用户进行不同类型的培训。</li><li>尤其不能忽略的是对<strong>系统管理员</strong>进行培训。要培训系统管理员如何启动和运行新系统、如何配置系统、如何授权或拒绝对系统的访问、如何支持用户、如何处理异常等。</li><li>只介绍能够帮助用户完成主要工作和任务的功能。对于一些很少会被使用并且<strong>不太重要</strong>的功能，即使培训也会很快被用户忘记，可以让用户使用<strong>文档支持</strong>来学会使用。</li><li>培训时，要关注用户的工作和任务，不必涉及系统的内部操作，不必知道系统的存储方式、访问方式和权限控制方式。</li></ul></li><li>文档支持<ul><li>用户文档：用户文档是指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。</li><li><img src="image-20240611202441645.png" alt="image-20240611202441645" style="zoom:50%;" /></li><li>系统管理员文档：与用户文档注重系统使用细节不同，系统管理员文档更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。</li></ul></li></ul></li><li>项目评价<ul><li>常见的项目评价针对四个方面：<ol><li>项目管理：可以帮助建立对项目的更准确认知，例如常见的管理问题与偏差、时间与成本耗费分布等。</li><li>产品：可以帮助开发者建立对产品的更准确认知，提高产品的开发经验。</li><li>团队：可以帮助开发者更好地组织分工，也可以帮助团队建立更好的沟通与交流途径。</li><li>个人：可以帮助开发者更准确认知自己的生产力，学习常见问题及其处理方法，了解自己的长处和不足并持续提高。</li></ol></li><li>项目评价方法<ul><li>评审：项目评审通过评审重要项目制品的方法来评价项目，这些重要制品包括项目计划、管理文档、会议记录、历史数据等。</li><li>度量数据分析：度量数据可以提供丰富的信息，通过分析这些信息，开发团队可以获取正确和深入的结论。</li></ul></li></ul></li></ul><h2 id="21-软件的维护与演化"><a href="#21-软件的维护与演化" class="headerlink" title="21. 软件的维护与演化"></a>21. 软件的维护与演化</h2><ul><li>概念<ul><li>软件维护只需要完成少量的使用帮助、故障解决和磨损处理等工作</li><li>修改软件的代价非常高，软件维护的重点在于软件修改和变更上。</li><li>软件变更的常见场景<ul><li>问题发生了改变</li><li>环境发生了改变</li><li>软件产品中存在缺陷</li></ul></li></ul></li><li>软件维护类型划分<ul><li>完善性维护：为了满足用户新的需求、增加软件功能而进行的软件修改活动。</li><li>适应性维护：为了使软件能适应新的环境而进行的软件修改活动。</li><li>修正性维护：为了排除软件产品中遗留缺陷而进行的软件修改活动。</li><li>预防性维护：为了让软件产品在将来可维护，提升可维护性的软件修改活动。<ol><li>随着持续的修改，软件的复杂度会上升，质量会下降。预防性修改是为了解决上述问题而进行的软件调整，是一种特殊类型的”修改”</li><li>只有这一种维护是根源于软件维护中的规律性。</li></ol></li></ul></li><li>前期(开发阶段)更充分的准备可以减轻后期维护的压力和困难<ul><li>考虑软件的可变更性：预测变更并将其独立封装，便于修改时的程序定义与理解，防止修改时的连锁反应</li><li>为降低维护困难而开发<ul><li>编写详细的技术文档并保持及时更新。</li><li>保证代码的可读性。</li><li>维护需求跟踪链。<ol><li>需求跟踪链从正反两个方向纪录”需求、设计、编码、测试”之间的跟踪与回溯关系</li></ol></li><li>维护回归测试基线。<ol><li>回归测试基线包含了系统修改之前的有效测试用例集合， 因此只需要根据修改情况对回归测试基线进行简单的修正</li></ol></li></ul></li></ul></li><li>软件维护过程<ul><li><img src="2.png" style="zoom:67%;" /></li></ul></li><li>软件演化生命周期<ul><li><img src="4-1746704106380.png" style="zoom: 67%;" /></li><li>初始开发<ul><li>初始开发阶段按照传统的软件开发方式完成第一个版本的软件产品开发。第一版的软件产品可以实现全部需求，也可以(通常是)只包含部分需求——对用户来说非常重要和紧急的最高优先级需求。</li><li>初始阶段的一个极其重要的工作是建立一个好的软件体系结构</li></ul></li><li>演化<ul><li>在完成初始开发之后，软件产品就进入演化阶段。该阶段可能会有预先安排的需求增量，也可能完全是对变更请求的处理，它们的共同点都是保持软件产品的持续增值，让软件产品能够满足用户越来越多的需要，实现更大的业务价值</li><li>演化阶段的软件产品要具备两个特征：<ol><li>软件产品具有<strong>较好的可演化性</strong>。一个软件产品在演化过程中复杂性会逐渐增高，可演化性会逐渐降低直至无法继续演化。</li><li>软件产品能够帮助用户实现较好的<strong>业务价值</strong>。只有这样，用户才会继续需要该产品，并持续提供资金支持。</li></ol></li><li>如果在演化过程中，一个软件产品开始不满足第(2)条特征，那么该产品就会提前进入停止阶段。如果软件产品满足第(2)条的同时不满足第(1)条特征，那么该产品就会进入服务阶段。</li></ul></li><li>服务<ul><li>服务阶段的软件产品不再持续的增加自己的价值，而只是周期性的修正已有的缺陷。</li></ul></li></ul></li><li>软件维护与演化的技术<ul><li>遗留软件<ul><li>如果遗留软件已经没有使用价值，就直接丢弃该软件。</li><li>如果遗留软件还有使用价值，但是其维护的成本效益比低于新开发一个软件系统的成本效益比，那么冻结遗留软件，将其作为一个新的更大系统的组成部分进行使用。</li><li>如果遗留软件的成本效益比低于新开发一个软件系统的成本效益比，而且该遗留软件仍然具备较好的可维护性，那么就逆向工程遗留软件并继续维护一段时间；</li><li>如果遗留软件的成本效益比高于新开发一个软件系统的成本效益比，而且该遗留软件已经不具备可维护性，那么就修改系统使其获得新生(即再工程该系统)，然后继续维护再造后的系统。</li></ul></li><li>逆向工程<ul><li>处理遗留软件时，维护人员接受的维护对象可能是一个没有任何文档也没有程序源代码的软件程序，此时，维护人员需要使用逆向工程技术</li><li>逆向工程技术是指：”分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程</li><li>逆向工程的基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li></ul></li><li>再工程<ul><li>再工程的目的是对遗留软件系统进行分析和重新开发，以便进一步利用新技术来改善系统或促进现存系统的再利用。</li><li><img src="7-1746704109456.png" style="zoom: 50%;" /></li><li>常见的具体活动有<ol><li>重新文档化</li><li>重组系统的结构</li><li>将系统转换为更新的编程语言</li><li>修改数据的结构组织。</li></ol></li></ul></li></ul></li></ul><h2 id="22-软件开发过程模型"><a href="#22-软件开发过程模型" class="headerlink" title="22. 软件开发过程模型"></a>22. 软件开发过程模型</h2><ul><li>概念<ul><li>软件过程模型在生命周期模型的基础则进一步详细说明各个阶段的任务、活动、对象及其组织、控制过程</li><li>与简略的软件生命周期模型不同，软件过程模型可以被看作是网络化的活动组织</li><li>不同的生命周期模型有不同的软件过程模型：阶段划分不一样</li><li>同一个生命周期模型也会有多个不同的软件过程模型</li></ul></li><li>构建-修复模型<ul><li><img src="image-20240613123828381.png" alt="image-20240613123828381" style="zoom: 67%;" /></li><li>缺点<ul><li>在这种模型中，没有对开发工作进行规范和组织，所以随着软件系统的<strong>复杂度提升</strong>，开发活动会超出个人的直接控制能力，构建-修复模型就会导致开发活动无法有效进行而失败；</li><li>没有分析<strong>需求的真实性</strong>，给软件开发带来很大的风险；</li><li>没有考虑<strong>软件结构的质量</strong>，使得软件结构在不断的修改中变得质量越来越糟，直至无法修改；</li><li>没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难。</li></ul></li><li>适用范围<ul><li>软件规模很小，只需要几百行程序，其开发复杂度是个人能力能够胜任的；</li><li>软件对质量的要求不高，即使出错也无所谓；</li><li>只关注开发活动，对后期维护的要求不高，甚至不需要进行维护</li></ul></li></ul></li><li>瀑布模型<ul><li><img src="image-20240613123952041.png" alt="image-20240613123952041" style="zoom: 50%;" /></li><li>优点：为软件开发活动定义了清晰的阶段划分(包括输入&#x2F;输出、主要工作及其关注点)，这让开发者能够以关注点分离的方式更好地进行那些复杂度超越个人能力的软件项目的开发活动</li><li>缺点<ul><li>对文档的过高期望具有局限性。<ul><li>一方面会耗费很大的工作量和成本</li><li>另一方面很难为经常变化的需求建立完备可靠的文档。</li></ul></li><li>对开发活动的线性顺序假设具有局限性。<ol><li>要求一个阶段的工作经过验证后才能进入后续阶段是不切实际的。在实际开发中，常常需要进行一定的后续工作才能验证当前的工作是否正确、可靠。</li></ol></li><li>客户、用户参与具有局限性。<ol><li>成功的项目开发需要客户、用户从始至终的参与，而不仅仅是一个阶段。</li></ol></li><li>里程碑粒度具有局限性：里程碑粒度过粗，基本丧失了”早发现缺陷早修复”这一思想</li></ul></li><li>适用范围<ul><li>需求非常成熟、稳定，没有不确定的内容，也不会发生变化；</li><li>所需的技术成熟、可靠，没有不确定的技术难点，也没有开发人员不熟悉的技术问题；</li><li>复杂度适中，不至于产生太大的文档负担和过粗的里程碑。</li></ul></li></ul></li><li>增量迭代模型<ul><li><img src="image-20240613125033159.png" alt="image-20240613125033159"></li><li>优点<ul><li>迭代式开发更加符合软件开发的实践情况，具有更好的适用性；</li><li>并行开发可以帮助缩短软件产品的开发时间；</li><li>渐进交付可以加强用户反馈，降低开发风险。</li></ul></li><li>缺点<ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。</li><li>增量交付模型需要<strong>一个完备、清晰的项目前景和范围</strong>以进行并发开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围。</li></ul></li><li>适用范围：因为能够很好地适用于大规模软件系统开发，所以增量迭代模型在实践中有着广泛的应用，尤其是比较成熟和稳定的领域。</li></ul></li><li>演化模型<ul><li><img src="image-20240613125157881.png" alt="image-20240613125157881"></li><li>优点<ul><li><strong>使用了迭代式开发，具有更好的适用性</strong>，尤其是其演化式迭代安排能够适用于那些需求变更比较频繁或不确定性较多的软件系统的开发；</li><li>并行开发可以帮助<strong>缩短</strong>软件产品的开发时间；</li><li>渐进交付可以<strong>加强用户反馈</strong>，降低开发风险。</li></ul></li><li>缺点<ul><li>无法在项目早期阶段建立项目范围，所以项目的整体计划、进度调度、尤其是商务协商事宜无法准确把握；</li><li>后续迭代的开发活动是在前导迭代基础上进行修改和扩展的，这容易让后续迭代忽略设分析与设计工作，蜕变为构建-修复方式。</li><li>容易退化为构建修复方式</li></ul></li><li>适用范围：在实践中，<strong>不稳定领域的大规模软件系统</strong>开发适合使用<strong>演化模型</strong>进行组织。</li></ul></li><li>原型模型<ul><li><img src="image-20240613125236672.png" alt="image-20240613125236672"></li><li>抛弃式原型<ol><li>它通过模拟”未来”的产品，将”未来”的知识置于”现在” 进行推敲，解决不确定性。</li><li>存在的原因是”不确定的”，这一类原型在后续的开发过程中会被抛弃</li></ol></li><li>演化式原型<ol><li>在迭代中构建，是系统的核心，并不断扩充，最终成为真正的软件产品。</li><li>它将作为真正产品的一部分，所以必须有很好的质量。在迭代式开发中，通常会在第一个迭代中构建一个核心的体系结构演化式原型，并且在后续迭代中不断扩充，成为真正的软件产品。</li></ol></li><li>优点<ul><li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度；</li><li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性。</li></ul></li><li>缺点<ul><li>原型方法能够解决风险，但是自身也能带来新的风险，例如原型开发的成本较高，可能会耗尽项目的费用和时间；</li><li>实践中，很多项目负责人不舍得抛弃”抛弃式原型”，使得质量较差的代码进入了最终产品，导致了最终产品的低质量。</li></ul></li></ul></li><li>螺旋模型<ul><li><img src="image-20240613125349691.png" alt="image-20240613125349691"></li><li>原型模型 vs 螺旋模型<ol><li>原型模型：使用原型解决需求的不确定性</li><li>螺旋模型：实用原型解决项目开发中常见的各种类型的技术风险，包括系统需求开发、软件需求开发、软件体系结构设计、详细设计等各个阶段</li></ol></li><li>自内向外，螺旋模型有4次风险解决迭代，分别解决了几个高风险的阶段的问题<ol><li>解决系统需求开发中的风险，尤其是产品概念设计风险，得到一个确定的产品前景和范围。</li><li>解决软件需求开发中的风险，得到清晰的软件需求</li><li>解决软件体系结构设计中的技术风险，构建高质量的核心体系结构原型。</li><li>解决详细设计和实现中的关键技术风险，建立一个可实现的高质量软件结构。</li></ol></li><li>优点：可以降低风险，减少项目因风险造成的损失</li><li>缺点<ul><li>风险解决需要使用原型手段，也就会存在原型自身带来的风险，这一点与原型模型相同；</li><li>模型过于复杂，不利于管理者依据其组织软件开发活动；</li></ul></li><li>适用性：在实践中，螺旋模型在高风险的大规模软件系统开发中有着较多的应用。</li></ul></li><li>Rational 统一过程<ul><li>总结和借鉴传统上的各种有效经验，建立最佳实践方法的集合，并提供有效的过程定制手段，允许开发者根据特定的需要定制一个有效的过程模型。</li><li><img src="11-1746704120722.png" style="zoom:67%;" /></li><li>RUP裁剪：确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。</li><li>核心思想<ul><li>迭代式开发，这是过去被反复证明的最佳实践方法；</li><li>管理需求，重视需求工程中除了需求开发之外的需求管理活动；</li><li>使用基于组件的体系结构，它帮助建立一个可维护、易开发、易复用的软件体系结构；</li><li>可视化建模，利用UML进行建模；</li><li>验证软件质量，尽早和持续地开展验证，以尽早发现缺陷，降低风险和成本；</li><li>控制软件变更，适应1990s以后需求变更越来越重要的事实</li></ul></li><li>适用性：RUP是重量级过程，能够胜任大型软件团队开发大型项目时的活动组织。但RUP经过裁剪和定制，也可以变为轻量级过程，也能够胜任小团队的开发活动组织。</li></ul></li><li>敏捷过程：略</li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程与计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2024/01/19/COA/"/>
    <url>/2024/01/19/COA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理整理"><a href="#计算机组成原理整理" class="headerlink" title="计算机组成原理整理"></a>计算机组成原理整理</h1><h2 id="第一讲：计算机概述"><a href="#第一讲：计算机概述" class="headerlink" title="第一讲：计算机概述"></a>第一讲：计算机概述</h2><ul><li>冯诺依曼结构<ul><li>计算机由运算器、存储器、控制器、输入设备、输出设备组成<ul><li>主存储器：地址和存储的内容</li><li>算术逻辑单元 &#x2F; 处理单元：执行信息的实际处理</li><li>程序控制单元 &#x2F; 控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li><li>指令和数据以同等地位存放在存储器内，并可按地址访问</li><li>指令和数据均用二进制表示</li></ul></li><li>计算机性能标准<ul><li>CPU ：速度</li><li>存储器：速度，容量</li><li>I&#x2F;O ：速度，容量</li></ul></li></ul><span id="more"></span><ul><li>CPU性能<ul><li>时钟频率 &#x2F; 时钟速度（单位：Hz） ：计算机在单位时间内执行最基本操作的次数</li><li>时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间</li><li>CPI：执行程序时平均每条指令所需的时钟周期数</li><li><img src="image-20231205151251333.png" alt="image-20231205151251333"></li></ul></li><li>字长<ul><li>机器字长：计算机能直接处理的二进制数据的位数。机器字长通常与主存单元的位数一致。计算机中运算器进行算术运算和逻辑运算，机器字长也就是进行定点数运算的字长，通常也是CPU内部数据通路的宽度。</li><li>指令字长：一个指令字中包含二进制代码的总位数。指令字长取决于操作码的长度、操作码地址的长度和操作码地址的个数。</li><li>存储字长：一个存储单元存储二进制代码的位数。</li></ul></li></ul><h2 id="第三讲：数据的机器级表示"><a href="#第三讲：数据的机器级表示" class="headerlink" title="第三讲：数据的机器级表示"></a>第三讲：数据的机器级表示</h2><ul><li>原码、反码、补码<ul><li>无符号整数只有原码</li><li>正数三码合一</li><li>负数补码 &#x3D; 绝对值原码取反 + 1</li></ul></li><li>浮点数的二进制表示<ul><li>S： 1位标志，表示正负</li><li>E： 8位阶码（指数），无符号整数<ul><li>计算指数要减偏移量127</li></ul></li><li>B： 23位尾数</li><li>规格化数：2^-126 <strong>~</strong> (2 - 2 ^ -23) * 2^128，隐藏位为1</li><li>非规划数：阶码全0，尾数不全为0，2^-149 ~ 2^-126</li></ul></li></ul><p><img src="image-20231205154100699.png" alt="image-20231205154100699.png"></p><p><img src="image-20231205154159726.png" alt="image-20231205154159726.png"></p><ul><li>十进制数的BCD码<ul><li>符号（4位）：正数1100，负数1101</li><li>后面每四位表示十进制数的一位</li></ul></li></ul><h2 id="第四讲：数据校验码"><a href="#第四讲：数据校验码" class="headerlink" title="第四讲：数据校验码"></a>第四讲：数据校验码</h2><blockquote><p>本课程不考虑两位及以上出错</p></blockquote><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul><li>在数据结尾增加一位表示数据中1的数量是奇数还是偶数</li><li>数据输入<ul><li>奇校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1⊕1（偶数个1校验码为1）</li><li>偶校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1（奇数个1校验码为1）</li></ul></li><li>数据输出<ul><li>奇校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1⊕1</li><li>偶校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1</li></ul></li><li>检错： S&#x3D;𝐶′′⊕𝐶′<ul><li>若S ≠ 1：出错，数量为奇数</li><li>若S &#x3D; 0：正确</li></ul></li></ul><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><ul><li><p>将数据分成几组 对每一组都使用奇偶校验码进行检错</p></li><li><p>过程：</p><ul><li><p>将M位数据分为K组</p><ul><li><p>2^K &gt;&#x3D; M + K + 1</p></li><li><p>数据错：M；校验码错：K；无错：1</p></li><li><p>分组方法：</p><p><img src="image-20231205160431994.png" alt="image-20231205160431994.png"></p><ol><li>插入位置：原数据2的指数倍（1，2，4，8……）</li><li>校验码Ci等于所有对应故障字号低i位为1的数据位异或（例：C2 &#x3D; D1 ⊕ D3 ⊕ D4 ⊕ D6 ⊕ D7）</li></ol></li></ul></li><li><p>数据输入：为数据D中每组生成1位校验码，合并得到K位校验码C</p></li><li><p>数据输出：为数据 𝐷′中 每组生成1位校验码，合并得到新的 𝐾位校验码 𝐶′′</p></li><li><p>检错：将校验码 𝐶′′和取出的校验码 C’ 按位进行异或，生成𝐾位故障字</p><ul><li>故障字含两个及以上1：对应数据位错</li><li>故障字含一个1：校验码错，忽略</li><li>故障字全0：正确</li></ul></li></ul></li></ul><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><ul><li><p>适用于以流格式存储和传输大量数据</p></li><li><p>假设数据有M位，左移数据<strong>K</strong>位（右侧补0），并用<strong>K+1</strong>位生成多项式除它（模2运算）</p></li><li><p>K位余数为校验码，若无余数则正确</p><p><img src="image-20231205162055616.png" alt="image-20231205162055616.png"></p></li></ul><h2 id="第五讲：整数运算"><a href="#第五讲：整数运算" class="headerlink" title="第五讲：整数运算"></a>第五讲：整数运算</h2><h3 id="加法（减法）"><a href="#加法（减法）" class="headerlink" title="加法（减法）"></a>加法（减法）</h3><ul><li><p>串行进位加法器</p><p><img src="image-20231205162812144.png" alt="image-20231205162812144.png"></p><ul><li><p>延迟：</p><ul><li>Cn: 2n ty</li><li>Sn:（2n + 1）ty</li></ul></li></ul></li><li><p>全先行进位加法器（CLA）：比串行快，缺点为复杂</p></li><li><p>部分先行进位加法器：取多个CLA串联，取得平衡</p></li><li><p>减法：将C0置为1</p></li><li><p>加法溢出判断</p><ul><li>𝑋𝑛&#x3D;𝑌𝑛且𝑆𝑛≠𝑋𝑛,𝑌𝑛: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D; [𝑋𝑛 &amp; 𝑌𝑛 &amp; ( ~ 𝑆𝑛 ) ] | [ (~ 𝑋𝑛 ) &amp; ( ~ 𝑌𝑛 ) &amp; 𝑆𝑛 ]</li><li>𝐶𝑛≠𝐶𝑛−1: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D;𝐶𝑛⊕𝐶𝑛−1</li><li>减法同理</li></ul></li></ul><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>计算机乘法与手算不同：</p><p><img src="image-20231205165157005.png" alt="image-20231205165157005.png"></p><ul><li>每步都计算部分积求和结果</li><li>右移部分积，而不是左移</li><li>若Yi（当前乘的位）为0，直接移位</li></ul></li><li><p>布斯算法</p><p><img src="image-20231205165944658.png" alt="image-20231205165944658.png"></p><ul><li>增加Y0 &#x3D; 0</li><li>根据Yi - Yi+1 决定是否增加 X , -X , +0</li><li>右移部分积（移前第一位为0前面补0，反之补1）</li><li>重复上两步n次</li></ul></li></ul><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul><li><p>判断是否够减</p><p><img src="image-20231205203705216.png" alt="image-20231205203705216.png"></p></li><li><p>恢复余数除法过程</p><ul><li><p>通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄存器中</p></li><li><p>将余数和商左移，判断是否够减</p><ul><li>如果“够”，则做减法（同号）或者加法（异号），并上商为1</li><li>如果“不够”，则上商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>如果除数和被除数不同号，则将商替换为其相反数</p><p><img src="image-20231205204154289.png" alt="image-20231205204154289.png"></p></li></ul></li><li><p>不恢复余数除法过程</p><ul><li><p>思路：如果余数 𝑅𝑖足够大，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；如果余数 𝑅𝑖不够大，𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌−𝑌&#x3D;2𝑅𝑖+𝑌</p></li><li><p>如果除数和被除数符号相同，则做减法；否则，做加法</p><ul><li>如果余数和除数符号相同，则商𝑄𝑛&#x3D;1；否则， 𝑄𝑛&#x3D;0</li></ul></li><li><p>如果余数和除数符号相同，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；否则， 𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌</p><ul><li>如果新的余数和除数符号相同，使商为 1 ；否则，使商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>将商左移一位，若商为负，商加1</p></li><li><p>若余数与被除数符号不同修正余数：</p><ul><li><p>若被除数和除数符号相同，最后余数加除数；否则，最后余数减除数</p><p><img src="image-20231205205029238.png" alt="image-20231205205029238.png"></p></li></ul></li></ul></li></ul><h2 id="第六讲：浮点数运算"><a href="#第六讲：浮点数运算" class="headerlink" title="第六讲：浮点数运算"></a>第六讲：浮点数运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><ul><li><p>步骤</p><ul><li>检查是否为0</li><li>对齐</li><li>加减操作</li><li>规格化</li></ul><p><img src="image-20231206162424022.png" alt="image-20231206162424022.png"></p></li><li><p>加法</p><ul><li>若最高位有进位，则<strong>溢出</strong></li><li>符号与被加数相同</li></ul></li><li><p>减法</p><ul><li>若最高位有进位，正确（符号与被减数相同）</li><li>若最高位无进位，须计算结果补码（符号与被减数不同）</li></ul></li><li><p>对阶</p><ul><li>先计算ΔE &#x3D; Ex - Ey（均为补码）</li><li>若ΔE &lt; 0则Ex小，反之Ey小</li><li>对小的那个进行右移操作，右移过程中移出的位需保留用于尾数运算</li></ul></li><li><p>尾数加减</p><ul><li>隐藏位需加入运算</li></ul></li><li><p>规格化</p><ul><li>结果一：1.bb……b + 1.bb……b &#x3D; ±1b.bb……b<ul><li>右规：尾数右移一位；阶码加一</li><li>若阶码为127，加一后发生上溢</li><li>最后一位移出要考虑<strong>舍入</strong></li></ul></li><li>结果二：1.bb……b - 1.bb……b &#x3D; ±0.00…01b…b<ul><li>左规：尾数不断左移，阶码减一，直到最前面的1移到小数点前</li><li>若此过程中阶码小于0，发生下溢</li></ul></li></ul></li><li><p>舍入处理</p><ul><li>就近舍入：结果被舍入成最近的可表示的数</li><li>朝+∞舍入：结果朝正无穷大方向向上舍入</li><li>朝-∞舍入：结果朝负无穷大方向向下舍入</li><li>朝 0 舍入：结果朝 0 舍入</li></ul></li><li><p>溢出判断</p><ul><li>上溢：右规</li><li>下溢：左规</li></ul></li></ul><h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>过程</p><ul><li>尾数相乘，指数相加</li><li>尾数规格化</li><li>舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相乘，指数相加</p><ul><li>计算时将隐藏位1还原</li><li>乘积符号位为操作数符号位异或结果</li><li>指数：e &#x3D; e1 + e2 - 127</li></ul></li><li><p>尾数规格化</p><ul><li>尾数小数点前有三种：10、11、01（不用规格化）</li><li>10&#x2F;11:右规，位数右移一位，阶码加一</li><li>右规需要考虑溢出（与加法相同）</li></ul></li><li><p>尾数舍入</p><ul><li>对右规后的2n - 2位进行舍入</li><li>规则与加法一样</li></ul></li><li><p>溢出判断</p><ul><li>指数相加：上溢&#x2F;下溢</li><li>舍入：上溢</li><li>右规：上溢</li></ul></li></ul><h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ul><li><p>过程</p><ul><li>尾数相除，阶相减</li><li>尾数规格化</li><li>尾数舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相除，阶相减</p><ul><li>符号位为原操作数异或结果</li><li>阶码e &#x3D; e1 - e2 + 127</li><li>尾数还原隐藏位1后作为无符号整数相除</li></ul></li><li><p>尾数规格化</p><ul><li>结果范围：0.5~2</li><li>若第一位为0，小数点右边第一位必为1</li><li>若第一位为0，进行左规，尾数左移一位，阶码减一</li><li>左移时判断下溢</li></ul></li><li><p>尾数舍入</p><ul><li>与加减相同</li></ul></li><li><p>溢出判断</p><ul><li>左规：下溢</li><li>舍入：上溢</li><li>指数相减：上溢&#x2F;下溢</li></ul></li></ul><h2 id="第八讲：内部存储器"><a href="#第八讲：内部存储器" class="headerlink" title="第八讲：内部存储器"></a>第八讲：内部存储器</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li>地址：单元唯一标识符</li><li>地址空间：可标识单元总数</li><li>寻址能力：存储在每个单元中信息位数</li><li>位元：半导体存储器的基本元件，用于存储1位数据</li></ul><h3 id="RAM（随机存取存储器）"><a href="#RAM（随机存取存储器）" class="headerlink" title="RAM（随机存取存储器）"></a>RAM（随机存取存储器）</h3><ul><li>特点<ul><li>可快速进行读写操作</li><li>易失</li></ul></li><li>DRAM<ul><li>在电容器上用电容充电的方式存储数据</li><li>需要周期地充电刷新以维护数据存储</li></ul></li><li>SRAM<ul><li>使用传统触发器、逻辑门配置来存储二进制值</li><li>有电源就能一直保持</li></ul></li><li>两者对比<ul><li>DRAM比SRAM具有更简单、更小的位元，但要求能支持刷新的电路</li><li>DRAM比相应的SRAM密度更高，价格更低</li><li>SRAM通常比DRAM快</li><li>DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高速缓存（Cache），DRAM用于主存</li></ul></li><li>SDRAM<ul><li>传统DRAM与处理器异步，及CPU需要等待DRAM内部存取数据操作</li><li>SDRAM与处理器同步时钟信号</li></ul></li><li>DDR SDRAM<ul><li>每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在<br>下降沿</li></ul></li></ul><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><ul><li>特点<ul><li>非易失</li><li>只读，一般不能写入</li><li>随机存取（与RAM相同）</li></ul></li><li>PROM（可编程ROM）<ul><li>非易失</li><li>只能写入一次</li><li>通过电信号写入</li></ul></li></ul><h3 id="主要进行读操作的存储器"><a href="#主要进行读操作的存储器" class="headerlink" title="主要进行读操作的存储器"></a>主要进行读操作的存储器</h3><ul><li>EPROM<ul><li>光擦除：在写操作前将封装芯片暴露在紫外线下，需要20分钟</li><li>电写入</li><li>比PROM贵</li></ul></li><li>EEPROM（电可擦除可编程“只读”存储器）<ul><li>可以随时写入而不删除之前的内容</li><li>只更新寻址到的一个或多个字节</li><li>写操作每字节需要几百微秒</li><li>比EPROM更贵，且密度低，支持小容量芯片</li></ul></li><li>Flash Memory（快闪存储器）<ul><li>电可擦除：与EEPROM相同，优于EPROM</li><li>擦除时间为几秒：优于EPROM，不如EEPROM</li><li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM</li><li>达到与EPROM相同的密度：优于EEPROM</li><li>价格介于EPROM和EEPROM之间</li></ul></li></ul><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul><li><p>寻址单元（Addressable unit）：由若干相同地址的位元组成（一个存储单元）</p></li><li><p>寻址模式</p><ul><li>字节（常用）Byte</li><li>字Word</li></ul></li><li><p>存储阵列（Memory Array）：由大量寻址单元组成</p></li><li><p>地址译码器</p><p><img src="image-20231208194708017.png" alt="image-20231208194708017.png"></p><ul><li>一个n位译码器有2^n种输出</li><li>当所有n个寻址位都满足条件时，该输出为1</li><li>任何时候，只有一个输出是1其他的都是0</li></ul></li></ul><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul><li>集中式刷新：停止读写，刷新所有行，刷新过程中不能读写<ul><li>芯片刷新按每块芯片每行刷新：先算每块芯片是多少乘多少，得到有多少行，即为刷新次数</li></ul></li><li>分散式刷新：在每个存储周期中，当读写操作完成时进行刷新</li><li>异步刷新：每一行各自以64 ms间隔刷新</li></ul><h3 id="从位元到主存的架构"><a href="#从位元到主存的架构" class="headerlink" title="从位元到主存的架构"></a>从位元到主存的架构</h3><ul><li><img src="image-20231208195217394.png" alt="image-20231208195217394.png"></li><li>位扩展：地址线不变，数据线增加：使用8块 4K * 1bit的芯片组成 4K * 8bit的存储器</li><li>字扩展：地址线增加，数据线不变：使用4个16K * 8bit 的芯片组成64K * 8bit的存储器</li><li>字、位同时扩展：地址线增加，数据线增加：使用8个16K * 4bit 的芯片组成64K * 8bit的存储器</li><li>位元-&gt;寻址单元-&gt;存储阵列-&gt;芯片-&gt;模块组织-&gt;主存</li><li>DRAM与SRAM地址线与数据线计算<ul><li>SRAM : log2存储单元数量</li><li>DRAM : log2存储单元数量 &#x2F; 2（使用了地址复用技术）</li><li>数据线：该芯片一个存储单元有几位就几根</li></ul></li></ul><h2 id="第九讲：Cache"><a href="#第九讲：Cache" class="headerlink" title="第九讲：Cache"></a>第九讲：Cache</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li><p>检查：检查该字是否在Cache中</p><ul><li>命中：如果在cache中，则把这个字传送给 CPU</li><li>未命中：如果不在cache中 , 则将主存中包含这个字固定大小的块读入cache中，然后再从cache传送该字 给CPU</li></ul></li><li><p>判断是否命中</p><ul><li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li></ul></li><li><p>程序访问的局部性原理</p><ul><li>时间局部性 ：在相对较短的时间周期内重复访问特定的信息，也就是访问相同位置的信息</li><li>空间局部性 ：在相对较短的时间周期内访问相邻存储位置的数据</li></ul></li><li><p>平均访问时间</p><ul><li>注意点：即使未命中也需存取Cache</li></ul><p><img src="image-20231209093818319.png" alt="image-20231209093818319.png"></p><p><img src="image-20231231100740150.png" alt="image-20231231100740150.png"></p></li></ul><h3 id="Cache的设计"><a href="#Cache的设计" class="headerlink" title="Cache的设计"></a>Cache的设计</h3><ul><li>Cache行的构成<ul><li>标记 + 有效位 + (脏位) + 替换算法控制位 + 数据部分</li></ul></li><li>映射<ul><li>直接映射<ul><li>将主存中的每个块映射到一个固定可用的cache行中</li><li>假设i是cache行号，j是主存储器的块号，C是 cache 的行数，i &#x3D; j % C</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2𝐶位标记位，第二部分为𝑙𝑜𝑔2𝐶位Cache行号，第三部分为块内地址（位数由块大小决定）</li></ul></li><li>(全)关联映射<ul><li>一个块可以装入Cache内任意一行</li><li>主存地址分为标记和块内地址</li></ul></li><li>组关联映射<ul><li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行</li><li>组号 &#x3D; 块号 % 组数</li><li>K-路组关联：K &#x3D; Cache行数&#x2F;组数</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2S位标记位，第二部分为𝑙𝑜𝑔2S位Cache组号，第三部分为块内地址（位数由块大小决定）</li><li>如果 𝐾&#x3D;1，组关联映射等同于直接映射</li><li>如果 𝐾&#x3D;𝐶，组关联映射等同于关联映射</li></ul></li><li>关联度：一个主存块映射到cache中可能存放的位置个数<ul><li>直接映射：1</li><li>关联映射：C</li><li>组关联映射：K</li><li>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小</li></ul></li></ul></li><li>替换算法<ul><li>最近最少使用算法LRU<ul><li>策略：替换掉在cache中最长时间未被访问的数据块</li></ul></li><li>先进先出算法FIFO<ul><li>策略：替换掉在Cache中停留时间最长的块</li></ul></li><li>最不经常使用算法LFU<ul><li>策略：替换掉cache中被访问次数最少的数据块</li></ul></li><li>随机替换算法</li></ul></li><li>写策略<ul><li>写直达<ul><li>所有写操作都同时对cache和主存进行</li><li>确保主存中的数据总是和cache中的数据一致，总是最新的</li><li>产生大量的主存访问，减慢写操作</li></ul></li><li>写回法<ul><li>先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存</li><li>利用脏位</li><li>减少了访问主存的次数，但数据不一定最新</li></ul></li></ul></li><li>多级Cache<ul><li>当L1未命中时减少处理器对总线上DRAM或ROM的访问</li><li>使用单独的数据路径代替系统总线在L2缓存和处理器之间传输数据部分处理器将L2 cache结合到处理器芯片上</li></ul></li></ul><h2 id="第十讲：外部存储器"><a href="#第十讲：外部存储器" class="headerlink" title="第十讲：外部存储器"></a>第十讲：外部存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>特点<ul><li>非易失</li><li>用于存储不经常使用的、数据量较大的信息</li></ul></li><li>类型<ul><li>磁盘存储器</li><li>光存储器</li><li>磁带</li><li>U盘、固态硬盘</li></ul></li></ul><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><ul><li><p>磁盘是由涂有可磁化材料的非磁性材料 （基材）构成的圆形盘片</p></li><li><p>玻璃基材优势</p><p><img src="image-20231209100435594.png" alt="image-20231209100435594.png"></p></li><li><p>结构</p><p><img src="image-20231209100647883.png" alt="image-20231209100647883.png"></p><ul><li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动</li><li>在任何时候，所有磁头都位于距磁盘中心等距离的磁道上</li></ul></li><li><p>磁头：对盘片进行读写操作的装置</p><ul><li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li><li>磁头越窄，离盘片的距离就越近（飞行高度）</li><li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li><li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li><li>现代磁盘采用双磁头：读磁头和写磁头</li></ul></li><li><p>读写机制</p><ul><li>读：读取磁头是由一个部分屏蔽的磁阻MR敏感器组成其电阻取决于在其下移动的介质的磁化方向，通过电流后产生的电压指示其电阻</li><li>写：电流脉冲被发送到写入磁头，变化的电流激发出磁场，变化的电流激发出磁场</li></ul></li><li><p>数据组织结构</p><p><img src="image-20231209101418029.png" alt="image-20231209101418029.png"></p><ul><li>磁道：盘片上的数据组织呈现为一组同心圆环，称为磁道track</li><li>数据以扇区（sector）的形式传输到磁盘或从传出磁盘：扇区默认512B</li><li>相邻磁道之间有 间隙，相邻的扇区之间也留有间隙</li><li>所有盘片上处于相同的相对位置的一组磁道被称为柱面</li></ul></li><li><p>访问时间</p><ul><li><p>寻道时间：磁头定位到所需移动到的磁道所花费的时间</p></li><li><p>旋转延迟：等待响应扇区的起始处到达磁头所需的时间，<strong>通常为旋转半圈时间</strong></p></li><li><p>传送时间：数据传输所需的时间</p></li><li><p><img src="image-20231209101754880.png" alt="image-20231209101754880.png"></p><img src="计组整理.assets/image-20231209101819663.png" alt="image-20231209101819663" style="zoom:50%;" /><p><img src="image-20231209101819663.png" alt="image-20231209101819663.png"></p></li></ul></li><li><p>磁头寻道算法</p><ul><li>先来先服务FCFS<ul><li>按照请求访问磁盘的先后次序进行处理</li></ul></li><li>最短寻道时间优先SSTF<ul><li>优先处理起始位置与当前磁头位置最接近的读写任务</li></ul></li><li>扫描&#x2F;电梯（SCAN）<ul><li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li></ul></li><li>循环扫描C-SCAN<ul><li>只有磁头朝某方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，<strong>返回途中不做任何处理</strong></li></ul></li><li>LOOK<ul><li>SCAN 算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li></ul></li><li>C-LOOK<ul><li>C-SCAN 算法的升级，只要磁头移动方向上不再有请求，就立即让磁头返回起点</li></ul></li></ul></li></ul><h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><ul><li><p>分类</p><p><img src="image-20231209102434412.png" alt="image-20231209102434412.png"></p></li><li><p>CD和CD-ROM</p><ul><li>CD和CD-ROM采用类似的技术，但CD-ROM更加耐用且有纠错功能</li><li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD或CD-ROM处读取信息</li><li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同</li></ul></li><li><p>高清晰光盘</p><ul><li>通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li></ul></li></ul><h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><ul><li>介质是柔韧的聚酯薄膜带，外涂磁性材料</li><li>顺序读取</li></ul><h3 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h3><ul><li>U盘<ul><li>采用了快闪存储器，属于非易失性半导体存储器</li><li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li></ul></li><li>固态硬盘<ul><li>与 U 盘没有本质区别：容量更大，存储性能更好</li></ul></li></ul><h2 id="第十一讲：冗余磁盘阵列"><a href="#第十一讲：冗余磁盘阵列" class="headerlink" title="第十一讲：冗余磁盘阵列"></a>第十一讲：冗余磁盘阵列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>基本思想<ul><li>将多个独立操作的磁盘按某种方式组织成磁盘阵列 以增加容量</li><li>将数据存储在多个盘体上 通过这些盘并行工作来提高数据传输率</li><li>采用数据冗余来进行错误恢复以提高系统可靠性</li></ul></li><li><img src="image-20231214205505393.png" alt="image-20231214205505393.png"></li></ul><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p><img src="image-20231214205749592.png" alt="image-20231214205749592.png"></p><ul><li>数据以条带的形式在可用的磁盘上分布</li><li>不采用冗余来改善性能（不是 RAID 家族中的真正成员）</li><li>用途：1.高数据传输率 2.高速响应I&#x2F;O请求</li></ul><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p><img src="image-20231214210100316.png" alt="image-20231214210100316.png"></p><ul><li>采用了数据条带</li><li>采用简单地备份所有数据的方法来实现冗余</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li><li>两组硬盘都可以读取，读速度快</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li></ul><h3 id="RAID-2-3"><a href="#RAID-2-3" class="headerlink" title="RAID 2 &amp; 3"></a>RAID 2 &amp; 3</h3><ul><li><p>RAID 2</p><p><img src="image-20231214210342894.png" alt="image-20231214210342894.png"></p><ul><li>采用并行存取技术</li><li>采用<strong>非常小</strong>的数据条带</li><li>所有磁盘都参与每个I&#x2F;O请求的执行</li><li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li><li>对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li></ul></li><li><p>RAID 3</p><p><img src="image-20231214210503149.png" alt="image-20231214210503149.png"></p><ul><li>与RAID 2 不同点：对所有数据盘上同一位置的数据计算奇偶校验码</li></ul></li></ul><h3 id="RAID-4-5"><a href="#RAID-4-5" class="headerlink" title="RAID 4 &amp; 5"></a>RAID 4 &amp; 5</h3><ul><li><p>RAID 4</p><p><img src="image-20231214220218541.png" alt="image-20231214220218541.png"></p><ul><li>采用独立存取技术：每个磁盘成员的操作是独立的，各个I&#x2F;O请求能够并行处理</li><li>采用相对较大的数据条带</li><li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li><li>每次写操作都需要修改校验位，I&#x2F;O请求较大时有优势（可用新数据计算）</li></ul></li><li><p>RAID 5</p><p><img src="image-20231214220451002.png" alt="image-20231214220451002.png"></p><ul><li>与RAID 4组织方式相似</li><li>在所有磁盘上都分布了奇偶校验条带</li></ul></li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><img src="image-20231214220620920.png" alt="image-20231214220620920.png"></p><ul><li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li><li>提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才会造成数据丢失</li><li>写损失：每次写都要影响两个校验块</li></ul><h2 id="第十二讲：虚拟存储器"><a href="#第十二讲：虚拟存储器" class="headerlink" title="第十二讲：虚拟存储器"></a>第十二讲：虚拟存储器</h2><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul><li>分区<ul><li>分区方式将主存分为两大区域</li><li>系统区：固定的地址范围内，存放操作系统</li><li>用户区：存放所有用户程序</li><li>简单固定分区：用户区划分成长度不等的固定长的分区，当一个任务调入主存时，分配一个可用的、能容纳它的最小的分区</li><li>可变长分区：用户区按每个任务所需要的内存大小进行分配，会导致碎片化</li></ul></li><li>分页<ul><li>把主存分成固定长且比较小的存储块，称为页框；每个任务也被划分成固定长的程序块，称为页</li><li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li><li>逻辑地址：指令中的地址</li><li>物理地址：实际主存地址</li></ul></li></ul><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul><li><p>基本思想</p><ul><li>仅将当前需要的的页面调入主存</li><li>通过硬件将逻辑地址转换为物理地址</li><li>未命中时在主存和硬盘之间交换信息</li></ul></li><li><p>分页式虚拟存储器</p><p><img src="image-20231224164127892.png" alt="image-20231224164127892.png"></p><ul><li>主存储器和虚拟地址空间都被划分为大小相等的页面</li><li>页表：页表中包含了所有虚拟页的信息,包括虚拟页的存放位置 、装入位valid、修改位dirty、存取权限位、<strong>物理地址</strong>等等，存储在主存中</li><li>地址 &#x3D; 页号 + 页内偏移量</li><li>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li></ul></li><li><p>快表</p><ul><li>页表的使用增加了主存的访问次数，为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li><li>主存中的页表相应地称之为“慢表”</li></ul></li><li><p>CPU访存过程</p><ul><li><img src="image-20231224164538671.png" alt="image-20231224164538671.png"></li><li><img src="image-20231224165337226.png" alt="image-20231224165337226.png"></li><li><img src="image-20231224165513175.png" alt="image-20231224165513175.png"></li></ul></li><li><p>分段式虚拟存储器</p><ul><li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li><li>虚拟地址：段号 + 段内偏移量</li><li>与分页式虚拟存储器相比：分页式简单，但一个数据或一条指令可能会分跨在两个页面；分段式段的分界与程序的自然分界相对应，易于管理，但段大小不固定</li></ul></li><li><p>段页式虚拟存储器</p><ul><li>将程序和数据分段，段内再进行分页</li><li>每个段都有一个页表</li><li>虚拟地址 &#x3D; 段号 + 页号 + 页内偏移量</li></ul></li></ul><h2 id="第十三讲：指令系统"><a href="#第十三讲：指令系统" class="headerlink" title="第十三讲：指令系统"></a>第十三讲：指令系统</h2><h3 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h3><ul><li><p>指令要素</p><ul><li>操作码：指定将要完成的操作</li><li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li><li>结果操作数引用：操作可能会产生一个结果</li><li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li></ul></li><li><p>操作码</p><ul><li>指令类型：数据传送、算术运算、逻辑运算、转换、输入&#x2F;输出、系统控制、控制转移</li><li>数据传送：指明源和目标操作数的位置、将要传送数据的长度、寻址方式</li></ul></li><li><p>操作数</p><ul><li>大端法和小端法：大端为高位存在小地址，低位存在大地址，小端与之相反</li><li>寻址方式<ul><li>立即寻址：操作数实际出现在指令中</li><li>直接寻址：地址字段含有操作数的有效地址</li><li>间接寻址：地址字段指示一个存储器字地址 , 而此地址出保存有操作数的全长度地址</li><li>寄存器寻址：地址字段指示的是寄存器</li><li>寄存器间接寻址：地址字段指示的是寄存器，寄存器中存操作数地址</li><li>偏移寻址：EA &#x3D; (R) + A，即地址 &#x3D; 偏移量 + 地址，分为三种：相对寻址（R为PC）、基址寄存器寻址(R对应寄存器中为基址，A为偏移量)、变址寻址（A为某主存地址，R中为对于该地址正的偏移量）</li><li>栈寻址：方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li></ul></li></ul></li><li><p>指令设计原则</p><ul><li>指令尽量短</li><li>有足够的操作码位数：要为操作类型不断增加预留</li><li>操作码的编码必须有唯一的解释</li><li>指令长度是字节的整数倍</li><li>合理选择地址字段的个数</li><li>指令尽量规整：简化硬件的实现</li></ul></li><li><p>题型：计算指令系统需要多少位</p><p><img src="image-20240101163022494.png" alt="image-20240101163022494.png"></p><ul><li>先算地址多的，多出来没用的操作码n个给地址少的作为操作码前几位</li><li>地址少的用多出来的地址位k和n算出可用操作码数（2^k * n），与需要的操作码数量对比，如果足够就结束，不够就要增加一位</li><li>所有种类指令都验证完后将位数向上取整变成8的整数倍</li></ul></li></ul><h2 id="第十四讲：指令流水线"><a href="#第十四讲：指令流水线" class="headerlink" title="第十四讲：指令流水线"></a>第十四讲：指令流水线</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><p>指令周期 ：处理单个指令的过程</p><p><img src="image-20231224195348224.png" alt="image-20231224195348224.png"></p><p><img src="image-20231224195406263.png" alt="image-20231224195406263.png"></p></li><li><p>间址周期：把间接地址的读取看成是一个额外的指令子周期</p></li><li><p>CPU寄存器</p><ul><li>1个存储地址寄存器MAR</li><li>1个存储缓冲寄存器MBR&#x2F; 存储数据寄存器MDR</li><li>1个程序计数器PC</li><li>1个指令寄存器IR</li></ul></li><li><p>指令周期数据流</p><ul><li>取指周期<ul><li>控制器先发出控制信号告知存储器，PC使用地址总线传输待取指令地址，存储器得到地址</li><li>存储器将指令数据传入数据总线，存储缓冲寄存器MBR从数据线上得到指令，再传给IR</li><li>控制器告知PC取指完成，使PC中值对应 + 4</li></ul></li><li>间址周期<ul><li>MBR第一次取回的是地址，将它传入MAR再进行一次读取</li></ul></li><li>中断周期<ul><li>终端前要将所有寄存器状态存入存储器</li></ul></li></ul></li></ul><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ul><li><p>指令流水线 ：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成</p></li><li><p>六阶段方法：</p><p><img src="image-20231224200754205.png" alt="image-20231224200754205.png"></p><ul><li>取指令（ Fetch instruction FI ）：读下一条预期的指令到缓冲器</li><li>译码指令（ Decode instruction DI ）：确定操作码和操作数指定符</li><li>计算操作数（ Calculate operands CO ）：计算每个源操作数的有效地址</li><li>取操作数（ Fetch operands FO ）：从存储器取出每个操作数，寄存器中的操作数不需要取</li><li>执行指令（ Execute instruction EI ）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li><li>写操作数（ Write operand WO ）：将结果存入存储器</li><li>问题：不是所有指令都包含6个阶段；不是所有的阶段都能并行完成；若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</li><li>条件转移指令会使若干周期无效</li></ul></li><li><p><img src="image-20231224201109097.png" alt="image-20231224201109097.png"></p></li></ul><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ul><li>结构冒险<ul><li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源</li><li>解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源</li></ul></li><li>数据冒险<ul><li>原因：未生成指令所需要的数据</li><li>解决方案 1 ：插入 nop 指令</li><li>解决方案 2 ：插入 bubble</li><li>解决方案 3 ：转发 forwarding &#x2F; 旁路 bypassing：无需等待数据存入对应寄存器，而是将需要的其他指令执行结果直接传送到对应位置</li><li>解决方案 4 ：交换指令顺序</li></ul></li><li>控制冒险<ul><li>原因：指令的执行顺序被更改（转移、中断、异常、调用&#x2F;返回）</li><li>解决：取多条指令、分支预测</li></ul></li></ul><h2 id="第十五讲：控制器"><a href="#第十五讲：控制器" class="headerlink" title="第十五讲：控制器"></a>第十五讲：控制器</h2><h3 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h3><p><img src="image-20240101162745149.png" alt="image-20240101162745149.png"></p><ul><li>用户可见寄存器<ul><li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li><li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回</li><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：仅可用于保持数据而不能用于操作数地址的计算</li><li>地址寄存器：可以是自身有某些通用性，或是专用于某种具体的寻址方式</li><li>条件码寄存器&#x2F;标志寄存器：CPU硬件设置这些条件位作为操作的结果</li></ul></li><li>控制和状态寄存器<ul><li>由控制器来控制 CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li><li>大多数控制和状态寄存器在大多数机器上是用户不可见的</li><li>程序计数器PC（Program counter）：通常在每次取指令之后， PC 的内容即被CPU更改，因此总指向将被执行的下一条指令（用户可见）</li><li>指令寄存器IR（Instruction register）：存有最近取来的指令，在其中分析操作码和操作数</li><li>存储器地址寄存器MAR（Memory address register）：直接与地址总线相连，存有存储器位置的地址</li><li>存储器缓冲寄存器MBR（Memory buffer register）：直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR交换数据</li><li>ALU 可对MBR和用户可见寄存器直接存取</li></ul></li><li>程序状态字<ul><li>一个或一组包含状态信息的寄存器 包含条件码加上其他状态信息</li><li>符号、零、进位、等于、溢出、中断禁止&#x2F;允许、监管</li></ul></li></ul><h3 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h3><ul><li><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令，每个指令周期又可以看作是由几个更小的子周期组成（取指、间址、执行、中断），每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些步骤称为微操作</p></li><li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p><p><img src="image-20231225192443296.png" alt="image-20231225192443296.png"></p><ul><li>事件的流动顺序必须是恰当的</li><li>必须避免冲突</li><li>满足上述条件下 所用的时间单位尽可能少</li></ul></li><li><p>间址周期：如果指令采用间接寻址，则在指令执行前有一个间址周期</p><p><img src="image-20231225192951356.png" alt="image-20231225192951356.png"></p></li><li><p>执行周期：对于不同的操作码，会出现不同的微操作序列</p><img src="计组整理.assets/image-20231225193031697.png" alt="image-20231225193031697" style="zoom: 50%;" /><p><img src="image-20231225193031697.png" alt="image-20231225193031697.png"></p></li><li><p>中断周期：在完成执行周期时，要确定是否有允许的中断产生，如果有，则出现一个中断周期</p></li><li><p>指令周期代码：假设一个 2 位的ICC寄存器，明确 CPU 处于指令周期哪个阶段</p><p><img src="image-20231225193941116.png" alt="image-20231225193941116.png"></p><ul><li>00 ：取指</li><li>01 ：间址</li><li>10 ：执行</li><li>11 ：中断</li></ul></li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li><p>CPU内部总线</p><ul><li>ALU和寄存器都连接到CPU内部总线上</li><li>内部总线和寄存器之间有门和控制信号</li></ul></li><li><p>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</p></li><li><p>CPU需要完成的微操作：</p><ul><li>在寄存器之间传送数据</li><li>将数据由寄存器传送到外部接口（如系统总线）</li><li>将数据由外部接口传送到寄存器</li><li>将寄存器作为输入和输出，完成算术和逻辑运算</li></ul></li><li><p>控制器的两个基本任务：定序、执行</p></li><li><p>控制器的输入：</p><ul><li>指令寄存器：当前指令的寻址方式和操作码</li><li>标志：确定CPU的状态和前一个ALU操作的结果</li><li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li><li>来自控制总线的控制信号：向控制器提供控制信号（如中断请求）</li></ul></li><li><p>控制器的输出：CPU内的控制信号、到控制总线的控制信号</p></li><li><p>控制器实现</p><ul><li>硬布线实现：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，<br>即控制信号</li><li>微程序实现：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号</li></ul></li><li><p>硬布线实现</p><ul><li><p>硬布线控制器是将控制部件做成产生专门固定信号的逻辑电路，产生各种控制信号，因而又称为组合逻辑控制器。微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。</p></li><li><p>控制器输入：标志和控制总线信号、指令寄存器、时钟</p></li><li><p>控制器逻辑：为每个输出的控制信号设计一个关于控制器输入的布尔表达式</p></li></ul></li><li><p>微程序实现</p><ul><li><p>基本思路：</p><ul><li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li><li>构造一个<strong>控制字</strong>，每位代表一根控制线，这样每个微操作能用控制字中的不同的 0 和 1 的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li></ul></li><li><p>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址</p></li><li><p>任务：定序和执行</p><p><img src="image-20231225205024319.png" alt="image-20231225205024319.png"></p></li><li><p>微指令编码方式</p><ul><li><p>直接控制方式：在微指令的控制字段里对不同的微命令各自设置一个数位来表示发出与否（”0&#x2F;1”）</p></li><li><p>字段直接编译法：对控制字段进行划分，得到多个不同的字段，这些字段表示多个互斥的控制信号，这些微命令在同一时间只有其中的某一个微命令可以生效。</p><p><img src="image-20240101165541902.png" alt="image-20240101165541902.png"></p></li><li><p>字段间接编译法：同样是对控制字段进行划分，但是字段间接编译法在直接编译法以一个字段来表示一条微命令的基础上，辅以另一个字段来解释这个字段。这样的编译方法，可以使得指令的长度进一步减短，但微指令的并行控制能力被削弱了。</p><p><img src="image-20240101165705537.png" alt="image-20240101165705537.png"></p><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li><li><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li></ul></li><li><p>工作流程：</p><ul><li>为执行一条指令，定序逻辑发出一个读命令给控制存储器</li><li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li><li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息</li><li>定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存器中</li></ul></li></ul></li></ul><h2 id="第十六讲：总线"><a href="#第十六讲：总线" class="headerlink" title="第十六讲：总线"></a>第十六讲：总线</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>类型<ul><li>芯片内部总线：连接芯片内部的各个部分</li><li>系统总线：连接CPU、存储器、I&#x2F;O控制器和其他功能设备</li><li>通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</li></ul></li><li>总线结构<ul><li>数据线：在系统组件之间传输数据，数据线的数量决定了一次可以传输的数据的大小</li><li>地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向，地址线的数量决定了寻址空间的大小</li><li>控制线：控制对数据线和地址线的存取和使用</li></ul></li><li>特点<ul><li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</li><li>当总线在被使用过程中，其它设备不可以抢占</li></ul></li></ul><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ul><li><p>用途</p><ul><li>专用总线：始终只负责一项功能，或始终分配给特定的计算机组件</li><li>复用总线：将同一线路用于多种用途</li></ul></li><li><p>总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备</p><ul><li>集中式：由仲裁器或总线控制器负责分配总线使用权</li><li>分布式：每个设备都包含访问控制逻辑，各设备共同作用，分享总线</li></ul></li><li><p>链式查询</p><p><img src="image-20231227191653439.png" alt="image-20231227191653439.png"></p><ul><li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备</li><li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号</li><li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</li></ul></li><li><p>计数器查询</p><p><img src="image-20231227192026850.png" alt="image-20231227192026850.png"></p><ul><li>将总线允许线替换为设备ID线，如果总线空闲，总线仲裁器通过设备ID线发送计数</li><li>如果当前发送请求的设备ID等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为忙</li><li>通过使用不同的初始计数，可以灵活地确定设备优先级（强调优先级从1开始，强调公平性从上次使用总线的下一个设备的ID开始）</li></ul></li><li><p>独立请求</p><ul><li>每个设备都有自己的总线请求线和总线允许线，当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器，总线仲裁器决定哪个设备可以使用总线</li></ul></li><li><p>自举式</p><p><img src="image-20231227194000898.png" alt="image-20231227194000898.png"></p><ul><li>固定优先级，每个设备在其总线请求线上发送请求</li><li>每个设备自行判断自己是否在请求总线的设备中优先级最高</li></ul></li><li><p>时序</p><ul><li><p>确定每个总线事务的开始和结束时间</p></li><li><p>同步时序：事件的发生由时钟决定，所有设备共享同一个时钟</p></li><li><p>异步时序：一个事件的发生取决于前一个事件的发生</p></li><li><p><img src="image-20231227205709273.png" alt="image-20231227205709273.png"></p><p><img src="image-20231227201133777.png" alt="image-20231227201133777.png"></p></li><li><p>半同步时序：为了减少噪声的影响，在异步计时中使用时钟</p></li><li><p>分离事务：将一个总线事件分离为两个过程</p></li></ul></li><li><p>总线带宽（bus bandwidth）：总线的最大数据传输速率</p></li><li><p>数据传输速率：考虑地址传输、握手等因素</p><ul><li><p>同步总线时间：</p><ul><li>发送指令和地址到内存</li><li>内存准备数据时间（时钟周期整数倍，向上取整，例：时钟周期50 ns，230 ns -&gt; 250 ns）</li><li>将数据传输到CPU</li></ul></li><li><p>异步总线时间：</p><ul><li>步骤一握手</li><li>max{步骤2、3、4一起的时间，数据准备时间}</li><li>步骤5、6、7时间</li></ul></li><li><p>不同数据块大小：</p><p><img src="image-20231227212626052.png" alt="image-20231227212626052.png"></p><p><img src="image-20231227212641717.png" alt="image-20231227212641717.png"></p><p><img src="image-20231227212657044.png" alt="image-20231227212657044.png"></p></li><li><p>每秒总线事务数：用1s除以<strong>每个</strong>总线事务所需时间</p></li></ul></li><li><p>总线传输方式</p><ul><li>**猝发&#x2F;突发传输（Burst Transfer）：**在一次总线事务中，通过多个时钟周期连续传输一块数据，而不需要额外的地址和控制信号。这种方式可以提高数据传输的效率，因为它减少了每次传输所需的总线控制开销。</li><li><strong>DMA传输（Direct Memory Access）：</strong> DMA是一种通过专用的DMA控制器直接在主存储器和I&#x2F;O设备之间传输数据的方式，而无需CPU的直接干预。这提高了数据传输的效率。</li><li><strong>同步传输（Synchronous Transfer）：</strong> 在同步传输中，数据在一个统一的时钟信号下传输，根据时钟的边沿进行数据传送。这有助于确保数据的同步性，但要求系统中的各个部件都能保持同步。</li><li><strong>异步传输（Asynchronous Transfer）：</strong> 异步传输不依赖于统一的时钟信号，而是使用起始位和停止位来标识数据的开始和结束。异步传输通常用于短距离通信，例如串口通信。</li><li><strong>串行传输（Serial Transfer）：</strong> 串行传输是指每个时钟周期传输一个比特。虽然每个时钟周期只传输少量的数据，但串行传输通常具有较高的稳定性和较低的成本。典型：<strong>USB</strong></li><li><strong>并行传输（Parallel Transfer）：</strong> 在并行传输中，多个数据位同时在总线上传输。每个时钟周期传输多个比特，这样可以在同一时刻传输更多的数据，提高传输速率。</li></ul></li><li><p>总线层次</p><ul><li>单总线结构：CPU、存储器和I&#x2F;O模块都连接到一条系统总线</li><li>双总线结构：<ul><li>方案一：在 CPU 和存储器中间增加一个存储器总线</li><li>将系统总线分为存储器总线、 I&#x2F;O 总线 和 IOP (input&#x2F;output processor)</li></ul></li><li>多总线结构：<ul><li>方案一：增加一个本地总线（ local bus来连接CPU和cache）</li><li>方案二：将系统总线分为存储器总线、I&#x2F;O总线和DMA总线</li><li>方案三：增加一个高速I&#x2F;O总线来连接高速设备</li></ul></li></ul></li><li><p>注：60%的时间在读40%时间写直接用读写的数据传输速度加权；60%的访问为读40%访问为写需要在分母上对消耗的时钟周期加权然后重新计算数据传输速率</p><p><img src="image-20240102203024170.png" alt="image-20240102203024170.png"></p></li></ul><h2 id="第十七讲：输入输出（I-O）"><a href="#第十七讲：输入输出（I-O）" class="headerlink" title="第十七讲：输入输出（I&#x2F;O）"></a>第十七讲：输入输出（I&#x2F;O）</h2><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h3><ul><li><p>连接情况</p><ul><li>通过系统总线或中央交换器和存储器连接</li><li>通过专用数据线与一个或多个外设连接</li></ul></li><li><p>外部设备接口</p><p><img src="image-20231228163308278.png" alt="image-20231228163308278.png"></p><ul><li>I&#x2F;O模块的接口以控制 、 状态和数据信号的形式出现</li><li>与设备相关的控制逻辑控制外设的操作，以响应来自I&#x2F;O模块的命令</li><li>缓冲器用于缓存I&#x2F;O模块和外设之间传送的数据</li></ul></li><li><p>I&#x2F;O模块功能</p><ul><li>处理器通信<ul><li>命令译码：I&#x2F;O模块接收来自处理器的命令（I&#x2F;O指令），这些命令一般作为信号发送到控制总线</li><li>数据：数据是在处理器（通用寄存器组）和I&#x2F;O模块之间经由数据总线来交换的</li><li>状态报告：由于外设速度很慢 , 所以知道I&#x2F;O模块的状态很重要</li><li>地址识别：I&#x2F;O模块必须能识别它所控制的每个外设的唯一地址</li></ul></li><li>设备通信：通信内容包含命令、状态信息和数据</li><li>数据缓冲：外设的数据传送速度与存储器或处理器不同，有的快有的慢</li><li>控制和定时：处理器会非预期的与一个或几个外设进行通信</li><li>检错：检错并把差错信息报告给处理器</li></ul></li><li><p>结构</p><p><img src="image-20231228165511903.png" alt="image-20231228165511903.png"></p></li><li><p>I&#x2F;O端口和I&#x2F;O模块区别</p><ul><li>I&#x2F;O端口是计算机体系结构中的一个机制，用于通过特定地址进行I&#x2F;O访问，而I&#x2F;O模块表示连接到计算机系统的外部设备及其相关的控制电路。 I&#x2F;O模块通常包含一个或多个I&#x2F;O端口，其中每个端口对应于不同的功能或寄存器。</li></ul></li><li><p>外部接口</p><ul><li>并行接口：多根线连接I&#x2F;O模块和外设，同时传送多位数据</li><li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li></ul></li><li><p>编址方式</p><ul><li><strong>独立编址（Separate Addressing）：</strong> 在独立编址中，内存和I&#x2F;O设备拥有不同的地址空间。系统使用不同的地址范围来访问内存和I&#x2F;O设备，这意味着CPU使用不同的指令或地址范围来读写内存和I&#x2F;O设备。</li><li><strong>统一编址（Unified Addressing）：</strong> 在统一编址中，内存和I&#x2F;O设备共享相同的地址空间。系统使用相同的地址范围来访问内存和I&#x2F;O设备，使得CPU可以使用相同的指令和地址范围来读写内存和I&#x2F;O设备。</li></ul></li></ul><h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h3><ul><li><p>编程式I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</p><ul><li>当处理器在执行过程中遇到一条与I&#x2F;O操作有关的指令时，它通过发送指令到对应I&#x2F;O模块来执行这条指令</li><li>I&#x2F;O模块将执行所要求的动作，然后在I&#x2F;O状态寄存器中设置一些适当的位</li><li>I&#x2F;O不会中断处理器 因此处理器需要周期性地检查I&#x2F;O模块的状态 直到发现该操作完成</li></ul></li><li><p>中断驱动式I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令；并且当I&#x2F;O模块完成其工作后，才去中断处理器工作</p><p><img src="image-20231228171431496.png" alt="image-20231228171431496.png"></p><ul><li>处理器发送一个I&#x2F;O命令到模块，然后去处理其它有用的工作</li><li>当I&#x2F;O模块准备和处理器交换数据时，它中断处理器以请求服务</li><li>处理器执行数据传送，最后恢复它原先的处理工作</li><li>响应优先级和处理优先级<ul><li>响应优先级：中断被触发时，系统多快能够响应并开始执行相应的中断服务程序</li><li>处理优先级：在处理器已经响应中断并开始执行中断服务程序后，不同中断服务程序之间的执行顺序</li><li>过程：当中断同时来临时先按照响应优先级顺序响应中断，然后按该顺序处理，准备好当前响应优先级最高的中断所需环境后，比较处理优先级，如果有比当前中断处理优先级高的，插入该中断，完成后再回到原中断。在此过程中新的中断来了正常响应加入队列，但只在每次处理前检查队列的处理优先级</li><li>掩码字&#x2F;屏蔽字：该位为1表示可屏蔽对应的中断（自己一定可以屏蔽自己），即当前处理优先级高于该位对应中断的优先级</li></ul></li><li>设备识别方法：多条中断线、软件轮询、菊花链、独立请求</li></ul></li><li><p>直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与主存直接交换数据，而不需要处理器的干涉</p><ul><li>处理器通过发送以下信息向DMA模块发出命令：读&#x2F;写、I&#x2F;O设备地址、内存中的起始位置、字数，然后处理器继续进行其他工作</li><li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出而无需经过处理器</li><li>当传输完成时DMA模块向处理器发送一个中断信号</li><li><strong>DMA使用总线优先级高于CPU</strong></li></ul></li><li><p>DMA访问方法</p><ul><li>CPU停止法：控制简单，但影响CPU，没有充分利用内存</li><li>周期窃取：充分利用CPU和内存，及时响应I&#x2F;O请求，但每次都要申请总线，且一次只传输一个字</li><li>交替分时访问：CPU未停止或等待，DMA不请求总线</li></ul></li><li><p>查询式I&#x2F;O</p><ul><li>在轮询方式中，CPU定期地检查I&#x2F;O设备是否准备好进行数据传输。这种方式包括以下步骤：<ul><li><strong>步骤1：CPU发起请求</strong> CPU向I&#x2F;O设备发送一个请求，询问设备是否准备好进行数据传输。</li><li><strong>步骤2：等待设备准备</strong> CPU在一定的时间间隔内不断轮询（检查）设备的状态，看是否已经准备好执行请求。</li><li><strong>步骤3：数据传输</strong> 一旦I&#x2F;O设备准备好，CPU开始执行实际的数据传输。</li></ul></li><li>在此方式下，CPU全程参与数据传输，占用率为100%</li></ul></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法整理"><a href="#数据结构与算法整理" class="headerlink" title="数据结构与算法整理"></a>数据结构与算法整理</h1><h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><ul><li>数据结构概念<ul><li>A data structure is a data object together with the relationships among the data members that compose the object</li><li>Data Structure &#x3D; {D，R}，D为数据，R为所有数据间的关系</li><li>抽象数据结构ADT：数据 + 对应操作</li></ul></li></ul><span id="more"></span><ul><li>线性结构<ul><li><img src="image-20240106150547680.png" alt="image-20240106150547680" style="zoom: 50%;" /></li></ul></li><li>算法<ul><li>an operation sequence of solving a problem</li></ul></li><li>递归<ul><li>递归的两条基本规则: (1) Base cases (2) Making progress</li><li>直接递归：函数或过程直接调用自身。</li><li>间接递归：函数或过程调用其他函数，而这些其他函数中又调用原始函数，最终形成一个递归循环。</li></ul></li><li>泛型<ul><li>泛型（Generic）是一种编程范式，它允许在编写代码时使用一种抽象的方式来操作数据类型。</li></ul></li></ul><h2 id="第二章-算法分析"><a href="#第二章-算法分析" class="headerlink" title="第二章 算法分析"></a>第二章 算法分析</h2><ul><li><p>空间复杂度</p><ul><li><p>用来衡量算法在执行过程中所需存储空间的度量。它表示算法的额外空间需求与输入规模之间的关系。</p></li><li><p>组成部分</p><ul><li>指令空间</li><li>数据空间</li><li>运行环境栈空间</li></ul></li><li><p>分类</p><ul><li>固定部分：指令、简单变量、定长复合变量、常量</li><li>可变部分：复合变量、动态分配空间、递归栈</li></ul></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">SequentialSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> [] a, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length &amp;&amp;a[i]!=x; i++) ;<br>        <span class="hljs-keyword">if</span>(i= = a.length) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据空间：12 bytes : x，i，a[i]，0，1，a.length</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">float</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> sum(a, n - <span class="hljs-number">1</span>) + a[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归栈空间：（参数 + 返回地址）* 递归深度</li></ul></li></ul></li><li><p>时间复杂度</p><ul><li><p>用来衡量算法执行时间随输入规模增长而变化的度量，描述的是随着输入规模的增大，算法的运行时间将如何增长。</p></li><li><p>最优、最差与平均复杂度：平均复杂度一般难以计算，因此多用最差和最优情况分析</p></li><li><p>计算</p><ul><li>统计基本操作的执行次数： 首先，确定算法中的基本操作，例如赋值、比较、循环迭代等。然后，统计这些基本操作的执行次数，以及它们与输入规模的关系。</li><li>忽略常数项： 在计算时间复杂度时，通常会忽略常数项，即忽略执行次数中与输入规模无关的常数因子。这是因为在大规模输入时，常数项对总体复杂度的增长影响较小。</li><li>关注主导因子： 确定算法执行步骤中占主导地位的因子，即最大影响复杂度增长的部分。通常，我们关注循环中执行次数最多的部分或递归算法的递归关系。</li></ul></li><li><p>秩排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RankSort</span> &#123;<br>    <span class="hljs-comment">// Rank the elements in the array a[0:n-1] and store ranks in the array r</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rank</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            r[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[j] &lt;= a[i]) &#123;<br>                    r[i]++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r[j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rearrange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (r[i] != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> r[i];<br>                swap(a[i], a[t]);<br>                swap(r[i], r[t]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>数据比较：n * (n - 1) &#x2F; 2</p></li><li><p>元素交换次数：2 * n（每次循环中至少有一个元素的秩被正确放置，故不超过n次）</p></li></ul></li><li><p>注意点</p><ul><li>在计算数据移动次数时，一次swap需要移动元素3次</li><li>循环里的变量初始赋值以及循环条件里的赋值也各算一次移动，当存在多重循环时需要考虑（一般只考虑循环体里的赋值）</li></ul></li></ul></li><li><p>大O表示法</p><ul><li>定义：对于一个函数 f(n)，如果存在正常数 c 和正整数 n0，使得对于所有的 n &gt; n0，都有 f(n) &lt;&#x3D; c * g(n)，其中 g(n) 是某个已知函数，那么我们就说 f(n) 的渐近上界是 O(g(n))，记作 f(n) &#x3D; O(g(n))。</li><li>Ω表示法：渐近下界</li><li>θ表示法：介于中间</li></ul></li><li><p>折半查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 如果目标值等于中间值，找到目标值</span><br>        <span class="hljs-keyword">if</span> (array[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果目标值小于中间值，在左侧继续查找</span><br>        <span class="hljs-keyword">if</span> (target &lt; array[mid]) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果目标值大于中间值，在右侧继续查找</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br>    <span class="hljs-comment">// 如果未找到目标值，返回 -1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SelectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> n; size &gt; <span class="hljs-number">1</span>; size --)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Max(a,size);<span class="hljs-comment">//寻找a[0 : size - 1]中的最大值,O(n)</span><br>swap(a[j],a[size-<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Max数据比较次数：n * (n - 1) &#x2F; 2</li><li>数据交换次数：3 * (n - 1)</li></ul></li><li><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">1</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j &lt; i - <span class="hljs-number">1</span>, j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &gt; a[j+<span class="hljs-number">1</span>])swap(a[j],a[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据比较次数和选择排序一样</li></ul></li><li><p>插入排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j+<span class="hljs-number">1</span>]&lt;arr[j])&#123;swap(&amp;arr[j],&amp;arr[j+<span class="hljs-number">1</span>]);&#125; <br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第三章-线性表"><a href="#第三章-线性表" class="headerlink" title="第三章 线性表"></a>第三章 线性表</h2><ul><li><p>定义</p><ul><li><p>L &#x3D; (e1, e2, ···, en), size 为n，n &#x3D; 0 -&gt; 空表</p></li><li><p>操作：<img src="image-20240106173001935.png" alt="image-20240106173001935" style="zoom:50%;" /></p></li></ul></li><li><p>数组实现的线性表</p><ul><li><img src="image-20240106173658855.png" alt="image-20240106173658855" style="zoom:50%;" /></li><li>search(x) ：O(length)</li><li>remove( k,x)：O(n)</li><li>insert (x , i)：O(n)</li><li>缺点：插入和删除时间长</li></ul></li><li><p>单链表实现的线性表</p><ul><li><img src="image-20240106210937444.png" alt="image-20240106210937444" style="zoom:50%;" /></li><li>操作方法和链表一样</li></ul></li><li><p>单链表操作</p><ul><li>删除：<ul><li>若为头节点直接将head指针指向下一个节点</li><li>将下一个节点的值复制到当前节点，覆盖当前节点的值。</li><li>将当前节点的 next 指针指向下一个节点的下一个节点。</li></ul></li><li>插入<ul><li>创建一个新节点，将新节点的next指针指向目标节点的下一个节点。</li><li>将目标节点的 next指针指向新节点。</li></ul></li><li>交换<ul><li>设有abcd四个节点</li><li>先让a指向c，再让b指向d，最后再让c指向b（b有额外指针，即已知）</li></ul></li><li>单链表类<ul><li>ListNode：链表结点类</li><li>LinkedList：链表本身的类isEmpty()、makeEmpty()、zeroth()、first()、find(object x)、remove()、insert(Object x, LinkedListItr p)、findprevious(Object x)</li><li>LinkedListItr：一个迭代器（类比读卡器），用来读取链表节点isPastEnd()、retrieve()、advance()</li></ul></li></ul></li><li><p>带表头结点的单链表</p><ul><li>头结点是链表的第一个结点，但不存储实际的数据。它的存在使得链表的插入、删除等操作在任何位置都可以统一为一种操作，无需特殊处理头结点。</li><li>空链表表示为头结点的 next 指针为 null</li></ul></li><li><p>链表的数组实现</p><img src="image-20240106210926230.png" alt="image-20240106210926230" style="zoom:50%;" /></li><li><p>基数排序</p><ul><li><img src="image-20240106212447675.png" alt="image-20240106212447675" style="zoom:40%;" /></li><li>按从低位到高位依次放入桶中，n（最高位数）次后排序完成</li><li>实现：原始要排序的数据、桶中的数据都可以用链表或数组来实现。</li></ul></li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><ul><li>定义<ul><li>插入和删除都在同一侧的线性表</li><li>末端叫top，另一端叫bottom</li></ul></li><li>方法<ul><li><img src="image-20240107091929146.png" alt="image-20240107091929146" style="zoom:50%;" /></li><li>pop()：出栈</li><li>push()：入栈</li></ul></li></ul><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h3><ul><li>定义<ul><li>插入和删除在两端的线性表</li><li>也叫先进先出列表</li><li>新元素进入的端叫rear，旧元素出队的端叫front</li></ul></li><li>方法<ul><li><img src="image-20240107093052919.png" alt="image-20240107093052919" style="zoom:50%;" /></li><li>数组实现：<img src="image-20240107093427609.png" alt="image-20240107093427609" style="zoom:50%;" /></li><li>enqueue()：入队</li><li>dequeue()：出队</li></ul></li></ul><h2 id="第四章-树"><a href="#第四章-树" class="headerlink" title="第四章 树"></a>第四章 树</h2><ul><li>定义<ul><li>节点的集合，由一个根节点和若干子树构成</li><li>节点的度degree：孩子的个数</li><li>树的度：节点度的最大值</li><li>枝和叶：度为0的节点称为叶，度数不为0的节点称为枝</li><li>级level：根的级为0&#x2F;1，其他节点的级为父节点的级+1</li><li>树的深度&#x2F;高度：最大的级</li></ul></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><p>二叉树</p><ul><li>定义：有根节点且其余每个节点构成两棵子树，称为左子树和右子树</li><li>定理<ul><li>二叉树的边数 &#x3D; 节点数 - 1</li><li>第i层的节点数最多为2 ^ i</li><li>高度为h的二叉树节点个数：h + 1 到 2 ^ (h + 1) - 1</li><li>叶节点数量 &#x3D; 度为2节点个数 + 1</li><li>有n个节点的树高度范围：n - 1 到 log2(n + 1) - 1</li></ul></li><li>满二叉树：高度为h且有2 ^ (h + 1) - 1个节点的树</li><li>完全二叉树：<img src="image-20240107111044518.png" alt="image-20240107111044518" style="zoom:50%;" /></li><li>数组实现：二叉树被看作完全二叉树缺失了部分节点，完全二叉树按顺序填入数组</li><li>链表实现：节点结构为数据 + 左子树 + 右子树</li><li>cursor实现：<img src="image-20240107115634904.png" alt="image-20240107115634904" style="zoom: 33%;" /></li><li>方法：<img src="image-20240107115801585.png" alt="image-20240107115801585" style="zoom:40%;" /></li></ul></li><li><p>二叉树的遍历</p><ul><li><img src="image-20240107120939766.png" alt="image-20240107120939766" style="zoom:50%;" /></li><li><p>前序遍历：根-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历：左子树-&gt;根-&gt;右子树</p></li><li><p>后序遍历：左子树-&gt;右子树-&gt;根</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Preorder traversal递归写法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BinaryNode&lt;T&gt;* t)</span></span>&#123;<br>    <span class="hljs-comment">// preorder traversal of *t.</span><br><span class="hljs-keyword">if</span>(t)&#123;<br>        <span class="hljs-built_in">visit</span>(t);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Left);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Right);<br>        <span class="hljs-comment">//InOrder和PostOrder只需要换顺序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法：<img src="image-20240107123919487.png" alt="image-20240107123919487" style="zoom: 40%;" /></p></li><li><p>用遍历结果建树</p><ul><li><img src="image-20240107123115144.png" alt="image-20240107123115144" style="zoom:45%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  void CreateBT(String pres, String ins, BinaryNode<Type>* &amp; t){<br>      int inpos;<br>      String prestemp, instemp;</p><pre><code class="hljs">  if (pres.length() == 0)      t = NULL;  else &#123;      t = new BinaryNode;      t-&gt;element = pres.ch[0];      inpos = 0;      while (ins.ch[inpos] != t-&gt;element)inpos++;      //对左子树建树      prestemp = pres(1, inpos);      instemp = ins(0, inpos-1);      CreateBT(prestemp, instemp, t-&gt;left);      //对右子树建树      prestemp = pres(inpos + 1, pres.length() - 1);      instemp = ins(inpos + 1, pres.length() - 1);      CreateBT(prestemp, instemp, t-&gt;right);  &#125;</code></pre><p>  }<br>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 如果为后序+中序：建根节点时和移动inpos时注意后序最后一个元素为根,递归部分如下：<br><br>  ````c++<br>  posttemp = posts(<span class="hljs-number">0</span>, inpos - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(0, </span>inpos - <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;left);<br>  <br>  posttemp = posts(inpos, posts.length() - <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(inpos </span>+ <span class="hljs-number">1</span>, <span class="hljs-keyword">ins.length() </span>- <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;right);<br></code></pre></td></tr></table></figure></p></li></ul><h3 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h3><ul><li>树的存储方式<ul><li><strong>左子女右兄弟表示法</strong>（重点）<ul><li>每个节点除了存储自己的信息外，还存储了其<strong>最左边</strong>的子节点和<strong>最靠近</strong>的右兄弟节点的指针。</li><li><code>TreeNode *firstchild, *nextsibling;</code></li></ul></li><li>双亲表示法：在树节点中存储父节点的位置</li><li>广义表（基本不考）：如a(b(f,g),c,d(h,i,j),e)</li></ul></li><li>森林<ul><li>若干树的集合</li><li>森林-&gt;树：先将树全部转成二叉树，再将树的根节点用右链相连</li><li>树-&gt;森林：依次剪断根节点和右子树，形成新的树</li><li>把一棵树转化为二叉树：从这棵树的根结点开始，从上到下，看每一个结点，把你正在看的结点的孩子放在左子树，兄弟放在右子树。（将节点的孩子放在左子树，将节点的兄弟放在右子树）</li></ul></li><li>树的遍历<ul><li>深度优先遍历<ul><li>先序次序遍历：先访问树的根，再按先序遍历根的第一棵子树，第二棵子树，……</li><li>后序次序遍历：按先序遍历根的第一棵子树，第二棵子树，……，最后访问树的根</li></ul></li><li>广度优先遍历<ul><li>分层访问</li></ul></li><li>森林的遍历：先把森林转化成二叉树，再进行树的遍历</li></ul></li></ul><h3 id="特殊的树"><a href="#特殊的树" class="headerlink" title="特殊的树"></a>特殊的树</h3><ul><li><p>线索树</p><ul><li><p>n个结点的二叉树有2n个链域，其中真正有用的是n - 1 个，其它 n + 1 个都是空域。为了充分利用结点中的空域，使得对某些运算更快，用这些空域存储额外的信息</p></li><li><p>一个节点内增加两个标记：左子女|左线索|数据|右线索|右子女</p></li><li><p>若左线索为0，左子女指针正常指向左子女；若左线索为1，左子女指向前驱（某线性序列）</p></li><li><p>若右线索为0，右子女指针正常指向右子女；若右线索为1，右子女指向后继</p></li><li><p>中序线索树节点A的<strong>前驱</strong>为A左子树中的最右节点或者A的某个右子树包含A的祖先节点</p></li><li><p>中序线索树节点A的<strong>后继</strong>为A的右子树中的最左节点，或者是A的某个左子树包含A的祖先节点</p></li></ul><blockquote><p>注：这里的左右看的是垂直位置</p><p>​             1</p><p>如： &#x2F;        \     中从左到右为2-&gt;1-&gt;3</p><p>​     2              3</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadedTreeNode prev;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createThreadedTree</span><span class="hljs-params">(ThreadedTreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            createThreadedTree(root.left);<br><span class="hljs-comment">//左子女为空填前驱</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                root.left = prev;<br>                root.leftThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//pre右子女为空填当前节点</span><br>            <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span> &amp;&amp; prev.right == <span class="hljs-literal">null</span>) &#123;<br>                prev.right = root;<br>                prev.rightThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            prev = root;<span class="hljs-comment">//更新前驱</span><br><br>            createThreadedTree(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>霍夫曼树</p><p><a href="https://blog.csdn.net/qinglongzhan/article/details/80983492">Huffman编码算法详解_哈夫曼编码怎么算-CSDN博客</a></p><ul><li>增长树：对原二叉树中度为1的结点，增加一个空树叶；对原二叉树中的树叶，增加两个空树叶</li><li>外通路长度(外路径)E：根到每个外结点(增长树的叶子)的路径长度的总和(边数)；与之类似，内路径长度I对应内节点(非叶子)</li><li>结点的带权路径长度：一个结点的权值与结点的路径长度的乘积，用于算带权的外(内)路径长度</li><li>霍夫曼树：给出 m 个实数作为m个外结点的权构造一棵增长树，使得带权外路径长度最短</li><li>霍夫曼算法<ul><li><strong>初始化：</strong> 将每个字符看作一个独立的树，节点的权重为字符的频率。</li><li><strong>选择两棵权重最小的树：</strong> 从当前的树集合中选择两棵权重最小的树，合并成一棵新的树，新树的权重为两棵树的权重之和。</li><li><strong>重复步骤2：</strong> 不断重复步骤2，直到只剩下一棵树为止。</li><li>注意: 当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。</li></ul></li></ul></li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li><p>定义：二叉搜索树（Binary Search Tree，简称BST）是一种二叉树，其中每个节点都包含一个键值，并且满足以下性质：</p><ol><li>对于每个节点，其左子树中所有节点的键值都小于该节点的键值。</li><li>对于每个节点，其右子树中所有节点的键值都大于该节点的键值。</li><li>对于每个节点，其左右子树都是二叉搜索树。</li></ol></li><li><p>Indexed binary search tree：在二叉搜索树基础上每个节点增加一个leftsize &#x3D; 左子树节点个数 + 1</p></li><li><p>查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">find</span><span class="hljs-params">( Comparable x, BinaryNode t )</span>&#123;<br>    <span class="hljs-keyword">if</span>( t = = <span class="hljs-literal">null</span> )&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-keyword">if</span>( x. compareTo( t.element ) &lt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.left );&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo( t.element ) &gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.right );&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> t;&#125; <span class="hljs-comment">//Match</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>插入：<code>if( t = = null )&#123;t = new BinaryNode( x, null, null );&#125;</code>其他与查找相同</p></li><li><p>删除</p><ul><li>待删节点为叶节点：直接删</li><li>待删节点有一个非空子树：删除该节点后将它的子树接在被删节点的位置</li><li>待删节点有两个非空子树：找出左子树的最大值或右子树的最小值，将这个节点与待删节点互换位置，然后删除换位后的待删节点</li></ul></li><li><p>查找时间复杂度：worst-&gt;O(n)，best-&gt;O(log2 n)</p></li></ul><h3 id="AVL树（自平衡的二叉搜索树）"><a href="#AVL树（自平衡的二叉搜索树）" class="headerlink" title="AVL树（自平衡的二叉搜索树）"></a>AVL树（自平衡的二叉搜索树）</h3><ul><li>平衡因子：左子树和右子树的高度（或深度）之差，不能超过1</li><li>AVL的插入与删除：与二叉搜索树相同，但插入和删除若破坏平衡，要进行<strong>旋转</strong></li><li>AVL的旋转<ul><li>最小失衡树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。只需要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</li><li>左外侧不平衡：右单旋</li><li>右外侧不平衡：左单旋</li><li>左内侧不平衡：左双旋转</li><li>右内侧不平衡：右双旋转</li><li><img src="image-20240107185808987.png" alt="image-20240107185808987"  /></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><ul><li><p>m-路搜索树</p><ul><li>在m路搜索树中，每个内部节点可以有多达m个子树。它有以下特性：<ol><li>每个节点最多有m个子树。</li><li>除根节点和叶子节点外，每个节点至少有m &#x2F; 2个子树。</li><li>所有叶子节点都在同一层次上。</li></ol></li></ul></li><li><p>B-树：平衡的m-路搜索树</p><ul><li><p>查找：</p><ul><li><strong>从根节点开始：</strong> 从B树的根节点开始，逐级向下搜索。</li><li><strong>在节点中查找关键字：</strong> 在当前节点中查找目标关键字。如果目标关键字等于当前节点中的某个关键字，则查找成功，返回相应的信息或指针。</li><li><strong>选择子树：</strong> 如果目标关键字小于当前节点中的所有关键字，选择当前节点的第一个子树。如果目标关键字大于当前节点中的某个关键字，选择该关键字右侧的子树。</li><li><strong>递归：</strong> 递归地在所选择的子树上执行查找操作，回到步骤2。</li><li><strong>叶子节点：</strong> 如果当前节点是叶子节点，表示到达了树的底部，但仍未找到目标关键字。查找失败，返回相应的提示或空值。</li></ul></li><li><p>插入（假设为3阶B-树）</p><ul><li>首先与查找操作一样，找到待插入节点</li><li>若目标插入节点关键字数量小于2（m - 1），直接插入</li><li>若目标插入节点关键字数量已经为2进行<strong>分裂</strong></li><li>分裂：分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</li><li><img src="image-20240107194100165.png" alt="image-20240107194100165" style="zoom: 60%;" /></li></ul></li><li><p>删除</p><ul><li><p>若该节点删除前关键字个数大于m &#x2F; 2，直接删除</p></li><li><p>若该节点关键字个数等于m &#x2F; 2，即删除后不满足B-树要求，按从左到右顺序从相邻的兄弟节点借一个数据</p><img src="image-20240107200008343.png" alt="image-20240107200008343" style="zoom: 40%;" /></li><li><p>若相邻兄弟节点关键字个数为m &#x2F; 2，则将两个节点合并（把父节点里根位置关键字也合并进来），若此过程使父节点也不满足B-树定义，递归向上进行</p><img src="image-20240107200139516.png" alt="image-20240107200139516" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><ul><li>装载因子<ul><li>定义：装载因子（Load Factor）是哈希表中用于衡量已经存储的元素数量与哈希表容量之比的一个指标，表示为：Load Factor &#x3D; 哈希表容量已存储的元素数量 &#x2F; 哈希表容量</li><li>装载因子大于1碰撞概率大，小于1碰撞概率小</li></ul></li></ul><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><ul><li><p>取余法：</p><img src="image-20240107201105493.png" alt="image-20240107201105493" style="zoom: 67%;" /></li><li><p>平方取中法</p><img src="image-20240107201206982.png" alt="image-20240107201206982" style="zoom: 67%;" /></li><li><p>乘法杂凑法：使用[M * ( k * A % 1) ]作为哈希地址，其中A是一个在0和1之间的常数。</p><img src="image-20240107201240355.png" alt="image-20240107201240355" style="zoom: 67%;" /></li></ul><h3 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h3><ul><li>线性探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 2 ··· m - 1，0 ··· d - 1号位置，若检测到空闲，则占据该位置</li><li>简单地说就是从原位置沿数组找第一个空位置插入</li></ul></li><li>二次探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 4，d + 9··· 号位置，若检测到空闲，则占据该位置</li></ul></li><li>双哈希<ul><li>使用两个独立的哈希函数来计算下一个探测位置。这两个哈希函数分别为h1(key)和h2(key)</li><li>若发生冲突，探测d + c, d + 2c, d + 3c······号位置</li></ul></li><li>再散列：当哈希表中的元素数量达到一定阈值时，再散列会触发，引发哈希表的重新构建。主要步骤：<ul><li><strong>创建新的哈希表：</strong> 当哈希表中的元素数量达到一定的阈值（例如，装载因子超过某个预定的阈值），再散列会创建一个新的更大的哈希表。</li><li><strong>重新哈希：</strong> 将哈希表中的所有元素重新插入到新的哈希表中。这个过程会使用新的哈希函数，通常是一个更大的哈希表大小对应的函数。</li><li><strong>替换原有哈希表：</strong> 重新哈希完成后，新的哈希表替换了原有的哈希表，成为存储元素的主要数据结构。</li></ul></li><li>分离链接<ul><li><img src="image-20240107205422549.png" alt="image-20240107205422549" style="zoom:50%;" /></li></ul></li></ul><h2 id="第六章-优先级队列（堆）"><a href="#第六章-优先级队列（堆）" class="headerlink" title="第六章 优先级队列（堆）"></a>第六章 优先级队列（堆）</h2><ul><li>定义<ul><li>类似于普通的队列或堆栈，但是每个元素都关联有一个优先级。在优先级队列中，元素按照其优先级被处理，而不是按照插入的顺序。</li><li>查找、删除最高优先级的叫最大优先级队列，反之称为最小优先级队列</li></ul></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>定义：一个最大（小）堆是所有节点值都比其孩子节点值大（小）的<strong>完全二叉树</strong></p></li><li><p>插入：新插入的元素插在堆的最后，若插入后不满足最大（小）堆的要求，向上调整，即不断交换</p><img src="image-20240107211422734.png" alt="image-20240107211422734" style="zoom:67%;" /></li><li><p>删除：堆只能删除顶部元素，删除后将底部元素提到顶部，再从上向下调整（例：若为最大堆则每次选择两个孩子中更大的进行交换）</p><img src="image-20240107211726374.png" alt="image-20240107211726374" style="zoom:67%;" /></li><li><p>方法：<img src="image-20240107211909366.png" alt="image-20240107211909366" style="zoom:50%;" /></p></li><li><p>向下调整算法建堆</p><ul><li><p>向下调整算法：如图，以下二叉树经过以下步骤转换为大堆</p><ul><li>选出孩子节点中大的值大的与父结点比较，如孩子节点大于父结点则交换，如小于则停止。</li><li>持续向下比较，比较到叶子结点或者孩子结点小于父结点则停止。</li></ul><p><img src="image-20240107212509783.png" alt="image-20240107212509783"></p></li><li><p>从后向前建堆：找到数组最后一个元素的父节点，为图中编号为1的子树，从后向前执行向下调整算法。</p><img src="image-20240107212531304.png" alt="image-20240107212531304" style="zoom: 67%;" /></li></ul></li><li><p>向上调整算法建堆</p><ul><li><p>向上调整算法建堆的过程与向下调整算法相似，从下标为1（即顶部）的结点开始向后调整：</p><ul><li>如孩子节点大于父结点就进行交换，直到与根结点比较完毕。</li><li>如孩子节点小于父节点也停止调整，让下一结点进行调整。</li></ul><p><img src="image-20240107213231846.png" alt="image-20240107213231846"></p></li></ul></li><li><p>堆排序</p><ul><li>第一步：将给定数据按顺序建成完全二叉树，然后调整成最大堆（从小到大排序用最大堆，从大到小排序用最小堆）</li><li>第二步：堆分为有序区和无序区，每次把无序区的最后一个元素与堆顶元素交换，此时有序区扩增，然后对无序区进行向下调整让它重新成为最大（小）堆</li><li>重复进行第二步直到排序完成</li></ul><img src="image-20240107213415919.png" alt="image-20240107213415919" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        percDown(a, i, a.length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        swapReferences(a, <span class="hljs-number">1</span>, i);<br>        percDown(a, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(Comparable[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    Comparable tmp;<br>    <br>    <span class="hljs-keyword">for</span> (tmp = a[i]; leftChild(i) &lt; n; i = child) &#123;<br>        child = leftChild(i);<br>        <br>        <span class="hljs-keyword">if</span> (child != n - <span class="hljs-number">1</span> &amp;&amp; a[child].compareTo(a[child + <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>            child++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (tmp.compareTo(a[child]) &lt; <span class="hljs-number">0</span>) &#123;<br>            a[i] = a[child];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    a[i] = tmp;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第七章-并查集"><a href="#第七章-并查集" class="headerlink" title="第七章 并查集"></a>第七章 并查集</h2><ul><li><p>等价类：指集合中的元素按照某个等价关系被划分成若干个子集，其中每个子集内的元素在这个等价关系下是相互等价的。一个等价关系是满足以下三个性质的关系：自反性、对称性、传递性</p></li><li><p>并查集定义：用于处理集合的数据结构，主要用于解决元素的等价关系和集合合并的问题。每个元素都被分配一个唯一的标识符，并且每个集合由一棵树来表示，其中树的根节点是集合的代表元素。</p></li><li><p>操作</p><ul><li>find(e)：在并查集中寻找e</li><li>union(a, b)：将a、b两个等价类合并，通常把其中一个的根节点连到另一个的根节点上</li><li>combine(a, b)：i&#x3D;Find(a)；j&#x3D;Find(b)；if(i !&#x3D; j) Union(i, j)；</li></ul></li><li><p>实现：每个等价类取出一个代表元素作为根，其他元素按层级结构作为孩子</p><ul><li><img src="image-20240108093433682.png" alt="image-20240108093433682" style="zoom:50%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  int Find(int e){<br>      while(parent[e])<br>          e &#x3D; parent[e];<br>      return e;<br>  }</p><p>  void Union(int i, int j){<br>      parent[j]&#x3D;i;<br>  }<br>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>    - 时间复杂度：find-&gt;<span class="hljs-built_in">O</span>(h)，<span class="hljs-keyword">union</span>-&gt;θ(<span class="hljs-number">1</span>)<br><br>+ <span class="hljs-keyword">union</span>算法的提升<br><br>    - 重量规则：将树中节点多的根作为合并后的新根<br>    - 高度规则：将树高更高的根节点作为合并后的新根，用一个数组实现，根结点中放负数，绝对值代表高度<br><br>  ````c++<br>  <span class="hljs-comment">//重量规则</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>      root = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//指示该节点是否为根</span><br>      parent = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//存放树节点个数</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">1</span>; e &lt;= n; e++) &#123;<br>          parent[e] = <span class="hljs-number">1</span>;<br>          root[e] = <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (!root[e]) &#123;<br>          e = parent[e];<br>      &#125;<br>      <span class="hljs-keyword">return</span> e;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (parent[i] &lt; parent[j]) &#123; <span class="hljs-comment">// i becomes subtree of j</span><br>          parent[j] = parent[j] + parent[i];<br>          root[i] = <span class="hljs-literal">false</span>;<br>          parent[i] = j;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          parent[i] = parent[i] + parent[j];<br>          root[j] = <span class="hljs-literal">false</span>;<br>          parent[j] = i;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//高度规则</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[root2] &lt; s[root1]) &#123;<br>        s[root1] = root2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (s[root1] == s[root2]) &#123;<br>            s[root1] = root2;<br>            s[root2] = root1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>find的提升：路径压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(parent[e] == e)&#123;<span class="hljs-keyword">return</span> e;&#125;<br>    <span class="hljs-keyword">return</span> parent[e] = <span class="hljs-built_in">find</span>(parent[e]);<br>&#125;<br><span class="hljs-comment">//第一次find没有压缩，以后的都压缩过了</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="第八章-图"><a href="#第八章-图" class="headerlink" title="第八章 图"></a>第八章 图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>定义：Graph&#x3D;(V, E)；V：非空有限点集；E：边集合</p><ul><li>无向图：边(v1, v2) &#x3D; (v2, v1)</li><li>有向图与无向图相反</li></ul></li><li><p>完全图：有n个点和n * (n - 1) &#x2F; 2条边的无向图（有向图n * (n - 1)条边），即每个点都和其他点直接相连</p></li><li><p>度</p><ul><li>入度：以该点为终点的边的条数</li><li>出度：以该点为起点的边的条数</li><li>对无向图，度就是节点连接的边的条数</li></ul></li><li><p>子图：V’ 包含于V，E’ 包含于E，则(V’, E’)为(V, e)的子图</p></li><li><p>简单路径与简单回路：一个简单路径是指图中不包含重复节点的路径，简单回路是起始点相同的简单路径</p></li><li><p>连通图</p><ul><li>一个图是连通图，如果图中的任意两个节点之间存在至少一条路径</li><li>一个有向图是强连通图，如果图中的任意两个节点之间存在双向路径</li></ul></li><li><p>连通分量</p><ul><li>一个图的连通分量是指图中的一个最大连通子图</li><li>强连通分量是指有向图中的一个极大强连通子图，即一个最大的子图，其中任意两个节点都是强连通的。</li></ul></li><li><p>权重图：边上带有权值，表示对象之间的关系具有权重。</p></li><li><p>网络：连通的权重图和子图</p></li><li><p>生成树：无环连通图的一种特殊子图。对于一个连通图 G，它的生成树是 G 的一个子图，包含了图中的所有节点，并使得这个子图是一个树（无环连通图）。</p><p>生成树有以下特性：</p><ol><li>包含了图中的所有节点。</li><li>是一个树，即无环连通图。</li><li>保留了原图中的边，但是边的数量是节点数减一。</li></ol></li><li><p>方法：<img src="image-20240108103611106.png" alt="image-20240108103611106" style="zoom: 60%;" /></p></li><li><p>邻接矩阵（Adjacency Matrix）： 用二维数组表示节点之间的关系，矩阵中的元素表示边的存在或权值。</p><ul><li>aij &#x3D; 1表示存在(i, j)这条边</li><li>无向图的邻接矩阵是对称矩阵</li><li>若图为网络（权重图），则将0换为∞，1换为权重</li></ul></li><li><p>邻接表</p><ul><li>如果边的数量少，使用邻接表可以减少内存消耗</li><li><img src="image-20240108104520940.png" alt="image-20240108104520940" style="zoom:50%;" /></li><li><img src="image-20240108104535783.png" alt="image-20240108104535783" style="zoom:50%;" /></li></ul></li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li><p>深度优先遍历 DFS</p><ul><li><p>沿着图的深度尽可能远的方式遍历图的节点，直到无法再继续前进为止，然后回溯到之前的节点，继续探索其他路径。</p><img src="image-20240108110219014.png" alt="image-20240108110219014" style="zoom:67%;" /></li><li><p>步骤：</p><ul><li>选择一个起始节点作为当前节点。</li><li>访问当前节点，并标记为已访问。</li><li>对当前节点的每个邻接节点，如果该邻接节点未被访问，递归地应用 DFS。</li><li>若该节点向下的邻接节点都已被访问，返回到上一步，继续对其他未访问的节点应用 DFS。</li></ul></li><li><p>使用辅助数组visited[]实现</p></li></ul></li><li><p>广度优先遍历</p><ul><li>思想：从图中某顶点v0出发，在访问了v0之后依次访问v0的各个未曾访问过的邻接点，然后分别从这些邻接点出发广度优先遍历图，直至图中所有顶点都被访问到为止</li><li><img src="image-20240108110234403.png" alt="image-20240108110234403" style="zoom:50%;" /></li><li>使用辅助数组visited[]实现</li></ul></li><li><p>连通分量</p><ul><li>当无向图(以无向图为例)为非连通图时，从图的某一顶点出发进行遍历(深度&#x2F;广度)只能访问到该顶点所在的最大连通子图(即连通分量)的所有顶点</li><li><img src="image-20240108110814458.png" alt="image-20240108110814458" style="zoom:40%;" /></li></ul></li></ul><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul><li><p>最小代价生成树：各边权的总和为最小的生成树</p></li><li><p>逐步求解(Grandy)策略：</p><ul><li>设：连通网络<br>N&#x3D;{V,E}, V 中有 n 个顶点。<ul><li>先构造 n 个顶点， 0 条边的森林 F&#x3D;{T0 ,T1 ,…..,Tn-1}</li><li>每次向 F 中加入一条边。该边是一端在 F 的某棵树Ti上而另一端不在Ti上的所有边中具有最小权值的边。这样使F中两棵树合并为一棵，树的棵数 - 1</li><li>重复n - 1次</li></ul></li></ul></li><li><p>Kruskal算法</p><ul><li><img src="image-20240108114809407.png" alt="image-20240108114809407" style="zoom:50%;" /></li><li><p>图用邻接矩阵表示，顶点信息在顶点表Verticelist中，取最小的边利用最小堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> edgesAccepted;<br>    DisjSet s;<br>    PriorityQueue h;<br>    Vertex u, v;<br>    SetType uset, vset;<br>    Edge e;<br>    <span class="hljs-comment">// 从图中读取边并构建最小堆</span><br>    h = readGraphIntoHeapArray();<br>    h.buildHeap();<br>    <span class="hljs-comment">// 初始化并查集和边的数量</span><br>    s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisjSet</span>(NUM_VERTICES);<br>    edgesAccepted = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环直到生成树中的边数量达到 NUM_VERTICES - 1</span><br>    <span class="hljs-keyword">while</span> (edgesAccepted &lt; NUM_VERTICES - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从最小堆中取出权值最小的边</span><br>        e = h.deleteMin(); <span class="hljs-comment">// Edge e = (u, v)</span><br>        <span class="hljs-comment">// 查找边两端节点所在的集合</span><br>        uset = s.find(u);<br>        vset = s.find(v);<br>        <span class="hljs-comment">// 如果两个节点不在同一集合，说明加入这条边不会形成环</span><br>        <span class="hljs-keyword">if</span> (uset != vset) &#123;<br>            edgesAccepted++;<br>            <span class="hljs-comment">// 合并两个点集合</span><br>            s.union(uset, vset);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Prim算法</p><ul><li><img src="image-20240108115459395.png" alt="image-20240108115459395" style="zoom:50%;" /></li><li><img src="image-20240108115748149.png" alt="image-20240108115748149" style="zoom:50%;" /></li><li>算法实现<ul><li><img src="image-20240108121334560.png" alt="image-20240108121334560" style="zoom:50%;" /></li><li><img src="image-20240108121352722.png" alt="image-20240108121352722" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li><p>含非负权值的单源最短路径(Dijkstra)</p><ul><li><p>目标：得到指定点V0到所有其他点的最短路径</p></li><li><p>第一步：先排出V0点到所有目标点的直接路径（不可达用∞）</p></li><li><p>第二步：从中挑出最短的那一条，放入结果区，即V0到该点最短路径</p></li><li><p>第三步：根据新加入结果区的那一条路径更新路径表（比较取短的）</p></li><li><p>重复以上步骤n - 1次即可得到结果</p></li><li><img src="image-20240108141408779.png" alt="image-20240108141408779" style="zoom:50%;" /></li></ul></li><li><p>边上权值为任意值的单源最短路径（贝尔曼-福特）</p><ul><li><p>目标：在边上权值可以为负数的情况下，寻找指定点V0到所有其他点的最短路径</p></li><li><p>算法内容：构造一个最短路径长度数组，dist 1[u]，dist 2[u]，···，dist n-1[u]，其中dist k[u]表示从V0出发最多经过k条边到达终点u的最短路径长度，并且不允许负权重边参与构成回路</p></li><li><p>递推公式：dist 1[u]&#x3D;Edge[v] [u] ;</p><p>[dist k[u] &#x3D; min{dist k-1[u] , min{dist k-1[j] + Edge[j] [u] } }      {j &#x3D; 0,1,2,…,n - 1}</p></li><li><img src="image-20240108143316318.png" alt="image-20240108143316318" style="zoom:50%;" /></li></ul></li><li><p>所有顶点之间的最短路径(Floyed)</p><ul><li>前提：各边权值均大于0的带权有向图。</li><li>算法内容：<ul><li>设A为原邻接矩阵，在A上作n次迭代，设每次迭代结果分别为A1，A2······An</li><li>迭代方法（自己理解的）：对于An，取矩阵An-1的第n行和第n列为基准，对于aij（基准行列上的可以剔除），用以它为中心的十字与基准行列交叉得到两个数据相加，若结果小于当前的aij，则更新aij</li><li>最后得到的An对应的path矩阵aij对应i-&gt;j最短路径的 j 前最后一个点</li></ul></li></ul></li></ul><h3 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h3><ul><li><p>用顶点表示活动的网络（AOV网络）</p><ul><li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网</li><li>直接前驱、直接后继：&lt;i,j&gt; 是网中一条弧，则 i 是 j 的直接前驱，j是 i 的直接后继</li><li>前驱、后继：从顶点 i 到顶点 j 有一条有向路径，则称 i 是 j 的 前驱，j 是 i 的后继</li><li>不能出现有向环</li><li>有向图G&#x3D;(V,E),V 里结点的线性序列（vi1 ,vi2 ,…,vin）如果满足：在 G 中从结点vi 到vj 有一条路径，则序列中结点vi 必先于结点vj，称这样的线性序列为一拓扑序列。</li><li>拓扑排序：求拓扑序列<ul><li>从图中选择一个入度为 0 的结点输出之。（如果一个图中，同时存在多个入度为0的结点，则随便输出哪一个结点）</li><li>从图中删掉此结点及其所有的出边。</li><li>反复执行以上步骤，直到所有结点都输出了，则算法结束；如果图中还有结点，但入度不为 0 ，则说明有环路</li></ul></li></ul></li><li><p>用边表示活动的网络（AOE网络）</p><ul><li><p>顶点：表示事件(event)，它的入边代表的活动已完成，它的出边代表的活动可以开始</p></li><li><p>有向边：表示活动，边上的权表示完成一项活动需要的时间</p></li><li><p>有唯一的入度为0的开始结点，唯一的出度为0的完成结点</p></li><li><p><strong>关键路径（Critical Path）：</strong> 是指由一系列关键活动组成的路径，即具有从开始顶点(源点)-&gt;完成顶点(汇点)的最长的路径，其总持续时间等于项目的最短完成时间。</p></li><li><p>找关键活动算法中一些量的定义</p><ul><li>Ve[i]：表示事件 V i 的可能最早发生时间，定义为从源点V0到Vi 的最长路径长度 , 如 Ve[4]&#x3D;7 天</li><li>Vl[i]：表示事件 Vi 的允许的最晚发生时间。是在保证汇点Vn-1在Ve[n-1] 时刻完成的前提下，事件<br>Vi允许发生的最晚时间＝ Ve[n-1] - Vi到Vn-1的最长路径长度。</li><li><img src="image-20240108161745262.png" alt="image-20240108161745262" style="zoom: 40%;" /></li><li>e[k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的可能的最早开始时间。即等于事件Vi 的可能最早发生时间。e[k]&#x3D;Ve[i]</li><li>l [k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的允许的最迟开始时间。l[k] &#x3D; Vl [j] - &lt;i, j&gt;</li><li>e[k] - l [k]表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间</li><li>若松弛时间为0，则ak为关键事件</li></ul></li><li><p>找关键活动算法步骤</p><ul><li><p>求各事件的可能最早发生时间：从Ve[0]&#x3D;0开始，向前推进求其它事件的Ve</p><p>（Ve[i] &#x3D; max{ Ve[j] + dur(&lt;Vj ,Vi &gt;) }<img src="image-20240108203531665.png" alt="image-20240108203531665" style="zoom:40%;" /></p></li><li><p>求各事件的允许最晚发生时间：从Vl [n-1] &#x3D; Ve[n-1]开始，反向递推</p><p>Vl [i]&#x3D;min{ Vl[j] - dur (&lt;Vi ,Vj &gt;) } <img src="image-20240108203823440.png" alt="image-20240108203823440" style="zoom:40%;" /></p></li><li><p>求e[k]和l [k]，若e[k] &#x3D; l [k]则ak为关键活动</p></li></ul></li></ul></li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><img src="image-20240108155038706.png" alt="image-20240108155038706" style="zoom:67%;" /></li><li><img src="image-20240108155112178.png" alt="image-20240108155112178" style="zoom: 67%;" /></li><li>分类<ul><li>内排序：对内存中的 n 个对象进行排序 。(插入排序，交换排序，选择排序，归并排序，基数排序)</li><li>外排序：内存放不下，还要使用外存的排序。</li></ul></li><li>稳定性：如果待排序的对象序列中，含有多个关键码值相等的对象，用某种方法排序后，这些对象的相对次序是不变的，则是稳定的，否则为不稳定</li><li>算法分析：<ul><li>时间开销：比较次数 + 移动次数</li><li>所需的附加空间</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>直接插入排序：<img src="image-20240108195151936.png" alt="image-20240108195151936" style="zoom:50%;" /><ul><li>最优：原数据按大小顺序排列，比较次数n - 1，移动次数0</li><li>最差：原数据按大小逆序排列，比较次数1 + 2 + ··· + n - 1 &#x3D; O(n^2)，移动次数(1 + 2) + ··· + (n - 1 + 2) &#x3D; O(n^2)</li></ul></li><li><del>折半插入排序</del> <strong>不考</strong><ul><li>对于已排序的部分，使用二分查找的方法，将插入位置的搜索范围缩小一半，从而提高排序的效率。</li><li>O(n * log2 n)</li></ul></li><li>希尔排序<ul><li>取一增量（间隔 gap&lt;n ），按增量分组，对每组使用直接插入排序或其他方法进行排序。</li><li>减少增量（分的组减少，但每组记录增多）。直至增量为1，即为一个组时。</li><li><img src="image-20240108200440789.png" alt="image-20240108200440789" style="zoom:50%;" /></li><li>算法分析：与选择的缩小增量有关，但到目前还不知如何选择最好结果的缩小增量序列。</li></ul></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ul><li>冒泡排序<ul><li>从头到尾做一遍相邻两元素的比较有颠倒则交换，记下交换的位置。一趟结束，一个或多个最大(小)元素定位。</li><li>去掉已定位的的元素，重复上一步，直至一趟无交换。</li><li>算法分析：最优n-1 次比较，0次移动；最差：(n - 1) + (n - 2) + ··· + 1次比较和交换</li></ul></li><li>快速排序 <strong>重要</strong><ul><li>在 n 个对象中，取一个对象(如第一个对象 -&gt; 基准pivot),按该对象的关键码把所有&lt;&#x3D;该关键码的对象分划在它的左边。&gt; 该关键码的对象分划在它的右边。</li><li>对左边和右边（子序列）分别再用快速排序。</li><li><img src="image-20240108210555872.png" alt="image-20240108210555872" style="zoom:50%;" />- j指针一直左移，直到它指的数比i指的数(基准)小，然后交换i、j所指数，i右移一位，继续该过程- 当i、j相遇，本轮快排完成</li><li>算法分析<ul><li><img src="image-20240108210823462.png" alt="image-20240108210823462" style="zoom:50%;" /><img src="image-20240108210953952.png" alt="image-20240108210953952" style="zoom:50%;" /></li><li>平均时间复杂度：O(n * log2 n)</li></ul></li></ul></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>直接选择排序<ul><li>思想：首先在n个记录中选出关键码最小（最大）的记录，然后与第一个记录（最后第n 个记录）交换位置，再在其余的n-1 个记录中选关键码最小（最大）的记录，然后与第二个记录（第n-1个记录）交换位置，直至选择了n-1个记录。</li><li>比较次数：n - 1 + n - 2 + ··· + 1 &#x3D;n * (n - 1) &#x2F; 2&#x3D;O(n^2)</li></ul></li><li>堆排序<ul><li>思想：第一步，建堆，根据初始输入数据，利用堆的调整算法，形成初始堆。第二步，一系列的对象交换和重新调整堆</li><li>算法分析：调整n - 1次(FilterDown)，时间为 O(n * log2 n)；交换次数为2n次，时间为O(n)；总复杂度为O(n * log2 n)</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>步骤</p><ul><li><strong>分解（Divide）：</strong> 将待排序的序列分解成两个子序列，通常是平均划分。这一步鼓励递归的应用，直到每个子序列只有一个元素。</li><li><strong>解决（Conquer）：</strong> 递归地对每个子序列进行排序。当子序列长度为1时，它已经是有序的。</li><li><strong>合并（Combine）：</strong> 将已排序的子序列合并成一个新的有序序列。这是归并排序的关键步骤。</li></ul></li><li><p>算法分析：合并趟数 log 2 n, 每趟比较 n 次，所以为 O(n log2 n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    Comparable[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[a.length];<br>    mergeSort(a, tmpArray, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        mergeSort(a, tmpArray, left, center);<br>        mergeSort(a, tmpArray, center + <span class="hljs-number">1</span>, right);<br>        merge(a, tmpArray, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> leftPos, <span class="hljs-type">int</span> rightPos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftEnd</span> <span class="hljs-operator">=</span> rightPos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpPos</span> <span class="hljs-operator">=</span> leftPos;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numElements</span> <span class="hljs-operator">=</span> rightEnd - leftPos + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;<br>        <span class="hljs-keyword">if</span> (a[leftPos].compareTo(a[rightPos]) &lt;= <span class="hljs-number">0</span>) &#123;<br>            tmpArray[tmpPos++] = a[leftPos++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpArray[tmpPos++] = a[rightPos++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd) &#123;<br>        tmpArray[tmpPos++] = a[leftPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (rightPos &lt;= rightEnd) &#123;<br>        tmpArray[tmpPos++] = a[rightPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numElements; i++, rightEnd--) &#123;<br>        a[rightEnd] = tmpArray[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计网重点"><a href="#计网重点" class="headerlink" title="计网重点"></a>计网重点</h1><span id="more"></span><img src="OSI.jpg" style="zoom:100%;" /><img src="transfer.png" style="zoom:100%;" /><img src="transfer2.jfif" style="zoom:100%;" /><ul><li><p>数据传输过程梳理</p><p>发送方：</p><ul><li>第一步：发送方从应用程序出发，应用层产生数据，表示层进行格式转换，会话层管理应用程序间的连接</li><li>第二步：数据进入传输层，如果是UDP，直接加上首部后进入网络层；如果是TCP，将数据进行切片变成数据段（segment），先建立连接，然后加上TCP报文首部，进入网络层</li><li>第三步：网络层IP协议加上IP报头封装成IP数据包</li><li>第四步：数据链路层的LLC和MAC子层先后加上其对应的报头，将数据包封装成数据帧<ul><li>此过程中若未知MAC地址，通过ARP协议获取</li></ul></li><li>第五步：数据帧进入物理层，作为比特流开始发送</li></ul><p>分情况：</p><ul><li>局域网内：比特流传给目标主机解析</li><li>局域网外：比特流传给路由器连接本网段的端口（网关），路由器的物理层、数据链路层、网络层等对其进行解析，根据目标IP地址进行路由决策，然后从对应的端口再次封装成数据包，进行转发（线路传播时以比特流形式）；对应网络的路由器收到后再进行这些过程之后把数据包再传输给目标主机</li></ul><p>接收方：</p><ul><li><strong>物理层：</strong><ul><li><strong>比特流接收：</strong> 接收方的物理层负责从传输媒介（电缆、光纤等）接收比特流。</li></ul></li><li><strong>数据链路层：</strong><ul><li><strong>帧解析：</strong> 物理层传递的比特流被数据链路层接收，数据链路层负责解析帧，提取出帧头和帧尾，确保帧的完整性。</li><li><strong>MAC地址比对：</strong> 数据链路层检查帧中的目标MAC地址，与接收设备的MAC地址进行比对，以确定是否是发给自己的帧。</li><li><strong>数据帧提取：</strong> 如果目标MAC地址匹配，数据链路层提取出帧中的数据部分。</li></ul></li><li><strong>网络层：</strong><ul><li><strong>IP头解析：</strong> 数据链路层提供的数据帧中包含IP数据包，网络层解析IP头，提取源IP地址和目标IP地址。</li></ul></li><li><strong>传输层：</strong><ul><li><strong>TCP&#x2F;UDP头解析：</strong> 如果使用TCP或UDP协议，传输层解析TCP或UDP头，提取端口号等信息。</li></ul></li><li><strong>应用层：</strong><ul><li><strong>数据交付应用程序：</strong> 最终，数据交付给应用层，应用层根据协议和数据的特定格式进行解析，将数据交付给目标应用程序进行进一步处理</li></ul></li></ul></li><li><p>网络拓扑</p><img src="17.png" style="zoom:50%;" /><ul><li>最可靠的是网状拓扑（mesh）</li></ul></li><li><p>多层ISP结构的Internet</p><img src="5.png" style="zoom: 40%;" /><ul><li>互联网服务提供商(ISP,Internet Service Providers)</li><li>第一层ISP是核心层，主要负责远距离连通。</li><li>这种多层ISP结构可以将大量的流量本地化</li><li>NAP(Network Access Point):第一二层之间的接入点,也可以是google(大公司)直接和第一层ISP进行链接</li><li>ICP(Internet Content Provider):互联网内容提供商,不提供接入服务</li><li>在低层次的ISP可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li></ul></li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="局域网介质"><a href="#局域网介质" class="headerlink" title="局域网介质"></a>局域网介质</h3><ul><li>UTP (无屏蔽双绞线 Unshielded Twisted Pair)<ul><li>由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限)</li><li>易于安装且成本较低，线薄接口小</li><li>与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声和干扰</strong></li><li>双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)<strong>短</strong></li></ul></li><li>同轴电缆 Coaxial<ul><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，比双绞线传输更加远，成本也要高一点</li></ul></li><li>光缆 Fiber-Optic<ul><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ul></li><li>光缆模式<ul><li>单模式：单个光传输</li><li>多模式：多根光不同角度传输 Multi-mode</li></ul></li><li>无线通信<ul><li>激光</li><li>红外线</li><li>无线电波</li></ul></li></ul><h3 id="UTP-for-Ethernet"><a href="#UTP-for-Ethernet" class="headerlink" title="UTP for Ethernet"></a>UTP for Ethernet</h3><blockquote><p>UTP线分类见笔记</p></blockquote><h3 id="介质和信号问题"><a href="#介质和信号问题" class="headerlink" title="介质和信号问题"></a>介质和信号问题</h3><ul><li>信令和通信问题<ul><li>传播(本质是电磁波)延迟</li><li>衰减 Attenuation</li><li>反射 Reflection</li><li>噪声(电子干扰) Noise</li></ul></li><li>冲突和冲突域<ul><li>当两个位元在同一网路上同时传播时，会发生碰撞</li><li>分割冲突域：将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中</li><li>通过添加中继器和集线器<strong>扩展</strong>冲突域。</li><li>可以通过添加智能设备(如网桥、交换机和路由器)来<strong>分割</strong>冲突域</li></ul></li></ul><h3 id="数据通信基础概念"><a href="#数据通信基础概念" class="headerlink" title="数据通信基础概念"></a>数据通信基础概念</h3><ul><li><p>概念</p><ul><li><p>码元(code)：在使用<strong>时间域</strong>(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形，是传输基本单位，并不一定只包含一位</p></li><li><p>香农公式：C &#x3D; W log<sub>2</sub>(1 + S&#x2F;N) bps（C：最高数据传输速率，W：带宽Hz，S：信号功率，N：噪声功率）</p></li><li><p>波特率(调制速率)：波信号每秒钟变化的次数</p></li><li><p>比特率：每秒钟传送的二进制位数</p></li><li><p>传输过程：</p><img src="16.png" style="zoom:50%;" /></li></ul></li><li><p>数字数据编码</p><ul><li>将数字数据转换到模拟信号：调制</li><li>将数字数据转换到数字信号：线路编码<ul><li>线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波</li></ul></li></ul></li><li><p>编码方式的分类</p><ul><li><p>单极性编码:一个正极或者负极，用0电平表示”0”，正电平表示”1”</p></li><li><p>极化编码：不归零制码(NRZ: Non-Return to Zero)</p><ul><li>不归零电平编码：用负电平表示”0”，正电平表示”1” (或相反)，一定的中和</li><li>不归零反相编码：信号电平的一次<strong>翻转</strong>代表比特1，无电平变化代表0</li></ul></li><li><p>极化编码：归零制码(RZ: Return to Zero)</p><img src="19.png" style="zoom: 80%;" /><ul><li>用负电平表示”0”，正电平表示”1”(或 相反)，比特中位跳变到零电平，从而提供同步</li></ul></li><li><p>极化编码：曼彻斯特码(Manchester)</p><img src="20.png" style="zoom: 80%;" /><ul><li>每一位中间都有一个跳变，从低跳到高表示”0”，从高跳到低表示”1”</li></ul></li><li><p>极化编码：差分曼彻斯特码(Differential Manchester)</p><img src="21.png" style="zoom:50%;" /><ul><li>每一位中间跳变：表示时钟</li><li>每一位位前跳变：表示数据：有跳变表示”0”，无跳变表示”1”</li></ul></li><li><p>双极性编码：双极性传号交替反转码(AMI)</p><img src="22.png" style="zoom: 80%;" /><ul><li>采用三个电平：正、负与零，零电平表示”0”，正负电平的跃迁表示 “1”，实现对”1”电平的交替反转</li></ul></li></ul></li><li><p>多路复用</p><ul><li><p>时分复用TDM：时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙</p><img src="25.png" style="zoom:50%;" /></li><li><p>统计时分复用 STDM (Statistic TDM)</p><img src="26.png" style="zoom:50%;" /></li><li><p>频分复用 FDM：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p></li><li><p>波分复用 WDM：波分复用就是光的频分复用：频率和波长是成倒数关系的</p></li><li><p>码分复用 CDM：用户采用相同频率，但是对于数据编码进行变换</p></li></ul></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>主要任务</p><ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li><strong>流控制</strong>(Flow control)</li></ul></li><li><p>用帧组织比特流</p></li><li><p>提供三种服务</p><ul><li><p>不带有确认的无连接服务</p></li><li><p>带有确认的无连接服务：无线网</p></li><li><p>带有确认的有连接服务：蓝牙</p></li></ul></li><li><p>与物理层的对比</p></li></ul><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织&#x2F;分组比特</td></tr></tbody></table><ul><li>局域网三种传输方式<ul><li>单播：将单个数据包从源发送到网络上的单个目标</li><li>多播：由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播：单个数据包传输到网络上的所有节点</li></ul></li><li>多播地址<ul><li>IPv4 中的多播地址是从 224.0.0.0 到 239.255.255.255 的范围</li><li><strong>224.0.0.0 - 224.0.0.255：</strong> 为系统保留，用于本地网络控制块。</li><li><strong>224.0.1.0 - 224.0.1.255：</strong> 为路由信息协议（Routing Information Protocol, RIP）的用途保留。</li><li><strong>224.0.0.0&#x2F;4：</strong> 称为预留地址空间，用于各种用途。</li><li><strong>232.0.0.0 - 232.255.255.255：</strong> 为源特定多播（Source-Specific Multicast, SSM）保留。</li></ul></li></ul><h3 id="以太网与带冲突检测的载波侦听多路访问（CSMA-CD）"><a href="#以太网与带冲突检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）"></a>以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）</h3><ul><li><p>IEEE 802.2、802.3、802.5</p><ul><li><p>LLC子层（802.2）</p><ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li><li><p>MAC子层（802.3）</p><ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li><li><strong>802.3 覆盖了物理层和第二层下半层</strong></li></ul></li><li><p>令牌环（802.5）</p><ul><li>在令牌环网络中，计算机连接成一个物理环或逻辑环，数据包通过一个称为“令牌”的特殊控制帧在环上传递。令牌是一种允许持有它的设备在网络上传递数据包的权限标记。</li></ul></li></ul></li><li><p>帧结构</p><ul><li>前同步码：8字节（不算在帧长度里）</li><li>目标地址：6字节</li><li>源地址：6字节</li><li>长度&#x2F;类型：2字节</li><li>数据：46(18 + 46 &#x3D; 64字节) ~ 1500字节</li><li>FCS字段（包含循环冗余校验码）：4字节</li></ul></li><li><p>最短帧长：64字节</p></li><li><p>LLC子层对数据包进行封装并添加控制信息，然后交给MAC子层进一步封装</p></li><li><p>MAC子层</p><ul><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong></li><li>广播目标MAC：全1(FFFF.FFFF.FFFF)，仅在未知目的主机MAC和目的主机为全部主机时使用</li><li>以太网是广播网络</li></ul></li><li><p>以太网的CSMA&#x2F;CD</p><img src="11.png" style="zoom:50%;" /><ol><li>首先设备要发送数据</li><li>开始侦听链路是否忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam signal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完链路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol></li></ul><h3 id="无线局域网的CSMA-CA"><a href="#无线局域网的CSMA-CA" class="headerlink" title="无线局域网的CSMA&#x2F;CA"></a>无线局域网的CSMA&#x2F;CA</h3><ul><li><p>无线局域网分类</p><ul><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ul></li><li><p>一些名词</p><ul><li>BSS：基础服务集</li><li>BS：基站</li><li>AP：无线接入点</li></ul></li><li><p>无线局域网标准</p><ul><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5 GHz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为”速率加倍”的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ul><img src="13.png" style="zoom:50%;" /></li><li><p>数据帧结构</p></li><li><p>无线网络的CSMA&#x2F;CA</p><ul><li>A向B发送RTS(Request To Send，请求发送)帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A；</li><li>B向A回答CTS(Clear To Send，清除发送)帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据；</li><li>A开始发送</li><li>若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。(A和C同时发送RTS)</li></ul></li></ul><img src="16-1746703648396.png" style="zoom: 50%;" /><ul><li><img src="data_link_layer-1-CSMACA.png" style="zoom: 33%;" /></li><li><p>WLAN和以太网区别</p><table><thead><tr><th>Ethernet</th><th>WLAN</th></tr></thead><tbody><tr><td>信号被传输到连接在线缆上的所有站点上</td><td>信号只被传输到接近发送站点的站点</td></tr><tr><td></td><td>接受站点检测冲突</td></tr><tr><td>只会有一个有效帧在信道上传播</td><td>会有多个有效帧同时在信道上传播</td></tr><tr><td></td><td>MAC协议必须尽可能保证只有发送站点接近接收站点</td></tr></tbody></table></li></ul><h3 id="第二层设备"><a href="#第二层设备" class="headerlink" title="第二层设备"></a>第二层设备</h3><ul><li><p>网桥、交换机：具体见笔记</p></li><li><p>分割冲突域：</p><p><strong>网桥</strong></p><ul><li>用网桥来分割局域网的以太网，给每个用户提供更多带宽，因为每个网段上用户更少</li><li>网桥增加了10%~30%的网络延迟，因为需要做决定</li></ul><p><strong>交换机</strong></p><ul><li>交换机比网桥更快，因为他们在硬件中交换，然而网桥在软件中交换</li><li>局域网交换机减小了冲突域的大小</li><li>所有连接到交换机的主机仍然在同一个广播域中</li></ul><p><strong>路由器</strong>（第三层）</p><ul><li>路由器可以创建最高级别的细分：<ol><li>创建较小的<strong>冲突域</strong></li><li>创建较小的<strong>广播域</strong>：除非经过编程，否则路由器不会转发广播。</li></ol></li><li>路由器通过检查数据包上的<strong>目标逻辑地址</strong>，然后在其路由表中查找转发指令来完成数据包的转发</li><li>由于路由器比网桥执行更多的功能，因此它们以更高的延迟率运行。</li><li>路由器可以用作<strong>网关</strong>，用于连接不同的网络媒体和不同的LAN技术</li><li>是根据逻辑地址(IP地址)进行转发，不再是MAC</li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)    <strong>Q：到底能不能流量控制</strong></li><li>路由器<ul><li>互连网段或网络(不同网段的分割)</li><li>根据IP地址做出合理的决定</li><li>确定最佳路径，根据路由表。</li><li>将数据包从入站端口切换到出站端口</li></ul></li><li>广播域划分：如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发送的是<strong>本网段</strong>的广播地址，路由器则不会进行转发</li></ul><h3 id="IP地址和子网划分"><a href="#IP地址和子网划分" class="headerlink" title="IP地址和子网划分"></a>IP地址和子网划分</h3><ul><li><p>IPv4报文结构（具体见笔记）</p><img src="3.png" style="zoom:50%;" /></li><li><p>IP地址</p><ul><li><p>IP地址为32位长(IPv4中)</p></li><li><p>它们以点分十进制格式表示为四个八位字节：133.14.17.0</p></li><li><p>IP地址包含两个组成部分：</p><ol><li>网络ID</li></ol></li></ul><ol start="2"><li>主机ID</li></ol><ul><li><p>分类：</p><ul><li>0–127 Class A address A类地址</li><li>128-191 Class B address B类地址</li><li>192–223 Class C address C类地址</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)</li><li>240–255 Class E - Research  E类地址：研究</li><li>host不能全取0，也不能全取1。全取0：网络地址；全取1：广播地址</li></ul></li><li><p>专用地址&#x2F;私有地址：用于局域网内部网段</p><blockquote><p>10.0.0.0 - 10.255.255.255<br>172.16.0.0 - 172.31.255.255<br>192.168.0.0 - 192.168.255.255</p></blockquote></li></ul></li><li><p>子网</p><img src="11-1746703659590.png" style="zoom: 67%;" /><img src="12.png" style="zoom: 50%;" /><ul><li><p>借用的最小位数是2，为什么？</p><ol><li>如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。</li><li>两位的时候，01和10给Host，00为网络ID，11为广播地址</li><li>全0可能导致误判</li></ol></li><li><p>子网掩码：网络位全1，主机位全0</p><p>计算子网网络地址：子网地址和子网掩码按位与</p><p>计算过程见笔记</p></li></ul></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul><li>端口与网关<ul><li>接口是路由器连接到网络的附件，在IP路由中也可以称为<strong>端口。</strong></li><li>这个IP地址往往被作为这个<strong>网络的网关</strong></li><li>每个接口必须具有一个单独的唯一网络地址</li></ul></li><li>IP地址分配<ul><li>静态地址分配</li><li>动态地址分配：<ul><li>RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。ARP为IP到MAC的转换，而RARP为MAC到IP的转换，向RARP服务器请求分配IP。主要流程：发出要反向解析的物理地址并希望返回其对应的IP地址。发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个 IP 地址。 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的 IP 地址。 如果存在，RARP服务器器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用; 如果不存在，RARP服务器对此不做任何的响应。 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯;如果一直没有收到RARP 服务器的响应信息，表示初始化失败。</li><li>BOOTstrap协议。用于工作栈</li><li>DHCP: Dynamic Host Configuration Protocol. (比较多用)动态主机配置协议</li></ul></li></ul></li><li>ARP协议（地址解析协议）<ul><li>源主机访问目的主机不知道对方MAC，优先查找本地ARP表（时效性）</li><li>若ARP表中没有，将目标MAC设为全1进行广播，发送ARP请求<ul><li>若目标主机在局域网内，它收到ARP请求后检查IP地址发现与自己IP一致，将自己的MAC放进帧中发送给源主机</li><li>若目标主机处于另一个网络，则路由器会将自己的MAC作为目标主机MAC给源主机，此后源主机的帧由路由器转发给目的主机（代理ARP）</li><li>此过程中所有收到帧的主机都会将发送方MAC存进自己的ARP表</li></ul></li></ul></li><li>默认网关<ul><li>除了代理ARP，还可以通过默认网关与另一网络设备通信</li><li>默认网关是路由器上连接到源主机所在网段的<strong>接口的IP地址</strong></li><li>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong></li></ul></li></ul><h3 id="网络协议操作"><a href="#网络协议操作" class="headerlink" title="网络协议操作"></a>网络协议操作</h3><ul><li>Routed protocol 被动可路由协议<ul><li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li><li>然后请求路由表可以发现目的网段对应端口</li><li>再次将报文封装转发给对应的主机</li><li>路由表是存储在内存中的</li></ul></li><li>管理距离<ul><li>管理距离（Administrative Distance）是路由选择过程中一个用于衡量路由可信度的参数。在多路由协议环境中，可能存在多个路由到达相同目的地的候选项，管理距离用于确定使用哪个路由信息。较低的管理距离值表示路由更可信。</li><li>直接连接（Connected）：0</li><li>静态路由（Static Route）：1</li><li>Enhanced Interior Gateway Routing Protocol (EIGRP)：90</li><li>Open Shortest Path First (OSPF)：110</li><li>Routing Information Protocol (RIP)：120</li><li>Border Gateway Protocol (BGP)：200</li><li>当未指定管理距离时，使用以上默认值（default）</li></ul></li><li>静态路由和动态路由的区别<ul><li>静态路由<ol><li>用于<strong>隐藏</strong>部分网络。安全(不必进行路由表的交换)</li><li>测试网络中的特定链接。</li><li>用于仅在到达目标网络的路径时维护路由表。</li></ol></li><li>动态路由<ol><li>维护路由表。</li><li>以路由更新的形式及时分发信息。</li><li>依靠路由协议共享知识。</li><li>路由器可以调整以适应不断变化的网络状况。</li><li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li></ol></li></ul></li><li>被动路由协议和主动路由协议<ul><li>Routed Protocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。</li><li>Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。</li><li>Routing Protocol 决定 Routed Protocols</li></ul></li><li>动态路由协议的分类<ul><li>内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)：可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司网络，学区的网络或政府机构的网络。</li><li>外部网关协议(Exterior Gateway Protocols，EGP，BGP)：用于在<strong>自治系统之间路由数据包</strong>。</li></ul></li><li>内部网关协议的分类：DVP and LSP<ul><li>距离矢量协议(Distance-Vector Protocols，RIP, IGRP):<ol><li>从<strong>邻居</strong>的角度查看网络拓扑，只知道到达一个网段的最少跳数(注意不基于全局)</li><li>在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次)</li><li>经常定期(periodic)更新，即与邻居交换路由信息</li><li>将整个路由表的<strong>副本</strong>传递到邻居路由器。</li></ol></li><li>链路状态协议(Link State Protocols, OSPF):<ol><li>获取整个网络拓扑的通用视图。(全局的视角，会有代价)</li><li>计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据)</li><li><strong>事件</strong>触发的更新。如果没有事件发生那么就不会更新</li><li>将链接状态路由更新传递给其他路由器。</li><li>LSP操作过程:<ol><li>相互交换彼此学到对应的Topological Database(是全局的信息)</li><li>之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li><li>根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。</li></ol></li></ol></li></ul></li><li>RIP（典型DVP）<ul><li>基于DVP</li><li>唯一的指标是跳数。</li><li>最大跳数为15。(评判依据简单，是一个短板)</li><li><strong>每30秒更新一次(广播)，可以修改</strong></li><li>并非总是选择最快的路径(而是走跳数最短的路径)。</li><li>产生大量的网络流量。</li></ul></li><li>OSPF(Open Shortest Path First)：典型LSP<ul><li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li><li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，<strong>本科阶段只考虑带宽的。</strong></li><li><strong>事件触发更新</strong></li><li>在LSP中用的比较多。它节约了带宽资源，需要host的CPU资源来执行算法。将最小生成树转化成路由表</li><li>最快和什么有关？(最快指的是带宽)<ol><li>和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关</li><li>带宽表示为代价，带宽和代价成<strong>反比</strong></li></ol></li></ul></li><li>IGRP (Interior Gateway Routing Protocol)和EIGRP (Enhanced IGRP)<ul><li>思科开发的一种用于在较大的企业网络中进行内部路由选择的距离矢量路由协议。它是专有协议，用于在局域网（LAN）和广域网（WAN）中的路由器之间交换路由信息。</li><li>IGRP最大跳数为255，每90秒更新一次。</li><li>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</li></ul></li></ul><h3 id="VLSM（可变长子网掩码）"><a href="#VLSM（可变长子网掩码）" class="headerlink" title="VLSM（可变长子网掩码）"></a>VLSM（可变长子网掩码）</h3><ul><li><h4 id="经典路由-Classful-routing，有类路由-无子网掩码"><a href="#经典路由-Classful-routing，有类路由-无子网掩码" class="headerlink" title="经典路由(Classful routing，有类路由) 无子网掩码"></a>经典路由(Classful routing，有类路由) 无子网掩码</h4><ol><li>有类的路由协议要求单个网络使用相同的子网掩码。</li><li>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</li><li>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</li></ol></li><li><p>VLSM特点</p><ul><li>VLSM允许组织<strong>在同一网络地址空间内使用多个子网掩码</strong></li><li>实施VLSM通常被称为”子网划分”，可用于最大化寻址效率</li><li>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一</li><li>会导致地址空间的浪费:广播地址和网络号都无法被使用</li><li>更好的路由聚合(aggregation):构建超网</li><li>全0子网是否可用看题目，全1子网不可用</li></ul></li><li><p>计算过程**（重要）**</p><ul><li>第一步：先对划分的子网按主机需求量排序，按从大到小计算</li><li>第二步：分别对每个子网进行计算<ul><li>每个子网第一个为网络地址，最后一个为广播地址</li><li>下一个子网从前一个最后的地址（广播）后一个开始</li><li>在每个子网分配完后，最后需要对WAN分配地址，每个WAN（两两连接）需要2个网络地址（两个路由器双方的端口），所以需要2位主机号（还需要网络号和广播地址）</li></ul></li><li>总结<ul><li>重要的是要记住，只有未使用的子网才能进一步划分子网。</li><li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li><li>一般是从主机多大到主机少(路由间网络)进行划分</li></ul></li></ul></li><li><p>CIDR（Classless Inter Domain Routing，无类域间路由）</p><ul><li><strong>无类别地址块：</strong> CIDR不再依赖于固定的类别，而是将IP地址块视为连续的一段。这样，IP地址可以更灵活地分配，而不受限于A、B、C类别。</li><li><strong>前缀表示法：</strong> CIDR使用前缀表示法，例如，192.168.1.0&#x2F;24，其中“&#x2F;24”表示子网掩码中的前24位是网络部分，剩余的8位是主机部分。</li><li><strong>地址聚合：</strong> CIDR支持对相邻的地址块进行聚合，减少了路由表的大小。这对于减少路由表的条目数量，提高路由表的效率非常重要。</li></ul></li><li><p>路由聚合</p><ul><li>多个路由条目汇聚成小的路由条目，使用了CIDR和VLSM</li><li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少</li><li>方法</li></ul><img src="60.png" style="zoom:50%;" /><blockquote><p>如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果</p></blockquote></li></ul><h3 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议 ICMP"></a>因特网控制报文协议 ICMP</h3><ul><li>概述<ul><li>ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)</li><li>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</li><li>ICMP 只是IP层的协议</li><li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li><li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个<strong>ICMP差错报文</strong>。</li></ul></li></ul><img src="61.png" style="zoom: 50%;" /><ul><li><p>分类</p><ul><li>查询报文</li><li>差错报告报文</li></ul></li><li><p>差错报告报文内容</p><ul><li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li><li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li><li>然后添加一个首部作为IP数据报进行发送</li></ul><img src="63.png" style="zoom: 50%;" /></li><li><p>不应发送 ICMP 差错报告报文的几种情况</p><ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol><li>127.0.0.0:逻辑回路地址</li><li>0.0.0.0:确认路由地址</li></ol></li></ul></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><ul><li>第四层功能<ul><li>分割上层应用程序数据(新的数据单元-数据段)，<strong>第四层只会在终端上有</strong></li><li>建立端到端(end to end)的运营</li><li>从一个终端主机向另一个终端主机发送段**(第三层和第二层不进行可靠性检验，第四层完成可靠性检验）**，接受方认为数据错误，在第四层进行要求重传)</li><li>流量控制和可靠性</li></ul></li><li>第四层重要协议<ul><li>传输控制协议(TCP, Transmission Control Protocol)  <strong>可靠传输</strong>，使用<strong>数据段</strong>作为传输单位</li><li>用户数据报协议(UDP, User Datagram Protocol)，使用<strong>用户数据报</strong>作为传输单位</li><li>SCTP(Stream Control Transmission Protocol)：流控制传输协议，用于<strong>视频和音频的传输</strong></li></ul></li><li>端口<ul><li>TCP和UDP都使用<strong>端口</strong>来跟踪(track)同时穿越网络的<strong>不同会话（即不同进程）</strong></li><li>进程通过端口号来标识</li><li>端口分配规范<ul><li>低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)</li><li>0-1023是熟知端口，有分发的规范，不应当被随意使用</li><li>1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</li><li>49152~65535即为短暂端口号，用于和远端通信</li><li>基于端口号的不同，进行不同的包的分发</li></ul></li></ul></li><li>套接字 Socket<ul><li>第四层进行通信的单位是进程，由IP和端口共同指定。socket是第四层的地址</li><li>套接字表示为(IP地址，端口)</li><li>通讯被认为<strong>是以一个socket和另一个socket之间的连接</strong></li></ul></li></ul><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><ul><li>概述<ul><li><strong>TCP不支持多播和广播</strong></li><li>TCP解决问题：<ul><li>可靠传输</li><li>流传输<ol><li>滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)</li><li>避免拥塞</li></ol></li><li>连接控制<ol><li>建立连接:三次握手</li><li>断开连接:四次握手</li></ol></li></ul></li></ul></li><li>TCP数据报结构</li></ul><img src="2.png" style="zoom:50%;" /><ul><li><p>段的大小必须与IP数据包匹配，并且还必须满足底层的需求</p><ol><li>例如，以太网的MTU(最大传输单位)为1500字节</li><li>是面向字节的传输。</li></ol></li><li><p>每个段都有：</p><ol><li>标头为20个字节(可选部分除外)</li><li>0或更多数据字节(请求连接的时候)</li></ol></li><li><p>TCP建立连接：三次握手</p><img src="8.png" style="zoom:50%;" /><blockquote><p>英文缩写含义：</p><p>SYN：控制信号之一，表示同步序号用于建立连接</p><p>ACK：控制信号之一，表示确认号是否有效</p><p>seq：序号（4字节），标识发送方发送的数据字节的顺序</p><p>ack：确认号（4字节），期望收到的下一个数据段的序号</p></blockquote><ul><li>第一次：<ul><li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li><li>客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求</li></ul></li><li>第二次：服务器检查是否存在监视端口的服务进程<ul><li>如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段</li><li>如果存在进程，则决定拒绝或接受请求</li><li>如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段</li></ul></li><li>第三次：<ul><li>客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接</li><li>为了避免出现延时之类的情况(如果只有两次会浪费服务器资源)</li></ul></li></ul><blockquote><p>有时候我们会选择，第三次握手的时候同时携带数据</p></blockquote></li><li><p>连续ARQ协议</p><ul><li>ARQ (Automatic Repeat reQuest) 自动重传请求：这表示”重新发送请求”为自动发送并且接收方无需请求发送方重新发送错误段</li></ul><img src="12-1746703681176.png" style="zoom:50%;" /><ul><li><p>多个数据同时发送过去(一次发送多个)</p></li><li><p>窗口大小是双方协商的，通过TCP报文中的<strong>窗口字段</strong>表示</p></li><li><p><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong></p></li><li><p>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离</p><img src="14.png" style="zoom:50%;" /></li><li><p>此过程中接收方可在回复报文中设置WIN字段值来改变发送方窗口大小</p></li></ul></li><li><p>TCP结束连接：四次握手</p><img src="21-1746703684266.png" style="zoom: 50%;" /><ul><li>步骤<ul><li>客户端：发起断开连接请求（FIN &#x3D; 1）</li><li>服务器端：Ack &#x3D; 1:允许断开，但是此时并不是断开连接，而是说不在发送新的数据，此时我们需要<strong>完成之前未处理完成的数据的处理</strong>。(这里只是说我已经收到了你请求停止传输的请求)</li><li>服务器端：FIN &#x3D; 1:数据处理完成，注意需要的变化(此时表示<strong>所有的需要处理的数据已经处理完了</strong>，此时表示正式确认断开)</li><li>客户端：确认收到B的断开信息（ACK &#x3D; 1）</li><li>在完全断开连接前，等待最大的网路往返时间(保证能处理到B最后发送的报文)</li></ul></li><li>为什么必须等待2 MSL？（MSL：最大报文段生存时间）<ol><li>为了确保A发送的最后一个ACK可以到达B</li><li>防止出现任何无效的连接请求段：等待2 MSL之后，我们可以确保连接上的所有段（最后一个ACK）均已消失，以免与后续的新连接产生混淆</li></ol></li></ul></li><li><p>TCP中的计时器</p><ul><li>重传计时器：当发送方发送一个数据段后，会启动一个重传计时器。如果在规定的时间内没有收到对应的确认（ACK）或者接收方没有成功接收数据，发送方会认为数据段可能丢失了，就会触发重传机制，重新发送该数据段。</li><li>坚持计时器：在TCP中，发送方可能会使用持续计时器来处理窗口大小为零的情况。当发送方的窗口大小为零时，表明接收方的缓冲区已满，但发送方仍然希望保持连接的活动性。在这种情况下，发送方会启动持续计时器，定期发送窗口探测段以维持连接。</li><li>保持计时器：保活计时器用于检测连接是否仍然处于活动状态。如果在一段时间内没有收到任何数据，保活计时器会触发，并发送保活探测段。这有助于检测连接是否断开，并在必要时终止连接。</li><li>时间等待计时器：在TCP的四次握手结束后，连接的一方会进入TIME-WAIT状态，等待2倍的最大报文段生存时间（2MSL）。这个等待时间由时间等待计时器控制。它确保在TIME-WAIT状态期间，之前的连接的所有报文都已经从网络中消失，以防止新连接与旧连接的报文混淆。</li></ul></li></ul><h3 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h3><ul><li><p>概述</p><ul><li>没有建立连接(避免延时)</li><li>没有拥塞控制：UDP可以按照期望的速度传输</li><li>常用于流媒体、多媒体应用（<strong>速率敏感</strong>）</li><li>应用：RIP（路由信息协议）、DNS（域名解析协议）、SNMP（简单网络管理协议，位于应用层）、TFTP（简单文件传输协议，位于传输层）、DHCP（动态主机配置协议，位于应用层）</li></ul></li><li><p>数据帧格式</p><img src="23.png" style="zoom:67%;" /><ul><li>UDP只有8个字节的首部，所以UDP报文最少是8个字节</li><li>源端口、目的端口、长度、校验(data)、Data</li><li>校验也要对data一并校验，如果出现错误，直接丢弃。</li><li>应用层进行数据切片，决定如何进行发送，UDP直接发送，UDP不会再自己分片了</li></ul></li><li><p>TCP与UDP比较</p><ul><li>TCP<ul><li>不是立即交给上层校验，而是需要先和对方沟通</li><li><strong>缓存满了才统一交付</strong></li></ul></li><li>UDP<ul><li>直接转发报文，保留报文边界</li><li>应用程序会发送比较合适的UDP报文大小进行发送</li></ul></li></ul></li></ul><h3 id="NAT-和-PAT"><a href="#NAT-和-PAT" class="headerlink" title="NAT 和 PAT"></a>NAT 和 PAT</h3><ul><li><p>NAT是在IP数据包头中将一个地址交换为另一个地址的过程</p><ol><li>网络地址转换</li><li>是网络地址即将用完的解决方案</li><li>内部主机发送报文给网关，网关根据NAT Table进行翻译，转换成内部全局地址，然后进行转发</li><li>主要设备：路由器</li></ol><ul><li>在NAT 路由器将局域网地址转换成网络上的地址(双向转换，有一个NAT表)</li><li>路由器会将IP数据包中的地址字段进行修改</li></ul></li><li><p>NAT类型</p><ul><li>静态NAT：固定的内部地址(internal address)到注册地址(registered address)的映射(一开始就写死)</li><li>动态NAT：映射以先到先得的方式动态进行(不是写死，配一个地址池,不断更新)</li><li>PAT(过载，Port address translation)：端口地址转换用于允许许多内部用户共享一个”内部全局”地址(基于Socket映射，而不是IP地址，多个内网主机映射到一个公网地址)</li></ul></li><li><p>NAT地址类型</p><img src="25-1746703689130.png" style="zoom: 50%;" /><ul><li>Inside Local address (内部本地地址):内网IP地址</li><li>Inside Global address (内部全局地址): 注册IP地址, 对外部展示的内部地址</li><li>Outside Global address (外部全局地址):由主机所有者分配的IP地址。通常是注册地址。(对内网而言的外部，是目的地址)</li></ul></li><li><p>PAT</p><img src="29.png" style="zoom:40%;" /><img src="28.png" style="zoom:50%;" /></li></ul><ul><li>基于socket映射</li><li>出口IP相同，通过端口号来区别</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：会话层</h3><ul><li>职责<ul><li>基于令牌进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li><li>进行数据分段、拼接，保证传输的有效。</li><li>同步技术，保证故障恢复</li></ul></li><li>服务<ul><li><strong>半双工通信（Half-Duplex）：</strong> 在半双工通信中，数据可以在通信双方之间进行双向传输，但同一时刻只能有一个方向上的数据传输。这意味着通信的两端能够交替发送和接收数据，但不能同时进行。对讲机就是一个常见的半双工通信的例子，一方说话时，另一方必须听，不能同时说话。</li><li><strong>全双工通信（Full-Duplex）：</strong> 在全双工通信中，通信双方能够同时进行双向数据传输。这意味着每一方都可以独立地发送和接收数据，而不会干扰对方。典型的电话通信就是全双工通信的例子，双方可以同时说话和听对方说话。</li><li><strong>多点通信（Multipoint Communication）：</strong> 多点通信是指多个设备之间进行通信的情境。在多点通信中，一个设备可以与多个其他设备进行通信，而不仅仅是与一个设备进行通信。这包括点对点通信（两个设备之间的直接通信）、广播通信（发送方向网络上的所有设备广播消息）以及多播通信（发送方向特定组中的多个设备发送消息）。</li></ul></li></ul><h3 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：表示层</h3><ul><li>表示层负责以接收<strong>设备可以理解</strong>的形式表示数据</li><li>表示层具有3个主要功能：<ol><li>数据格式(format)</li><li>数据压缩(compression):早期网络比较慢，倾向于先压缩在发送</li><li>数据加密(encryption)</li></ol></li><li>图像文件格式<ul><li>图形交换格式(GIF，Graphic Interchange Format)</li><li>联合图像专家组(JPEG，Joint Photographic Experts Group)。</li></ul></li></ul><h3 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h3><img src="5-1746703695119.png" style="zoom:50%;" /><ol><li><p>上图中各层的一些协议和使用：会话层对端口进行管理</p></li><li><p>第七层对应了应用界面，第六层对应了各种协议</p></li><li><p>应用程序层(最接近用户)支持应用程序的通信组件</p></li></ol><ul><li><p>超文本传输协议 (HTTP，HyperText Transfer Protocol)</p><ul><li><p>统一资源定位符 URL(Uniform Resource Locator)</p><ol><li>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</li><li>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</li><li>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</li><li>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</li><li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ol><li>访问方式:协议HTTPS 或者 HTTP</li><li>主机:域名的方式</li><li>端口对应进程</li><li>路径对应具体的文件</li></ol></li></ol></li><li><p>HTTP</p><ol><li>HTTP 是<strong>面向事务</strong>的客户服务器协议。</li><li>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)。<ol><li>每一次请求是独立的，不记录上一次请求信息。</li><li>Cookie是征求同意的存储(维持登录状态)，可以保证在多个应用之间维持登录状态。</li></ol></li><li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为HTTP daemon， 有的文献将它缩写为 HTTPD。</li><li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户</li></ol></li><li><p>http报文结构</p><img src="7.png" style="zoom: 50%;" /></li><li><p>HTML(HyperText Markup Language)</p><ol><li>定义了许多用于排版的命令(标签)。</li><li>HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。</li><li>仅当HTML文档是以.html或.htm为后缀时，浏览器才对此文档的各种标签进行解释。</li><li>当浏览器从服务器读取HTML文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li><li>HTML用一对标签(一个开始标签和一个结束标签)或几对标签来标识一个元素。</li></ol></li></ul></li><li><p>FTP(File Transfer Protocol) and TFTP(Trivial File Transfer Protocol)</p><ol><li>FTP是一种可靠的，面向连接的服务，它使用TCP传输文件。<ol><li>FTP首先在客户端和服务器(端口21)之间建立<strong>控制连接</strong></li><li>然后，建立第二个连接，这是计算机之间通过其传输数据的链接。(端口20)</li></ol></li><li>TFTP是使用UDP的无连接服务(简化的FTP)<ol><li>体积小，易于实施。更加方便</li><li>例如。 TFTP在路由器上用于传输配置文件和Cisco IOS映像</li><li>不支持交互，没有目录浏览功能</li></ol></li></ol></li><li><p>Telnet 协议</p><ul><li>Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能</li></ul></li><li><p>简单邮件传输协议 SMTP(Simple Mail Transfer Protocol) and POP(Post Office Protocol)</p><ul><li><p>电子邮件服务器使用SMTP发送和POP接收邮件相互通信</p><ul><li>SMTP (Simple Mail Transfer Protocol) SMTP(简单邮件传输协议)邮件发送，登录发送等操作</li><li>POP 3 (Post Office Protocol version 3) 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。</li><li>两者都使用TCP</li></ul></li></ul><blockquote><p>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器，然后用户登录后通过POP3协议收邮件到本地</p></blockquote></li><li><p>简单网络管理协议 SNMP(Simple Network Management Protocol)</p><img src="11-1746703699380.png" style="zoom: 67%;" /><ul><li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li><li>通过管理数据库(MIB)进行信息交流</li><li>使用<strong>UDP</strong>通过广播进行实现。</li></ul></li><li><p>域名系统(DNS, Domain Name System)</p><ul><li><p>多数使用UDP，少数情况TCP（大型网络）</p></li><li><p>Domain Name 域名</p><img src="13-1746703701223.png" style="zoom:67%;" /><ul><li>使用<code>.</code>将字符串进行分隔开，字符串不应该太长</li><li>越靠后域名级别越高</li><li>www就是对应到主机群</li></ul></li><li><p>顶级域 ：TLD (Top Level Domain)</p><ul><li>如<code>.cn</code>、<code>.com</code>、 <code>.edu</code>等，具体见笔记</li></ul></li><li><p>Domain Name Server 域名服务器</p><img src="14-1746703702903.png" style="zoom:50%;" /><ul><li>顶级域名底下的域名就是由顶级域名下面进行管理</li><li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li></ul></li><li><p>结合域名服务器查找IP地址</p><img src="15.png" style="zoom: 67%;" /><ul><li>DNS系统以层次(hierarchy)结构设置，该层次结构创建不同级别的DNS服务器。</li><li>此级别的DNS服务器判断其自身是否能够将域名转换为关联的IP地址：<ol><li>如果可以，则将结果返回给客户端</li><li>如果没有，它将请求发送到更高级别。(向上级请求)</li></ol></li><li>递归地进行查找，下面递归，上面迭代</li></ul></li></ul></li><li><p>应用层沟通的方式</p><ul><li>通信处理发生的一种方式：(无上下文，请求后就断开)<ol><li>当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端。</li><li>处理完成后，连接断开</li></ol></li><li>第二种方式：(有上下文)<ol><li>作为Telnet和FTP，建立与服务器的连接并保持该连接，直到执行所有处理。</li><li>当用户确定他&#x2F;她已完成时，客户端将终止连接。</li></ol></li><li>所有的交流活动都属于这两类之一</li></ul></li><li><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)</p><ul><li><p>概述</p><ul><li>一个协议软件在使用之前先作正确协议配置，具体配置内容取决于协议。</li><li>接到因特网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址</li><li>子网掩码</li><li>默认路由器的 IP 地址</li><li>域名服务器的 IP 地址</li></ol></li><li>Dynamic Host Configuration Protocol可以高效地分配IP地址<ol><li>局域网的网络协议</li><li>使用UDP来实现</li></ol></li><li>目前一般都是自动获取IP地址，而不需要手动去获取IP地址等信息</li></ul></li><li><p>工作过程</p><img src="16-1746703706866.png" style="zoom:60%;" /><ul><li><p>Client先广播Discover报文去搜索（广播携带地址是MAC地址，因为未知server地址）</p></li><li><p>所有Server在IP地址池中查找合法的IP地址，返回一个Offer报文</p></li><li><p>Client选择优先返回的Offer来优先服务</p></li><li><p>Client进行广播，告知接受谁的服务</p></li><li><p>然后B返回一个Ack报文</p></li><li><p>到了时间之后，选择release或者续租</p><ol><li><p>在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP 参数更新自己的配置，IP租用更新完成</p></li><li><p>当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约到时间后，Server会主动询问，如果没有应答会自动释放</p></li></ol></li></ul></li><li><p>DHCP报文类型</p><ul><li>DHCP Discover：发现</li><li>DHCP Offer：提供</li><li>DHCP Request：告知决定</li><li>DHCP ACK：租约确认</li><li>DHCP NAK：租约不确认</li><li>DHCP Release：释放租约</li><li>DHCP Decline:收到Ack后，Client告诉服务器不接受</li><li>DHCP Inform:客户端向服务器端请求详细信息</li></ul></li><li><p>DHCP欺骗：见笔记</p></li></ul></li></ul><h2 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器的内部组件"><a href="#路由器的内部组件" class="headerlink" title="路由器的内部组件"></a>路由器的内部组件</h3><img src="1.png" style="zoom:60%;" /><ul><li><h4 id="随机存取存储器-RAM-Random-Access-Memory"><a href="#随机存取存储器-RAM-Random-Access-Memory" class="headerlink" title="随机存取存储器(RAM, Random Access Memory)"></a>随机存取存储器(RAM, Random Access Memory)</h4><ul><li><p>路由器配置文件的临时存储，一般做为内存使用</p></li><li><p>断电或重新启动时RAM内容丢失</p></li><li><p>存储:</p><ul><li>路由表</li><li>ARP缓存</li><li>快速切换缓存</li><li>报文缓存:可能前面有正在处理的，需要等待</li><li>数据包保留队列</li></ul></li><li><p>根据地址位就可以读到地址内容(访问比较快)</p></li></ul></li><li><h4 id="非易失随机存取存储器-NVRAM-Non-volatile-RAM"><a href="#非易失随机存取存储器-NVRAM-Non-volatile-RAM" class="headerlink" title="非易失随机存取存储器(NVRAM, Non-volatile RAM)"></a>非易失随机存取存储器(NVRAM, Non-volatile RAM)</h4><ul><li><p>存储备份(backup)&#x2F;启动(startup)配置文件</p></li><li><p>路由器掉电或重启时内容不会丢失。</p></li><li><p>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</p></li><li><p>保证快速访问，但是存储空间有限</p></li></ul></li><li><h4 id="Flash-相当于台式机硬盘"><a href="#Flash-相当于台式机硬盘" class="headerlink" title="Flash (相当于台式机硬盘)"></a>Flash (相当于台式机硬盘)</h4><ul><li><p>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</p></li><li><p>存储了Cisco IOS(互联网操作系统)</p></li><li><p>允许更新软件而无需更换闪存芯片</p></li><li><p>可以存储多个版本的IOS</p></li><li><p>断电保持</p></li></ul></li><li><h4 id="只读存储器-ROM-Read-Only-Memory"><a href="#只读存储器-ROM-Read-Only-Memory" class="headerlink" title="只读存储器(ROM, Read-Only Memory)"></a>只读存储器(ROM, Read-Only Memory)</h4><ul><li><p>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</p></li><li><p>引导程序(加载Cisco IOS)</p></li><li><p>系统软件</p><ul><li>IOS的备份，精简(trimmed down)版本</li><li>升级需要安装新的芯片组</li></ul></li></ul></li><li><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>数据包通过其进入和离开路由器的网络连接口</p></li><li><p>附在主板(motherboard)上或作为单独的模块。</p></li><li><p>大部分是网口，主要是用来支持网络的</p></li><li><p>0&#x2F;0第一个，串口接口可能还分多个</p></li></ul></li></ul><h3 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h3><ul><li>系统启动程序<ul><li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li><li>验证CPU，内存和网络接口端口的基本操作</li><li>软件初始化</li></ul></li><li>软件启动程序<ul><li>步骤1：让ROM中的通用引导加载程序(bootstrap)在CPU卡上执行</li><li>步骤2：可以在以下几个位置之一找到操作系统：<ul><li>先从Flash找，也就只有一个image文件，将image导入内存</li><li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li><li>如果TFTP也没有配置，则去ROM中导出IOS</li></ul></li><li>步骤3：将保存在NVRAM中的<strong>配置文件</strong>加载到主存储器中，并一次执行一行<ul><li>先看NVRAM中有没有配置(start.config)</li><li>然后看TFTP Server有没有配置，如果有则下载一个</li><li>如果都没有，用console进行配置</li></ul></li><li>步骤4：如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong></li></ul></li><li>路由器初始化过程<ul><li>设置不用作在路由器中输入复杂协议功能的模式。</li><li>对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序</li></ul></li></ul><h3 id="路由和配置"><a href="#路由和配置" class="headerlink" title="路由和配置"></a>路由和配置</h3><ul><li><p>路由器功能：路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。</p><ul><li><p><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></p></li><li><p><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</p></li></ul></li></ul><h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><ul><li>当只有一条路径可访问网络时，到网络的静态路由就足够了</li></ul><ul><li>管理距离<ul><li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)<ul><li>数字越大，可信度(trustworthiness)越低。</li><li>因此静态路由的管理距离通常很短(默认值为1)</li><li>管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高</li></ul></li></ul></li><li>配置命令<ul><li><code>ip route [目标网络] [子网掩码] [下一跳地址]</code></li><li><code>ip route 192.168.2.0 255.255.255.0 10.0.0.1</code></li><li>这个命令指定了将数据包发送到目标网络192.168.2.0&#x2F;24时，下一跳路由器的IP地址是10.0.0.1</li></ul></li></ul><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><ul><li><p>收敛时间:</p><ul><li><p>从刚启动到网络达到稳定的时间</p></li><li><p>从发生变化到再次稳定的时间</p></li></ul></li><li><p>动态路由协议分类</p><ul><li>距离矢量(DV,Distance Vector)</li><li>链路状态(LS,Link State)</li><li>混合路由(HR,Hybrid Routing)</li></ul></li><li><p>距离矢量协议 DVP</p><ul><li><p>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></p></li><li><p>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递<em><strong>路由表</strong></em>的周期性副本。</p><ul><li><p>邻居交换Routing Table</p></li><li><p>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</p></li></ul></li><li><p>代表：RIP</p></li></ul></li><li><p>路由环路问题：<strong>有名词解释题目</strong></p><img src="18.png" style="zoom: 50%;" /><ul><li><p>解决方案</p><ul><li><p>路由环路解决方案一：定义最大值</p><p>1.设置最大跳数，比如最多转发15跳，16跳以上为不可达</p></li><li><p>路由环路解决方案二：路由中毒(Route Poisoning)</p><img src="21-1746703714747.png" style="zoom:67%;" /><ol><li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li><li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li><li>最终所有的路由器都知道不可达</li><li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li></ol></li><li><p>路由环路解决方案三：水平分隔(Split Horizon)</p><img src="22-1746703716393.png" style="zoom:50%;" /><ol><li>从某个端口收到的报文信息，不能再从端口发送回去</li><li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的</li><li>如果B和D接收到一个到达目的网段1的更好的路径，A会接收</li></ol></li><li><p>路由环路解决方案四：计时器(Hold-Down Timers)</p><ol><li>收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li><li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li><li>计时器结束后，删除掉对应的条目，避免出现问题</li><li>每一条路由表的记录都有<strong>有效时间</strong></li></ol></li></ul></li></ul></li><li><p>链接状态协议(LSP, Link-state Protocol)</p><ul><li>过程<ul><li><strong>邻居发现：</strong> 路由器首先通过一些机制（例如Hello消息）发现它的直接邻居。这些邻居是直接连接的路由器。</li><li><strong>链路状态信息收集：</strong> 每个路由器收集关于它与邻居之间链路的状态信息。这包括链路的带宽、延迟、可靠性等信息。</li><li><strong>链路状态信息传播：</strong> 路由器将它所知道的链路状态信息通过链路状态通告（Link State Advertisement, LSA）广播给所有邻居。LSA包含了路由器所连接的链路的信息，以及这些链路的状态。</li><li><strong>LSA数据库维护：</strong> 每个路由器维护一个LSA数据库，其中包含了它所收到的所有LSA。这个数据库用于构建整个网络的拓扑图。</li><li><strong>拓扑图建立：</strong> 路由器使用LSA数据库中的信息构建整个网络的拓扑图。这是一个图形表示，显示了网络中所有路由器和它们之间的链路关系。</li><li><strong>最短路径计算：</strong> 一旦拓扑图建立完成，路由器使用某种最短路径算法（如Dijkstra算法）计算到达网络中每个路由器的最短路径。</li><li><strong>路由表更新：</strong> 路由器根据最短路径计算结果更新它的路由表。路由表包含了到达网络中每个目的地的最佳路径。</li><li><strong>定期更新：</strong> 为了保持网络状态的实时性，链路状态协议定期发送Hello消息并交换LSA。这有助于检测链路状态的变化，并及时更新路由表。</li></ul></li><li>当发生事件导致链路变化，路由器广播一个LSU消息（一种用于传递链路状态信息的消息类型）</li><li>传递的是链路信息，不是路由表（与DVP区别）</li></ul></li><li><p>Routing Protocols 主动路由协议</p><table><thead><tr><th>英文缩写</th><th>英文解释</th><th>中文解释</th><th>备注</th></tr></thead><tbody><tr><td>RIP</td><td>a distance-vector routing protocol</td><td>距离矢量协议</td><td>DV</td></tr><tr><td>IGRP</td><td>Cisco’s distance-vector routing protocol IGRP</td><td>思科的距离矢量路由协议</td><td>DV，基本启用</td></tr><tr><td>OSPF</td><td>Open Shortest Path First</td><td>开放式最短路径优先</td><td>LSP</td></tr><tr><td>EIGRP</td><td>Enhanced IGRP</td><td>平衡的混合路由协议</td><td>杂合</td></tr></tbody></table></li><li><p>路由协议的主要目标</p><ul><li>最佳(Optimal)路线:选择最佳路线</li></ul></li></ul><ul><li>效率(Efficiency):最少使用带宽和路由器处理器资源<ul><li>快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。</li></ul></li><li>灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由</li></ul><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><ul><li>默认路由使路由表更短。(很多路由被省略)</li><li>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</li><li>命令：<code>ip route 0.0.0.0 0.0.0.0 [默认下一跳地址]</code></li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="RIP-v1-v2"><a href="#RIP-v1-v2" class="headerlink" title="RIP v1 &#x2F; v2"></a>RIP v1 &#x2F; v2</h3><ul><li>RIP v1<ul><li>RIP v1被认为是一种<strong>内部网关协议</strong>，它是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器。默认间隔为<strong>30秒</strong>。</li><li>RIP使用<strong>跳数</strong>作为度量标准，最大跳数为<strong>15</strong>，达到16跳的报文自动抛弃</li><li>RIP v1能够在多达六个等价路径上进行<strong>负载平衡(Load Balancing)</strong>，默认情况下为四个路径，最多6个，跳数相同才能完成负载均衡，跳数不同不满足条件</li><li>负载平衡：在多条路径之间分配网络流量，以确保网络资源的均衡利用和提高网络性能</li><li>更新中不发送子网掩码：不支持VLSM</li><li>不支持身份验证，安全性差</li><li>以255.255.255.255的广播形式发送更新:只能发给邻居，不能通过路由器转发</li></ul></li><li>RIP v2<ul><li>RIP v2是RIP v1的改进版本，并且新增了以下的功能：<ul><li>这是一种使用<strong>跳数指标</strong>的距离矢量协议。</li><li>它使用<strong>抑制计时器</strong>来防止路由循环-默认值为<strong>180秒</strong>,6倍于交换时间</li><li>它使用水平分割(Split Horizon)来防止路由循环(Routing Loops)。</li><li>它使用16跳作为<strong>无限距离的度量</strong>。(15跳及以内可达)</li></ul></li></ul></li><li>RIP v1和RIP v2之间的区别<ul><li>支持有类路由:可以携带子网掩码</li><li>使用组播地址进行发送广播:<strong>特定给RIP接受，避免了接受后发现没有启动RIP进程耽误时间</strong></li><li>需要身份认证才确定是否继续进行接收</li></ul></li></ul><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ul><li><p>概述</p><ul><li>链接的状态是对<strong>接口</strong>及其与其<strong>相邻路由器关系</strong>的描述</li><li>链接状态的集合形成一个<strong>链接状态数据库</strong>，有时也称为<strong>拓扑数据库</strong></li><li>路由器应用<strong>Dijkstra最短路径优先</strong>(SPF)算法来构建以自己为根的SPF树</li><li>路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放置在<strong>路由表</strong>中</li></ul></li><li><p>特征</p><img src="10.png" style="zoom:67%;" /><ul><li>将大的网络分成多个area，每一个area只和area 0相连，<strong>保证area没有回路</strong></li><li><strong>层次最多只有2个</strong>，只存在一个area 0。其它area都和area 0相连。</li><li>层次维持树的关系</li><li>在一个Area中才算是neighbours，neighbour之间交换Topology Databases（存的是link-state）</li><li>一个Area中获得全部LS(Link State)后计算Tree，生成表</li></ul></li><li><p>OSPF与RIP对比</p><ul><li><img src="image-20231223162518274.png" alt="image-20231223162518274" style="zoom:67%;" /></li><li><img src="9.png" style="zoom: 50%;" /></li><li>上面带宽大，2跳达到，下面带宽小，1跳到达。</li><li>OSPF从上面走，RIP从下面走，但是上面会快一些，因此OSPF选择的路径是更加优越的</li></ul></li><li><p>名词</p><ul><li>区域：有着同样区域ID的网络&#x2F;路由器集合。在同一个区域的每个路由器有着同样的链路状态信息</li><li>开销：固定值除以带宽</li><li>链路状态:物理链路的信息，路由器连接关系、通过什么接口、链路带宽、网络类型(点对点、多路复用)等</li><li>自治系统：一组具有相同的路由政策的IP网络和路由器的集合</li><li>DR：指定路由器，只有在多路复用的链路下使用，被选举出来</li><li>BDR：备份指定路由器，如果DR坏了，再次选举会出现问题，如果DR损坏，BDR立即成为DR</li><li>ABR(Area Border Router):区域边界路由器，有一定的约束(一个路由器最多不连接超过3个以上的路由器)</li></ul></li><li><p>OSPF域</p><img src="20-1746703728020.png" style="zoom: 60%;" /><ul><li>区域用32位数字标识：可以是IP格式（标准定义），也可以是一个十进制值</li><li>区域0：区域编号为0的单个区域。 area是OSPF两层结构划分的单位</li><li>OSPF使用2级分层模型：逻辑上必须是2层结构，而物理实现上可能有一定的差异，如果更多需要进行逻辑配置</li><li>在多区域OSPF网络中，要求所有区域都连接到区域0(主干)</li></ul></li><li><p>成为邻居的条件</p><ul><li>**Hello协议匹配：**OSPF邻居的建立依赖于Hello协议。路由器必须能够相互发送和接收Hello消息，并且这些消息中的参数必须匹配，包括Hello定时器、Dead定时器等。</li><li>**IP配置正确：**路由器必须配置正确的IP地址，并且它们之间能够相互通信。这通常包括确保两个路由器在同一个子网内，并且能够通过IP层相互到达。</li><li>**区域号匹配：**OSPF使用区域的概念，路由器必须在同一区域内才能成为邻居。如果两个路由器的区域不同，它们将无法建立邻居关系。</li></ul></li><li><p>OSPF过程</p><ul><li>步骤1：建立邻接关系<ul><li>路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播（TTL每经过一个路由器减一）</li><li>如果邻居被发现了：将邻居添加到邻居数据库</li><li>发现网络类型<ol><li>如果是多路复用网络，进入DR&#x2F;BDR选举过程，然后进入步骤2。</li><li>如果是点对点或点对多点网络，则不会举行DR&#x2F;BDR选举过程，并跳过步骤2。</li><li>如果hello数据包标头中的DR&#x2F;BDR字段已被占用(即DR &#x2F; BDR对已经存在)，则不会进行DR&#x2F;BDR选举，并跳过步骤2</li></ol></li></ul></li><li>步骤2：选择DR和BDR(如果需要):<strong>多路复用的时候才需要</strong><ul><li>如果没有其他路由器联机，则该路由器将成为DR。下一个要”启动”的路由器将是BDR</li><li>如果多个路由器(两个或更多)同时联机，进行选举</li></ul></li><li>步骤3：发现路线<ul><li>路由器确定”主&#x2F;从(master&#x2F;slave)”关系</li><li>多路复用网络中的DR&#x2F;BDR交换LSA(Type 2)，并且所有其他路由器将其Type 2 DBD发送给DR&#x2F;BDR</li><li>如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态：所有路由器必须在”加载状态”中等待，直到完全更新请求的路由器</li></ul></li><li>步骤4：选择适当的路线<ul><li>与网络上的所有其他路由器并行地计算SPF算法</li><li>在发生这种情况之前，所有路由器必须具有相同的链接状态数据库</li><li>SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树，OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享</li></ul></li><li>步骤5：维护路线信息<ul><li>常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制</li><li>根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)<ol><li>对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接</li><li>对于小于T1的链接，每30秒：非广播多路访问链接</li><li>“死间隔”是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)</li></ol></li></ul></li></ul></li><li><p>DR和BDR选举</p><ul><li><p>为什么要选择DR和BDR？</p><ul><li>如果不选择DR和BDR会导致每一个路由器都和其他所有路由器交流</li><li>每一个都要建立n * n - 1 &#x2F; 2个链接，对于链路的复杂比较高，如果有了DR就只需要(n-1)个连接</li><li>BDR是DR的备份，其他路由器之间就不用通信了</li></ul></li><li><p>选举方法</p><ul><li>优先级+路由器ID，最大的是DR，第二大的是BDR</li><li>路由器ID：手动配置、自动分配</li><li>自动分配时，如果有一个已经分配的回环接口（Loopback Interface），OSPF会选择其中最高的回环IP地址作为路由器ID，如果没有分配回环接口，OSPF将选择路由器上最高的活动接口的IP地址作为路由器ID</li><li>回环接口：是网络设备上的虚拟接口，通常用于本地主机内部进行测试和通信。它是一个虚构的网络接口，不连接到任何物理硬件，而是直接与本地设备的内部协议栈进行通信。</li></ul></li><li><p>过程</p><img src="25-1746703731030.png" style="zoom:60%;" /><ul><li>每个路由器与DR和BDR形成邻接关系</li><li>对于所有OSPF路由器，DR使用224.0.0.5(自己的IP)的<strong>主播地址</strong>向该网段上的所有其他路由器发送链接状态信息</li><li>为确保DR&#x2F;BDR看到所有路由器在网段上发送的链接状态，<strong>给所有DR&#x2F;BDR的多播地址是224.0.0.6</strong> <strong>(DR和BDR之间)</strong></li><li>几个Area有几个DR和BDR(是在不同Area上)</li></ul></li></ul></li><li><p>OSPF报文</p><ul><li><img src="26-1746703735937.png" style="zoom:50%;" /></li><li>Hello报文<ul><li>路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔（<strong>每10秒</strong>）发送hello</li><li>Hello数据包的地址为224.0.0.5</li></ul></li><li>DBD与LSA区别<ul><li>DBD消息是用于同步链路状态数据库的摘要信息，而LSA是用于传递链路状态数据库中详细的拓扑信息。</li><li>一旦通过DBD消息同步了LSDB（链路状态数据库）的状态，路由器之间就会进行LSA的交换。在LSA交换过程中，路由器可以请求缺失的LSA，也可以发送新的或者更新的LSA。</li></ul></li></ul></li></ul><h2 id="局域网交换与VLAN"><a href="#局域网交换与VLAN" class="headerlink" title="局域网交换与VLAN"></a>局域网交换与VLAN</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>基本功能<ul><li>根据MAC地址建立和维护<strong>交换表</strong>(类似于网桥表)</li><li>将帧切换出接口到目标</li><li>若收到的帧目的地址不在MAC表中，从所有端口转发</li></ul></li><li>对称交换与非对称交换<ul><li>对称交换可在具有相同带宽的端口之间提供交换连接</li><li>非对称交换通过将带有服务器的网段连接到更高带宽的端口，减少了服务器上潜在瓶颈的可能性</li></ul></li><li>内存缓冲<ul><li>作用：交换机中临时存储目标和传输数据的内存区域，直到可以将其切换出正确的端口为止</li><li>基于端口(Port)的内存缓冲<ul><li>数据包存储在每个端口的队列中</li><li>由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输，其他端口可能会空闲，存在不均衡的问题</li><li>每个端口都有一个buffer</li></ul></li><li>共享内存缓冲<ul><li>所有端口共享的公用内存缓冲</li><li>允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。</li><li>需要自己记录端口的信息</li></ul></li></ul></li><li><strong>交换方式</strong><ul><li>存储转发：交换机<strong>接收整个帧</strong>，先将其计算为循环冗余校验码（CRC），校验正确后再将其发送到目的地</li><li>直通：快速转发切换：<strong>仅在立即转发帧之前检查目标MAC(只看到帧的目的地址就转发，而不看帧的后面的部分)</strong></li><li>无碎片转发：交换机在接收到数据包的前64字节后，再开始进行数据包的转发。这意味着交换机会检查数据包的前64字节以确保没有任何碎片</li></ul></li><li>分层交换机<ul><li>第二层交换机：大规模集成电路，保证链路效率，低时延，低成本，有MAC地址</li><li>第三层交换机：基于硬件的帧转发机制，较高的帧转发性能，低时延（路由器是针对路由表进行转发），<strong>对数据流进行路由</strong>，<strong>生成MAC和IP的映射</strong>能够划分广播域，支持更复杂的网络拓扑</li><li>第四层交换机：可以根据端口主机的应用特点进行一定的流量控制，识别到前80个字节的数据报长度，对指定应用进行管理</li></ul></li></ul><h3 id="生成树协议-STP-The-Spanning-Tree-Protocol"><a href="#生成树协议-STP-The-Spanning-Tree-Protocol" class="headerlink" title="生成树协议(STP, The Spanning-Tree Protocol)"></a>生成树协议(STP, The Spanning-Tree Protocol)</h3><ul><li><p>桥环路：网络环路可能导致数据包在网络中无限循环，造成网络拥塞和性能问题，主要由第二层交换机冗余造成。STP通过自动选择和维护一棵”生成树”，从而阻止环路的产生。</p></li><li><p>概述</p><ul><li>主要功能：在<strong>交换&#x2F;桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</li><li>STP通过计算<strong>稳定的生成树</strong>网络拓扑<strong>来防止环路</strong></li><li><strong>生成树帧</strong>：桥协议数据单元BPDU(bridge protocol data unit)用于确定生成树拓扑</li></ul></li><li><p>STP决策顺序</p><ul><li>生成树始终使用相同的四步决策序列：<ul><li>在拓扑里面最低的root BID(网桥标识)</li><li>找到 Root bridge的最低路径成本</li><li>每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子</li><li>每个路径再指定一个最低的ID端口</li></ul></li><li>这些信息的得取都是靠的BPDU帧的交换</li></ul></li><li><p>BPDU(Bridge Protocol Data Unit)</p><ul><li>STP建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</li><li>不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)</li><li>在阻塞的链接上收到的数据帧将被丢弃。</li><li>交换机发送的允许形成无环逻辑拓扑的消息是BPDU</li></ul></li><li><p><strong>端口状态：</strong> STP定义了几种端口状态，包括：</p><ul><li><strong>指定端口（Designated Port）：</strong> 被选中作为某个网络段上的主端口，用于传输数据。</li><li><strong>根端口（Root Port）：</strong> 每个非根桥上选择通往根桥的最短路径的端口。</li><li><strong>阻塞端口（Blocked Port）：</strong> 阻塞状态的端口，用于防止环路的形成。</li></ul></li><li><p>选举根交换机</p><ul><li>交换机通过查找具有<strong>最低BID</strong>（较小的优先级值表示更高的优先级）的交换机(通常称为根战争)来选择单个根交换机。</li><li>如果所有交换机都使用默认的网桥优先级32768，则最低的MAC地址将作为根交换机。</li></ul></li><li><p>路径代价 Cost</p><ul><li>桥梁使用成本的概念来评估它们与其他桥梁的距离。</li><li>和OSPF算法相同的，这个标准是比较合适的，比之前OSPF要新，<strong>用固定的数值除以带宽来获得代价</strong></li></ul></li><li><p>STP状态的默认顺序为：</p><ol><li>阻塞：不转发帧，接收BPDU</li><li>监听：不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了</li><li>学习：不转发帧，学习地址</li><li>转发：转发帧，学习地址</li><li>禁用：不转发帧，不接收BPDU</li></ol></li><li><p>步骤</p><ul><li><p>步骤一：根交换机决定</p><ul><li>每个交换机都有一个优先级（Priority）值和一个唯一的MAC地址。首先，所有交换机都假定自己是根桥，广播一个BPDU（Bridge Protocol Data Unit）消息，其中包含了自己的优先级和MAC地址信息。</li><li>当其他交换机收到BPDU消息时，它们会比较收到的BPDU的根桥信息和自身的根桥信息，选择具有最小优先级和最小MAC地址的交换机作为根桥。这个过程会逐级传递，最终网络中的所有交换机都能得知根桥的信息。</li></ul></li><li><p>步骤2：选择根端口</p><ul><li><p>每个非根桥必须选择一个根端口</p></li><li><p>桥的根端口是最接近根桥的端口。</p></li><li><p>根路径成本是到根网桥的<strong>所有链接的累积成本。</strong></p></li></ul></li><li><p>步骤3：选择网段的指定端口</p><ul><li>每个网络段（两台交换机间的链路）上都会有一个指定端口，用于连接到生成树上。指定端口是具有最小根路径开销的端口。</li><li>如果有多个端口的根路径开销相同，则选择具有最小端口ID的端口作为指定端口。</li></ul></li></ul></li><li><p>解题技巧</p><ul><li>计算cost时，不能穿过自己</li><li>包含根的网段的指定端口一定是根交换机自己的端口</li></ul></li></ul><h3 id="VLAN-Virtual-Local-Area-Network-虚拟局域网"><a href="#VLAN-Virtual-Local-Area-Network-虚拟局域网" class="headerlink" title="VLAN(Virtual Local Area Network 虚拟局域网)"></a>VLAN(Virtual Local Area Network 虚拟局域网)</h3><ul><li><p>VLAN特点</p><ul><li>在第2层和第3层工作</li><li>控制网络广播，提供更严格的网络安全性</li><li>允许用户由网络管理员分配</li><li>VLAN<strong>创建一个不限于物理网段</strong>的单个广播域，并且将其视为子网</li><li>广播帧仅在具有相同VLAN ID的一个或多个交换机的端口之间切换。(VLAN ID属于端口)</li></ul></li><li><p>虚拟局域网中路由器的作用</p><ul><li>路由器为不同VLAN提供网关以实现不同VLAN之间的连接，可以用子接口，也可以用多个接口</li><li>交换机与路由器连接的端口设置为trunk：节约交换机端口，否则每个VLAN都需要一个端口</li><li>路由器将一个VLAN的帧转发到另一个VLAN时，接受帧的子接口会先解析标识，然后交给对应目标VLAN的子接口加上新的标记后转发</li></ul></li><li><p>设备连线</p><ul><li>PC控制路由器、交换机用全反线连接console口</li><li>同种类型（同层）设备之间使用交叉线连接，不同类型（不同层）设备间使用直通线连接</li><li>特例：PC和路由器看作同层，用交叉线连接</li></ul></li><li><p>虚拟局域网中帧的使用</p><ul><li><p>骨干网（BackBone）：用于VLAN间通信的区域，速度快</p></li><li><p>交换机根据帧中的数据做出过滤和转发决策</p></li><li><p>帧过滤：检查有关每个帧的特定信息（MAC地址或第3层协议类型）,特定的VLAN记录或者映射</p></li><li><p>帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符</p></li><li><p>标记过程：在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符，当帧到达终端之前删除该标记</p></li></ul></li><li><p>静态VLAN</p><ul><li>静态VLAN是指将交换机上的端口管理性地分配给VLAN</li><li>VLAN信息是写死在交换机的端口上的，基于端口</li></ul></li><li><p>动态VLAN</p><ul><li>当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口</li><li>基于MAC地址</li></ul></li><li><p>以端口为中心的VLAN</p><ul><li>同一VLAN的所有节点连接到路由器的同一个端口</li><li>使管理更容易</li></ul></li><li><p>交换机端口分类</p><ul><li>访问链接（access link）：只属于一个VLAN，且仅向该VLAN转发数据帧，一般与客户机连接</li><li>汇聚链接（Trunk Link）：主干链路能够支持多个VLAN，通常用于将交换机连接到其他交换机或路由器<ul><li><strong>一般Trunk就是BackBone</strong></li><li>骨干链路不属于特定的VLAN：充当交换机和路由器之间VLAN的通道</li><li>trunk口可以理解为两台交换机或路由器之间的通道，若无trunk口，每个VLAN都需要消耗交换机的一个接口，trunk相当于它们的汇集</li><li>一般将两台交换机间的连接端口设置为trunk，在帧出trunk端口时会被加上标记（VLAN标识符），进入另一个trunk端口后标记会在解析后被删除</li></ul></li></ul></li><li><p>解题注意</p><ul><li>同一VLAN中的两台主机可以跨越多台交换机</li><li>必须是第三层及以上的交换机才能用来构建VLAN</li><li>新交换机会有一个默认的vlan 1</li><li>vlan只能分割广播域，不能分割冲突域</li><li>每个vlan中都有一个分离的桥接表（bridging table）</li></ul></li></ul><h2 id="WAN-广域网"><a href="#WAN-广域网" class="headerlink" title="WAN(广域网)"></a>WAN(广域网)</h2><h3 id="广域网技术和服务"><a href="#广域网技术和服务" class="headerlink" title="广域网技术和服务"></a>广域网技术和服务</h3><ul><li><p>WAN Services 广域网服务</p><ul><li>定义:WAN是通过WAN服务提供商连接LAN的通信网络</li><li>WAN在OSI的前三层运行，但<strong>主要集中在物理和数据链路层</strong></li><li>广域网的最小单位是公司，一般由运营商完成</li></ul></li><li><p>物理结构</p><ul><li>通过Network远程接入，通过WSP提供的CO Switch来连接到中心局</li><li>CPE:位于公司本地的设备(主要是接入设备)，安装在用户的场所，用于连接到服务提供商网络</li><li>CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案</li><li>Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理</li><li>实际上实现了点对点的连接</li></ul></li><li><p>广域网虚拟电路</p><ul><li><p>广域网虚拟电路是一种在广域网中建立的逻辑通信路径，它允许在远距离的地理位置之间进行数据通信。虚拟电路是一种面向连接的通信方式，其中数据通过在网络中建立的虚拟通道进行传输。</p></li><li><p>三个阶段：</p><ol><li><p>电路建立–创建虚拟电路(逻辑确定)</p></li><li><p>数据传输–发送和接收用户数据(含有虚电路号等)，<strong>不会出现丢失和乱序问题，实现了可靠传输</strong></p></li><li><p>电路中断–拆除虚拟电路</p></li></ol></li></ul></li><li><p>广域网设备</p><ul><li>为了连接到专线(leased line)，客户必须具备以下条件：<ol><li>访问服务提供商的电路</li><li>可用的适当路由器端口</li><li>CSU&#x2F;DSU，调制解调器，ISDN终端适配器等</li></ol></li><li><img src="6.jpg" style="zoom:67%;" />- CSU：负责在用户设备和数字线路之间提供物理层连接的设备- DSU：负责在用户设备和数字线路之间提供数据链路层连接的设备- 这两者通常一起使用，合称为 "CSU/DSU"，它们提供了一个完整的连接，确保用户设备与数字通信线路之间的兼容性和有效通信</li></ul></li></ul><h3 id="广域网和OSI模型"><a href="#广域网和OSI模型" class="headerlink" title="广域网和OSI模型"></a>广域网和OSI模型</h3><ul><li>设备：<ul><li>DCE：代表 “Data Circuit-terminating Equipment”，它是用于连接到数字通信线路的设备，工作在物理层、数据链路层。DCE 通常是一种数字通信设备，负责提供物理连接、数据格式转换和时钟同步等功能，如调制解调器、CSU&#x2F;DSU。</li><li>DTE：代表 “Data Terminal Equipment”，数据终端设备。DTE 是指在数字通信系统中生成、处理或终结数据的设备，如计算机、终端、打印机、路由器或其他生成或处理数字数据的设备，工作在应用层、表示层和部分会话层</li><li><strong>DCE与 DTE 的连接：</strong><ul><li>用户设备（DTE，如计算机、路由器等）通过一个数据接口连接到 DCE。</li><li>DCE 然后连接到数字通信线路</li></ul></li></ul></li><li>物理层协议<ul><li>描述如何为WAN服务提供电气，机械，操作和功能连接的协议</li><li>描述数据终端设备和数据电路终端设备之间的接口</li><li>在此模型中，通过调制解调器或CSU&#x2F;DSU提供给DTE的服务</li></ul></li><li>数据链路层协议<ul><li>WAN数据链路协议描述了如何在单个数据链路上的系统之间承载帧</li><li><strong>点对点协议(PPP,Point-to-Point Protocol)</strong>：PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议)，根据不同的网络协议对帧做控制与检查</li><li><strong>高级数据链路控制(HDLC, High-Level Data Link Control)</strong>：不同供应商之间不兼容HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点&#x2F;多点配置(抽象规范和约束，各个厂商不同)</li><li><strong>帧中继(Frame Relay)</strong>：使用简化的封装，对高质量的数字设备不进行纠错</li><li><strong>ISDN</strong>：通过现有电话线传输语音和数据的一组数字服务</li><li><strong>平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)</strong>：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制。</li></ul></li></ul><h3 id="广域网访问方法"><a href="#广域网访问方法" class="headerlink" title="广域网访问方法"></a>广域网访问方法</h3><ul><li><p>PPP&#x2F;HDLC</p><ul><li>点对点的标准，工作在串行链路上（数据链路层）</li><li>如果都是同一个厂商的可以用HDLC，不然使用PPP</li><li>两者都是广域网点对点链路中的封装方式</li></ul></li><li><p>PPP 点对点协议  <strong>考点</strong></p><ul><li>串行链路上使用最广泛的第2层协议</li><li><strong>多协议支持：</strong> PPP 支持多种网络层协议，如 IP、IPv6等。</li><li><strong>可靠性：</strong> PPP 提供了一系列的错误检测和纠正机制，以确保数据的可靠传输。</li><li><strong>认证：</strong> PPP 支持用户身份验证，可以使用用户名和密码进行认证。</li></ul></li><li><p>PPP组件</p><ul><li>HDLC：封装第3层数据报的基础</li><li>LCP(链接控制协议Link Control Protocol)：建立连接、连接配置选项、链接质量测试</li><li>NCP(网络控制协议Network Control Protocol)：选择和配置第3层协议</li></ul></li><li><p>PPP帧格式</p><img src="10.jpg" style="zoom:50%;" /><ul><li>Flag: 01111110 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li><li>Address ：11111111，广播地址</li><li>Control ：00000011，用户数据作为无序帧传输</li><li>Protocol: 数据字段中的协议类型（既可以指网络层，又可以指数据链路层）</li><li>Data: 数据报，最大默认值为1500字节</li><li>FCS: 2或者4字节</li></ul></li><li><p>PPP会话建立&#x2F;终止</p><ul><li>为了通过点对点链路建立通信，PPP经历四个不同的阶段：<ol><li>步骤一:链接建立和配置协商(negotiation)(LCP)。</li><li>步骤二:链接质量测试。</li><li>步骤三:网络层协议配置(NCP)。</li><li>步骤四:链接终止。</li></ol></li><li><strong>链路建立阶段：</strong><ul><li>通信的第一步是链路建立阶段。在这个阶段，通信的两端（通常是两个路由器或计算机）通过 PPP 协议建立连接。</li><li>LCP（Link Control Protocol）运行在这个阶段，它负责协商链路的特性。这包括链路的最大帧大小、帧起始标志、帧校验序列（FCS）类型等。LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如<strong>压缩和身份验证协议</strong>等。</li></ul></li><li><strong>链路质量和参数协商：</strong><ul><li>在链路建立阶段，LCP 还负责检测链路的质量，发送和接收LCP数据包以测量链路上的错误率，并根据需要进行调整。它可以选择性地协商和改变链路特性，以适应网络的需求。</li><li>身份验证(如果使用)在网络层协议配置阶段开始之前进行</li><li>一旦 LCP 完成成功，链路建立阶段就结束，进入 NCP（Network Control Protocol）阶段。</li></ul></li><li><strong>网络层协议配置：</strong><ul><li>NCP 运行在链路建立后的阶段，其目标是协商和配置网络层协议。在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。</li><li>通信的两端通过 NCP 协商确定要在 PPP 连接上使用的网络层协议。一旦协商成功，通信的两端就可以开始在 PPP 连接上发送来自每个网络层协议的数据报。</li></ul></li><li><strong>连接终止阶段：</strong><ul><li>当数据传输完成或者需要终止连接时，通信的一方可以发起连接的终止。</li><li>LCP可以随时终止链接：应用户要求(一方请求终止)、链接质量、超时</li><li>LCP 可能会再次参与，协商关闭链路。在 PPP 连接终止阶段，LCP 和 NCP 都可能发挥作用。</li></ul></li></ul></li><li><p>PPP安全认证</p><ul><li>PAP 安全认证协议<ul><li>链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。</li><li>远程节点使用双向握手PAP建立其身份。</li><li>远程节点<strong>重复</strong>发送用户名&#x2F;密码对，直到确认身份验证或连接终止</li><li>密码以明文形式通过链接发送。</li><li>在建立连接阶段之后，仅对远程节点进行一次身份验证</li></ul></li><li>CHAP(Challenge Handshake Authentication Protocol)<ul><li><strong>挑战：</strong> 在连接建立时，认证服务器向客户端发送一个挑战，这是一个随机生成的字符串。挑战的目的是验证客户端是否知道共享的密钥。</li><li><strong>响应：</strong> 客户端收到挑战后，使用共享的密钥（通常是密码）对挑战进行哈希运算，生成一个响应字符串。客户端将这个响应字符串发送回认证服务器。</li><li><strong>验证：</strong> 服务器收到客户端的响应后，使用与客户端共享的密钥进行相同的哈希运算，然后比较计算出的响应与客户端发送的响应是否匹配。如果匹配，认证成功；否则，认证失败。</li><li><strong>周期性挑战：</strong> 为增强安全性，CHAP可以使用周期性挑战。在初始认证成功后，认证服务器可以定期发送新的挑战给客户端，要求客户端再次提供响应，以确保连接仍然是合法的。</li></ul></li></ul></li><li><p>综合数字服务网络(ISDN, Integrated Services Digital Networks)</p><ul><li>集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接</li><li>可以携带语音，视频和数据</li><li>服务有两种：BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP；PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD</li><li>BRI是ISDN的基本服务接口，提供两个B通道（Bearer Channels）和一个D通道（Data Channel）。每个B通道的带宽为<strong>64 Kbps</strong>，D通道的带宽为<strong>16 Kbps</strong>。因此，BRI总带宽为<strong>144 Kbps</strong>。</li><li>PRI是ISDN的高级服务接口，通常用于更大规模的组织。它提供了更多的B通道和更高的总带宽，通常为23个B通道和1个D通道，总带宽为1.544 Mbps（T1）或30个B通道和1个D通道，总带宽为2.048 Mbps（E1）。</li></ul></li><li><p>非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)</p><ul><li>xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</li><li>xDSL 的几种类型<ul><li>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</li><li>HDSL (High speed DSL)：高速数字用户线</li><li>SDSL (Single-line DSL)：1 对线的数字用户线</li><li>IDSL：ISDN用户线</li><li>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率</li></ul></li><li>ADSL的极限传输距离：与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系(用户线越细，信号传输时的衰减就越大)</li><li>ADSL特点：<ul><li>上行和下行带宽不对称:上行指从用户到ISP，而下行指从ISP 到用户，下载速度通常比上传速度快</li><li>ADSL在用户线(铜线)的两端各安装一个ADSL调制解调器，在用户端，调制器将数字数据转换为模拟信号，以适应电话线的传输特性。在ISP端，解调器将模拟信号转换回数字数据。</li><li>我国目前采用的方案是离散多音调（DMT） 调制技术，采用频分复用的方法</li><li>通常下行数据率在 32 kb&#x2F;s 到 6.4 Mb&#x2F;s 之间，而上行数据率在 32 kb&#x2F;s 到 640 kb&#x2F;s 之间。</li></ul></li></ul></li><li><p>其他广域网连接技术（应该不考，仅简写）</p><ul><li>同步光纤网SONET和同步数字系列SDH</li><li>光纤同轴混合网 HFC (Hybrid Fiber Coax)</li></ul></li></ul><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>被动攻击：截获信息的攻击称为被动攻击(并不改变通讯的过程)</li><li>主动攻击：更改信息和拒绝用户使用资源的攻击称为主动攻击</li><li>恶意程序<ul><li>计算机病毒:会”传染”其他程序的程序，”传染” 通过修改其他程序来把自身或其变种复制进去而完成。</li><li>计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)</li><li>特洛伊木马:一种程序，它执行的功能超出所声称的功能。运作木马获得特殊的权限</li><li>逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li></ul></li><li><img src="2-1746703748557.png" style="zoom:50%;" /></li></ul><h3 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h3><ul><li><strong>密码编码学</strong>(cryptography)：密码体制的设计学(设计密码)</li><li><strong>密码分析学</strong>(cryptanalysis)：在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。</li><li>对称密钥密码体系：常规密钥密码体制，即加密密钥与解密密钥是<strong>相同</strong>的密码体制</li><li>数据加密标准(DES Data Encryption Standard)：一种分组密码，属于常规密钥密码体制，详细略</li><li>公钥密码体制：使用<strong>不同的加密密钥与解密密钥(非对称密码体系)</strong></li><li>任何加密方法的安全性取决于<strong>密钥的长度</strong>，以及<strong>攻破密文所需的计算量</strong></li><li>数字签名：<ul><li>数字签名必须保证以下三点：<ol><li>报文鉴别:接收者能够核实发送者对报文的签名</li><li>报文的完整性:发送者事后不能抵赖对报文的签名</li><li>不可否认:接收者不能伪造对报文的签名</li></ol></li></ul></li></ul><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul><li><p>防火墙在互连网络中的位置</p><img src="6.png" style="zoom: 50%;" /></li><li><p>防火墙的功能与分类</p><ul><li>防火墙的功能有两个：<strong>阻止和允许</strong>。<ol><li><strong>阻止</strong>就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)</li><li><strong>允许</strong>的功能与<strong>阻止</strong>恰好相反</li></ol></li><li>防火墙的分类<ul><li><strong>网络级防火墙</strong>:用来防止整个网络出现外来非法的入侵。属于这类的有<strong>分组过滤和授权服务器</strong><ol><li>前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据</li><li>后者则检查用户的登录是否合法</li></ol></li><li><strong>应用级防火墙</strong>:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过</li></ul></li></ul></li></ul><h3 id="访问控制列表ACL-Access-Control-Lists"><a href="#访问控制列表ACL-Access-Control-Lists" class="headerlink" title="访问控制列表ACL(Access Control Lists)"></a>访问控制列表ACL(Access Control Lists)</h3><ul><li><p>概述</p><ul><li>ACL是指令列表，它告诉<strong>路由器</strong>允许或拒绝什么类型的数据包</li><li>如果要让路由器拒绝某些数据包，则必须配置ACL。否则只要链路打开，路由器将接受并转发所有数据包</li></ul></li><li><p>入站ACL过程</p><ul><li>收到数据包时，按照ACL列表逐个语句比对</li><li>当一个语句”匹配”时，<strong>不再评估任何语句</strong>。(前面的语句先匹配，处理掉)</li><li>ACL末尾有一个隐含的”deny any”语句：如果数据包与ACL中的任何语句都不匹配，则将其丢弃</li></ul></li><li><p>出站ACL过程</p><ul><li>检查数据包是否可路由。如果是这样，请在路由表中查找路由</li><li>检查出站接口的ACL：如果没有ACL，则将数据包切换出目标接口；如果有ACL，匹配<strong>源地址</strong></li></ul></li><li><p>ACL分类</p><img src="8-1746703752741.png" style="zoom:50%;" /><ul><li><p>ACL命令：<code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></p><ul><li><p>在ACL的<code>&#123;test condition&#125;</code>部分中，大多数访问列表的共同点是源地址和通配符掩码</p></li><li><img src="image-20231229125458373.png" alt="image-20231229125458373" style="zoom:67%;" /></li><li><p>通配符掩码和子网掩码是取反关系（如子网掩码为255.255.255.224，通配符掩码为0.0.0.31）</p></li><li><p>源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为IP掩码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">//拒绝来自192.168.2.0/24的流量<br>Router(config)# access-list 2 deny 192.168.2.0 0.0.0.255<br>Router(config)# access-list 2 permit any<br><br>//拒绝来自主机 192.168.1.10 的流量<br>Router(config)# access-list 1 deny host 192.168.1.10<br>Router(config)# access-list 1 permit any<br>//拒绝某主机也可用：<br>Router(config)#access-list 1 permit 192.5.5.10 0.0.0.0<br></code></pre></td></tr></table></figure></li></ul></li><li><img src="10-1746703757308.png" style="zoom:67%;" /><blockquote><ol><li>IP mask ：IPv4的地址</li><li><strong>Wildcard mask</strong>:和netmask是不同的，指示哪些位置被检查</li></ol></blockquote></li></ul></li></ul><ul><li><p>标准ACL：序号通常在1到99之间，仅检查源IP地址</p></li><li><p>扩展ACL：序号通常在100到199之间，可检查源和目标IP地址、协议类型、端口号等信息</p></li><li><p><strong>标准ACL靠近目的，拓展ACL靠近源</strong></p></li></ul><ul><li><p>常见端口号</p><ul><li><img src="13-1746703759203.png" style="zoom:67%;" /></li><li><strong>DHCP (Dynamic Host Configuration Protocol):</strong><ul><li>服务端口：67</li><li>客户端端口：68</li></ul></li><li><strong>HTTP (HyperText Transfer Protocol):</strong><ul><li>默认端口：80</li></ul></li><li><strong>HTTPS (HTTP Secure):</strong><ul><li>默认端口：443</li></ul></li><li><strong>POP3 (Post Office Protocol version 3):</strong><ul><li>默认端口：110</li></ul></li><li>注：20也是FTP的端口号，21用于建立连接，20用于传输数据</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>核心课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/12/05/test/"/>
    <url>/2023/12/05/test/</url>
    
    <content type="html"><![CDATA[<p>RPC</p><ul><li>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</li><li>步骤：客户端调用-&gt;请求发送(序列化) -&gt; 服务器接受并处理(反序列化) -&gt; 结果返回(序列化) -&gt; 客户端接收结果(反序列化)</li><li>常见的 RPC 框架：gRPC、Thrift、Dubbo</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
