<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><span id="more"></span><h2 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h2><ul><li>Thompson算法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110195743">编译原理: Thompson 构造法（正则表达式 转 NFA）_thompson构造法-CSDN博客</a></li><li><img src="image-20240611150213632.png" alt="image-20240611150213632"></li><li><img src="image-20240611150228916.png" alt="image-20240611150228916"></li><li><img src="image-20240611150236987.png" alt="image-20240611150236987"></li><li><img src="image-20240611150247191.png" alt="image-20240611150247191" style="zoom:50%;" /></li><li><img src="image-20240611150257922.png" alt="image-20240611150257922" style="zoom:67%;" /></li><li><img src="image-20240611150306204.png" alt="image-20240611150306204" style="zoom:67%;" /></li><li><img src="41.png"></li></ul></li><li>子集构造法<ul><li><a href="https://blog.csdn.net/weixin_44691608/article/details/110213913">编译原理: Subset Construction 子集构造法(幂集构造)(NFA转DFA)_编译原理nfa转dfa-CSDN博客</a></li><li><img src="image-20240611150549771.png" alt="image-20240611150549771"></li><li><img src="image-20240611150602989.png" alt="image-20240611150602989" style="zoom:67%;" /></li><li>解释：先把初始状态和它通过无条件转移能到达的并为一个状态，然后一步步根据不同输入扩展，知道所有状态在所有输入情况下的目标状态都已定义</li></ul></li><li>DFA最小化算法<ul><li><img src="image-20240611152632268.png" alt="image-20240611152632268"></li><li><img src="image-20240611152648720.png" alt="image-20240611152648720" style="zoom:50%;" /></li><li>解释：先把非接受状态和接受状态分成两类，再在每个等价类内部判断每个成员是否会转移到其他等价类，如果是就把它拎出去单独成一个等价类，直到最后只剩最小闭包。</li><li>合并等价状态时注意只把它们之间的状态转移去掉，但它们自己到自己的边和与外界相连的边要保留</li></ul></li></ul><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><ul><li>上下文无关文法<ul><li><img src="image-20240611154021569.png" alt="image-20240611154021569"></li><li><img src="image-20240611155045696.png" alt="image-20240611155045696" style="zoom:67%;" /></li><li>在最左推导中，每一步总是替换字符串中最左边的非终结符。具体过程如下（最右推导相反）：<ol><li>从起始符号（开始符号）S开始。</li><li>在每一步推导中，选择当前字符串中最左边的非终结符，并使用某个产生式规则进行替换。</li><li>重复步骤2，直到得到仅由终结符组成的字符串。</li></ol></li><li><img src="image-20240611155322088.png" alt="image-20240611155322088"></li><li>文法G 的语言L(G) 是它能推导出的所有句子构成的集合</li></ul></li></ul><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><ul><li><p>FIRST与FOLLOW求解</p><ul><li><p><a href="https://blog.csdn.net/jianbai_/article/details/106367466">编译原理：LL(1)文法-构造预测分析表_ll(1)分析表-CSDN博客</a></p></li><li><p>示例看这篇：<a href="https://blog.csdn.net/qq_40741513/article/details/106036849">编译原理LL(1)预测分析表的构造_构造文法l(1)l预测分析表-CSDN博客</a></p></li><li><p>First(α) 是可从α 推导得到的句型的首终结符号的集合，Follow(A) 是可能在某些句型中紧跟在A 右边的终结符的集合</p></li><li><p>注意，FIRST和FOLLOW都是针对单个非终结符的，预测分析表的行也是单个非终结符，也就是说不存在类似FIRST(ABC)</p></li><li><img src="28.png" style="zoom: 50%;" /></li><li><img src="29.png" style="zoom:50%;" /></li><li><p>对文法G的每个产生式A-&gt;α 执行如下步骤：</p></li></ul><p>  （1）对每个a∈First(α)，把 A-&gt;α 加入M[A,a]</p><p>  （2）若 ε∈First(α)，则对任何b∈Follow(A) ,把 A-&gt; ε加至M[A,b]中</p></li><li><p>判断某文法是否为LL(1)</p><ul><li><a href="https://blog.csdn.net/weixin_44162921/article/details/103482452">编译原理——判断是否为LL（1）文法及构造分析表_请写出ll(1)文法应满足的条件。-CSDN博客</a></li><li><img src="image-20240611193206421.png" alt="image-20240611193206421" style="zoom:80%;" /></li><li>另一种方式：检查预测分析表是否无冲突，即检查是否有一个单元格中是否有有超过一个表达式，如果有则不是LL(1)</li></ul></li></ul><h3 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a>LR(0)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105554383">编译原理学习笔记（七）~LR(0)分析-CSDN博客</a></li><li>画自动机<ul><li>先对文法增广</li><li>通过初始状态得到I0</li><li>一步步对每个点不在最右边的情况生成新的状态，计算项集时注意每一条点不在最右边的要把点后非终结符的规则加进来</li><li>直到最后不再有新的状态出现</li></ul></li><li>画分析表<ul><li>根据自动机填表</li><li>非终结符部分有三种（移入s，规约r，接受acc），终结符部分直接写数字表示状态跳转</li><li>注意需要规约的状态无论看到什么输入都进行规约</li></ul></li><li>关注栈的状态<ul><li>移入动作代表入栈</li><li>入栈的同时也带来新的状态</li><li>出栈时状态回到该句柄入栈前的状态</li></ul></li></ul><h3 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a>SLR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105596980">编译原理学习笔记（九）~SLR分析-CSDN博客</a></li><li>如果文法G 的SLR(1) 分析表是无冲突的, 则G 是SLR(1) 文法。</li><li><img src="image-20240612154526804.png" alt="image-20240612154526804"></li><li>新的自动机：在规约项后加上FOLLOW集中的元素，表示只有下一个输入符号为这些之一才规约，否则移入</li><li><img src="image-20240612155521083.png" alt="image-20240612155521083"></li></ul><h3 id="LALR-1"><a href="#LALR-1" class="headerlink" title="LALR(1)"></a>LALR(1)</h3><ul><li><a href="https://blog.csdn.net/weixin_44225182/article/details/105599118">编译原理学习笔记（十一）~LALR分析法-CSDN博客</a></li><li>LALR(1) : 合并具有相同核心LR(0)项的状态(忽略不同的向前看符号)</li><li><img src="image-20240612160005965.png" alt="image-20240612160005965"></li></ul><h2 id="ANTLR优先级上升算法"><a href="#ANTLR优先级上升算法" class="headerlink" title="ANTLR优先级上升算法"></a>ANTLR优先级上升算法</h2><ul><li>优先级确定：根据原文法从下往上每条规则优先级从1递增</li><li>非左递归规则改写：<ul><li>放在开头，用( )包裹，两条规则中间用|隔开</li><li>若包含递归规则，分为含运算符和不含运算符两种</li><li>不含运算符（如<code>( expr )</code>）则传参数0</li><li>若含右结合单操作数运算符（如<code>&#39;-&#39; expr</code>），则传参等于此条规则优先级</li></ul></li><li>左递归规则改写：<ul><li>用( )包裹，最后有*</li><li>每条规则前有优先级判断（如<code>(5 &gt;= $_P)?</code>）</li><li>非终结符调用递归规则，若运算符为左结合（包括单操作数，如阶乘 !）则传参为该规则优先级+1，若运算符为右结合（如指数运算2^5，规则前要加一条<code>&lt;assoc = right&gt;</code>）则传参为该规则优先级</li><li>优先级升高原因：使优先级等于或高于当前节点的能在当前节点下展开，小于的回到上一级展开</li></ul></li><li>示例<ul><li><img src="image-20240621092049848.png" alt="image-20240621092049848"></li><li><img src="image-20240621092105593.png" alt="image-20240621092105593" style="zoom: 50%;" /></li><li><img src="image-20240621092118737.png" alt="image-20240621092118737"></li><li><img src="image-20240621092141481.png" alt="image-20240621092141481"></li><li><img src="80a9dcf969d7026c3dda87a88cb61c40-1718933855431.png" alt="img" style="zoom:50%;" /></li></ul></li></ul><h2 id="语法制导翻译SDT"><a href="#语法制导翻译SDT" class="headerlink" title="语法制导翻译SDT"></a>语法制导翻译SDT</h2><ul><li><img src="image-20240611195505703.png" alt="image-20240611195505703" style="zoom:50%;" /></li><li>综合属性<ul><li><img src="image-20240611195633623.png" alt="image-20240611195633623" style="zoom:50%;" /></li><li>在LL 语法分析器中, 递归下降函数A 返回时,计算相应节点A 的综合属性值</li><li>综合属性用returns定义！</li></ul></li><li>继承属性<ul><li><img src="image-20240611195804291.png" alt="image-20240611195804291" style="zoom:50%;" /></li><li><img src="image-20240611200431868.png" alt="image-20240611200431868" style="zoom:50%;" /></li><li>继承属性用参数定义！</li></ul></li><li>L属性<ul><li><img src="image-20240611195917546.png" alt="image-20240611195917546" style="zoom:50%;" /></li><li>直观来说就是继承属性只能从上往下、从左往右传递</li><li><img src="image-20240611200751148.png" alt="image-20240611200751148" style="zoom:50%;" /></li></ul></li><li><img src="image-20240611200549503.png" alt="image-20240611200549503" style="zoom:50%;" /></li><li>例子<ul><li><img src="image-20240621094922672.png" alt="image-20240621094922672"></li><li><img src="image-20240621095154487.png" alt="image-20240621095154487"></li><li><img src="image-20240621095217714.png" alt="image-20240621095217714"></li><li><img src="image-20240621095309194.png" alt="image-20240621095309194"></li><li><img src="image-20240621101202137.png" alt="image-20240621101202137"></li></ul></li></ul><h2 id="中间代码翻译"><a href="#中间代码翻译" class="headerlink" title="中间代码翻译"></a>中间代码翻译</h2><ul><li>表达式<ul><li><img src="image-20240612141832786.png" alt="image-20240612141832786" style="zoom:50%;" /></li></ul></li><li>数组引用<ul><li><img src="image-20240612143015988.png" alt="image-20240612143015988" style="zoom:67%;" /></li></ul></li><li>控制流语句翻译中的地址回填技术<ul><li><img src="image-20240612143619019.png" alt="image-20240612143619019" style="zoom: 50%;" /></li><li>祖先节点通过综合属性收集子节点中具有相同目标的跳转指令</li><li>综合属性B.truelist 保存需要跳转到B.true 标签的指令</li><li>综合属性B.falselist 保存需要跳转到B.false 标签的指令</li><li>综合属性S&#x2F;L.nextlist 保存需要跳转到S&#x2F;L.next 标签的指令</li><li><img src="image-20240612144545716.png" alt="image-20240612144545716"></li></ul></li><li>控制流语句<ul><li>简单模式：只使用综合属性，为布尔表达式B 计算逻辑值(假设保存在临时变量t1 中)，if、while 等语句根据 B 的结果改变控制流</li><li>困难模式：父节点为子节点准备跳转指令的目标标签，子节点通过继承属性确定跳转目标</li><li><img src="image-20240612145711859.png" alt="image-20240612145711859"></li><li><img src="image-20240612145745468.png" alt="image-20240612145745468"></li></ul></li></ul><h2 id="RISC-V指令集"><a href="#RISC-V指令集" class="headerlink" title="RISC-V指令集"></a>RISC-V指令集</h2><ul><li>寄存器<ul><li>ra：返回地址</li><li>t0 - t6：临时寄存器</li><li>pc：程序计数器</li></ul></li><li>指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>one: .word 1 # int one = 1; 32位下word4字节，byte1字节，doubleword8字节<br>result: .word 0<br>msg: .string &quot;hello&quot; # 自带\0的字符串，.ascii是不带\0的<br>array: .word 10, 20, 30, 40 # 每个数字占一个word<br><br>.text<br>li t0, 200 # 立即数加载，伪指令<br>addi t0, zero, 200 # 立即数加法，实现li<br>add t2, t0, t1 # t2 = t0 + t1<br>sub t2, t0, t1 # t2 = t0 - t1<br>mul t2, t0, t1 # t2 = t0 * t1<br>slli t2, t0, 2 # t2 = t0 &lt;&lt; 2<br><br># 系统调用<br>li a7, 1 # 系统调用号存入a7, 1是输出单字，4输出字符串<br>add a0, t0, zero # 传参到a0 - a6<br>mv a0, t0 # 伪指令，a0 &lt;- t0<br>ecall # 触发系统调用<br><br># 从内存中存取数据<br>la t0, one<br>lw t0, 0(t0) # load word，加载一个字节(也有lb)，0是offset，t0是基址<br><br>la t1, result<br>sw t0, 0(t1) # save word，与lw对应，但是注意方向相反：t0 -&gt; 0(t1)<br># 等价于lw t0, one和sw t0, result, t2伪指令<br><br># 访问数组<br>la t0, array<br>lw t1, 12(t0) # 访问array[3]<br><br># 条件判断<br>bge t0, t1, label1 # branch if t0 &gt;= t1<br>bltz t0, label1 # branch if t0 &lt; 0<br>beqz t0, label1 # branch if t0 = 0<br>j label1 # jump<br><br># 函数调用<br>jal ra, max # 调用max函数，把max首条指令地址存入pc，并把下条指令地址存入ra<br># 可以缩写成jal max或call max，默认用ra存<br><br>jalr zero, 0(ra) # 被调用方用，返回0(ra)的地址，并将当前下一条指令存入第一个参数(用zero表示丢弃)<br># 可以缩写成jr ra或ret<br><br>#栈操作<br>addi sp, sp, -8 # 腾出8字节栈空间<br>sw a0, 4(sp) # 将需要保存的寄存器值存入栈空间<br>sw ra, 0(sp) # 注意，ra在多层调用时一定要保存<br># 此处省略函数调用，如递归<br>mv t0, a0 # 把返回值存入t0，防止丢失<br>lw a0, 4(sp)<br>lw ra, 0(sp)<br>addi sp, sp, 8<br></code></pre></td></tr></table></figure><h2 id="寄存器分配算法"><a href="#寄存器分配算法" class="headerlink" title="寄存器分配算法"></a>寄存器分配算法</h2><ul><li><img src="image-20240621110136179.png" alt="image-20240621110136179" style="zoom: 50%;" /></li><li><img src="image-20240621110531657.png" alt="image-20240621110531657" style="zoom: 67%;" /></li><li><img src="image-20240621110653715.png" alt="image-20240621110653715" style="zoom:50%;" /></li><li>线性扫描分配算法<ul><li>三大关键操作: 占用、释放、溢出</li><li><img src="image-20240621110903961.png" alt="image-20240621110903961" style="zoom:50%;" /></li><li>发生溢出时，比较右端点，把最远的放入内存，腾出来的寄存器给新变量</li><li><img src="image-20240621111514563.png" alt="image-20240621111514563" style="zoom:50%;" /></li><li>解决方案一：生成代码时, 使用临时物理寄存器实现临时变量</li><li>解决方案二: 预留若干物理寄存器, 作为溢出处理时所需的临时寄存器</li><li>分支指令问题<ul><li><img src="image-20240621111658512.png" alt="image-20240621111658512" style="zoom:50%;" /></li><li><img src="image-20240621111710530.png" alt="image-20240621111710530" style="zoom:50%;" /></li><li><img src="image-20240621111722291.png" alt="image-20240621111722291"></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II</title>
    <link href="/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/"/>
    <url>/2024/06/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="软工II整理"><a href="#软工II整理" class="headerlink" title="软工II整理"></a>软工II整理</h1><h2 id="01-软件工程基础"><a href="#01-软件工程基础" class="headerlink" title="01.软件工程基础"></a>01.软件工程基础</h2><ul><li><p>软件的特性</p><ul><li>软件与现实世界关系更加密切，对需求的规格化更加困难</li><li>软件⽐硬件容易修改的多，并且不需要昂贵的⽣产线复制产品</li><li>软件没有损耗</li><li>软件不可见</li></ul></li></ul><span id="more"></span><ul><li><p>云原生</p><ul><li><img src="image-20240311210317505.png" alt="image-20240311210317505" style="zoom: 67%;" /></li></ul></li><li><p>软件类别</p><ul><li>系统软件：操作系统、数据库、数据仓库、嵌⼊式设备、安全</li><li>编程软件：IDE、测试、持续集成、建模、度量</li><li>应用软件：商业、政府、休闲、医疗、教育、国防、 个⼈、专业、科学</li></ul></li><li><p>应⽤软件</p><ul><li>应⽤软件被开发的⽬的和意图来源于现实世界的问题。</li><li>应⽤软件必须基于现实才能解决问题。</li><li>软件最终要被⽤于现实并改进现实。</li><li><img src="image-20240311210345790.png" alt="image-20240311210345790" style="zoom:67%;" /></li></ul></li><li><p>工程</p><ul><li>定义：创造性地应用科学原理，设计或开发结构、机器、仪器或制造工艺，或单独或组合使用它们的工程；或在充分了解它们的设计的情况下建造或操作它们；或在特定操作条件下预测它们的行为；就预期功能、运行的经济性或生命财产安全而言</li><li><strong>CCSE - About Engineer 关于工程师的介绍</strong><ul><li>工程师通过⼀系列的<strong>讨论决策</strong>，仔细评估项⽬的可选活动，并在每个决策点选择⼀种在当前环境中适合工当前任务的⽅法进⾏工作。可以通过对成本和收益进⾏折衷分析调整相应策略。</li><li>工程师需要对某些对象进⾏度量，有时需要定量的工作；他们要校准和确认度量⽅法，并根据经验和实验数据进⾏估算。</li><li>软件工程师强调<strong>项目设计过程的纪律性</strong>，这是团队⾼效工作的条件。</li><li>工程师可胜任研究、开发、设计、⽣产、测试、构造、操作、管理，以及销售、咨询和培训等<strong>多种角色</strong>。</li><li>工程师们需要在某些过程中使⽤工具，选择和使用合适的工具是工程的关键要素。</li><li>工程师们通过专业协会发展和确认原理、标准和最佳实践⽅法，并提⾼个⼈能⼒。</li><li>工程师们能够重用设计和设计制品。</li></ul></li><li><img src="image-20240311210400691.png" alt="image-20240311210400691" style="zoom:50%;" /></li></ul></li><li><p>工程的要素</p><ul><li>具有解决实际问题的动机</li><li>应⽤科学知识指导⼯程活动</li><li>以成本效益比有效为基本条件</li><li>构建机器或事物</li><li>以服务⼈类为最终⽬的</li></ul></li><li><p>软件工程定义</p><ol><li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</li><li>对(1)中各种方法的研究。</li></ol></li><li><p>软件工程特点</p><ul><li>软件⼯程是⼀种⼯程活动</li><li>软件⼯程的动机是解决实际问题</li><li>软件⼯程是科学性、实践性和⼯艺性并重的</li><li>软件⼯程追求⾜够好，不是最好</li><li>软件⼯程真正的产品是基于虚拟计算机的软件⽅案</li><li>软件⼯程的最终⽬的是要促进整个社会的进步</li></ul></li><li><p>软件工程技术域</p><ul><li><img src="image-20240311210414779.png" alt="image-20240311210414779" style="zoom:67%;" /></li><li><img src="image-20240311210434034.png" alt="image-20240311210434034" style="zoom:67%;" /></li><li>软件工程管理知识域：<img src="image-20240311210446065.png" alt="image-20240311210446065"></li></ul></li><li><p>角色分工</p><ul><li>需求工程师，⼜被称为需求分析师：承担需求开发任务。软件产品的需求开发⼯作通常由多个需求工程师来完成，他们共同组成⼀个需求工程师⼩组，在⾸席需求工程师的领导下开展⼯作。通常⼀个团队只有⼀个需求工程师⼩组。</li><li>软件体系结构师：承担软件体系结构设计任务。通常也是由多⼈组成⼀个小组，并在首席软件体系结构师的领导下开展⼯作。通常⼀个团队只有⼀个软件体系结构师小组。</li><li>软件设计师：承担详细设计任务。在软件体系结构设计完成之后，可以将其部件分配给不同的开发小组。开发小组中负责所分配部件详细设计工作的⼈员就是软件设计师。⼀个团队可能有⼀个或多个开发小组。 ⼀个小组可能有⼀个或多个软件设计师。</li><li>程序员：承担软件构造任务。程序员与软件设计师通常是同⼀批⼈，也是根据其所分配到的任务开展⼯作。</li><li>⼈机交互设计师：承担⼈机交互设计任务。⼈机交互设计师与软件设计师可以是同⼀批⼈，也可以是不同⼈员。在有多个小组的软件工程团队中，可以有⼀个单独的人机交互设计师小组，也可以将⼈机交互设计师分配到各个小组。</li><li>软件测试⼈员：承担软件测试任务。软件测试⼈员通常需要独⽴于其他的开发⼈员⻆⾊。⼀个团队可能有⼀个或多个测试⼩组。⼀个⼩组可能有⼀个或多个软件测试⼈员。</li><li>项⽬管理⼈员：负责计划、组织、领导、协调和控制软件开发的各项⼯作。相⽐于传统意义上的管理者，他们不完全是监控者和控制者，更多得是协调者。通常⼀个团队只有⼀个项⽬管理⼈员。</li><li>软件配置管理⼈员：管理软件开发中产⽣的各种制品，具体⼯作是对重要制品进⾏标识、变更控制、状态报告等。通常⼀个团队只有⼀个软件配置管理⼈员。</li><li>质量保障⼈员：在⽣产过程中监督和控制软件产品质量的⼈员。通常⼀个团队有⼀个质量保障⼩组，由⼀个或多个⼈员组成。</li><li>培训和⽀持⼈员：负责软件移交与维护任务。他们可以是其他开发⼈员的⼀部分，也可以是独立的⼈员。</li><li>⽂档编写⼈员：专⻔负责写作软件开发各种⽂档的⼈员。他们的存在是为了充分利⽤部分宝贵的⼈⼒资源(例如需求工程师和软件体系结构师)，让这些⼈⼒资源从繁杂的⽂档化⼯作中解放出来。</li></ul></li></ul><h2 id="02-项目启动"><a href="#02-项目启动" class="headerlink" title="02.项目启动"></a>02.项目启动</h2><h3 id="项目和项目管理"><a href="#项目和项目管理" class="headerlink" title="项目和项目管理"></a>项目和项目管理</h3><ul><li>项目的定义<ul><li>具有⼀个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul></li><li>项目管理的目标<ul><li>在限定时间内</li><li>在⼀定的成本内</li><li>在要求的质量水平上</li><li>高效使用资源</li><li>获得客户认可</li></ul></li><li>过程组：项目启动、项目计划、项目执⾏，项目跟踪与控制和项目收尾</li><li>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</li></ul><h3 id="团队组织与管理"><a href="#团队组织与管理" class="headerlink" title="团队组织与管理"></a>团队组织与管理</h3><ul><li>团队定义：为了⼀致的目的、绩效标准、⽅法⽽共担责任并且技能互补的少数⼈。</li><li>团队结构<ul><li><strong>主程序员团队</strong>：决策需要由主程序员进行制定<ul><li>效率高，如果完成把握大，并且需要时间紧迫，可以优先考虑</li><li>一个人的决断容易影响整个团队，如果项目复杂，主程序员会成为瓶颈。</li><li>适用于把握性大，时间要求紧的情况</li></ul></li><li><strong>民主团队</strong>：没有集中的瓶颈，成员发挥能动性，工作效率降低，冲突解决。敏捷+较有挑战性的项目</li><li><strong>开放团队</strong><ul><li>为了创新而存在的。黑箱管理，问题在于项目进展没有可视度。</li><li>相对于前两个团队的需求明确，团队的需求并不明确</li><li>管理者主要负责清除出现的障碍。</li><li>开放团队是为了<strong>创新</strong>而存在</li></ul></li></ul></li><li>团队建设(高凝聚力的团队被称为胶冻团队)<ul><li><strong>建立团队章程</strong>：建立明确的团队章程，统一团队成员的目标，对团队成员进行一定的约束。经验：有必要指定一定的章程，约束团队成员之间的行为，比如开会请假必须得到其他三人的同意，又如一旦某项决策做出，不同意者不能再后续阶段违反等</li><li><strong>持续成功</strong>：设置小里程碑，每隔一段时间让团队体验成功。每次作业的检查结果一定程度上肯定了每个小阶段的工作。</li><li><strong>和谐沟通</strong>：和谐沟通：建立持续有效的沟通机制，相互尊重，管道畅通，开放透明，坦诚真实。开会频率保持在每周一次左右为宜，在工作量大的时候，需要集体工作，当面沟通，另外吵架可以，但是需要达成一致。</li><li><strong>不断总结</strong>：不断总结上一阶段的工作成果，运用项目评审等手段，进行反思回顾，指导后续阶段的开发。每个阶段都会有启动会议对上个阶段进行回顾，评审会议对此阶段进行评审。</li><li><strong>避免团队杀手</strong>：需要对别人的工作全心全意的信任，尽管评审是必要的。产品质量的降低会使凝聚力下降</li></ul></li></ul><h3 id="软件质量保障"><a href="#软件质量保障" class="headerlink" title="软件质量保障"></a>软件质量保障</h3><ul><li><p>质量属性</p><ul><li>⼈们通常会选⽤系统的某些质量要素进行量化处理，建⽴质量特征，这些特征被称为<strong>质量属性</strong></li><li>为了根据质量属性描述和评价系统的整体质量，⼈们从很多质量属性的定义当中选择了⼀些能够相互配合、相互联系的特征集，它们被称为<strong>质量模型</strong></li></ul></li><li><p>质量模型</p><ul><li>因素</li><li>功能性</li><li>可靠性</li><li>易用性:人机交互</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li><p>质量保障</p><ul><li><img src="3.png" style="zoom:50%;" /></li><li><img src="image-20240312201645433.png" alt="image-20240312201645433" style="zoom:50%;" /></li><li><p>度量产生自统计控制思想。</p></li><li><p>测度就是为了描述软件产品而提供的定量指标，如代码行数</p></li><li><p>进行测度的活动被称为测量</p></li><li><p>度量是软件产品在特定属性上的量化测度程度</p></li></ul></li><li><p>评审</p><ul><li><img src="5.png" style="zoom:50%;" /></li><li>在<strong>规划</strong>阶段，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与⼈员、审查内容等等。</li><li>在<strong>总体部署</strong>阶段，向所有参与审查会议的⼈员描述待审查材料的内容、审查的⽬标以及⼀些假设，并分发⽂档。</li><li>在<strong>准备</strong>阶段，审查⼈员各⾃独⽴执⾏检查任务。在检查的过程当中，他们可能会被要求使⽤检查清单、场景等检查⽅法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集 ⼈员。</li><li>在<strong>审查会议</strong>阶段，通过会议讨论，识别、确认、分类发现的错误。</li><li>在**返⼯**阶段，修改发现的缺陷。</li><li>在<strong>跟踪</strong>阶段，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</li></ul></li><li><p>软件配置管理的动机</p><ul><li>在软件开发活动中，除了最终产品之外，还会产⽣很多<strong>中间制品</strong>，例如需求规格说明、需求分析模型、软件体系结构设计模型、详细设计模型等。这些制品是不同阶段、不同角色、不同软件开发活动进行协同的基础。</li><li>在复杂软件系统开发中，产⽣的制品数量众多，以⾄于开发者需要维护⼀个清单才能清楚项目所处的状态，理解已经完成的⼯作和将要进行的⼯作。</li><li>某个制品发⽣变化带来的最大挑战是如何确保其使用者能够得到最新的制品，避免开发协同出现问题</li></ul></li><li><p>配置管理</p><ul><li>IEEE定义：用技术的和管理的指导和监督方法，来标识和说明<strong>配置项</strong>的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的⼀致性</li><li><strong>配置项</strong>：置于软件配置管理之下的软件配置的各种有关项⽬，包括各类管理文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等</li><li><strong>基线</strong>：基线是指通过了评审和验证，可以作为后续开发工作基础而进入协同工作过程，需要纳入配置管理和执行变更控制的制品</li><li><strong>配置管理活动</strong>：<ul><li>标识配置项版本管理：确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单</li><li>配置审计：验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告：反映当前的配置状态。</li><li>软件发布管理：将配置项发布到开发活动之外，例如发布给客户。</li><li><img src="image-20240312203602358.png" alt="image-20240312203602358" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h3 id="管理实践"><a href="#管理实践" class="headerlink" title="管理实践"></a>管理实践</h3><ul><li>投入<ul><li>⼈员的成本：这是最重要的一部分投⼊。 除了开发⼈员外，还要计算项目管理⼈员和其他相应⽀持⼈员的费用</li><li>工具的购买：包括计算机及其周围配套设备等硬件，也包括开发⼯具、办公套件等软件。</li><li>培训的费用：开发⼈员接受培训，获得开发项⽬所需技能的费⽤。</li><li>差旅费：拜访客户，参加会议等的费⽤。</li><li>维护的费用：定时的数据备份、系统监控、系统维修和升级等引起的费⽤。</li><li>生产停顿的损失：因为项⽬调试引起正常⼯作业务停顿的损失。</li><li>市场和服务的费用：推⼴软件产品所要的⼴告费用、参加展览会的费用等。</li><li>机会成本：因为投资该项目，而不能投资别的项目或者放银行收取利息的机会成本。</li></ul></li><li>产出<ul><li>节约商业活动成本：只要是和无新软件系统时候比较，将节省的时间和原材料折算成量化的数字。例如，开发了新的库存管理系统后，加快了流通并减少了库存浪费。</li><li>创新商机增加销售：指由于使用新软件带来的盈利，可能是软件产品本身的销售，也可能是软件项目带来的营业成⻓。</li><li>提高品牌含金量： 提高质量和客户满意度，可以带来品牌含金量的提高。这比较虚⼀点，但也可以像企业的无形资产⼀样估算。</li></ul></li></ul><h3 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h3><ul><li><p>为实践项目组建你的团队：</p><ul><li>选择技能互补的成员组成团队，明确分工；</li><li>根据成员特点，选择团队结构；(建议使用民主团队)</li><li>建立团队章程；</li><li>明确团队的交流沟通⼿段。</li><li>需要保留开发过程，用来确保可查</li></ul></li><li><p>配置管理</p><ul><li>所有产物都通过Gitlab来管理</li><li>建立Group</li><li>⽂档采用MD文件</li></ul></li></ul><h2 id="03-需求基础"><a href="#03-需求基础" class="headerlink" title="03.需求基础"></a>03.需求基础</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><ul><li><p>需求工程的概念：所有需求处理活动的总和。它<strong>收集</strong>信息、<strong>分析</strong>问题、<strong>整合</strong>观点、记录需求并<strong>验证</strong>其正确性，最终描述出软件被应用后与其环境互动形成的<strong>期望效应</strong>。</p></li><li><p>三个主要任务：</p><ul><li>需求工程必须说明软件系统将被应用的应用环境及其<strong>目标</strong>，说明用来达成这些目标的软件功能，也即要同时说明软件”需要<strong>做什么</strong>“和”<strong>为什么</strong>需要做”。</li><li>需求⼯程必须将⽬标和功能反映到软件系统当中，映射为<strong>可行的软件行为</strong>，并对软件⾏为进行准确的<strong>规格说明</strong>。</li><li>现实世界是<strong>不断变化</strong>的世界，因此需求⼯程还需要妥善处理⽬标和功能随着时间演化的变动情况。</li></ul></li><li><p>需求工程活动</p><ul><li><img src="image-20240313121004338.png" alt="image-20240313121004338" style="zoom:50%;" /></li></ul></li><li><p>需求开发</p><ul><li><img src="image-20240313121025278.png" alt="image-20240313121025278" style="zoom:50%;" /></li><li><p>需求获取</p><ul><li>从<strong>人、文档或者环境</strong>当中获取需求的过程</li><li>要利⽤各种方法和技术来<strong>发现</strong>需求</li><li>目标分析：1. 根据问题确定目标:发现用户的期望和现实之间的差距 2. 通过分析利害关系人确定目标</li><li>需求获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型、民族志、竞品分析</li><li>问题与解决方案<ol><li>用户和开发⼈员的背景不同，⽴场不同：消除默认知识</li><li>普通用户缺乏概括性、综合性的表述能力：专业的需求人员</li><li>⽤户存在认知困境：原型(做一个原型帮助用户理解的草图模型)</li><li>⽤户越俎代庖：需求是开发人员开发出来的，不是⽤户提出来的；协商</li><li>缺乏用户参与：为用户参与提供⽅便</li></ol></li></ul></li><li><p>需求分析</p><ul><li>通过<strong>建模</strong>来整合各种信息，以使得人们更好的理解问题。</li><li>为问题定义出⼀个需求集合，这个集合能够为问题界定⼀个有效的<strong>解决方案</strong>。</li><li><strong>检查</strong>需求当中存在的错误、遗漏、不⼀致等各种缺陷，并加以修正</li><li>边界分析<ol><li>定义项目的范围。系统边界之内定义的是系统需要对外提供的功能</li><li>系统边界的定义要保证系统能够和周围环境形成有效的互动</li><li>系统用例图、上下文图通常被用来定义系统的边界</li></ol></li></ul></li><li><p>需求规格说明</p><ul><li>在系统用户之间<strong>交流需求信息</strong></li><li>要简洁、精确、⼀致和易于理解</li><li>需求工程师在这个阶段的重要工作包括:<ol><li>定制文档模版，提高效率</li><li>编写文档(模型语言和自然语言两种)</li></ol></li></ul></li><li><p>需求验证</p><ul><li>需求规格说明文档至少要满足下面几个标准:<ol><li>文档内每条需求都<strong>正确、准确</strong>的反映了用户的意图；</li><li>文档记录的需求集在整体上具有<strong>完整性和⼀致性</strong>；</li><li>文档的组织方式和需求的书写方式具有<strong>可读性</strong>和<strong>可修改性(方便保证版本简化)</strong>。</li></ol></li><li>需求验证的方法：同级评审、原型、模拟等</li></ul></li></ul></li><li><p>需求管理</p><ul><li>保证需求作用的持续、稳定和有效发挥：在需求开发活动之后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展⼯作</li><li>进行变更控制：纳入和实现合理的变更请求，拒绝不合理的变更请求，控制变更的成本和影响范围</li></ul></li></ul><h3 id="需求基础"><a href="#需求基础" class="headerlink" title="需求基础"></a>需求基础</h3><ul><li>IEEE对需求的定义：<ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对1或2中的一个条件或一种能力的一种文档化表述。</li></ol></li><li>需求开发的目标<ul><li><img src="4.png" style="zoom: 67%;" /></li></ul></li><li>问题域<ul><li>现实世界运行规律的一种反映</li><li>需求的<strong>产生域</strong>，也是需求的<strong>解决地</strong>。</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄⾃修改现实世界的实际情况。</li></ul></li></ul></li><li>规格说明<ul><li>软件产品的方案描述，它以软件产品的运行机制为主要内容。</li><li>它不是需求但实现需求，不是问题域但需要与问题域互动。</li><li>规格说明要以关注<strong>对外交互</strong>的⽅式描述软件解决⽅案，它既需要从软件产品的⻆度⽽不是⽤户的⻆度进⾏描述，⼜不能太多地涉及软件产品的内部构造机制。</li><li>为什么描述的是交互？因为交互对我们而言是一个对外的重要展示。</li></ul></li><li>需求、问题域、规格说明三者要进行区分<ul><li><img src="image-20240313122311441.png" alt="image-20240313122311441" style="zoom: 60%;" /></li></ul></li><li>需求层次性<ul><li>三种需求层次:业务需求、用户需求、系统级需求</li><li>业务需求(目标，解决方案与系统特性)<ul><li>业务需求是<strong>高层次</strong>的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。</li><li>为什么是系统特性？因为还没有到细节的部分</li><li>特性说明了系统为用户提供的各项功能，它限定了系统的<strong>范围</strong>(Scope)</li><li>例：在系统使用3个月后，销售额度应该提⾼20%</li></ul></li><li>用户需求(任务，问题域知识)<ul><li>问题域知识：执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么<ol><li>直接用户</li><li>间接用户(<strong>通用软件的销售人员和售后支持人员</strong>)</li></ol></li><li>问题域知识：是需要了解到期望所来源的背景知识。</li><li><strong>特性</strong><ol><li>模糊、不清晰(允许适度的用形容词和副词)</li><li>多特性混杂 (功能和⾮功能的混杂)</li><li>多逻辑混杂 (⼀个任务需要多次系统交互才能完成)</li></ol></li><li>例：系统应该允许客户经理添加、修改或者删除会员个⼈信息</li></ul></li><li>系统级需求<ul><li>需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的⼀个实现细节</strong>(和用户需求有着很大的区别)</li><li>描述了开发人员<strong>需要实现什么</strong></li><li>将用户需求转化为系统需求的过程是⼀个复杂的过程<ol><li>首先需要分析<strong>问题领域</strong>及其特性，从中发现问题域和计算机系统的共享知识，建⽴系统的知识模型；</li><li>然后将⽤户需求<strong>部署到系统模型</strong>当中，即定义系列的系统⾏为，让它们联合起来实现⽤户需求，每⼀个系统⾏为即为⼀个系统需求。</li><li>该过程就是需求⼯程当中最为重要的需求分析活动，⼜称<strong>建模与分析活动</strong>。</li></ol></li><li>系统级需求还可能会补充一些与软件实现相关的细节</li><li>例：在客户经理输⼊会员的客户编号时，系统要提供该会员的个⼈信息</li></ul></li><li><img src="image-20240313122823522.png" alt="image-20240313122823522" style="zoom: 67%;" /></li></ul></li></ul><h3 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h3><ul><li><p>需求图谱</p><ul><li><img src="image-20240313163053020.png" alt="image-20240313163053020" style="zoom:50%;" /></li><li>项目需求(<strong>人的数量、计划成本、时间</strong>)：项目的成本要控制在60万元⼈⺠币以下、项目要在6个月内完成</li><li>过程需求(<strong>人的分工、合作、方法、工具</strong>)：如在开发中，开发者要提交软件需求规格说明文档、设计描述⽂档和测试报告；项目要使用持续集成⽅法进行开发</li></ul></li><li><p>需求的分类（IEEE）</p><ul><li><strong>功能需求</strong>：和系统主要共作相关的需求，即在不考虑物理约束的情况下，⽤户希望系统所能够执行的活动，这些活动可以帮助⽤户完成任务。<strong>功能需求主要表现为系统和环境之间的⾏为交互</strong>。</li><li><strong>性能需求</strong>：系统整体或系统组成部分应该拥有的性能特征，包括速度、容量、吞吐量、负载、实时性</li><li><strong>质量属性</strong>：系统完成工作的质量，即系统需要在⼀个”好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。</li><li><strong>对外接口</strong>：系统和环境中其他系统之间需要建⽴的接口，包括硬件接口、软件接口、数据库接口等等。</li><li><strong>约束</strong>：进行系统构造时需要遵守的约束，例如<strong>编程语言、硬件设施</strong>等</li></ul></li><li><p>功能需求</p><ul><li>功能需求是最常见、最主要和最重要的需求，是能够为用户带来业务价值的系统⾏为</li><li><strong>最需要按照三个抽象层次进行展开</strong>，说明了关系</li><li>软件产品产生价值的基础，需求检查最重要的部分</li><li>比如:在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息</li></ul></li><li><p>数据需求</p><ul><li><strong>功能需求</strong>的补充：如果在功能需求部分明确定义了<strong>相关的数据结构</strong>，那么就不需要再行定义数据需求</li><li>数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：<ul><li>各个功能使⽤的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li></ul></li></ul></li><li><p>性能需求</p><ul><li><img src="image-20240313165138780.png" alt="image-20240313165138780" style="zoom: 67%;" /></li></ul></li><li><p>质量属性</p><ul><li>系统为了满足<strong>规定的及隐含</strong>的所有要求而需要具备的要素称为质量</li><li>质量属性是为了度量质量要素而选用的特征</li><li>质量模型就是能够为质量需求的描述和评价提供工作基础的特征集及特征之间的联系</li></ul></li><li><p>常见质量属性</p><ol><li><strong>可靠性</strong>(Reliability)：在规格时间间隔内和规定条件下，系统或部件执⾏所要求能⼒的能⼒。<ul><li>在进⾏数据的下载和上传中，如果⽹络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复。</li></ul></li><li><strong>可用性</strong>(Availability)：软件系统在投⼊使⽤时可操作和可访问的程度或能实现其指定系统功能的概率。<ul><li>系统的可⽤性要达到98%。</li></ul></li><li><strong>安全性</strong>(Security)：软件阻止对其程序和数据进行未授权访问的能力，未授权的访问可能是有意，也可能是无意的。<ul><li>VIP顾客只能查看自己的个人信息和购买记录；</li><li>收银员只能查看，不能修改、删除VIP顾客的信息。</li></ul></li><li><strong>可维护性</strong>(Maintainability)：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。<ul><li>如果系统要增加新的特价类型，要能够在2个⼈⽉内完成。</li></ul></li><li><strong>可移植性</strong>(Portability)：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。<ul><li>集中服务器要能够在1⼈⽉内从Window 7操作系统更换到Solaris 10操作系统。</li></ul></li><li><strong>易用性</strong>(Usability)：与⽤户使⽤软件所花费的努⼒及其对使⽤的评价相关的特性。<ul><li>使用系统1个⽉的收银员进⾏销售处理的效率要达到10件商品&#x2F;分钟。</li></ul></li></ol></li><li><p>对外接口</p><ul><li><strong>解系统和其他系统</strong>之间的软硬件接⼝:包括硬件接口、软件接口、数据库接口等<ul><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li></ul></li><li>用户界面</li></ul></li><li><p>约束</p><ul><li>总体上限制了开发⼈员设计和构建系统时的选择范围</li><li><strong>系统开发及运行的环境</strong><ul><li>包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等</li><li>例：系统要使用Java语言进行开发。</li></ul></li><li><strong>问题域内的相关标准</strong><ul><li>包括法律法规、⾏业协定、企业规章等。</li></ul></li><li><strong>商业规则</strong><ul><li>⽤户在任务执⾏中的⼀些潜在规则也会限制开发⼈员设计和构建系统的选择范围</li></ul></li></ul></li></ul><h2 id="04-需求分析基础"><a href="#04-需求分析基础" class="headerlink" title="04.需求分析基础"></a>04.需求分析基础</h2><h3 id="需求分析基础"><a href="#需求分析基础" class="headerlink" title="需求分析基础"></a>需求分析基础</h3><ul><li>需求分析的任务<ul><li>建立<strong>分析模型</strong>，达成开发者和用户对需求信息的共同理解:分析将复杂的系统分解为简单的部分以及它们之间的联系，确定本质特征，抛弃次要特征。</li><li>依据共同的理解，<strong>发挥创造性</strong>，创建软件系统解决方案:分析可以将一个问题分解为独立的、更简单的和易于管理的子问题来帮助寻找解决方案</li></ul></li><li>模型<ul><li>模型是对事物的抽象，帮助⼈们在创建一个事物之前可以有更好的理解</li><li>为了更好地理解需求获取所得到的复杂信息，需要集中关注问题的计算特性(数据、功能、规则等)，建立相关的软件模型</li></ul></li><li>建模<ul><li>建模的目标是建立系统的一个表示，这个表示以精确⼀致的方式描述系统，使得系统的使用更加容易</li><li><strong>抽象</strong>和<strong>分解</strong>是建模最为常用的两种手段</li></ul></li><li>需求分析模型<ul><li><img src="image-20240314102113872.png" alt="image-20240314102113872" style="zoom:50%;" /></li></ul></li></ul><h3 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h3><ul><li><p>面向对象分析过程</p><ul><li><img src="image-20240314102240131.png" alt="image-20240314102240131" style="zoom:67%;" /></li></ul></li></ul><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><ul><li><p>用例</p><ul><li>定义：在系统(或者子系统或者类)和外部对象的交互当中所执行的行为序列的描述,包括各种不同的序列和错误的序列,它们能够联合提供⼀种有价值的服务</li><li>用例描述了在不同条件下系统对某一用户的请求的响应。根据用户的请求和请求时的系统条件,系统将执行不同的行为序列, 每⼀ 个行为序列被称为⼀个场景。⼀个用例是多个场景的集合。</li><li>用例图的建立：目标分析与解决方向的确定、寻找参与者、寻找用例、细化用例</li></ul></li><li><p>用例图基本元素：用例、参与者、关系、系统边界</p><ul><li>用例：椭圆<ul><li>以用例的形式表达需求。</li><li>用例表示有助于构建、关联和理解基本需求的典型场景集。</li><li>场景是对系统在实践中如何使用的描述：用户与计算机系统之间的典型交互</li><li>一般会用动宾短语，加上actor作为主语就是句子了</li></ul></li><li>参与者：小人<ul><li>参与者是用户或其他系统对要开发的系统所扮演的角色。</li><li>用例图中的单个参与者可以表示多个用户(或系统)。</li><li>单个用户(或系统)也可以扮演多个角色。</li><li>参与者不需要是人，例如，需要来自当前系统的某些信息的外部系统也是参与者。</li></ul></li><li>关系：简单的就是一条直线<ul><li>有关</li><li>泛化关系，指向的是被泛化的。</li><li>包含关系</li><li>继承关系</li></ul></li><li>系统边界：是一个框<ul><li>强调重点是什么是要详细的，什么不是。</li><li>系统边界隐式存在于没有显式表示的系统边界的图中</li><li>参与者总是在边界之外，用例总是在边界之内。</li><li>系统边界是指一个系统所包含的系统成分与系统外事务的分界线</li></ul></li></ul></li><li><p>目标分析</p><ul><li>问题目标的解决方案</li><li>×××连锁商店是一家刚刚发展起来的小型连锁商店，其前身是⼀家独立的小百货门面店。<ul><li>首先是随着商店规模的扩大，顾客量大幅增长，手工作业销售迟缓，顾客购物排队现象严重，导致流失客源。</li><li>其次是商店的商品品种增多，无法准确掌握库存，商品积压、缺货和报废的现象上升明显。</li><li>再次是商店面临的竞争比以前更⼤，希望在降低成本，吸引顾客，增强竞争力的同时，保持盈利水平</li></ul></li><li>业务需求<ol><li>BR1：在系统使⽤6个月后，商品积压、缺货和报废的现象要减少50%</li><li>BR2：在系统使⽤3个月后，销售⼈员⼯作效率提⾼50%</li><li>BR3：在系统使⽤6个月后，运营成本要降低15%<ul><li>范围：⼈力成本和库存成本</li><li>度量：检查平均员工数量和平均每10,000元销售额的库存成本</li></ul></li><li>BR4：在系统使⽤6个月后，销售额度要提高20%</li></ol></li><li>系统功能<ol><li>SF1：分析商品库存，发现可能的商品积压、缺货和报废现象</li><li>SF2：根据市场变化调整销售的商品</li><li>SF3：制定促销手段，处理积压商品</li><li>SF4：与生产厂家联合进行商品促销</li><li>SF5：制定促销手段进行销售竞争</li><li>SF6：掌握员工变动和授权情况</li><li>SF7：处理商品入库与出库</li><li>SF8：发展会员，提高顾客回头率</li><li>SF9：允许积分兑换商品和赠送吸引会员的礼品，提高会员满意度</li><li>SF10：帮助收银员处理销售与退货任务</li></ol></li></ul></li><li><p>寻找参与者与用例</p><ul><li>每个用户的任务(目标)都是⼀个独立用例</li><li><img src="image-20240314104447968.png" alt="image-20240314104447968" style="zoom: 67%;" /></li><li><img src="image-20240314104544180.png" alt="image-20240314104544180" style="zoom: 67%;" /></li></ul></li><li><p>细化用例</p><ul><li>如果用例的粒度不合适就需要进⾏细化和调整。</li><li>判断标准是：⽤例描述了为应对<strong>一个业务事件</strong>，由<strong>一个用户</strong>发起，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务</li><li>产品具体的细化（例子）<ol><li>特价策略制定、赠送策略制定两个用例的业务目的、发起源和过程基本相同，仅仅是业务数据不同，所以可以合并为⼀个用例销售策略制定。</li><li>会员管理用例有两个明显不同的业务事件，可以被细化为发展会员和礼品赠送2个更细粒度的用例。</li><li>客户经理的库存管理用例也有三个不同的业务⽬标：出库、⼊库和库存分析，所以也应该细化为三个用例商品出库、商品⼊库和库存分析，其中库存分析⽤例与总经理的库存分析⽤例相同。</li></ol></li><li><img src="image-20240314105045573.png" alt="image-20240314105045573" style="zoom:67%;" /></li></ul></li><li><img src="13.png" style="zoom: 80%;" /></li></ul><h4 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h4><ul><li><p>概念</p><ul><li>概念类图又被称为”领域模型”(Domain Model)</li><li>类图是面向对象分析方法的核心：类图描述类(对象)和这些类(对象)之间的关系</li><li>概念类图和<strong>设计类图</strong>的不同点：关注系统与外界的交互，⽽不是软件系统的内部构造机制</li><li><strong>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</strong></li><li>类图只有类和类名，没有包含方法。</li><li>用例不是概念类，同一个用例可能产生多个概念类</li></ul></li><li><p>概念类图基本元素</p><ul><li>对象<ul><li>标识符：对象自治、对象请求写作</li><li>状态：存储数据，如密码、名称</li><li>行为：利用数据做什么</li></ul></li><li>类:对象集合的抽象</li><li>链接<ul><li>对象之间的互相协作的关系</li><li>描述了对象之间的物理或业务联系</li></ul></li><li>关联<ul><li>对象之间链接的抽象</li><li>聚合(空心菱形)与组合(实心菱形)</li></ul></li><li>继承：泛化关系</li><li><img src="image-20240428112931962.png" alt="image-20240428112931962"></li></ul></li><li><p>建立概念类图的步骤</p><ul><li>对每个用例文本描述，尤其是场景描述，建立<strong>局部</strong>的概念类图<ul><li>识别候选类(名词分析法)</li><li><strong>确定概念类</strong> (看是否满足既有状态又有行为)<ol><li>既需要维持一定的状态，又需要依据状态表现一定的行为：确定为一个概念类</li><li>如只需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，却需要表现行为：首先重新审视需求是否有遗漏，因为没有状态支持的对象无法表现行为；如果确定没有需求的遗漏，就需要剔除该候选类，并将行为转交给具备状态支持能力的其他概念类</li><li>既不需要维护状态，又不需要表现行为：应该被完全剔除</li></ol></li><li>识别关联(文本中提取出”名词＋动词＋名词”的结构)：第一标准是满足需求的要求，第二标准是现实状况</li><li>识别重要属性：协作的必要信息，通过分析用例的描述，补充问题域信息发现。</li></ul></li><li>将所有用例产⽣的局部概念类图进行合并，建⽴软件系统的整体概念类图</li><li>自己注:先画关联关系，再添加类的属性</li><li><img src="image-20240410205025063.png" alt="image-20240410205025063" style="zoom: 60%;" /></li><li><img src="image-20240410205400576.png" alt="image-20240410205400576"></li></ul></li></ul><h4 id="顺序图（交互图）"><a href="#顺序图（交互图）" class="headerlink" title="顺序图（交互图）"></a>顺序图（交互图）</h4><ul><li>概念<ul><li>行为模型显示了对象之间的交互，以产生一些特定的系统行为，这些行为被指定为一个用例</li><li>UML中的序列图(或协作图)用于<strong>建模对象之间的交互</strong></li><li>分析阶段，主要是利用<strong>系统顺序图</strong>，表达系统和外部参与者之间的交互行为：务必要严格谨慎的界定系统</li></ul></li><li>图例<ul><li><img src="image-20240421171223317.png" alt="image-20240421171223317" style="zoom:67%;" /></li></ul></li><li>系统顺序图<ul><li><img src="image-20240421171303355.png" alt="image-20240421171303355" style="zoom: 80%;" /></li><li>画外部和内部之间的交互应当仔细辨别系统和系统(也就是系统边界)</li><li>不同框的含义:<ol><li>alt一定要选(多选一):<strong>注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[ ]里面。</strong></li><li>opt一定要选(选择0或者1)</li><li>loop:表示循环，在旁边使用[]书写循环条件</li></ol></li><li>步骤:<ol><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加消息</li></ol></li></ul></li></ul><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><ul><li>概念<ul><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ul></li><li><img src="31.png" style="zoom:50%;" /></li><li><img src="image-20240428223753527.png" alt="image-20240428223753527"></li><li><strong>创建状态图的步骤</strong><ul><li>确定上下文环境<ul><li>状态图是立足于状态快照进行行为描述的，因此建立状态图时首先要搞清楚<strong>状态的主体</strong>，确定状态的上下文环境。常见的状态主体有：类、用例、多个用例和整个系统。</li><li>状态应该是相对较多，比较复杂的。</li></ul></li><li>识别<strong>状态</strong><ul><li>状态主体会表现出⼀些稳定的状态，它们需要被识别出来，并且标记出其中的初始状态和结束状态集。在有些情况下，可能会不存在确定的初始状态和结束状态。</li></ul></li><li>建立<strong>状态转换</strong><ul><li>根据需求所描述的系统行为，建⽴各个稳定状态之间可能存在的转换。</li></ul></li><li>补充<strong>详细信息</strong>，完善状态图<ul><li>添加转换的触发事件、转换行为和监护条件等详细信息</li></ul></li></ul></li></ul><h3 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h3><ul><li>方法<ul><li>自顶向下分解</li><li>各种图<ul><li>数据流图</li><li>实体关系图</li><li>状态转移图</li></ul></li></ul></li><li>结构图<ul><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li></ul></li></ul><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><ul><li>数据流图<ul><li>数据流图将系统看做是过程的集合，其中一些由人来执行，另一些由软件系统来执行。</li><li><strong>过程的执行就是对数据的处理：它接收输入，进行数据转换，输出结果。</strong></li><li>数据流图主要是展示了数据在通过系统如何进行了变化。</li><li>可能需要和软件系统外的实体尤其是<strong>人</strong>进行交互</li><li>数据的变化包括：<strong>被转换、被存储、或者被分布</strong></li><li><img src="41.png" style="zoom: 80%;" /></li><li>外部实体：数据的产生或者消耗者，是待构建软件系统之外的人、组织、设备或者其他软件系统，它们不受系统控制，开发者不能以任何方式操纵它们</li><li>过程：<ul><li>将数据从输入转换到输出：示例：计算税金，确定面积，格式报告，显示图形必须始终以某种方式处理数据以实现系统功能</li><li>过程是指施加于数据的动作或者行为，它使得数据发生变化，包括被转换、被存储或者被分布</li></ul></li><li>数据流：数据流是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。</li><li>数据存储：软件系统需要在内部手机、保存，以供日后使用的数据集合。</li><li>数据流图分为三种图：上下文图、0层图和N层图<ul><li>上下文图是DFD的最高层次的图，是系统功能的最高抽象。上下文将整个系统看做一个过程，这个过程实现系统的所有功能</li><li>0层图通常被用作整个系统的功能概图为了概述整个系统的功能，建立0层图时需要分析需求获取的信息，归纳出系统的主要功能</li><li>N层图：父过程为被分解的过程，子图为分解后产生的揭示更多细节的图</li><li>具体见ppt</li></ul></li></ul></li></ul><h4 id="实体关系图"><a href="#实体关系图" class="headerlink" title="实体关系图"></a>实体关系图</h4><ul><li><p>实体关系图</p><ul><li><p>传统实体</p><ul><li>实体并不是孤立存在的，相互交互相互影响</li><li>参与关系的每个实体都针对关系拥有最大基数和最小基数</li><li>最大基数:对关系中任意的其他实体实例，该实体可能参与关系的最大数量。最大基数为1，表示为One，否则为Many</li><li>最小基数:对关系中任意的其他实体实例，该实体可能参与关系的最小数量。实体在关系中的最小基数被标记为Optional,最小基数为1时，实体在关系中的最小基数被标记为mandatory</li></ul></li></ul></li></ul><ul><li><p>关系</p><ul><li>系统必须记住的事实，不能或不能计算或推导出来<ul><li>关系的几个实例可以存在</li><li>实体可以以多种方式关联</li><li><img src="37.png" style="zoom: 67%;" /></li></ul></li><li>键：实体的⼀个或者多个属性能够唯⼀确定和标示每个实例，这些属性或者属性组合就被称为实体的标示符，或者键</li></ul></li><li><p>建立实体关系图的步骤</p><ul><li>第1级-对所有数据对象(实体)及其相互之间的”连接”建模</li><li>第2级-对所有实体和关系建模<ul><li>第3级-对所有实体、关系和属性建模，以提供进一步的深度</li></ul></li><li><img src="38.png" style="zoom: 67%;" /></li></ul></li></ul><h3 id="使用需求分析方法细化和明确需求"><a href="#使用需求分析方法细化和明确需求" class="headerlink" title="使用需求分析方法细化和明确需求"></a>使用需求分析方法细化和明确需求</h3><ul><li><p>为什么要细化</p><ul><li>用户需求的描述的模糊性和系统设计所需要的严谨性之间的矛盾</li></ul></li><li><p>如何细化</p><ul><li>需求分析建模</li><li>发现其中的遗漏、冲突、冗余和错误</li><li>迭代(获取、分析、获取、分析······)</li></ul></li><li><p>系统顺序图有助于发现交互性的缺失</p><ul><li><img src="image-20240327204341393.png" alt="image-20240327204341393" style="zoom: 80%;" /></li></ul></li><li><p>概念类图有助于发现</p><ul><li><p>部分信息的使用不准确</p></li><li><p>部分信息不明确</p></li><li><p>遗漏了重要内容</p></li><li><img src="image-20240327204359767.png" alt="image-20240327204359767" style="zoom:80%;" /></li></ul></li><li><p>状态图有助于发现页面的跳转</p><ul><li><img src="image-20240327204629398.png" alt="image-20240327204629398" style="zoom: 67%;" /></li></ul></li><li><p>建立系统需求</p><ul><li>8种规格说明：<ul><li>by mode 功能需求分类</li><li>by user class</li><li>by object</li><li>by feature</li><li>by stimulus</li><li>by functional hierarchy</li><li>multiple organization</li></ul></li><li>不同的分析⽅法适合不同的规格说明</li></ul></li></ul><h2 id="05-需求文档化与验证"><a href="#05-需求文档化与验证" class="headerlink" title="05.需求文档化与验证"></a>05.需求文档化与验证</h2><h3 id="用例文档"><a href="#用例文档" class="headerlink" title="用例文档"></a>用例文档</h3><ul><li>为什么文档化需求<ul><li>方便团队工作和沟通</li><li>方便项目管理</li><li>更加明确的体系架构</li><li>方便软件设计</li><li>方便编码</li><li>方便维护</li></ul></li><li>为什么建立需求规格说明？结合试验说明（<strong>重要</strong>）<ul><li>方便交流，软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以在软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li>需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li>在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化。</li></ul></li><li>用例文档<ul><li>在用户的角度以用例文本为主描述软件系统与外界的交互</li><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li><li><img src="image-20240331164631718.png" alt="image-20240331164631718" style="zoom:67%;" /></li><li>用例图等描述图可以更加直观的了解这部分</li></ul></li></ul><h3 id="软件需求规格说明文档（SRS）"><a href="#软件需求规格说明文档（SRS）" class="headerlink" title="软件需求规格说明文档（SRS）"></a>软件需求规格说明文档（SRS）</h3><ul><li>概念<ul><li>在软件产品的⻆度以系统级需求列表的⽅式描述软件系统解决方案</li><li><img src="image-20240331172611622.png" alt="image-20240331172611622" style="zoom: 67%;" /></li></ul></li><li>模板<ul><li><img src="3-1746703874907.png" style="zoom:67%;" /></li></ul></li></ul><h3 id="文档化需求"><a href="#文档化需求" class="headerlink" title="文档化需求"></a>文档化需求</h3><ul><li><p>注意事项</p><ul><li>简洁:动词名词+辅助词，不要使用复杂长句、形容词和副词。</li><li>精确:不能产生起义或无法理解。</li><li>易读(查询)：有效使用引言、目录、索引等能够增强文档易读性的方法；使用系统化的方式组织内容信息，提供文档内容的可读性。</li><li>易修改：使用相同的语句格式组织相关联或相似的信息；使用列表组织独立、并列的信息；使用编号表达繁杂信息之间的关系。引用而不是重复</li></ul></li><li><p>系统化的方式</p><ul><li>使用<strong>相同</strong>的语句格式来描述相似、关联的信息。</li><li>使用<strong>列表或者表格</strong>来组织独立、并列的信息。</li><li>使用<strong>编号</strong>来表达繁杂信息之间的关系,包括顺序关系、嵌套关系和层次关系。<ul><li>对图、表进行编号</li><li>对⽂档的章节进行编号</li><li>对信息内容进行标识和编号</li></ul></li></ul></li><li><p>需求书写要点</p><ul><li>需求书写要点<ul><li>使用用户术语:不要使用计算机术语(导致用户无法理解)</li><li>可验证：不可验证的需求一般是因为描述模糊或者过于抽象</li><li>可行性：需求必须能够在系统及其运行环境的已知条件和约束下实现。要考虑在限定成本、时间和人力约束内，实现需求的可能性</li></ul></li><li>需求规格说明文档书写要点<ul><li>充分利用标准的文档模版，保持所有内容位置得当</li><li>保持⽂档内的需求集具有完备性和⼀致性。</li><li>为需求划分优先级(可以分为高中低、也可以分为1-10等分)</li></ul></li></ul></li><li><p>验证需求文档</p><ul><li>评审<ul><li>评审的人员不能仅由技术人员组成，必须包括客户和用户</li><li>在评审中使用线索，⽤户对场景与线索表现出了最⼤的兴趣</li><li>使用需求检查列表</li></ul></li><li>开发系统测试用例<ul><li>基于用例描述，可以为销售处理确定测试用例套件</li><li>测试用例套件是测试用例的集合，将有关测试用例集合在一起</li></ul></li><li>建立测试用例<ul><li>主要是基于规格的技术，设计测试场景的输⼊与输出数据</li><li>不断地添加测试用例来完成测试</li></ul></li></ul></li><li><p>度量需求功能点</p><ul><li><p>度量需求</p><ul><li>用例的数量<ul><li>平均每个用例中的场景数量</li><li>平均用例行数</li><li>在一个尺度下进行分析</li></ul></li><li>软件需求数量</li><li>非功能需求数量</li><li>功能点数量</li></ul></li><li><p>度量的意义</p><ul><li>如果平均的用例场景<strong>数量过低</strong>，那么就可能存在对<strong>异常流程考虑不周</strong>的可能。</li><li>如果<strong>平均用例行数过大或者过小</strong>，那么可能对⽤例的细分粒度过⼤或者过小。</li><li>用例数量、软件需求数量和功能点数量应该是相对比例均衡的，如果三者之间有着**⾮常大的差距**，那么可能会有需求的遗漏。</li></ul></li><li><p>功能点度量</p><ul><li><p>用于估算和度量软件系统规模与复杂度的抽象单位</p></li><li><img src="image-20240331191831646.png" alt="image-20240331191831646" style="zoom:67%;" /></li><li><p>功能点测度总数：</p><img src="8.png" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="08-软件设计基础"><a href="#08-软件设计基础" class="headerlink" title="08.软件设计基础"></a>08.软件设计基础</h2><h3 id="什么是软件设计"><a href="#什么是软件设计" class="headerlink" title="什么是软件设计"></a>什么是软件设计</h3><ul><li>概念<ul><li>软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。</li><li>软件设计活动以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。</li><li>软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性。</li></ul></li><li>软件设计的核心思想<ul><li>软件设计方法的核心问题：控制系统复杂度</li><li>分解与抽象是软件设计的核心思想，两者都是由层次性的，彼此之间可以嵌套使用。<ol><li>分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象:在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度。</li></ol></li><li><img src="image-20240408111022715.png" alt="image-20240408111022715" style="zoom:50%;" /></li><li><img src="1.png" style="zoom: 67%;" /></li></ul></li><li>设计<ul><li>定义<ul><li>设计(名词):⼀个对象的规格说明。它由⼈创造,有明确的⽬标,适⽤于特殊的环境,由⼀些基础类型构件组成,满⾜⼀个需求集合,受⼀定的限制条件约束。</li><li>设计(动词):在⼀个环境中创建对象的规格说明</li></ul></li><li>设计经常需要⼀个设计师考虑⼀个对象或过程的<strong>审美、功能以及其他方面</strong>，这通常需要进⾏相当的研究、思考、建模、交互调整和重新设计。</li><li>分类<ul><li>工程设计和艺术设计</li><li>理性主义和经验主义</li><li>具体见PPT</li></ul></li></ul></li><li>软件设计的演化性<ul><li>需求是外部表现，需求和内部结构是有鸿沟的。</li><li>非功能需求(质量需求)</li><li>始终进行迭代</li><li><img src="6.png" style="zoom:50%;" /></li></ul></li><li>设计的决策<ul><li><img src="image-20240408111756337.png" alt="image-20240408111756337" style="zoom:50%;" /></li><li>决策的约束性<ul><li>需求；环境；资源；技术 …</li><li>最初的需求确定了对设计情况的最基本的约束和要求。</li><li>通常，在设计工作本身中最终会发现更多的约束。</li><li>约束既适用于设计的工件，也适用于设计活动中涉及的流程和参与者</li></ul></li><li><img src="7.png" style="zoom:60%;" /></li></ul></li></ul><h3 id="软件设计的分层（重要）"><a href="#软件设计的分层（重要）" class="headerlink" title="软件设计的分层（重要）"></a>软件设计的分层（重要）</h3><ul><li><img src="image-20240408112055301.png" alt="image-20240408112055301" style="zoom:50%;" /></li><li>低层设计<ul><li>将基本的语言单位(类型与语句)，组织起来，建立高质量的数据结构+算法</li><li>常见设计场景：<ul><li>数组的使用，链表的使用，内存的使用，遍历算法，递归算法…</li><li>一次问相对比较大的内存，然后我们自己在进行的内存的分配</li></ul></li><li>经典场景：<ul><li>堆栈，队列，树，排序算法，查找算法…</li></ul></li><li>数据结构与算法审美：简洁、结构清晰，坚固(可靠、高效、易读)</li><li>低层设计本质：屏蔽程序中复杂数据结构与算法的实现细节</li><li><img src="image-20240408120816682.png" alt="image-20240408120816682" style="zoom:50%;" /></li><li>模块划分<ul><li>1970s：函数的成熟与模块的出现</li><li>模块划分：将系统分成简单片段：⽚段有名字，可以被反复使用</li><li>名字和使⽤⽅法称为<strong>模块的抽象与接⼝</strong></li><li>模块内部的程序⽚段为精化与实现</li></ul></li></ul></li><li>中层设计<ul><li>开始：模块划分<strong>隐藏</strong>⼀些程序片段(数据结构+算法)的细节，暴露接口于外界</li><li><img src="image-20240408121107687.png" alt="image-20240408121107687" style="zoom:67%;" /></li><li>模块化的目标：完全独立性</li><li>方法：模块化、信息隐藏、抽象数据类型、封装</li></ul></li><li>高层设计：体系结构<ul><li><strong>部件</strong>承载了系统主要的<strong>计算与状态</strong></li><li><strong>连接件</strong>承载部件之间的<strong>交互</strong></li><li>部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，配置将它们的实例连接起来</li><li><img src="image-20240408122354610.png" alt="image-20240408122354610" style="zoom:50%;" /></li></ul></li></ul><h3 id="软件设计过程、方法和模型、描述"><a href="#软件设计过程、方法和模型、描述" class="headerlink" title="软件设计过程、方法和模型、描述"></a>软件设计过程、方法和模型、描述</h3><ul><li>软件设计过程的主要活动<ul><li><img src="image-20240408122621390.png" alt="image-20240408122621390" style="zoom: 80%;" /></li></ul></li><li>软件设计的模型和方法<ul><li>结构化设计方法</li><li>面向对象设计</li><li>数据为中心设计:有一些项目是做数据仓库等的，数据爬取操作和读取。</li><li>基于构件的设计:调用构件和库</li><li>形式化方法设计</li></ul></li><li>描述软件设计的模型，通常可以分为两类:<ul><li>静态模型<ul><li>静态模型是通过快照 的方式对系统中时间不变的属性进行描述。通常描述的是状态,而不<br>是行为。</li></ul></li><li>动态模型：动态模型通常描述的是系统行为和状态转移。</li><li><img src="image-20240408123041801.png" alt="image-20240408123041801" style="zoom: 67%;" /></li></ul></li><li>软件设计描述<ul><li><img src="image-20240408123255930.png" alt="image-20240408123255930" style="zoom:45%;" /></li><li><img src="image-20240408123336074.png" alt="image-20240408123336074" style="zoom:50%;" /></li></ul></li></ul><h2 id="09-软件体系结构基础"><a href="#09-软件体系结构基础" class="headerlink" title="09.软件体系结构基础"></a>09.软件体系结构基础</h2><ul><li>软件体系结构发展历史略</li></ul><h3 id="理解软件体系结构"><a href="#理解软件体系结构" class="headerlink" title="理解软件体系结构"></a>理解软件体系结构</h3><ul><li><p>概念</p><ul><li>软件体系结构：现代系统组件和子系统相互作用形成系统的结构和组织，以及最好在系统级别设计和分析的系统属性。</li><li>软件体系结构包含有关以下方面的重要决策<ul><li>软件系统的<strong>组织</strong></li><li>选择组成系统的<strong>结构元素及其接口</strong>，以及这些元素之间的协作所指定的<strong>行为</strong>，</li><li>将这些元素组成越来越大的<strong>子系统</strong>，</li><li>指导该组织，这些元素及其界面，协作和组成的结构元素及其接口。</li></ul></li><li>软件体系结构&#x3D;{部件(Component),连接件(Connector),配置(Configuration)}<ul><li><strong>部件</strong>是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;</li><li><strong>连接件</strong>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;</li><li><strong>配置</strong>是对”形式”的发展,定义了”部件”以及”连接件”之间的关联方式,将它们组织成系统的总体结构。</li></ul></li></ul></li><li><p>物理与逻辑</p><ul><li>模块<ul><li>逻辑：⼀个模块调用另⼀个模块</li><li>物理实现<ol><li>基本：接口调用</li><li>需要传递数据对象怎么办？</li></ol></li><li>逻辑：⼀个模块给另⼀个模块传递数据流</li><li>物理实现：读写共享数据、pipe…</li></ul></li><li>物理实现的载体<ul><li>低层：基本类型+基本控制结构</li><li>中层：OO编程语言机制<ol><li>类声明、实例创建与撤销、实例⽣命期管理</li><li>类权限控制机制</li><li>复杂机制：继承…</li></ol></li><li>高层：导⼊导出和名称匹配</li></ul></li></ul></li><li><p>高层抽象(体系结构 &#x3D; 部件 + 连接件 + 配置) <strong>重要</strong></p><ul><li><p>概念</p><ul><li><strong>组件</strong>是计算和状态的聚合</li><li><strong>连接件</strong>是组件之间的关系的聚合</li><li><img src="8-1746703902687.png"></li><li>连接件是⼀个与部件平等的单位。</li><li>部件与连接件是比类、模块等软件单位更高层次的抽象</li></ul></li><li><p>部件</p><ul><li>封装系统架构中的处理和数据的元素称为软件组件</li><li>件通常提供特定于应用程序的服务</li></ul><p><img src="9.png"></p><ul><li>部件承载系统主要功能，包括处理和数据</li></ul></li><li><p>原始部件和复合部件</p><ul><li><p>部件可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。</p></li><li><p>原始类型的部件可以直接被实现为相应的软件实现机制。</p></li><li><p>复合部件则由<strong>更细粒度</strong>的<strong>部件和连接件</strong>组成,复合部件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</p></li><li><img src="11.png" style="zoom:67%;" /></li></ul></li><li><p>连接件</p><ul><li>在复杂的系统中，交互可能比单个组件的功能更重要和更具挑战性</li><li>连接件定义了部件间的交互，是连接的抽象表示</li><li>与部件相似,在实现上连接件也可以分为<strong>原始</strong>(Primitive)和<strong>复合</strong>(Composite)两种类型。原始类型的连接件可以直接被实现为相应的软件实现机制。</li><li>复合连接件则由更细粒度的<strong>部件和连接件</strong>组成,复合连接件通过局部配置将其内部的部件和连接件连接起来,构成⼀个整体。</li><li><img src="image-20240410120546268.png" alt="image-20240410120546268" style="zoom: 67%;" /></li></ul></li><li><p>配置</p><ul><li>组件和连接器以给定系统体系结构中的特定方式构成，以实现该系统的目标</li><li>为了对软件体系结构进行更严格、准确的描述，人们建立了体系结构描述语言(ADL)，用于描述软件体系结构的形式化模型语言。</li><li>配置定义了部件和连接件之间的关联方式，将他们组织成系统的总体结构。</li></ul></li><li><p>高层抽象优点</p><ul><li>直观，便于理解</li><li>验证正确性</li><li>关注度分离，降低复杂度</li></ul></li></ul></li></ul><h3 id="体系结构风格初步"><a href="#体系结构风格初步" class="headerlink" title="体系结构风格初步"></a>体系结构风格初步</h3><ul><li><p>这部分需要重要掌握每一种风格的优点缺点和画图</p></li><li><p>分类</p><ul><li><img src="image-20240417154959514.png" alt="image-20240417154959514"></li></ul></li><li><p>主程序子进程风格</p><ul><li>组件：程序、函数和模块</li><li>连接件：在上述三个组件之间相互调用</li><li><img src="12.png" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>基于声明–使用(程序调用)关系建立连接件,以层次分解的方式建立系统部件, 共同组成层次结构。</li><li>每⼀个上层部件可以”使用”下层部件，但下层部件不能”使用”上层部件，即不允许逆方向调用。(层次性分解，基于定义使用关系)</li><li>系统<strong>单线程</strong>执行。主程序部件拥有初的执⾏控制权，并在”使用”中将控制权转移给下层子程序。</li><li>子程序只能够通过上层转移来获得控制权,可以在执⾏中将控制权转交给下层的子程序,并在自身执行完成之后必须将控制权还交给上层部件。</li><li>隐含子系统结构。</li></ul></li><li>实现<ul><li>主要实现机制:模块实现。</li><li>功能分解</li><li>集中控制</li><li>每个构件⼀个模块实现：主要是<strong>单向依赖</strong></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li>优点：流程清晰,易于理解；强控制性</li><li>缺点：程序调用是⼀种<strong>强耦合</strong>的连接方式,非常依赖交互方的接口规格,这会使得系统难以修改和复用；程序调用的连接方式限制了各部件之间的数据交互,可能会使得不同部件使用隐含的共享数据交流,产⽣不必要的公共耦合</li></ul></li></ul></li><li><p>面向对象风格</p><ul><li>组件：对象或模块(调用方法)</li><li>连接件：函数或者调用</li><li><img src="image-20240417165216134.png" alt="image-20240417165216134" style="zoom:67%;" /></li><li>设计决策及约束<ul><li>依照对数据的用情况,用<strong>信息内聚</strong>的标准,为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口,并隐藏内部数据的表示。</li><li>基于方法调用(Method Invocation)机制建立连接件,将对象部件连接起来。</li><li>每个对象负责维护其自身数据的⼀致性与完整性,并以此为基础对外提供”正确”的服务。</li><li>每个对象都是⼀个自治单位,不同对象之间是平级的,没有主次、从属、层次、分解等关系。</li></ul></li><li>实现<ul><li>主要实现机制：模块实现</li><li>任务分解</li><li>(委托式)分散式控制</li><li>每个构件⼀个模块实现<ol><li>使用接口将双向依赖转换为单向依赖</li><li>将每个构件分割为多个模块，以保证单向依赖</li><li>每个模块内部可以是基于面向对象方法，也可以基于结构化</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>面向对象式风格的优点有：<ul><li>内部实现的可修改性。</li><li>易开发、易理解、易复用的结构组织。</li></ul></li><li>面向对象式风格的缺点有:<ul><li>接口的耦合性。</li><li>标识的耦合性。</li><li>副作用</li></ul></li></ul></li><li><p>分层风格</p><ul><li>组件：通常是过程或对象的集合。</li><li>连接件：通常在受限可见性下进行过程调用或方法调用。</li><li><img src="image-20240417165555108.png" alt="image-20240417165555108" style="zoom:67%;" /></li><li>设计决策与约束<ul><li>从低层到高层,部件的抽象层次逐渐提升。每个下层为邻接上层提供服务, 每个上层将邻接下层作为基础设施使用。也就是说,在程序调用机制中上层调用下层。</li><li>两个层次之间的连接要遵守特定的交互协议,该交互协议应该是<strong>成熟、稳定和标准化</strong>的。也就是说,只要遵守交互协议,不同部件实例之间是可以互相替换的。</li><li>跨层次的连接是禁止的，不允许第 I 层直接调用 I+N(N&gt;1)层的服务。(也就是必须逐层进行调用)</li><li>逆向的连接是禁止的，不允许第 I 层调⽤第 J(J &lt; I)层的服务</li></ul></li><li>实现<ul><li>关注点分离(每层逐次抽象)</li><li>层间接口使用固定协议(固定控制)</li><li>每层⼀或多个模块实现<ol><li>单向依赖</li><li>层间数据传递建立专门模块</li></ol></li><li>使⽤utility或tools等基础模块</li></ul></li><li>优缺点<ul><li><img src="image-20240417170546313.png" alt="image-20240417170546313" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>Model-View-Controller Style MVC风格</p><ul><li><p>子系统模型被设计的不用依赖任何一种视图或者控制子系统</p></li><li><p>任何他们状态的修改都会被传播给显示子系统</p></li><li><p><img src="22.png"></p></li><li><p>组件</p><ol><li>模型组件负责保持问题域知识和确认视图层的修改</li><li>视图组件负责显示信息给用户并且将用户的行为传递给控制器</li><li>控制器<ol><li>修改模型的状态：将用户的行为和模型的更新映射起来</li><li>选择用来反映的视图</li></ol></li></ol></li><li><p>连接件：方法调用，信息，事件</p></li><li><p>设计决策和约束</p><ul><li>模型、视图、控制是分别是关于<strong>业务逻辑</strong>、<strong>表现</strong>和<strong>控制</strong>的三种不同内容抽象。</li><li>如果视图需要持续地显示某个数据的状态,那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更,模型会主动通知视图,然后再由视图查询数据的更新情况。</li><li>视图只能使用模型的数据查询服务,只有控制部件可以调用可能修改模型状态的程序。</li><li>用户行为虽然由视图发起,但是必须转交给控制部件处理。对接收到的用户行为, 控制部件可能会执行两种处理中的⼀种或两种：调用模型的服务,执行业务逻辑;提供下⼀个业务展现。</li><li>模型部件相对独立,既不依赖于视图,也不依赖于控制。虽然模型与视图之间存在⼀个”通知变更”的连接,但该连接的交互协议是⾮常稳定的,可以认为是非常弱的依赖。</li></ul></li><li><p>实现</p><ul><li>模型-视图-控制风格需要为模型、视图和控制的每个部件实例建立模块实现,各模块间存在导⼊&#x2F;导出关系,程序调用连接件不需要显式的实现。</li><li>特定技术实现，通常专用于WEB<ol><li>Model与Controller单向</li><li>Controller与View双向</li><li>Model与View双向</li></ol></li><li>典型实现<ol><li>View： JSP，HTML</li><li>Controller： Servlet</li><li>Model： JavaBean</li></ol></li></ul></li><li><p>效果</p><ul><li><img src="image-20240417171043461.png" alt="image-20240417171043461"></li></ul></li><li><p>分层与MVC</p><ul><li><img src="image-20240417171101444.png" alt="image-20240417171101444"></li></ul></li></ul></li><li><p>判断题：</p><ul><li>按照功能分解的方式进行模块分割能够实现高内聚的软件设计：<strong>√</strong></li><li>体系结构设计是软件非功能性的实现，而详细设计主要是软件功能性的实现。：<strong>√</strong></li></ul></li></ul><h2 id="10-软件体系结构设计与构建"><a href="#10-软件体系结构设计与构建" class="headerlink" title="10.软件体系结构设计与构建"></a>10.软件体系结构设计与构建</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><ul><li><p>步骤（重要）</p><ul><li>分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。</li><li>通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。</li><li>进行软件体系结构逻辑(抽象)设计：产生逻辑包图</li><li>依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图</li><li>完善体系结构设计：关键类图，持久化数据格式的定义等</li><li>添加构件接口：包、重要文件的创建，定义接口</li><li>迭代过程3-6</li></ul><blockquote><ol><li>步骤1-3是逻辑设计，步骤4-7是物理设计</li><li>接下来的部分将要按照这个思路进行下去</li></ol></blockquote></li><li><p>第一步：分析关键需求和项目约束</p><ul><li><p>一般来说，体系结构设计的输入要素主要由两个来源：</p><ol><li>软件需求规格说明</li><li>项目约束</li></ol></li><li><p>体系结构设计必须落实所有的功能性需求和非功能性需求</p></li></ul></li><li><p>第二步：通过选择体系结构风格</p><ul><li>例：分层风格<ul><li>协议不变情况下易于修改</li><li>能够促进并行开发</li></ul></li></ul></li><li><p>第三步：进行软件体系结构逻辑(抽象)设计</p><ul><li>将需求分配到子系统和模块<ol><li>考虑功能的相同性：不同任务，但是相同功能</li><li>考虑可复用性：结构、数据、行为的可复用性</li></ol></li><li>使⽤非功能性需求与项⽬约束评价和改进初始设计<ul><li>能够满足项目约束</li><li>无法满足安全需求和网络分布约束，所以需要改进</li></ul></li></ul></li><li><p>包设计原则</p><ul><li>复用发布等价原则(REP)：复用的粒度就是发布的粒度</li><li>共同封闭原则(CCP)：包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。</li><li>共同重用原理(CRP)：一个包中的所有类应该是能够共同重用的。</li><li>无环依赖原则(ADP)：在包的依赖关系图中不能存在环。</li><li>稳定依赖原则(SDP)：朝着稳定的方向进行依赖<ul><li>包的稳定性度量</li><li><img src="image-20240417194311104.png" alt="image-20240417194311104" style="zoom:50%;" /></li><li><img src="image-20240417194328157.png" alt="image-20240417194328157" style="zoom:50%;" /></li></ul></li><li>稳定抽象原则(SAP)：包的抽象程度应该和其稳定程度一致</li><li>前三条描述的是依赖性，后三条描述的是耦合性</li></ul></li><li><p>包设计过程</p><ul><li>迭代的过程:先用 CCP 原则对把可能⼀同变化的类组织成包进行发布</li><li>随着系统的不断增长,我们开始关注创建可重用的元素,于是开始使⽤ CRP 和 REP 来指导包的组合。</li><li>后使用 ADP、SDP、SAP 对包图进行度量，去掉不好的依赖。(修改设计)</li></ul></li><li><p>第四步：依赖逻辑设计进行软件体系结构(实现)设计</p><ul><li>内容<ul><li>开发包(构件)设计</li><li>运行时的进程</li><li>物理部署</li></ul></li><li>具体细节见PPT</li></ul></li><li><p>第五步：完善体系结构设计</p><ul><li>完善启动和网络链接<ul><li>失败业务的现场保护问题</li><li>网络连接断开的恢复问题</li><li>除了细化职责建立关键类图之后，模块传递的数据对象也需要被明确定义，因为他们是模块建接口的重要部分，必须严格、准确。</li></ul></li><li>细化模块</li><li>数据定义<ul><li>接口的数据对象、关键类的重要数据结构、Value Object (VO)、Persistent Object(PO)</li><li>Java 实体<ul><li>实体是一个可以代表一个临时的业务实体的对象，比如一个账单或者用户</li><li>没有逻辑业务方法(行为)</li><li>实体必须在使用它们的会话或事务之间持久存在。</li><li>实体是存储在文件或者数据库中的</li><li>实体是一个Beans</li></ul></li><li>Value Objects(逻辑层向展示层传递数据)<ul><li>价值对象(VO)包含一个或多个公共领域中实体的属性。</li><li>在层之间传递值对象，而不是实体。</li><li><strong>应该考虑实现Serializable</strong></li><li>值对象可以更新和创建实体。</li><li>实体可以创建价值对象。</li></ul></li></ul></li></ul></li><li><p>第六步：添加构件接口</p><ul><li>构件初步设计<ul><li>根据分配的需求确定模块对外接口</li><li>初步设计关键类</li><li>编写接口规范</li></ul></li></ul></li><li><p>体系结构的原型构建</p><ul><li>包的创建</li><li>重要文件的创建</li><li>定义构件之间的接口</li><li>关键需求的实现</li></ul></li><li><p>体系结构集成与测试</p><ul><li>当体系结构中原型各个模块的代码都编写完成并经过单元测试之后,需要将所有模块组合起来形成整个软件原型系统, 这就是集成。</li><li>集成的<strong>目的</strong>是为了逐步让各个模块合成为⼀个系统来⼯作,从而验证整个系统的功能、性能、可靠性等需 求。对于被集成起来的系统，⼀般主要通过其暴露出来的接口，伪装⼀定的参数和输入，进行黑盒测试。</li><li>Stub 桩程序：为了完成程序的编译和连接而使用的暂时代码</li><li>根据从模块之间集成的先后顺序,⼀般有下列几种常见的集成策略：<ul><li>大爆炸式(所有放在一起，看能不能过)</li><li>增量式：自顶向下式、自底向上式、三明治式、持续集成</li></ul></li><li>大爆炸式：将所有模块一次性组合在一起，可以在短时间内迅速完成集成，但一次运行成功可能性不高，不容易发现bug</li><li>自顶向下：先集成和测试上层的测模块，下层的模块用伪装的具体接口的桩程序</li><li>自底向上集成：先底层组件，对底层组件较早进行验证，桩的工作量少，但高层设计的错误不会被很快的发现</li><li>持续集成：一种增量集成方法,但它提倡尽早集成和频繁集成。尽早集成是指不需要总是等待⼀个模块开发完成才把它集成起来；频繁集成是指开发者每次完成⼀些开发任务之后,就可以用开发结果替换 Stub 中的相应组件,进行集成与测试</li></ul></li><li><p>体系结构评审</p><ul><li><p>评审的角度</p><ul><li>设计方案正确性、先进性、可行性;</li><li>系统组成、系统要求及接口协调的合理性;</li><li>对于功能模块的输⼊参数、输出参数的定义是否明确;</li><li>系统性能、可靠性、安全性要求是否合理;</li><li>⽂档的描述是否清晰、明确。</li></ul></li><li><p>体系结构评审的方法</p><ul><li>对结果的评审：Checklist(动态更新的)</li><li>对设计决策的评审</li></ul></li><li><p>软件体系结构设计文档的Checklist</p><p><img src="image-20240418164336573.png" alt="image-20240418164336573"></p></li></ul></li></ul><h2 id="11-人机交互设计"><a href="#11-人机交互设计" class="headerlink" title="11.人机交互设计"></a>11.人机交互设计</h2><h3 id="什么是人机交互"><a href="#什么是人机交互" class="headerlink" title="什么是人机交互"></a>什么是人机交互</h3><ul><li>概念<ul><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li><li>良好的HCI界面设计可鼓励用户与系统之间轻松，自然且引人入胜的交互</li></ul></li><li>HCI的重要组成：可用性<ul><li>可用性不是用户界面单一的一维属性，它包含以下维度：<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验</li></ol></li></ul></li></ul><h3 id="人机交互的三个要素"><a href="#人机交互的三个要素" class="headerlink" title="人机交互的三个要素"></a>人机交互的三个要素</h3><ul><li><p>人</p><ul><li>概念<ul><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ul></li><li>特性<ul><li>短期记忆有限</li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ul></li><li>精神模型 <strong>重要</strong><ul><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ul></li><li>发现精神模型<ul><li>找到用户在尝试去做什么——目标</li><li>用户，目标，结果任务的需求</li><li><strong>仅在确定有助于解决任务的功能时才应添加功能</strong></li><li>与用户个人资料相关的任务的频率</li></ul></li><li>差异性<ul><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进行业务导航，尽量避免出错。如果⼀个系统的⼤多数用户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是长时间使用软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家用户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计人机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新手用户提供易学性高的⼈机交互机制(图形界面)</li><li>又为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ul></li></ul></li><li><p>计算机</p><ul><li>⼈机交互设备<ul><li>输入设备</li><li>输出设备</li></ul></li><li>常见界面类型<ul><li><img src="image-20240418195946335.png" alt="image-20240418195946335"></li></ul></li><li>交互方式<ul><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ul></li></ul></li><li><p>交互</p><ul><li>导航 <strong>重要</strong><ul><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉用户，这个就是导航。</li><li>导航的目的就是为用户提供⼀个很好的完成任务的入口，好的导航会让这个入口非常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给不同的用户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给用户提供导航</li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据</li></ul></li><li>反馈 <strong>重要</strong><ul><li>一定要有反馈，避免进行错误的操作</li><li>用户喜欢较短的响应时间；</li><li>较长的响应时间(&gt;15秒)具有破坏性；</li><li>用户会根据响应时间的变化调整自己的工作方式；</li><li>较短的响应时间导致了较短的用户思考时间；</li><li>较快的节奏可能会提高效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间</li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间</li></ul></li><li>协作式设计 <strong>重要</strong><ul><li>人和计算机是人机交互的两方，其中人的因素比较固定，⼀定时期内不会发生大的变化，所以要让⼆者交互顺畅，就需要让计算机更多地适应人的因素，这也是人机交互设计以用户为中心的根本原因</li><li>这种调整计算机因素以更好地适应并帮助用户的设计方式被称为协作式设计</li></ul></li><li>人机交互设计原则<ul><li>简洁设计(7±2原则)</li><li>一致性设计</li><li>低出错率设计</li><li>易记性设计<ul><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ul></li><li>可视化设计要点</li></ul></li></ul></li></ul><h3 id="人机交互设计流程"><a href="#人机交互设计流程" class="headerlink" title="人机交互设计流程"></a>人机交互设计流程</h3><ul><li>设计过程<ul><li><img src="image-20240418204112209.png" alt="image-20240418204112209"></li><li>导航设计：建立多次交互之间的逻辑衔接结构</li><li>页面设计：设计交互中的具体界面的细节</li><li>页面原型化：使用界面原型工具</li><li>页面的评估与修改：用户进行评估</li></ul></li><li>页面设计<ul><li><img src="17.png"></li></ul></li></ul><h3 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h3><ul><li>内容<ul><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ul></li><li>关键点<ul><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ul></li><li>常见的GUI元素<ul><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ul></li><li>Check List<ul><li>数据输入界面</li><li>可定制的视觉设计</li><li>搜索和检索界面</li><li>附加的用户功能</li><li>控制用户访问</li><li>与其他集合的互操作性</li></ul></li><li>评估GUI<ul><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如”可用性检查”或”启发式评估”)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ul></li></ul><h2 id="12-详细设计"><a href="#12-详细设计" class="headerlink" title="12. 详细设计"></a>12. 详细设计</h2><h3 id="详细设计基础"><a href="#详细设计基础" class="headerlink" title="详细设计基础"></a>详细设计基础</h3><ul><li><p>概念</p><ul><li><p><img src="1-1746703946905.png"></p><blockquote><ol><li>高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。</li><li>中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。</li><li>低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。</li></ol></blockquote></li><li><p>软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息</p></li><li><p>细节设计通过细节设计机制实现模块</p><ol><li>中级：(子调制)-&gt; OO-&gt;类指定</li><li>低级：DS. + ALG. -&gt;实现类</li></ol></li><li><p>细节设计要求设计者考虑模块的美观，功能和许多其他方面</p><ol><li>详细设计中的质量要求：修改，维护，性能……</li></ol></li><li><img src="3-1746703948594.png" style="zoom: 80%;" /></li></ul></li><li><p>详细设计的出发点</p><ul><li>上下文<ul><li>模块的规格：导出&#x2F;导入接口</li><li>职责分配：<ol><li>有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图</li><li>其他一些来自实施决策</li></ol></li><li>在详细设计文档中需要明确定义:<ol><li>模块结构及其接口(如果有更细的模块分解)</li><li>类结构、类协作、类接口(面向对象分析方法)</li><li>控制结构与函数接口(结构化分析方法)</li><li>重要的数据结构和算法逻辑(如果必要的话)</li></ol></li></ul></li><li><img src="image-20240428111557004.png" alt="image-20240428111557004" style="zoom:67%;" /></li></ul></li></ul><h3 id="面向对象详细设计"><a href="#面向对象详细设计" class="headerlink" title="面向对象详细设计"></a>面向对象详细设计</h3><h4 id="设计模型建立"><a href="#设计模型建立" class="headerlink" title="设计模型建立"></a>设计模型建立</h4><ul><li>面向对象设计的思想：职责<ul><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ul><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作</li></ul></li><li>职责驱动的分解<ul><li>职责可以在不同的抽象层次上陈述。</li><li>职责可以分解。</li><li>可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ul></li><li>职责启发法<ul><li>很好地分配职责有助于实现高凝聚力和低耦合。(高内聚)</li><li>确保模块职责不重叠。</li><li><strong>仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。</strong></li></ul></li><li>委托：其中一个模块将职责交给另一个模块</li></ul></li><li>面向对象设计的思想：协作<ul><li>概念<ul><li>一个应用程序可以分解为许多不同的行为。</li><li>每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践</li><li>每次协作，无论大小，都保证实现应用程序的行为</li><li>将面向对象的应用程序想象成通过关系连接的对象网络。</li><li>协作是通过网络追求特定行为的<strong>消息模式</strong></li><li>协作分布在对象网络中，因此在任何地方都不存在</li></ul></li></ul></li><li>面向对象详细设计的过程<ul><li><img src="image-20240428112704867.png" alt="image-20240428112704867"></li></ul></li></ul><h4 id="通过职责建立静态设计模型"><a href="#通过职责建立静态设计模型" class="headerlink" title="通过职责建立静态设计模型"></a>通过职责建立静态设计模型</h4><ul><li>抽象类的职责<ul><li>类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图</li><li>职责分类<ol><li>属性职责:对象的状态</li><li>行为职责:对象的行为</li></ol></li></ul></li><li>类之间的关系<ul><li><img src="image-20240428112903745.png" alt="image-20240428112903745"></li></ul></li><li>GRASP原则<ul><li>General Responsibility Assignment Software Patterns（一般职责分配软件模式）</li><li>不是”设计模式”，而是对象设计的基本原理</li><li>专注于对象设计的最重要方面之一：为类分配职责</li><li>强调适用性：并不是一个普适的</li><li>常见的一些特点:<ol><li>低耦合：分配一个职责要保证低耦合度</li><li>高内聚：分配一个职责的时候要保持类的高聚合度</li><li>信息专家：将一个职责分配给专家-履行职责所必须的信息的类</li><li>创建者：创建规则在后面</li><li>控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一)</li></ol></li></ul></li><li>拇指原则：当存在替代设计选择时，请仔细研究替代方案的<strong>凝聚力和耦合含义</strong>，并可能对替代方案的未来发展压力。选择具有良好内聚性，耦合性和稳定性的替代方案。</li><li>信息专家<ul><li>问题：在面向对象设计中分配职责的最基本原则是什么？</li><li>解决方案：将职责分配给具有完成任务所必需的信息的类。</li><li>维护信息封装</li><li>促进低耦合</li><li>促进高内聚类</li><li>例子见PPT</li></ul></li><li>添加辅助类<ul><li>分类：接口类、记录类(数据类)、启动类、控制器类、实现数据类型的类、容器类</li></ul></li></ul><h4 id="通过协作创建动态设计模型"><a href="#通过协作创建动态设计模型" class="headerlink" title="通过协作创建动态设计模型"></a>通过协作创建动态设计模型</h4><ul><li><p>抽象对象之间协作</p><ul><li>从小到大,将对象的小职责聚合形成大职责;</li><li>从大到小,将大职责分配给各个小对象。</li><li>这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。</li><li>可以用顺序图表示对象之间的协作</li><li>除了顺序图，我们还可以通过状态图来表达软件的动态模型</li></ul></li><li><p>创建者（creator）</p><ul><li>如果有以下情况，则由创建者分配B类创建A类实例的职责：<ol><li>B 聚集了 A 对象</li><li>B 包含了 A 对象</li><li>B 记录了 A 的实例</li><li>B 要经常使用 A 对象</li></ol></li><li><img src="image-20240428224003187.png" alt="image-20240428224003187"></li></ul></li><li><p>控制器（controller）</p><ul><li><p>如果程序从图形界面以外的来源接收事件，添加事件类以将事件源与实际处理事件的对象分离</p></li><li><p>Controller本身不是面向对象的，它包含很多复杂的逻辑</p></li><li><p>使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为</p></li><li><p>控制器对象可能变得高耦合和职责上低内聚</p></li><li><p>将处理系统事件消息的职责分配给代表以下选项之一的类：</p><ol><li>整个组织的业务(立面控制器)。</li><li>整个系统(外观控制器)。</li><li>在问题域中真实操作解决问题的人(角色控制器)。</li><li>自动化解决用例的模块(用例控制器)。</li></ol></li></ul></li><li><p>选择合适的控制风格</p><ul><li>控制风格：系统行为的逻辑在对象(组件)网络之间分布的方式</li><li><img src="image-20240428224338297.png" alt="image-20240428224338297"></li><li>集中式控制风格<ul><li>几个控制器记录所有系统行为的逻辑</li><li>优点：容易找到做出决定的地方，易于查看如何制定决策以及如何更改决策流程</li><li>缺点：控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库（增加耦合、破坏信息隐藏）</li></ul></li><li>委托式控制风格<ul><li>通过对象网络分配决策，由几个控制器进行主要决策</li><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ul></li><li>分散式控制风格<ul><li>所有系统行为都通过对象网络广泛传播</li><li>其特点是拥有许多组件，几乎没有数据，职责也很少。</li><li>缺点：很难理解控制流；组件无法独自完成很多工作，从而增加了耦合；隐藏信息是很难的；内聚性通常很差；很少有模块化原则可以满足。</li><li>完全靠对象自治的方式来实现自己的职责</li></ul></li><li>控制器设计启发<ul><li>避免大多数消息都来自单个组件的交互设计</li><li>保持组件较小</li><li>确保并非仅将全部职责分配给几个组件</li><li><strong>确保操作职责与数据职责一致</strong></li><li>避免要求每个组件发送许多消息的交互</li></ul></li></ul></li></ul><h3 id="为类间协作开发集成测试用例"><a href="#为类间协作开发集成测试用例" class="headerlink" title="为类间协作开发集成测试用例"></a>为类间协作开发集成测试用例</h3><ul><li>详细设计的集成测试<ul><li>类间协作的集成测试<ul><li>重点针对复杂逻辑(交互比较多)</li><li>自顶向下或者自底向上的集成</li><li><img src="image-20240429093620217.png" alt="image-20240429093620217"></li></ul></li><li>Mock Object（不是stub）<ul><li><img src="image-20240429093541455.png" alt="image-20240429093541455" style="zoom:50%;" /></li></ul></li><li>测试用例</li></ul></li></ul><h3 id="结构化详细设计"><a href="#结构化详细设计" class="headerlink" title="结构化详细设计"></a>结构化详细设计</h3><ul><li>结构化设计的思想<ul><li>分解是降低复杂度的一种方法</li><li>按算法的分解：自然的分解想法，分而治之</li><li>从数据流图向结构图的转换</li></ul></li><li>降低复杂度的方法<ul><li>分解：同一层次</li><li>抽象：从低层次抽象出高层次</li></ul></li><li>结构化设计<ul><li>结构化设计的重心：从数据流图到结构图</li><li><img src="image-20240429094142412.png" alt="image-20240429094142412"></li><li>转化过程:<ul><li>寻找到输入的最高抽象点和输出的最高抽象点</li><li>根据输入、输出的最高抽象点，对模块进行划分</li><li>然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图</li></ul></li><li>详细参考课本(201页)</li><li>例子<ul><li><img src="image-20240429094505931.png" alt="image-20240429094505931"></li><li><img src="image-20240429094516376.png" alt="image-20240429094516376"></li></ul></li></ul></li></ul><h3 id="详细设计文档描述和评审"><a href="#详细设计文档描述和评审" class="headerlink" title="详细设计文档描述和评审"></a>详细设计文档描述和评审</h3><ul><li>评审<ul><li><img src="image-20240429094834998.png" alt="image-20240429094834998"></li></ul></li><li>度量<ul><li>模块化度量</li></ul></li><li>测试<ul><li>协作测试</li></ul></li></ul><h2 id="13-模块化与信息隐藏"><a href="#13-模块化与信息隐藏" class="headerlink" title="13. 模块化与信息隐藏"></a>13. 模块化与信息隐藏</h2><h3 id="模块化与信息隐藏思想"><a href="#模块化与信息隐藏思想" class="headerlink" title="模块化与信息隐藏思想"></a>模块化与信息隐藏思想</h3><ul><li><strong>内聚和耦合</strong><ul><li>内聚（越高越好）：内聚表达的是一个模块内部的联系的紧密型：包括信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。</li><li><img src="image-20240429103022348.png" alt="image-20240429103022348"></li><li>耦合（越低越好）：耦合描述的是两个模块之间关系的复杂程度，包括内容耦合，公共耦合，重复耦合，控制耦合，印记耦合，数据耦合</li><li><img src="15.png"></li></ul></li><li>模块化<ul><li>模块定义：模块是一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标识符。</li><li>为什么要将系统进行模块化<ul><li>管理：分而治之</li><li>演进：分离系统的各个部分，以便将一个部分的更改与其他部分的更改隔离开<ol><li>直接性原则(将需求明确分配到模块，理想情况下一个或多个需求映射到一个模块)</li><li>连续性&#x2F;局部性原则(需求的微小变化仅触发对一个模块的更改)</li></ol></li><li>理解：促使我们的系统更加容易被理解<ol><li>作为思维大小的块的组成，例如7±2规则</li><li>一部分只有一个问题，例如本地性原则，封装，关注点分离</li></ol></li><li>关键问题：模块化使用什么标准？-&gt;<strong>信息隐藏</strong></li></ul></li><li>最有可能被改变的设计域<ul><li>硬件依赖</li><li>输入输出格式</li><li>非标准语言特点和库路径</li><li>复杂设计和实现</li><li>复杂数据结构</li><li>复杂逻辑</li><li>全局变量</li><li>数据规模限制</li></ul></li></ul></li><li>信息隐藏<ul><li>目的：为了使可能的改动本地化</li><li>过程<ul><li>最常见的隐藏是您认为可能会更改的设计决策。</li><li>然后，您可以通过将每个设计秘密分配给自己的类，子例程或其他设计单元来分离它们。</li><li>接下来，您隔离(封装)每个机密，这样，如果它确实发生了更改，则更改不会影响程序的其余部分。</li></ul></li><li>接口与实现<ul><li>接口：用户对模块的看法，仅描述用户使用模块需要知道的内容</li><li>原则<ol><li>显式接口：使模块之间的所有依赖关系明确(无隐藏的耦合)</li><li>低耦合-接口少：最小化模块之间的依赖性</li><li>接口规模小：将大型接口分为几个接口</li><li>高内聚：一个模块应该封装一些定义良好的，连贯的功能(稍后会详细介绍)</li></ol></li><li>耦合与内聚<ol><li>内聚力是模块之间的一致性的度量。</li><li>耦合是模块之间的交互程度。</li><li>需要高内聚和低耦合</li></ol></li></ul></li></ul></li><li>KWIC例子<ul><li>具体见PPT</li><li>第一种模块化：处理过程中的每个主要步骤都是一个模块</li><li>第二种模块化：<ol><li>信息隐藏：每个模块都有一个或多个”隐藏”<ol><li>行：字符&#x2F;行的存储方式</li><li>循环位移：旋转算法，旋转存储</li><li>字符表化：alpha的算法，alpha的惰性</li><li>每个模块都以其对设计决策的了解为特征，而对其他所有决策则都不了解。</li></ol></li></ol></li></ul></li></ul><h3 id="结构化的模块化"><a href="#结构化的模块化" class="headerlink" title="结构化的模块化"></a>结构化的模块化</h3><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><ul><li>概念<ul><li>耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。<ul><li>连接有多复杂：全局变量，范围；与其他模块的连接</li><li>连接是指模块本身还是模块内部的东西</li><li>应该对外提供什么和接收什么</li></ul></li></ul></li><li>耦合强度1——连接有多复杂<ul><li>原则1：全局变量是被认为是有害的<ul><li>封装减少耦合：抽象和分解<ul><li>将潜在的共享元素细分成组</li><li>将每个组的访问权限限制为最小的模块子集</li></ul></li></ul></li><li>原则二：如果没有特殊要求，让代码清晰一点</li><li>原则三：不要重复</li></ul></li><li>耦合强度2——连接是指模块本身还是模块内部的东西<ul><li>以其名称寻址或整体引用一个模块的连接产生的耦合，比引用另一个模块内部元素的连接产生的耦合低(整体连接的耦合程度低于模块内部元素连接的耦合)</li><li>原则四：面向接口编程</li></ul></li><li>耦合强度3——应该对外提供什么和接收什么<ul><li>数据耦合：发送必要数据的耦合</li><li>印记耦合：发送数据比刚好需要的多</li><li>控制耦合：除了数据还有控制信号</li><li>内容耦合：数据和控制元素的耦合</li><li>显然，印记耦合可以实现更多的数据耦合</li><li>控制耦合比数据耦合还耦合更多：信息隐藏</li></ul></li></ul><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><ul><li>概念<ul><li>实现独立模块的方式<ul><li>减少不在同一模块中的元素之间的关系</li><li>增加同一模块中元素之间的关系</li><li>内聚程度的度量：绑定</li></ul></li><li>内聚度(绑定的类型)<ul><li>偶然内聚 &lt; 逻辑内聚 &lt; 临时内聚 &lt; 交流内聚 &lt; 功能内聚 &lt; 信息内聚</li></ul></li></ul></li></ul><h3 id="模块化思想的应用"><a href="#模块化思想的应用" class="headerlink" title="模块化思想的应用"></a>模块化思想的应用</h3><ul><li>低耦合处理<ul><li>软件体系结构的分层设计中<ul><li>不同层的模块之间仅能通过程序调用与数据传递实现交互，不能共享数据(例如 Model 层建立⼀个数据对象并将引用传递给 Logic 层使用)否则会导致公共耦合。</li></ul></li><li>软件体系结构的逻辑包设计中<ul><li>依据功能的特点将三个层次进⼀步划分为更小的包，而不是只使用 Presentation、Logic和 Model 三个包，可以通过包分割实现接口最小化，这能去除不必要的耦合。</li></ul></li><li>软件体系结构的物理包设计中<ul><li>将不同包的重复内容独立为单独的包以消除重复，避免产生隐式的重复耦合</li></ul></li><li>详细设计中对象创建者的选择<ul><li>如果两个对象 A、B 间已有比较高的耦合度了, 那么使用 A 创建 B 或者反之就不会带来额外的耦合度</li></ul></li></ul></li><li>高内聚处理<ul><li>软件体系结构的分层设计中:<ul><li>三个层次都是高内聚的,⼀个处理交互任务, ⼀个处理业务逻辑,⼀个处理数据持久化。</li></ul></li><li>软件体系结构的逻辑包设计中:<ul><li>将三个层次进⼀步划分为更小的包,可以实现每个更小的包都是高内聚的。</li></ul></li><li>详细设计中抽象类的职责:<ul><li>要求状态与方法紧密联系就是为了达到高内聚 (信息内聚)。</li></ul></li><li>详细设计中使用控制风格:<ul><li>控制风格分离了控制逻辑，可以实现业务逻辑对象的高内聚(功能内聚)。因为封装了控制逻辑，所以控制器对象承载了不可避免的顺序内聚、通信内聚和逻辑内聚，这就要求控制器对象必须是受控的，也是它们为什么倾向于对外委托而不是自己进行业务计算的原因。</li></ul></li></ul></li></ul><h3 id="结构化的信息隐藏"><a href="#结构化的信息隐藏" class="headerlink" title="结构化的信息隐藏"></a>结构化的信息隐藏</h3><ul><li>Module Guide<ul><li>模块的主要秘密：主要秘密描述的是这个模块所要实现的<strong>用户需求</strong>。是设计者对用户需求的实现的⼀次职责分配。有了这个描述以后，我们可以利⽤它检查我们是否完成所有的⽤户需求，还可以利⽤它和需求优先级来决定开发的次序。</li><li>模块的次要秘密：次要秘密描述的是这个模块在实现职责时候所涉及的具体的<strong>实现细节</strong>。包括数据结构，算法，硬件平台等信息。</li><li>模块的角色：描述了独立的模块在整个系统中所承担的角色，所起的作用以及与哪些模块有相关联的关系</li><li>模块的对外接口：模块提供给别的模块的接口</li></ul></li><li>信息隐藏思想的应用<ul><li><img src="image-20240429183633558.png" alt="image-20240429183633558"></li><li><img src="image-20240429183643021.png" alt="image-20240429183643021"></li></ul></li></ul><h2 id="14-面向对象的模块化"><a href="#14-面向对象的模块化" class="headerlink" title="14. 面向对象的模块化"></a>14. 面向对象的模块化</h2><ul><li>模块化的原则(总结)<ul><li><img src="1-1746703986798.png" style="zoom: 67%;" /></li><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ul></li></ul><h3 id="面向对象中的模块和耦合"><a href="#面向对象中的模块和耦合" class="headerlink" title="面向对象中的模块和耦合"></a>面向对象中的模块和耦合</h3><ul><li>耦合中的结构方法与面向对象方法<ul><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ul></li><li>降低耦合的设计原则<ul><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ul></li></ul><h3 id="访问耦合"><a href="#访问耦合" class="headerlink" title="访问耦合"></a>访问耦合</h3><ul><li><img src="image-20240508093021579.png" alt="image-20240508093021579"></li><li>隐式耦合：Cascading Message 级联调用问题<ul><li>解决方案<ol><li>引入局部变量，避免隐式耦合，变为显式耦合，降低耦合度</li><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ol></li></ul></li><li>组件耦合原理<ul><li>原则四：面向接口编程<ul><li>编写所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块&#x2F;类约定：所需方法&#x2F;提供的方法</li><li>方法约定：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li></ul></li><li>原则五：迪米特法则<ul><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li></ul></li><li>原则六：接口隔离原则(ISP)&#x2F;也叫接口最小化原则<ul><li>面向更简单的接口编程</li><li>许多客户端专用接口比一个通用接口要好</li><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li></ul></li></ul></li></ul><h3 id="继承耦合"><a href="#继承耦合" class="headerlink" title="继承耦合"></a>继承耦合</h3><ul><li><p><img src="image-20240508093924254.png" alt="image-20240508093924254"></p></li><li><p>修改继承耦合</p><ul><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ul></li><li><p>精化继承耦合</p><ul><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母的引用，则需要整个父母和子女的修饰</li></ul></li><li><p>扩展继承耦合</p><ul><li>最好的继承耦合</li><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ul></li><li><p>降低继承耦合的方法</p><ul><li><p>原则七：里氏替换原则</p><ul><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。”</li><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ul></li><li><p>原则八：组合代替继承</p><ul><li><p>组合优于继承</p></li><li><p>使用继承实现多态</p></li><li><p>使用委托时不要继承复用代码</p></li><li><p>例子：</p><ul><li><img src="16.png" style="zoom: 67%;" /><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><img src="17-1746703995843.png" style="zoom: 67%;" /><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li><li><img src="18.png" style="zoom:50%;" />- Person持有Role，Passenger和Agent实现抽象接口PersonRole- Role可以是一个List</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="内聚-1"><a href="#内聚-1" class="headerlink" title="内聚"></a>内聚</h3><ul><li>衡量标准<ul><li>方法和属性保持一致<ul><li><img src="image-20240508101030667.png" alt="image-20240508101030667" style="zoom:67%;" /></li></ul></li><li>属性之间是否体现一个职责<ul><li><img src="image-20240508101047791.png" alt="image-20240508101047791"></li></ul></li><li>属性间是否可以抽象<ul><li><img src="image-20240508101511363.png" alt="image-20240508101511363"></li></ul></li></ul></li><li>方法内聚<ul><li>一个类中的方法是普通耦合</li><li>所有方法服务于一个职责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ul></li><li>原则九：单一责任原则(SRP)<ul><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的</li></ul></li></ul><h3 id="耦合和内聚的度量"><a href="#耦合和内聚的度量" class="headerlink" title="耦合和内聚的度量"></a>耦合和内聚的度量</h3><ul><li><p>类之间的耦合度量</p><ul><li>第一种度量:CBO(方法调用耦合)<ul><li>对象类之间的耦合(CBO)</li><li>CBO &#x3D; 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ul></li><li>第二种度量:DAC(数据抽象耦合)<ul><li>DAC &#x3D; 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ul></li><li>第三种度量:Ca和Ce(有效和)<ul><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ul></li><li>第四种度量:DIT 继承树的深度<ul><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性。</li></ul></li><li>第五种度量 Number of children (NOC) 子类的数量<ul><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ul></li></ul></li><li><p>类内聚程度衡量</p><ul><li><p>Lack of cohesion in methods (LCOM)</p></li><li><p><img src="28.png"></p><ul><li><p>交集为空则在P中，交集不为空则在Q中</p></li><li><p>值越低越好</p></li><li><p>还定义了许多其他版本的LCOM</p></li><li><p>如果LCOM&gt;&#x3D; 1，则应将类划分</p></li></ul></li></ul></li><li><p>Summary:Principles from Modularization 模块化的原则</p><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol></li></ul><h2 id="15-面向对象的信息隐藏"><a href="#15-面向对象的信息隐藏" class="headerlink" title="15. 面向对象的信息隐藏"></a>15. 面向对象的信息隐藏</h2><h3 id="封装类的职责"><a href="#封装类的职责" class="headerlink" title="封装类的职责"></a>封装类的职责</h3><ul><li><p>结构化中的信息隐藏</p><ul><li>每一个模块都隐藏了这个模块中关于重要设计决策的实现，以至于只有这个模块的每一个组成部分才能知道具体的细节</li><li>最重要的细节：职责的变更</li><li>次要的细节：实现的变更</li></ul></li><li><p>类的职责</p><ul><li><p>职责是类或对象维护一定的状态信息，并基于状态履行行为职能的能力</p></li><li><p>职责的体现：封装</p></li></ul></li><li><p>类的封装</p><ul><li>封装：一个模块应该通过稳定的接口对外体现其所承载的要求，而隐藏它对需求的内部实现细节</li><li>封装将数据和行为同时包含在类中，分离对外接口与内部实现</li><li>接口是模块的可见部分：描述了一个类中的暴露到外界的可见特征</li><li>实现被隐藏在模块之中：隐藏实现意味着只能在类内操作，更新数据，而不意味着隐藏接口数据</li><li>面向对象中的接口通常包含的部分<ul><li>对象之间交互的消息(方法名)</li><li>消息中的所有参数</li><li>消息返回结果的类型</li><li>与状态无关的不变量(前置条件和后置条件)</li><li>需要处理的异常</li></ul></li><li>封装实现的细节<ul><li>封装数据和行为</li><li>封装内部结构</li><li>封装其他对象的引用</li><li>封装类型信息</li><li>封装隐藏变更</li></ul></li><li>原则十：最小化类和成员的可访问性<ul><li>抽象化：抽象集中于对象的外部视图，并将对象的行为与其实现分开</li><li>封装形式：类不应公开其内部实现细节</li><li>权限最小化原则</li></ul></li></ul></li></ul><h3 id="为变更而设计"><a href="#为变更而设计" class="headerlink" title="为变更而设计"></a>为变更而设计</h3><ul><li><p>OCP (开闭原则，Open&#x2F;Close Principle) <strong>重要</strong></p><ul><li><p>修改很复杂，修改后需要重新编译，有一定代价</p></li><li><p>解决方案：使用多态依赖完成</p></li><li><p>例子（图一为修改前，图二为修改后）：</p><ul><li><img src="1-1746704008602.png" style="zoom:67%;" /></li><li><img src="17-1746704010148.png" style="zoom: 67%;" /></li></ul></li><li><p>开闭原则(OCP)：软件实体应该开放进行扩展，而封闭以进行修改</p><ul><li>对<strong>扩展</strong>开放：模块的行为可以被扩展，比如新添加一个子类</li><li>对<strong>修改</strong>关闭：模块中的源代码不应该被修改</li></ul></li><li><p>RTTI：运行时类型信息是丑陋并且危险的</p><ul><li><p>RTTI &#x3D; Run-Time Type Information RTTI &#x3D; 运行时类型信息</p></li><li><p>如果模块尝试将基类指针动态转换为多个派生类，则每次扩展继承层次结构时，都需要更改模块</p></li><li><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSquare</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw         </span><br>    &#125;     <br>&#125; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        <span class="hljs-comment">//这里写法不合适</span><br>        <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Square) &#123;<br>            ((Square) shape).drawSquare();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Circle) &#123;<br>            ((Circle) shape).drawCircle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>都有draw方法，应该将draw放到shape里面</p></li></ul></li></ul></li><li><p>多态</p><ul><li>多态是指针对类型的语言限定，指的是不同类型的值能够通过统一的接口来操纵</li><li><img src="image-20240514200706623.png" alt="image-20240514200706623" style="zoom:67%;" /></li><li>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// draw implementation</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShapes</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>        shape.draw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>原则十二：DIP (Dependency Inversion Principle) 依赖倒置原则</p><ul><li>高级模块不应依赖于低级模块，两者都应依赖抽象；抽象不应该依赖细节，详细信息应取决于抽象</li><li>将接口从实现中分离出来 —— 抽象<ul><li>设计接口，而不是实现！</li><li>使用继承来避免直接绑定到类</li><li>实现依赖于接口</li></ul></li><li>例子：<ul><li><img src="23.png"></li><li>抽象：Writer，扩展的时候只需要被扩展类实现Writer</li></ul></li><li>抽象类&#x2F;接口：<ol><li>倾向于不经常改变</li><li>抽象是”铰接点”，在此更易于扩展&#x2F;修改</li><li>不必修改代表抽象(OCP)的类&#x2F;接口</li></ol></li><li>例外情况<ol><li>有些类很不可能修改<ol><li>因此对插入抽象层没有什么好处</li><li>示例：字符串类</li></ol></li><li>在这种情况下可以直接使用具体的类：在这种情况下可以直接使用具体的类…</li></ol></li><li>符合DIP的分层设计图参考课本256页</li></ul></li></ul><h2 id="16-设计模式"><a href="#16-设计模式" class="headerlink" title="16. 设计模式"></a>16. 设计模式</h2><h3 id="可修改性及其基本实现机制"><a href="#可修改性及其基本实现机制" class="headerlink" title="可修改性及其基本实现机制"></a>可修改性及其基本实现机制</h3><ul><li><p>可修改性</p><ul><li>实现的<strong>可修改性</strong>：涉及到大的场景的修改<ol><li>对已有实现的修改</li><li>例如：修改现有促销策略</li></ol></li><li>实现的<strong>可扩展性</strong>(DIP &amp; OCP)<ol><li>对新的实现的扩展</li><li>例如：增加一条新的促销策略(策略模式)</li></ol></li><li>实现的<strong>灵活性</strong><ol><li>对实现的动态配置</li><li>例如：动态修改更改某商品对应促销策略</li></ol></li></ul></li><li><p>可修改性的实现</p><ul><li><p>接口与实现的分离</p><ul><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。</li></ul></li><li><p>继承的优点</p><ul><li>虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。</li><li>子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。</li></ul></li><li><p>继承的缺点</p><ul><li>继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。</li><li>而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改。</li></ul></li><li><p>组合</p><ul><li><p>利用接口的组成关系，能在实现接口和实现的前提下，体现更好的灵活性。</p></li><li><p>优点</p><ol><li>前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。</li><li>后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。</li></ol></li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>概念<ul><li>设计模式：抽象一个重复的设计结构</li><li>包含类和&#x2F;或对象</li><li>提炼设计经验</li><li><strong>设计模式重点掌握类图</strong></li></ul></li><li>分类<ul><li>策略模式：减少耦合、依赖倒置。</li><li>抽象工厂模式：职责抽象、接口重用。</li><li>单件模式：信息隐藏、职责抽象。</li><li>迭代器模式：减少耦合、依赖倒置。</li></ul></li><li>策略模式<ul><li>策略模式：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li><li>参与者<ul><li>上下文（Context）:<ol><li>被配置了具体策略Concrete Strategy</li><li>拥有Strategy对象的一个引用</li><li>实现了一些方法以供Strategy访问其数据</li></ol></li><li>策略（Strategy）: 声明了所支持策略的接口。Context利用这些被Concrete Strategy定义的接口。</li><li>具体策略（Concrete Strategy）: 实现了Strategy声明的接口，给出了具体的实现。</li></ul></li><li>应用场景<ul><li>当很多相关类只在它们的行为的实现上不一样。策略模式提供了一个很好的方式来配置某个类，让其具有上述多种实现之一。</li><li>当我们需要同一个行为的不同实现（变体）的时候。策略模式可以用作实现这些变体。</li><li>算法需要用到一些数据，而这些数据不应该被客户知道。我们可以通过策略模式隐藏复杂的算法和数据接口。</li><li>一个类定义了很多行为，这些行为作为一个switch选择语句的分支执行部分。策略模式可以消除这些分支选择。</li></ul></li><li>类图<ul><li><img src="image-20240516152505556.png" alt="image-20240516152505556"></li></ul></li></ul></li><li>抽象工厂模式<ul><li>工厂模式就是为对象的创建提供一个接口，将具体创建的实现封装在接口之下，这样具体创建的实现的改变就不会对客户代码Client类产生影响。从而降低了Client类和多个具体类的耦合。</li><li><img src="image-20240516152625441.png" alt="image-20240516152625441" style="zoom:50%;" /></li><li>应用场景<ul><li>抽象工厂模式可以帮助系统独立于如何对产品的创建、构成、表现。</li><li>抽象工厂模式可以让系统灵活配置拥有某多个产品族中的某一个。</li><li>一个产品族的产品应该被一起使用，抽象工厂模式可以强调这个限制。</li><li>如果你想提供一个产品的库，抽象工厂模式可以帮助暴露该库的接口，而不是实现。</li></ul></li><li><img src="image-20240516152357093.png" alt="image-20240516152357093" style="zoom:67%;" /></li><li>类图<ul><li><img src="image-20240516152522467.png" alt="image-20240516152522467" style="zoom: 50%;" /></li></ul></li><li>工厂接口可以通过抽象工厂模式的专门的接口来实现，另外也可以通过父类的工厂方法，来让子类继承相应的工厂接口，这就是工厂方法模式</li></ul></li><li>单件模式<ul><li>在有些场景中，对于某个类，在内存中只希望有唯一一个对象存在。每次想得到这个类的一个对象的引用的时候，都指向唯一的那个对象。无论我创建多少次这个类的对象，其实总共还是只创建了一个对象。</li><li>类图<ul><li><img src="image-20240516152916693.png" alt="image-20240516152916693" style="zoom:50%;" /></li></ul></li><li>设计分析<ul><li><img src="image-20240516153424625.png" alt="image-20240516153424625"></li></ul></li></ul></li><li>迭代器模式<ul><li>当需要接受某个参数（如链表、散敛表）并对其进行迭代，将参数类型设为Collection</li><li>类图<ul><li><img src="image-20240516153154670.png" alt="image-20240516153154670" style="zoom:50%;" /></li></ul></li><li>参与者：<ul><li>迭代器（Iterator）： 迭代器定义访问和遍历元素的接口</li><li>具体迭代器（ConcreteIterator）：具体迭代器实现迭代器接口。对该聚合遍历时跟踪当前位置。</li><li>聚合（Aggregate）：聚合定义创建相应迭代器对象的接口。</li><li>具体聚合(ConcreteAggregate)：具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</li></ul></li><li>应用场景：<ul><li>访问一个聚合对象的内容而无需暴露它的内部实现。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ul></li></ul></li></ul><h2 id="17-软件构造"><a href="#17-软件构造" class="headerlink" title="17. 软件构造"></a>17. 软件构造</h2><ul><li>概述<ul><li>定义：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，⽣产可⼯作的、有意义的软件的详细创建过程。</li><li>软件构造是设计的延续<ul><li>设计是<strong>规划软件构造方法</strong>的过程，实现是依据<strong>规划的软件构造方案建造真正产品</strong>的过程</li><li>源程序是软件构建方案的<strong>最后一个规划</strong>，不是产品本身，真正的产品是运行于计算机上的由二进制代码组成的可执行程序。</li><li>源程序的生产过程-编程，属于设计活动，编译器完成的编译和链接才是依据规划建造软件产品的实现活动。</li><li><strong>编程不是一个简单的活动，核心是编码的设计</strong>。</li></ul></li><li>软件构造活动包含详细设计、编程、测试、调试、代码评审、集成与构建、构造与管理</li></ul></li></ul><h3 id="软件构造活动"><a href="#软件构造活动" class="headerlink" title="软件构造活动"></a>软件构造活动</h3><ul><li>详细设计<ul><li>概述<ul><li>有些项目会将主要的详细设计工作分配在软件构造阶段完成。</li><li>无论是哪种项目，在软件构造阶段都不可避免的会设计到详细设计的调整工作。因为编程语言是软件设计的一个重要约束，随着编程工作的进行和约束，人们可能会发现与预想不一致的情况和更多的约束，这个时候就需要在软件构造阶段修改详细设计方案。</li><li>软件构造阶段详细设计使用的方法与技术与软件设计阶段是一样的，只是应用在<strong>更小</strong>的规模上。</li><li>详细设计已经包含实际的代码实现了，不同编程语言的代码行数不同。</li></ul></li><li>程序代码的典型质量<ul><li>易读性：让软件更容易开发，尤其是易于调试；可以使的程序更加容易维护，减少理解代码的难度和成本：降低交流的成本，自己写完之后要修正代码使其易读。</li><li>易维护性:要求代码易读、易修改，增量开发，关键业务流程应该是易于扩展的</li><li>可靠性：执行正确，并能妥善处理故障。</li><li>性能：高性能，包括时间性能和空间性能，需要设计数据结构和算法设计。</li><li>安全性：不留系统漏洞，不出现重要信息的泄露(内存数据区泄露)</li></ul></li></ul></li><li>编程的主要技术<ul><li><img src="1-1746704036532.png" style="zoom:80%;" /></li></ul></li><li>测试、调试<ul><li>通常来说，程序员每修改⼀次程序就会进行最少⼀次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到了要求，没有程序错误。集成测试⼀般在单元测试之后，用来测试多个单元之间的接口是否编程正确。</li><li>调试过程可以分为三个部分：重现问题、诊断缺陷和修复缺陷。</li><li>重现问题的方法<ul><li><img src="4-1746704038583.png" style="zoom:80%;" /></li></ul></li><li>寻找和定位缺陷的方法<ul><li>灵活使用编译器提示。</li><li>持续缩小嫌疑代码的范围。</li><li>检查刚刚修改过的部分。</li><li>警惕已出现缺陷和常见缺陷。</li><li>利用工具。</li></ul></li><li><img src="6-1746704040318.png" style="zoom: 67%;" /></li><li>修复缺陷注意点<ul><li>⼀次只修复⼀个缺陷。</li><li>修改前保留旧版本的备份，如果项目使用了配置管理系统，这个工作会由配置管理工具完成，否则就需要由程序员手动完成。</li><li>使用测试和评审验证修复的有效性。</li><li>检查和修复类似的缺陷，这可以在代码搜索、程序切片等工具的帮助下进行。</li></ul></li></ul></li><li>代码评审<ul><li>代码评审对代码的系统检查，通常是通过同行专家评审来完成的。通过评审会议可以发现并修正之前忽略的代码错误，从而同时提高软件的质量和开发者的技巧。</li><li>代码评审⼀般分为正式评审、轻量级评审和结对编程。</li></ul></li><li>集成与构建<ul><li><img src="10.png" style="zoom: 80%;" /></li></ul></li><li>构造与管理<ul><li><img src="11-1746704043879.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="实践方法"><a href="#实践方法" class="headerlink" title="实践方法"></a>实践方法</h3><ul><li>重构<ul><li>概念：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。</li><li>重构的时机：<ul><li>增加新的功能时</li><li>发现了缺陷进行修复时</li><li>进行代码评审时</li></ul></li><li>代码的“坏味道”<ul><li><img src="image-20240528210426534.png" alt="image-20240528210426534"></li></ul></li><li>详见课本290页</li></ul></li><li>测试驱动开发<ul><li>测试驱动开发又被称为测试优先（Test First）的开发，随着极限编程方法的普遍应用而得到普及。</li><li>测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。测试代码通常由测试工具自动装载执行，也可以由程序员手工执行。完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性。</li><li><img src="image-20240528210620336.png" alt="image-20240528210620336" style="zoom: 67%;" /></li></ul></li><li>结对编程<ul><li>概念<ul><li>两位程序员并排工作，在相同的设计，算法，代码或测试上进行协作</li><li>一个程序员(驱动程序)可以控制键盘&#x2F;鼠标并主动执行程序</li><li>另一个程序员(观察员)不断观察驾驶员的工作，以发现战术上的(语法上的，拼写的等)缺陷，并从战略上考虑工作的方向</li><li>根据需要，两位程序员可以集思广益解决任何难题</li><li>两位程序员定期切换角色，他们平等地合作开发软件</li></ul></li><li>为什么结对编程有效？<ul><li>双压力：彼此保持专注并专注于任务</li><li>配对思考：为任务带来不同的先前经验</li><li>配对中继：每个人依次为自己的知识和能力做出最大贡献，然后坐下来思考，而他们的伴侣继续奋斗</li><li>配对审查<ol><li>持续的设计和代码审查</li><li>极高的缺陷去除效率</li><li>消除程序员对评论的厌恶</li><li>在所有(单独)程序员中，有80％都不定期或根本不这样做</li><li>预防缺陷总是比消除缺陷更有效</li></ol></li><li>配对调试：成对谈论问题可能会导致解决方案变得显而易见</li><li>配对学习：持续审核-&gt;向合作伙伴学习技术，语言知识，领域等。</li></ul></li></ul></li><li>有建设性的想法（具体见PPT）<ul><li>十年的软件建设进展</li><li>现代软件建设的十个现实情况</li><li>1990年代和2000年代最糟糕的建筑思想</li></ul></li></ul><h2 id="18-代码设计"><a href="#18-代码设计" class="headerlink" title="18. 代码设计"></a>18. 代码设计</h2><ul><li><p>设计易读的代码</p><ul><li>布局格式<ul><li>用缩进与对齐表达逻辑结构</li><li>将相关逻辑组织在一起（成员变量声明、构造方法和析构方法、public方法……）</li><li>将空行分隔逻辑(将大规模的逻辑划分的片段进行分隔)</li><li>将语句进行分隔(将过长的语句分隔到几行中进行显示)</li></ul></li><li>命名<ul><li>使用有意义的名称进行命名</li><li>名称要与实际内容相符</li><li>如果存在惯例，命名时要遵守惯例</li><li>临时变量命名要符合常规</li><li>不要使用太长的名称</li><li>不要使用易混字符进行命名</li><li>不要仅仅使用不易区分的多个名称（例如Sales与Sale）</li><li>不要使用没有任何逻辑的字母缩写进行命名</li></ul></li><li>注释<ul><li>语句注释（&#x2F;&#x2F;）</li><li>标准注释(&#x2F;* *&#x2F;)</li><li>文档注释(&#x2F;** *&#x2F;)</li><li>注释要有意义，不要简单重复代码的含义</li><li>重视对数据类型的注释</li><li>重视对复杂控制结构的注释</li></ul></li><li>javadoc<ul><li><img src="image-20240530104046105.png" alt="image-20240530104046105" style="zoom: 60%;" /></li><li><img src="image-20240530104115367.png" alt="image-20240530104115367" style="zoom:50%;" /></li></ul></li></ul></li><li><p>设计易维护的代码</p><ul><li><p>小型任务</p><ul><li>要让程序代码可修改，就要控制代码的复杂度。这首先要求每个函数或⽅法的代码应该是内聚的，恰好完成⼀个功能与⽬标。</li><li>如果内聚的代码本身比较简单，复杂性可控，那么它就具有比较好的可维护性。反之，内聚的代码也可以比较复杂，典型表现是完成⼀个功能需要多个步骤、代码比较长，那么就需要将其进⼀步分解为多个高内聚、低耦合的小型任务。</li></ul></li><li><p>复杂决策</p><ul><li><p>使用新的布尔变量简化复杂决策</p><img src="image-20240530104850436.png" alt="image-20240530104850436" style="zoom:50%;" /></li><li><p>使用有意义的名称封装复杂决策</p><img src="image-20240530104804574.png" alt="image-20240530104804574" style="zoom:50%;" /></li><li><p>表驱动编程</p><ul><li><img src="image-20240530105007694.png" alt="image-20240530105007694" style="zoom: 67%;" /></li><li><img src="image-20240530105028512.png" alt="image-20240530105028512"></li></ul></li></ul></li><li><p>数据使用</p><ul><li><img src="image-20240530105101590.png" alt="image-20240530105101590"></li></ul></li><li><p>明确依赖关系</p><ul><li>类之间模糊的依赖关系会影响到代码的理解与修改，非常容易导致修改时产生未预期的连锁反应</li></ul></li></ul></li><li><p>设计可靠的代码</p><ul><li>契约式设计——异常方式<ul><li><img src="image-20240530105257449.png" alt="image-20240530105257449" style="zoom:67%;" /></li></ul></li><li>契约式设计——断言方式<ul><li><img src="image-20240530105323619.png" alt="image-20240530105323619"></li><li><img src="image-20240530105351501.png" alt="image-20240530105351501" style="zoom: 50%;" /></li></ul></li><li>防御式编程<ul><li>防御式编程的基本思想是：在⼀个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害。</li><li>异常和断言都可以⽤来实现防御式编程，两种实现方式的差异与契约式设计的实现⼀样</li></ul></li></ul></li><li><p>使用模型辅助设计复杂代码</p><ul><li>决策表<ul><li><img src="image-20240530105808943.png" alt="image-20240530105808943" style="zoom:50%;" /></li><li><img src="image-20240530105821325.png" alt="image-20240530105821325"></li></ul></li><li>伪代码<ul><li><img src="image-20240530105846470.png" alt="image-20240530105846470"></li></ul></li><li>程序流程图<ul><li><img src="image-20240530105908073.png" alt="image-20240530105908073"></li></ul></li></ul></li><li><p>为代码开发单元测试用例</p><ul><li>为方法开发测试用例<ul><li><img src="image-20240530112339238.png" alt="image-20240530112339238" style="zoom: 50%;" /></li><li><img src="image-20240530112541314.png" alt="image-20240530112541314"></li></ul></li><li>为类开发测试用例<ul><li>在复杂类中，常常有着多变的状态，每次⼀个方法的执行改变了类状态时，都会给其他方法带来影响，也就是说复杂类的多个方法间是互相依赖的。</li><li>所以，除了测试类的每⼀个方法之外，还要测试类不同方法之间的互相影响情况。</li><li><img src="image-20240530112523161.png" alt="image-20240530112523161"></li></ul></li></ul></li><li><p>代码复杂度度量</p><ul><li>程序复杂度是造成各种编程困难的主要原因。为了帮助程序员处理程序复杂度，人们提出了<br>很多程序复杂度的度量手段，其中McCabe的圈复杂度[McCabe1976]得到了比较大的关注</li><li><img src="image-20240530113030652.png" alt="image-20240530113030652" style="zoom:50%;" /></li><li><img src="image-20240530113043738.png" alt="image-20240530113043738" style="zoom:50%;" /></li><li><img src="image-20240530113136053.png" alt="image-20240530113136053" style="zoom: 50%;" /></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>关闭隐式声明</li><li>声明全部的变量</li><li>遵循某种命名规则</li><li>检查变量名</li></ul></li><li>变量初始化<ul><li><img src="image-20240530192031434.png" alt="image-20240530192031434" style="zoom: 50%;" /></li></ul></li><li>作用域<ul><li>使变量应用局部化（空间）</li><li>尽可能缩短变量的存活时间（时间）</li></ul></li><li>持续性<ul><li>在程序中加⼊调试代码或者断言来检查那些关键变量的合理取值</li><li>编写代码时要假设数据并没有持续性</li></ul></li><li>数值理论<ul><li>避免使用“神秘数值”</li><li>如果需要，可以使用硬编码的0和1</li><li>预防除0的错误</li><li>避免混合类型的比较</li><li>使类型转换变得明显</li></ul></li></ul></li><li><p>⼀般控制问题</p><ul><li>布尔表达式<ul><li>用true和false做布尔判断</li><li>简化复杂的表达式</li><li>编写肯定形式的布尔表达式（isEmpty）</li><li><img src="image-20240530192745794.png" alt="image-20240530192745794" style="zoom:50%;" /></li></ul></li><li>复合语句<ul><li>把括号对⼀起写出</li><li>y6括号被条件表达清楚</li></ul></li><li>空语句<ul><li><img src="image-20240530193054565.png" alt="image-20240530193054565" style="zoom:50%;" /></li></ul></li><li>驯服危险的深层嵌套<ul><li><img src="image-20240530193149087.png" alt="image-20240530193149087" style="zoom:50%;" /></li></ul></li></ul></li></ul><h2 id="19-软件测试"><a href="#19-软件测试" class="headerlink" title="19. 软件测试"></a>19. 软件测试</h2><ul><li>概念<ul><li>软件正确性：在且仅在以下情况下，才根据规范S考虑程序P：对于每个有效输入，P的输出均符合规范S</li></ul></li><li>V&amp;V<ul><li>Verification: 验证，检查开发者是否正确地使用技术建立系统，确保系统能够在于其的环境中按照技术要求正确地运行。例如：“检查需求文档中的书写错误”，“发现设计思路的不完善”</li><li>Validation: 确认，检查开发者是否建立了正确的系统，确保最终产品符合规格。例如：“需求文档能否反应用户真实意图”，“代码是否按照需求与设计要求编写”</li><li>V＆V通常是指试图确保软件按要求运行的任何活动，差异无关紧要。(见课本320页,重要，会考V&amp;V)</li><li>软件开发的验证与确认主要有两种手段：<strong>静态分析</strong>与<strong>动态测试</strong></li><li><img src="image-20240611161053160.png" alt="image-20240611161053160" style="zoom: 50%;" /></li></ul></li><li>静态分析<ul><li>仅基于(手动或自动)检查软件模型和代码的项目文档以及有关需求和设计的其他相关信息，通常会产生有效的结果，但精度可能较弱。容易产生误报，因为多态的存在导致很多只能在运行的时候才报错。</li><li>评审是最常用的静态分析手段</li><li>传统静态技术–大量手动操作，容易出错，耗时<ol><li>软件检查–根据已编译的常见和历史缺陷清单，对生成的文档(可交付成果)进行逐步分析</li><li>软件评审–将工作产品的不同方面呈现给项目人员(经理，用户，客户等)和其他感兴趣的涉众以征求意见或批准的过程</li><li>阅读代码–对生成的代码进行桌面分析，以发现不违反样式或语法的键入错误</li><li>算法分析和跟踪–可以得出所用算法的复杂性以及最坏情况，平均情况和概率分析评估的过程</li></ol></li></ul></li><li>动态测试<ul><li>在软件运行时考察软件运行时的表现，完成验证与确认</li><li>动态分析技术<ul><li>测试：基于对有价输入的代码执行(必要时必须包括表征系统状态的参数和环境条件的定义)</li><li>性能分析：程序配置文件记录了一组受控执行过程中某些感兴趣的实体出现的次数</li></ul></li></ul></li><li>软件测试<ul><li>目的<ul><li>向开发者和用户展示软件满足了需求，表明软件产品是一个合格的产品</li><li>找出软件中的缺陷和不足</li></ul></li><li>测试用例<ul><li><img src="image-20240611161633280.png" alt="image-20240611161633280" style="zoom: 33%;" /></li></ul></li><li>桩与驱动<ul><li>桩程序是被测试部件的交互环境，他扮演被测试部件需要调用的其他系统部件。桩程序对其他系统部件的扮演仅限于规格相同，内部代码要简单的多，通常是直接返回固定数据或者按照固定规则返回数据。</li><li>驱动程序负责创建被测试部件的执行环境，并驱动和监控被测试部件执行测试用例的过程，判定测试用例的执行结果。</li><li><img src="image-20240611161721076.png" alt="image-20240611161721076" style="zoom: 33%;" /></li></ul></li><li>测试层次<ul><li><img src="image-20240611162004576.png" alt="image-20240611162004576" style="zoom: 80%;" /></li><li>开发者主要是进行单元测试，可以进行一定程度上的集成测试和系统测试</li><li>看一下α和β测试</li></ul></li><li>单元测试<ul><li><img src="image-20240611162115903.png" alt="image-20240611162115903" style="zoom: 33%;" /></li><li>在过程化编程中，一个单元就是一个函数与过程。</li><li>在面向对象编程中，一个单元就是类的一个方法。</li><li>发现技术缺陷和代码缺陷</li></ul></li><li>集成测试<ul><li><img src="image-20240611162205907.png" alt="image-20240611162205907" style="zoom: 60%;" /></li><li><img src="image-20240611162226820.png" alt="image-20240611162226820" style="zoom:60%;" /></li></ul></li><li>系统测试：关注不符合需求的缺陷和需求自身的内在缺陷。根据测试目标的不同，有很多不同类型的系统测试：功能测试、非功能性测试、验收测试、安装测试等等。</li></ul></li><li>软件测试技术<ul><li>随机测试：根据软件工程师的技能、直觉和对类似程序的经验，从所有可能的输入值中选择输⼊子集，建立测试用例。</li><li>黑盒测试：将测试对象作为一个黑盒子，完全基于输入和输出数据来判断测试对象的正确性。<ul><li>把所有可能的输入数据，即程序的输入域划分为若干部分(子集)，从每个子集中选取少量具有代表性的数据作为测试用例。</li><li>等价类划分：将输入域分为有效等价类和无效等价类。有效等价类指对系统规格说明来说合理的输入，无效等价类与之相反。设计测试用例时要同时考虑两种等价类。</li><li>边界值分析：对定价类划分的补充，错误容易发生在各个等价类的边界上，而不是等价类的内部，因此针对边界情况设计测试用例，可以发现更多的缺陷。</li><li>决策表是为复杂逻辑判断设计测试用例的技术。决策表是由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。（具体见18代码设计或者书P311）</li><li>状态转换是针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定。状态转换包含有效转换和无效转换，只有在复杂情况和可靠性要求较高的情况下才会为无效转换设计测试用例。</li></ul></li><li>白盒测试：将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。<ul><li>语句覆盖：设计测试用例的标准是确保被测试对象的每⼀行程序代码都⾄少执行⼀次。</li><li>条件覆盖：设计测试用例的标准是确保程序中每个判断的每个结果都⾄少满足⼀次</li><li>路径覆盖：测试用例的标准是确保程序中每条独立执行路径都⾄少执行⼀次</li></ul></li><li>特定测试技术和面向对象的测试技术略</li></ul></li><li>测试活动（P332）<ul><li>测试计划:在开始具体的软件测试活动之前，必须首先进行测试计划，以明确测试的工作范围、资源与成本、基本策略、进度安排等。</li><li>测试设计:测试的成功取决于有效设计的测试用例</li><li>测试执行:执行测试前需要选择好测试工具</li><li>测试评价:在测试完成后，必须评价测试结果</li></ul></li><li>测试度量<ul><li>缺陷数据：分类汇总测试过程中发现的缺陷</li><li>测试覆盖率<ul><li>需求覆盖率&#x3D;被测试的需求数量&#x2F;需求总数</li><li>模块覆盖率&#x3D;被测试的模块数量&#x2F;模块总数</li><li>代码覆盖率&#x3D;被测试的代码行&#x2F;代码行数</li></ul></li></ul></li></ul><h2 id="20-软件交付"><a href="#20-软件交付" class="headerlink" title="20. 软件交付"></a>20. 软件交付</h2><ul><li>概念<ul><li>软件交付是软件项目的结束阶段，标志着软件开发任务的完成</li><li>软件交付是软件开发与软件维护两个既连续又不同的软件产品生存状态的分水岭。</li><li>只有做好软件交付工作，才是真正地完成整个项目。</li></ul></li><li>安装<ul><li>概念：安装是软件交付的最常见形式，现在大多数产品都通过安装的形式交付，它要求开发团队创建一个安装包，用户可以通过的执行将软件产品部署到工作环境。</li><li>创建安装包的步骤<ul><li>确定安装环境<ol><li>确定安装包需要<strong>支持的操作系统</strong>，这既需要考虑当前用户的工作环境，又需要考虑产品未来的市场规划；</li><li>确定软件产品的语言支撑环境，例如使用Java语言开发的软件产品就需要安装JDK；</li><li>确定软件产品需要的软件支持，例如数据库系统、网络系统等；</li><li>确定硬件等其他要求，例如有些软件产品可能会要求扫描仪、视频卡、通信设备等特殊硬件。</li></ol></li><li>列举安装清单<ol><li>要根据软件产品的实现情况，结合所需的环境支撑，列举需要安装的文件、初始化数据、注册表等清单信息，要清楚<strong>标明它们在安装后将会出现的位置</strong>。</li><li>在考虑安装位置时要遵守一致性，标记名称的使用要意义清楚，让用户能便利地找出相应文件。</li></ol></li><li>设计和建立安装包：要对安装包进行详细的设计，包括一个渐进的安装步骤，各步骤的人机交互方式等等。完成设计后就可以使用安装工具创建安装包。</li><li>测试安装包：安装包需要在目标环境中进行安装测试，以发现可能的问题。必须以用户的工作环境为<strong>目标环境</strong>进行测试，因为用户使用的机器环境与开发者的机器环境有很大的不同</li></ul></li></ul></li><li>部署<ul><li>背景：在软件产品比较复杂时，仅仅通过一个安装包无法完成软件交付任务，这时可以使用另一种常见的软件交付方式——部署。</li><li>概念：部署通常是由开发人员直接操纵软件产品的目标环境，使得软件产品能够在目标环境中正常运行。</li><li>部署的步骤<ul><li>确定部署环境：需要对目标环境进行调查分析，搞清楚部署前的环境细节，然后才能与软件产品需要的环境细节进行比较，明确需要执行的部署任务。具体来说，软件部署需要了解服务器与网络拓扑、安全控制与权限管理、软硬件系统的配置信息等。</li><li>确定部署任务：将软件产品需要的目标环境与部署前的环境进行比较，分析二者之间的差距，并将其确立为部署的任务。确定任务之后，还需要以渐进的方式安排任务之间的执行次序。</li><li>完成部署准备：有些部署工作可以完全依靠现场执行，但多数的部署任务需要进行一定的事前准备，尤其是要综合考虑部署工作可能出现的各种情况，制定完备的应对方案。</li><li>执行部署任务</li></ul></li></ul></li><li>培训与文档支持<ul><li>培训<ul><li>培训主要是教会用户使用软件产品的功能来完成其工作和任务。依据任务的不同，要为不同的用户进行不同类型的培训。</li><li>尤其不能忽略的是对<strong>系统管理员</strong>进行培训。要培训系统管理员如何启动和运行新系统、如何配置系统、如何授权或拒绝对系统的访问、如何支持用户、如何处理异常等。</li><li>只介绍能够帮助用户完成主要工作和任务的功能。对于一些很少会被使用并且<strong>不太重要</strong>的功能，即使培训也会很快被用户忘记，可以让用户使用<strong>文档支持</strong>来学会使用。</li><li>培训时，要关注用户的工作和任务，不必涉及系统的内部操作，不必知道系统的存储方式、访问方式和权限控制方式。</li></ul></li><li>文档支持<ul><li>用户文档：用户文档是指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。</li><li><img src="image-20240611202441645.png" alt="image-20240611202441645" style="zoom:50%;" /></li><li>系统管理员文档：与用户文档注重系统使用细节不同，系统管理员文档更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。</li></ul></li></ul></li><li>项目评价<ul><li>常见的项目评价针对四个方面：<ol><li>项目管理：可以帮助建立对项目的更准确认知，例如常见的管理问题与偏差、时间与成本耗费分布等。</li><li>产品：可以帮助开发者建立对产品的更准确认知，提高产品的开发经验。</li><li>团队：可以帮助开发者更好地组织分工，也可以帮助团队建立更好的沟通与交流途径。</li><li>个人：可以帮助开发者更准确认知自己的生产力，学习常见问题及其处理方法，了解自己的长处和不足并持续提高。</li></ol></li><li>项目评价方法<ul><li>评审：项目评审通过评审重要项目制品的方法来评价项目，这些重要制品包括项目计划、管理文档、会议记录、历史数据等。</li><li>度量数据分析：度量数据可以提供丰富的信息，通过分析这些信息，开发团队可以获取正确和深入的结论。</li></ul></li></ul></li></ul><h2 id="21-软件的维护与演化"><a href="#21-软件的维护与演化" class="headerlink" title="21. 软件的维护与演化"></a>21. 软件的维护与演化</h2><ul><li>概念<ul><li>软件维护只需要完成少量的使用帮助、故障解决和磨损处理等工作</li><li>修改软件的代价非常高，软件维护的重点在于软件修改和变更上。</li><li>软件变更的常见场景<ul><li>问题发生了改变</li><li>环境发生了改变</li><li>软件产品中存在缺陷</li></ul></li></ul></li><li>软件维护类型划分<ul><li>完善性维护：为了满足用户新的需求、增加软件功能而进行的软件修改活动。</li><li>适应性维护：为了使软件能适应新的环境而进行的软件修改活动。</li><li>修正性维护：为了排除软件产品中遗留缺陷而进行的软件修改活动。</li><li>预防性维护：为了让软件产品在将来可维护，提升可维护性的软件修改活动。<ol><li>随着持续的修改，软件的复杂度会上升，质量会下降。预防性修改是为了解决上述问题而进行的软件调整，是一种特殊类型的”修改”</li><li>只有这一种维护是根源于软件维护中的规律性。</li></ol></li></ul></li><li>前期(开发阶段)更充分的准备可以减轻后期维护的压力和困难<ul><li>考虑软件的可变更性：预测变更并将其独立封装，便于修改时的程序定义与理解，防止修改时的连锁反应</li><li>为降低维护困难而开发<ul><li>编写详细的技术文档并保持及时更新。</li><li>保证代码的可读性。</li><li>维护需求跟踪链。<ol><li>需求跟踪链从正反两个方向纪录”需求、设计、编码、测试”之间的跟踪与回溯关系</li></ol></li><li>维护回归测试基线。<ol><li>回归测试基线包含了系统修改之前的有效测试用例集合， 因此只需要根据修改情况对回归测试基线进行简单的修正</li></ol></li></ul></li></ul></li><li>软件维护过程<ul><li><img src="2.png" style="zoom:67%;" /></li></ul></li><li>软件演化生命周期<ul><li><img src="4-1746704106380.png" style="zoom: 67%;" /></li><li>初始开发<ul><li>初始开发阶段按照传统的软件开发方式完成第一个版本的软件产品开发。第一版的软件产品可以实现全部需求，也可以(通常是)只包含部分需求——对用户来说非常重要和紧急的最高优先级需求。</li><li>初始阶段的一个极其重要的工作是建立一个好的软件体系结构</li></ul></li><li>演化<ul><li>在完成初始开发之后，软件产品就进入演化阶段。该阶段可能会有预先安排的需求增量，也可能完全是对变更请求的处理，它们的共同点都是保持软件产品的持续增值，让软件产品能够满足用户越来越多的需要，实现更大的业务价值</li><li>演化阶段的软件产品要具备两个特征：<ol><li>软件产品具有<strong>较好的可演化性</strong>。一个软件产品在演化过程中复杂性会逐渐增高，可演化性会逐渐降低直至无法继续演化。</li><li>软件产品能够帮助用户实现较好的<strong>业务价值</strong>。只有这样，用户才会继续需要该产品，并持续提供资金支持。</li></ol></li><li>如果在演化过程中，一个软件产品开始不满足第(2)条特征，那么该产品就会提前进入停止阶段。如果软件产品满足第(2)条的同时不满足第(1)条特征，那么该产品就会进入服务阶段。</li></ul></li><li>服务<ul><li>服务阶段的软件产品不再持续的增加自己的价值，而只是周期性的修正已有的缺陷。</li></ul></li></ul></li><li>软件维护与演化的技术<ul><li>遗留软件<ul><li>如果遗留软件已经没有使用价值，就直接丢弃该软件。</li><li>如果遗留软件还有使用价值，但是其维护的成本效益比低于新开发一个软件系统的成本效益比，那么冻结遗留软件，将其作为一个新的更大系统的组成部分进行使用。</li><li>如果遗留软件的成本效益比低于新开发一个软件系统的成本效益比，而且该遗留软件仍然具备较好的可维护性，那么就逆向工程遗留软件并继续维护一段时间；</li><li>如果遗留软件的成本效益比高于新开发一个软件系统的成本效益比，而且该遗留软件已经不具备可维护性，那么就修改系统使其获得新生(即再工程该系统)，然后继续维护再造后的系统。</li></ul></li><li>逆向工程<ul><li>处理遗留软件时，维护人员接受的维护对象可能是一个没有任何文档也没有程序源代码的软件程序，此时，维护人员需要使用逆向工程技术</li><li>逆向工程技术是指：”分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程</li><li>逆向工程的基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li></ul></li><li>再工程<ul><li>再工程的目的是对遗留软件系统进行分析和重新开发，以便进一步利用新技术来改善系统或促进现存系统的再利用。</li><li><img src="7-1746704109456.png" style="zoom: 50%;" /></li><li>常见的具体活动有<ol><li>重新文档化</li><li>重组系统的结构</li><li>将系统转换为更新的编程语言</li><li>修改数据的结构组织。</li></ol></li></ul></li></ul></li></ul><h2 id="22-软件开发过程模型"><a href="#22-软件开发过程模型" class="headerlink" title="22. 软件开发过程模型"></a>22. 软件开发过程模型</h2><ul><li>概念<ul><li>软件过程模型在生命周期模型的基础则进一步详细说明各个阶段的任务、活动、对象及其组织、控制过程</li><li>与简略的软件生命周期模型不同，软件过程模型可以被看作是网络化的活动组织</li><li>不同的生命周期模型有不同的软件过程模型：阶段划分不一样</li><li>同一个生命周期模型也会有多个不同的软件过程模型</li></ul></li><li>构建-修复模型<ul><li><img src="image-20240613123828381.png" alt="image-20240613123828381" style="zoom: 67%;" /></li><li>缺点<ul><li>在这种模型中，没有对开发工作进行规范和组织，所以随着软件系统的<strong>复杂度提升</strong>，开发活动会超出个人的直接控制能力，构建-修复模型就会导致开发活动无法有效进行而失败；</li><li>没有分析<strong>需求的真实性</strong>，给软件开发带来很大的风险；</li><li>没有考虑<strong>软件结构的质量</strong>，使得软件结构在不断的修改中变得质量越来越糟，直至无法修改；</li><li>没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难。</li></ul></li><li>适用范围<ul><li>软件规模很小，只需要几百行程序，其开发复杂度是个人能力能够胜任的；</li><li>软件对质量的要求不高，即使出错也无所谓；</li><li>只关注开发活动，对后期维护的要求不高，甚至不需要进行维护</li></ul></li></ul></li><li>瀑布模型<ul><li><img src="image-20240613123952041.png" alt="image-20240613123952041" style="zoom: 50%;" /></li><li>优点：为软件开发活动定义了清晰的阶段划分(包括输入&#x2F;输出、主要工作及其关注点)，这让开发者能够以关注点分离的方式更好地进行那些复杂度超越个人能力的软件项目的开发活动</li><li>缺点<ul><li>对文档的过高期望具有局限性。<ul><li>一方面会耗费很大的工作量和成本</li><li>另一方面很难为经常变化的需求建立完备可靠的文档。</li></ul></li><li>对开发活动的线性顺序假设具有局限性。<ol><li>要求一个阶段的工作经过验证后才能进入后续阶段是不切实际的。在实际开发中，常常需要进行一定的后续工作才能验证当前的工作是否正确、可靠。</li></ol></li><li>客户、用户参与具有局限性。<ol><li>成功的项目开发需要客户、用户从始至终的参与，而不仅仅是一个阶段。</li></ol></li><li>里程碑粒度具有局限性：里程碑粒度过粗，基本丧失了”早发现缺陷早修复”这一思想</li></ul></li><li>适用范围<ul><li>需求非常成熟、稳定，没有不确定的内容，也不会发生变化；</li><li>所需的技术成熟、可靠，没有不确定的技术难点，也没有开发人员不熟悉的技术问题；</li><li>复杂度适中，不至于产生太大的文档负担和过粗的里程碑。</li></ul></li></ul></li><li>增量迭代模型<ul><li><img src="image-20240613125033159.png" alt="image-20240613125033159"></li><li>优点<ul><li>迭代式开发更加符合软件开发的实践情况，具有更好的适用性；</li><li>并行开发可以帮助缩短软件产品的开发时间；</li><li>渐进交付可以加强用户反馈，降低开发风险。</li></ul></li><li>缺点<ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。</li><li>增量交付模型需要<strong>一个完备、清晰的项目前景和范围</strong>以进行并发开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围。</li></ul></li><li>适用范围：因为能够很好地适用于大规模软件系统开发，所以增量迭代模型在实践中有着广泛的应用，尤其是比较成熟和稳定的领域。</li></ul></li><li>演化模型<ul><li><img src="image-20240613125157881.png" alt="image-20240613125157881"></li><li>优点<ul><li><strong>使用了迭代式开发，具有更好的适用性</strong>，尤其是其演化式迭代安排能够适用于那些需求变更比较频繁或不确定性较多的软件系统的开发；</li><li>并行开发可以帮助<strong>缩短</strong>软件产品的开发时间；</li><li>渐进交付可以<strong>加强用户反馈</strong>，降低开发风险。</li></ul></li><li>缺点<ul><li>无法在项目早期阶段建立项目范围，所以项目的整体计划、进度调度、尤其是商务协商事宜无法准确把握；</li><li>后续迭代的开发活动是在前导迭代基础上进行修改和扩展的，这容易让后续迭代忽略设分析与设计工作，蜕变为构建-修复方式。</li><li>容易退化为构建修复方式</li></ul></li><li>适用范围：在实践中，<strong>不稳定领域的大规模软件系统</strong>开发适合使用<strong>演化模型</strong>进行组织。</li></ul></li><li>原型模型<ul><li><img src="image-20240613125236672.png" alt="image-20240613125236672"></li><li>抛弃式原型<ol><li>它通过模拟”未来”的产品，将”未来”的知识置于”现在” 进行推敲，解决不确定性。</li><li>存在的原因是”不确定的”，这一类原型在后续的开发过程中会被抛弃</li></ol></li><li>演化式原型<ol><li>在迭代中构建，是系统的核心，并不断扩充，最终成为真正的软件产品。</li><li>它将作为真正产品的一部分，所以必须有很好的质量。在迭代式开发中，通常会在第一个迭代中构建一个核心的体系结构演化式原型，并且在后续迭代中不断扩充，成为真正的软件产品。</li></ol></li><li>优点<ul><li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度；</li><li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性。</li></ul></li><li>缺点<ul><li>原型方法能够解决风险，但是自身也能带来新的风险，例如原型开发的成本较高，可能会耗尽项目的费用和时间；</li><li>实践中，很多项目负责人不舍得抛弃”抛弃式原型”，使得质量较差的代码进入了最终产品，导致了最终产品的低质量。</li></ul></li></ul></li><li>螺旋模型<ul><li><img src="image-20240613125349691.png" alt="image-20240613125349691"></li><li>原型模型 vs 螺旋模型<ol><li>原型模型：使用原型解决需求的不确定性</li><li>螺旋模型：实用原型解决项目开发中常见的各种类型的技术风险，包括系统需求开发、软件需求开发、软件体系结构设计、详细设计等各个阶段</li></ol></li><li>自内向外，螺旋模型有4次风险解决迭代，分别解决了几个高风险的阶段的问题<ol><li>解决系统需求开发中的风险，尤其是产品概念设计风险，得到一个确定的产品前景和范围。</li><li>解决软件需求开发中的风险，得到清晰的软件需求</li><li>解决软件体系结构设计中的技术风险，构建高质量的核心体系结构原型。</li><li>解决详细设计和实现中的关键技术风险，建立一个可实现的高质量软件结构。</li></ol></li><li>优点：可以降低风险，减少项目因风险造成的损失</li><li>缺点<ul><li>风险解决需要使用原型手段，也就会存在原型自身带来的风险，这一点与原型模型相同；</li><li>模型过于复杂，不利于管理者依据其组织软件开发活动；</li></ul></li><li>适用性：在实践中，螺旋模型在高风险的大规模软件系统开发中有着较多的应用。</li></ul></li><li>Rational 统一过程<ul><li>总结和借鉴传统上的各种有效经验，建立最佳实践方法的集合，并提供有效的过程定制手段，允许开发者根据特定的需要定制一个有效的过程模型。</li><li><img src="11-1746704120722.png" style="zoom:67%;" /></li><li>RUP裁剪：确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。</li><li>核心思想<ul><li>迭代式开发，这是过去被反复证明的最佳实践方法；</li><li>管理需求，重视需求工程中除了需求开发之外的需求管理活动；</li><li>使用基于组件的体系结构，它帮助建立一个可维护、易开发、易复用的软件体系结构；</li><li>可视化建模，利用UML进行建模；</li><li>验证软件质量，尽早和持续地开展验证，以尽早发现缺陷，降低风险和成本；</li><li>控制软件变更，适应1990s以后需求变更越来越重要的事实</li></ul></li><li>适用性：RUP是重量级过程，能够胜任大型软件团队开发大型项目时的活动组织。但RUP经过裁剪和定制，也可以变为轻量级过程，也能够胜任小团队的开发活动组织。</li></ul></li><li>敏捷过程：略</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>软件工程与计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2024/01/19/COA/"/>
    <url>/2024/01/19/COA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理整理"><a href="#计算机组成原理整理" class="headerlink" title="计算机组成原理整理"></a>计算机组成原理整理</h1><h2 id="第一讲：计算机概述"><a href="#第一讲：计算机概述" class="headerlink" title="第一讲：计算机概述"></a>第一讲：计算机概述</h2><ul><li>冯诺依曼结构<ul><li>计算机由运算器、存储器、控制器、输入设备、输出设备组成<ul><li>主存储器：地址和存储的内容</li><li>算术逻辑单元 &#x2F; 处理单元：执行信息的实际处理</li><li>程序控制单元 &#x2F; 控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li><li>指令和数据以同等地位存放在存储器内，并可按地址访问</li><li>指令和数据均用二进制表示</li></ul></li><li>计算机性能标准<ul><li>CPU ：速度</li><li>存储器：速度，容量</li><li>I&#x2F;O ：速度，容量</li></ul></li></ul><span id="more"></span><ul><li>CPU性能<ul><li>时钟频率 &#x2F; 时钟速度（单位：Hz） ：计算机在单位时间内执行最基本操作的次数</li><li>时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间</li><li>CPI：执行程序时平均每条指令所需的时钟周期数</li><li><img src="image-20231205151251333.png" alt="image-20231205151251333"></li></ul></li><li>字长<ul><li>机器字长：计算机能直接处理的二进制数据的位数。机器字长通常与主存单元的位数一致。计算机中运算器进行算术运算和逻辑运算，机器字长也就是进行定点数运算的字长，通常也是CPU内部数据通路的宽度。</li><li>指令字长：一个指令字中包含二进制代码的总位数。指令字长取决于操作码的长度、操作码地址的长度和操作码地址的个数。</li><li>存储字长：一个存储单元存储二进制代码的位数。</li></ul></li></ul><h2 id="第三讲：数据的机器级表示"><a href="#第三讲：数据的机器级表示" class="headerlink" title="第三讲：数据的机器级表示"></a>第三讲：数据的机器级表示</h2><ul><li>原码、反码、补码<ul><li>无符号整数只有原码</li><li>正数三码合一</li><li>负数补码 &#x3D; 绝对值原码取反 + 1</li></ul></li><li>浮点数的二进制表示<ul><li>S： 1位标志，表示正负</li><li>E： 8位阶码（指数），无符号整数<ul><li>计算指数要减偏移量127</li></ul></li><li>B： 23位尾数</li><li>规格化数：2^-126 <strong>~</strong> (2 - 2 ^ -23) * 2^128，隐藏位为1</li><li>非规划数：阶码全0，尾数不全为0，2^-149 ~ 2^-126</li></ul></li></ul><p><img src="image-20231205154100699.png" alt="image-20231205154100699.png"></p><p><img src="image-20231205154159726.png" alt="image-20231205154159726.png"></p><ul><li>十进制数的BCD码<ul><li>符号（4位）：正数1100，负数1101</li><li>后面每四位表示十进制数的一位</li></ul></li></ul><h2 id="第四讲：数据校验码"><a href="#第四讲：数据校验码" class="headerlink" title="第四讲：数据校验码"></a>第四讲：数据校验码</h2><blockquote><p>本课程不考虑两位及以上出错</p></blockquote><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul><li>在数据结尾增加一位表示数据中1的数量是奇数还是偶数</li><li>数据输入<ul><li>奇校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1⊕1（偶数个1校验码为1）</li><li>偶校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1（奇数个1校验码为1）</li></ul></li><li>数据输出<ul><li>奇校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1⊕1</li><li>偶校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1</li></ul></li><li>检错： S&#x3D;𝐶′′⊕𝐶′<ul><li>若S ≠ 1：出错，数量为奇数</li><li>若S &#x3D; 0：正确</li></ul></li></ul><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><ul><li><p>将数据分成几组 对每一组都使用奇偶校验码进行检错</p></li><li><p>过程：</p><ul><li><p>将M位数据分为K组</p><ul><li><p>2^K &gt;&#x3D; M + K + 1</p></li><li><p>数据错：M；校验码错：K；无错：1</p></li><li><p>分组方法：</p><p><img src="image-20231205160431994.png" alt="image-20231205160431994.png"></p><ol><li>插入位置：原数据2的指数倍（1，2，4，8……）</li><li>校验码Ci等于所有对应故障字号低i位为1的数据位异或（例：C2 &#x3D; D1 ⊕ D3 ⊕ D4 ⊕ D6 ⊕ D7）</li></ol></li></ul></li><li><p>数据输入：为数据D中每组生成1位校验码，合并得到K位校验码C</p></li><li><p>数据输出：为数据 𝐷′中 每组生成1位校验码，合并得到新的 𝐾位校验码 𝐶′′</p></li><li><p>检错：将校验码 𝐶′′和取出的校验码 C’ 按位进行异或，生成𝐾位故障字</p><ul><li>故障字含两个及以上1：对应数据位错</li><li>故障字含一个1：校验码错，忽略</li><li>故障字全0：正确</li></ul></li></ul></li></ul><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><ul><li><p>适用于以流格式存储和传输大量数据</p></li><li><p>假设数据有M位，左移数据<strong>K</strong>位（右侧补0），并用<strong>K+1</strong>位生成多项式除它（模2运算）</p></li><li><p>K位余数为校验码，若无余数则正确</p><p><img src="image-20231205162055616.png" alt="image-20231205162055616.png"></p></li></ul><h2 id="第五讲：整数运算"><a href="#第五讲：整数运算" class="headerlink" title="第五讲：整数运算"></a>第五讲：整数运算</h2><h3 id="加法（减法）"><a href="#加法（减法）" class="headerlink" title="加法（减法）"></a>加法（减法）</h3><ul><li><p>串行进位加法器</p><p><img src="image-20231205162812144.png" alt="image-20231205162812144.png"></p><ul><li><p>延迟：</p><ul><li>Cn: 2n ty</li><li>Sn:（2n + 1）ty</li></ul></li></ul></li><li><p>全先行进位加法器（CLA）：比串行快，缺点为复杂</p></li><li><p>部分先行进位加法器：取多个CLA串联，取得平衡</p></li><li><p>减法：将C0置为1</p></li><li><p>加法溢出判断</p><ul><li>𝑋𝑛&#x3D;𝑌𝑛且𝑆𝑛≠𝑋𝑛,𝑌𝑛: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D; [𝑋𝑛 &amp; 𝑌𝑛 &amp; ( ~ 𝑆𝑛 ) ] | [ (~ 𝑋𝑛 ) &amp; ( ~ 𝑌𝑛 ) &amp; 𝑆𝑛 ]</li><li>𝐶𝑛≠𝐶𝑛−1: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D;𝐶𝑛⊕𝐶𝑛−1</li><li>减法同理</li></ul></li></ul><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>计算机乘法与手算不同：</p><p><img src="image-20231205165157005.png" alt="image-20231205165157005.png"></p><ul><li>每步都计算部分积求和结果</li><li>右移部分积，而不是左移</li><li>若Yi（当前乘的位）为0，直接移位</li></ul></li><li><p>布斯算法</p><p><img src="image-20231205165944658.png" alt="image-20231205165944658.png"></p><ul><li>增加Y0 &#x3D; 0</li><li>根据Yi - Yi+1 决定是否增加 X , -X , +0</li><li>右移部分积（移前第一位为0前面补0，反之补1）</li><li>重复上两步n次</li></ul></li></ul><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul><li><p>判断是否够减</p><p><img src="image-20231205203705216.png" alt="image-20231205203705216.png"></p></li><li><p>恢复余数除法过程</p><ul><li><p>通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄存器中</p></li><li><p>将余数和商左移，判断是否够减</p><ul><li>如果“够”，则做减法（同号）或者加法（异号），并上商为1</li><li>如果“不够”，则上商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>如果除数和被除数不同号，则将商替换为其相反数</p><p><img src="image-20231205204154289.png" alt="image-20231205204154289.png"></p></li></ul></li><li><p>不恢复余数除法过程</p><ul><li><p>思路：如果余数 𝑅𝑖足够大，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；如果余数 𝑅𝑖不够大，𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌−𝑌&#x3D;2𝑅𝑖+𝑌</p></li><li><p>如果除数和被除数符号相同，则做减法；否则，做加法</p><ul><li>如果余数和除数符号相同，则商𝑄𝑛&#x3D;1；否则， 𝑄𝑛&#x3D;0</li></ul></li><li><p>如果余数和除数符号相同，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；否则， 𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌</p><ul><li>如果新的余数和除数符号相同，使商为 1 ；否则，使商为 0</li></ul></li><li><p>重复以上步骤</p></li><li><p>将商左移一位，若商为负，商加1</p></li><li><p>若余数与被除数符号不同修正余数：</p><ul><li><p>若被除数和除数符号相同，最后余数加除数；否则，最后余数减除数</p><p><img src="image-20231205205029238.png" alt="image-20231205205029238.png"></p></li></ul></li></ul></li></ul><h2 id="第六讲：浮点数运算"><a href="#第六讲：浮点数运算" class="headerlink" title="第六讲：浮点数运算"></a>第六讲：浮点数运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><ul><li><p>步骤</p><ul><li>检查是否为0</li><li>对齐</li><li>加减操作</li><li>规格化</li></ul><p><img src="image-20231206162424022.png" alt="image-20231206162424022.png"></p></li><li><p>加法</p><ul><li>若最高位有进位，则<strong>溢出</strong></li><li>符号与被加数相同</li></ul></li><li><p>减法</p><ul><li>若最高位有进位，正确（符号与被减数相同）</li><li>若最高位无进位，须计算结果补码（符号与被减数不同）</li></ul></li><li><p>对阶</p><ul><li>先计算ΔE &#x3D; Ex - Ey（均为补码）</li><li>若ΔE &lt; 0则Ex小，反之Ey小</li><li>对小的那个进行右移操作，右移过程中移出的位需保留用于尾数运算</li></ul></li><li><p>尾数加减</p><ul><li>隐藏位需加入运算</li></ul></li><li><p>规格化</p><ul><li>结果一：1.bb……b + 1.bb……b &#x3D; ±1b.bb……b<ul><li>右规：尾数右移一位；阶码加一</li><li>若阶码为127，加一后发生上溢</li><li>最后一位移出要考虑<strong>舍入</strong></li></ul></li><li>结果二：1.bb……b - 1.bb……b &#x3D; ±0.00…01b…b<ul><li>左规：尾数不断左移，阶码减一，直到最前面的1移到小数点前</li><li>若此过程中阶码小于0，发生下溢</li></ul></li></ul></li><li><p>舍入处理</p><ul><li>就近舍入：结果被舍入成最近的可表示的数</li><li>朝+∞舍入：结果朝正无穷大方向向上舍入</li><li>朝-∞舍入：结果朝负无穷大方向向下舍入</li><li>朝 0 舍入：结果朝 0 舍入</li></ul></li><li><p>溢出判断</p><ul><li>上溢：右规</li><li>下溢：左规</li></ul></li></ul><h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><ul><li><p>过程</p><ul><li>尾数相乘，指数相加</li><li>尾数规格化</li><li>舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相乘，指数相加</p><ul><li>计算时将隐藏位1还原</li><li>乘积符号位为操作数符号位异或结果</li><li>指数：e &#x3D; e1 + e2 - 127</li></ul></li><li><p>尾数规格化</p><ul><li>尾数小数点前有三种：10、11、01（不用规格化）</li><li>10&#x2F;11:右规，位数右移一位，阶码加一</li><li>右规需要考虑溢出（与加法相同）</li></ul></li><li><p>尾数舍入</p><ul><li>对右规后的2n - 2位进行舍入</li><li>规则与加法一样</li></ul></li><li><p>溢出判断</p><ul><li>指数相加：上溢&#x2F;下溢</li><li>舍入：上溢</li><li>右规：上溢</li></ul></li></ul><h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ul><li><p>过程</p><ul><li>尾数相除，阶相减</li><li>尾数规格化</li><li>尾数舍入处理</li><li>溢出判断</li></ul></li><li><p>尾数相除，阶相减</p><ul><li>符号位为原操作数异或结果</li><li>阶码e &#x3D; e1 - e2 + 127</li><li>尾数还原隐藏位1后作为无符号整数相除</li></ul></li><li><p>尾数规格化</p><ul><li>结果范围：0.5~2</li><li>若第一位为0，小数点右边第一位必为1</li><li>若第一位为0，进行左规，尾数左移一位，阶码减一</li><li>左移时判断下溢</li></ul></li><li><p>尾数舍入</p><ul><li>与加减相同</li></ul></li><li><p>溢出判断</p><ul><li>左规：下溢</li><li>舍入：上溢</li><li>指数相减：上溢&#x2F;下溢</li></ul></li></ul><h2 id="第八讲：内部存储器"><a href="#第八讲：内部存储器" class="headerlink" title="第八讲：内部存储器"></a>第八讲：内部存储器</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li>地址：单元唯一标识符</li><li>地址空间：可标识单元总数</li><li>寻址能力：存储在每个单元中信息位数</li><li>位元：半导体存储器的基本元件，用于存储1位数据</li></ul><h3 id="RAM（随机存取存储器）"><a href="#RAM（随机存取存储器）" class="headerlink" title="RAM（随机存取存储器）"></a>RAM（随机存取存储器）</h3><ul><li>特点<ul><li>可快速进行读写操作</li><li>易失</li></ul></li><li>DRAM<ul><li>在电容器上用电容充电的方式存储数据</li><li>需要周期地充电刷新以维护数据存储</li></ul></li><li>SRAM<ul><li>使用传统触发器、逻辑门配置来存储二进制值</li><li>有电源就能一直保持</li></ul></li><li>两者对比<ul><li>DRAM比SRAM具有更简单、更小的位元，但要求能支持刷新的电路</li><li>DRAM比相应的SRAM密度更高，价格更低</li><li>SRAM通常比DRAM快</li><li>DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高速缓存（Cache），DRAM用于主存</li></ul></li><li>SDRAM<ul><li>传统DRAM与处理器异步，及CPU需要等待DRAM内部存取数据操作</li><li>SDRAM与处理器同步时钟信号</li></ul></li><li>DDR SDRAM<ul><li>每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在<br>下降沿</li></ul></li></ul><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><ul><li>特点<ul><li>非易失</li><li>只读，一般不能写入</li><li>随机存取（与RAM相同）</li></ul></li><li>PROM（可编程ROM）<ul><li>非易失</li><li>只能写入一次</li><li>通过电信号写入</li></ul></li></ul><h3 id="主要进行读操作的存储器"><a href="#主要进行读操作的存储器" class="headerlink" title="主要进行读操作的存储器"></a>主要进行读操作的存储器</h3><ul><li>EPROM<ul><li>光擦除：在写操作前将封装芯片暴露在紫外线下，需要20分钟</li><li>电写入</li><li>比PROM贵</li></ul></li><li>EEPROM（电可擦除可编程“只读”存储器）<ul><li>可以随时写入而不删除之前的内容</li><li>只更新寻址到的一个或多个字节</li><li>写操作每字节需要几百微秒</li><li>比EPROM更贵，且密度低，支持小容量芯片</li></ul></li><li>Flash Memory（快闪存储器）<ul><li>电可擦除：与EEPROM相同，优于EPROM</li><li>擦除时间为几秒：优于EPROM，不如EEPROM</li><li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM</li><li>达到与EPROM相同的密度：优于EEPROM</li><li>价格介于EPROM和EEPROM之间</li></ul></li></ul><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul><li><p>寻址单元（Addressable unit）：由若干相同地址的位元组成（一个存储单元）</p></li><li><p>寻址模式</p><ul><li>字节（常用）Byte</li><li>字Word</li></ul></li><li><p>存储阵列（Memory Array）：由大量寻址单元组成</p></li><li><p>地址译码器</p><p><img src="image-20231208194708017.png" alt="image-20231208194708017.png"></p><ul><li>一个n位译码器有2^n种输出</li><li>当所有n个寻址位都满足条件时，该输出为1</li><li>任何时候，只有一个输出是1其他的都是0</li></ul></li></ul><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul><li>集中式刷新：停止读写，刷新所有行，刷新过程中不能读写<ul><li>芯片刷新按每块芯片每行刷新：先算每块芯片是多少乘多少，得到有多少行，即为刷新次数</li></ul></li><li>分散式刷新：在每个存储周期中，当读写操作完成时进行刷新</li><li>异步刷新：每一行各自以64 ms间隔刷新</li></ul><h3 id="从位元到主存的架构"><a href="#从位元到主存的架构" class="headerlink" title="从位元到主存的架构"></a>从位元到主存的架构</h3><ul><li><img src="image-20231208195217394.png" alt="image-20231208195217394.png"></li><li>位扩展：地址线不变，数据线增加：使用8块 4K * 1bit的芯片组成 4K * 8bit的存储器</li><li>字扩展：地址线增加，数据线不变：使用4个16K * 8bit 的芯片组成64K * 8bit的存储器</li><li>字、位同时扩展：地址线增加，数据线增加：使用8个16K * 4bit 的芯片组成64K * 8bit的存储器</li><li>位元-&gt;寻址单元-&gt;存储阵列-&gt;芯片-&gt;模块组织-&gt;主存</li><li>DRAM与SRAM地址线与数据线计算<ul><li>SRAM : log2存储单元数量</li><li>DRAM : log2存储单元数量 &#x2F; 2（使用了地址复用技术）</li><li>数据线：该芯片一个存储单元有几位就几根</li></ul></li></ul><h2 id="第九讲：Cache"><a href="#第九讲：Cache" class="headerlink" title="第九讲：Cache"></a>第九讲：Cache</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li><p>检查：检查该字是否在Cache中</p><ul><li>命中：如果在cache中，则把这个字传送给 CPU</li><li>未命中：如果不在cache中 , 则将主存中包含这个字固定大小的块读入cache中，然后再从cache传送该字 给CPU</li></ul></li><li><p>判断是否命中</p><ul><li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li></ul></li><li><p>程序访问的局部性原理</p><ul><li>时间局部性 ：在相对较短的时间周期内重复访问特定的信息，也就是访问相同位置的信息</li><li>空间局部性 ：在相对较短的时间周期内访问相邻存储位置的数据</li></ul></li><li><p>平均访问时间</p><ul><li>注意点：即使未命中也需存取Cache</li></ul><p><img src="image-20231209093818319.png" alt="image-20231209093818319.png"></p><p><img src="image-20231231100740150.png" alt="image-20231231100740150.png"></p></li></ul><h3 id="Cache的设计"><a href="#Cache的设计" class="headerlink" title="Cache的设计"></a>Cache的设计</h3><ul><li>Cache行的构成<ul><li>标记 + 有效位 + (脏位) + 替换算法控制位 + 数据部分</li></ul></li><li>映射<ul><li>直接映射<ul><li>将主存中的每个块映射到一个固定可用的cache行中</li><li>假设i是cache行号，j是主存储器的块号，C是 cache 的行数，i &#x3D; j % C</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2𝐶位标记位，第二部分为𝑙𝑜𝑔2𝐶位Cache行号，第三部分为块内地址（位数由块大小决定）</li></ul></li><li>(全)关联映射<ul><li>一个块可以装入Cache内任意一行</li><li>主存地址分为标记和块内地址</li></ul></li><li>组关联映射<ul><li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行</li><li>组号 &#x3D; 块号 % 组数</li><li>K-路组关联：K &#x3D; Cache行数&#x2F;组数</li><li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2S位标记位，第二部分为𝑙𝑜𝑔2S位Cache组号，第三部分为块内地址（位数由块大小决定）</li><li>如果 𝐾&#x3D;1，组关联映射等同于直接映射</li><li>如果 𝐾&#x3D;𝐶，组关联映射等同于关联映射</li></ul></li><li>关联度：一个主存块映射到cache中可能存放的位置个数<ul><li>直接映射：1</li><li>关联映射：C</li><li>组关联映射：K</li><li>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小</li></ul></li></ul></li><li>替换算法<ul><li>最近最少使用算法LRU<ul><li>策略：替换掉在cache中最长时间未被访问的数据块</li></ul></li><li>先进先出算法FIFO<ul><li>策略：替换掉在Cache中停留时间最长的块</li></ul></li><li>最不经常使用算法LFU<ul><li>策略：替换掉cache中被访问次数最少的数据块</li></ul></li><li>随机替换算法</li></ul></li><li>写策略<ul><li>写直达<ul><li>所有写操作都同时对cache和主存进行</li><li>确保主存中的数据总是和cache中的数据一致，总是最新的</li><li>产生大量的主存访问，减慢写操作</li></ul></li><li>写回法<ul><li>先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存</li><li>利用脏位</li><li>减少了访问主存的次数，但数据不一定最新</li></ul></li></ul></li><li>多级Cache<ul><li>当L1未命中时减少处理器对总线上DRAM或ROM的访问</li><li>使用单独的数据路径代替系统总线在L2缓存和处理器之间传输数据部分处理器将L2 cache结合到处理器芯片上</li></ul></li></ul><h2 id="第十讲：外部存储器"><a href="#第十讲：外部存储器" class="headerlink" title="第十讲：外部存储器"></a>第十讲：外部存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>特点<ul><li>非易失</li><li>用于存储不经常使用的、数据量较大的信息</li></ul></li><li>类型<ul><li>磁盘存储器</li><li>光存储器</li><li>磁带</li><li>U盘、固态硬盘</li></ul></li></ul><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><ul><li><p>磁盘是由涂有可磁化材料的非磁性材料 （基材）构成的圆形盘片</p></li><li><p>玻璃基材优势</p><p><img src="image-20231209100435594.png" alt="image-20231209100435594.png"></p></li><li><p>结构</p><p><img src="image-20231209100647883.png" alt="image-20231209100647883.png"></p><ul><li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动</li><li>在任何时候，所有磁头都位于距磁盘中心等距离的磁道上</li></ul></li><li><p>磁头：对盘片进行读写操作的装置</p><ul><li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li><li>磁头越窄，离盘片的距离就越近（飞行高度）</li><li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li><li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li><li>现代磁盘采用双磁头：读磁头和写磁头</li></ul></li><li><p>读写机制</p><ul><li>读：读取磁头是由一个部分屏蔽的磁阻MR敏感器组成其电阻取决于在其下移动的介质的磁化方向，通过电流后产生的电压指示其电阻</li><li>写：电流脉冲被发送到写入磁头，变化的电流激发出磁场，变化的电流激发出磁场</li></ul></li><li><p>数据组织结构</p><p><img src="image-20231209101418029.png" alt="image-20231209101418029.png"></p><ul><li>磁道：盘片上的数据组织呈现为一组同心圆环，称为磁道track</li><li>数据以扇区（sector）的形式传输到磁盘或从传出磁盘：扇区默认512B</li><li>相邻磁道之间有 间隙，相邻的扇区之间也留有间隙</li><li>所有盘片上处于相同的相对位置的一组磁道被称为柱面</li></ul></li><li><p>访问时间</p><ul><li><p>寻道时间：磁头定位到所需移动到的磁道所花费的时间</p></li><li><p>旋转延迟：等待响应扇区的起始处到达磁头所需的时间，<strong>通常为旋转半圈时间</strong></p></li><li><p>传送时间：数据传输所需的时间</p></li><li><p><img src="image-20231209101754880.png" alt="image-20231209101754880.png"></p><img src="计组整理.assets/image-20231209101819663.png" alt="image-20231209101819663" style="zoom:50%;" /><p><img src="image-20231209101819663.png" alt="image-20231209101819663.png"></p></li></ul></li><li><p>磁头寻道算法</p><ul><li>先来先服务FCFS<ul><li>按照请求访问磁盘的先后次序进行处理</li></ul></li><li>最短寻道时间优先SSTF<ul><li>优先处理起始位置与当前磁头位置最接近的读写任务</li></ul></li><li>扫描&#x2F;电梯（SCAN）<ul><li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li></ul></li><li>循环扫描C-SCAN<ul><li>只有磁头朝某方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，<strong>返回途中不做任何处理</strong></li></ul></li><li>LOOK<ul><li>SCAN 算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li></ul></li><li>C-LOOK<ul><li>C-SCAN 算法的升级，只要磁头移动方向上不再有请求，就立即让磁头返回起点</li></ul></li></ul></li></ul><h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><ul><li><p>分类</p><p><img src="image-20231209102434412.png" alt="image-20231209102434412.png"></p></li><li><p>CD和CD-ROM</p><ul><li>CD和CD-ROM采用类似的技术，但CD-ROM更加耐用且有纠错功能</li><li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD或CD-ROM处读取信息</li><li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同</li></ul></li><li><p>高清晰光盘</p><ul><li>通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li></ul></li></ul><h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><ul><li>介质是柔韧的聚酯薄膜带，外涂磁性材料</li><li>顺序读取</li></ul><h3 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h3><ul><li>U盘<ul><li>采用了快闪存储器，属于非易失性半导体存储器</li><li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li></ul></li><li>固态硬盘<ul><li>与 U 盘没有本质区别：容量更大，存储性能更好</li></ul></li></ul><h2 id="第十一讲：冗余磁盘阵列"><a href="#第十一讲：冗余磁盘阵列" class="headerlink" title="第十一讲：冗余磁盘阵列"></a>第十一讲：冗余磁盘阵列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>基本思想<ul><li>将多个独立操作的磁盘按某种方式组织成磁盘阵列 以增加容量</li><li>将数据存储在多个盘体上 通过这些盘并行工作来提高数据传输率</li><li>采用数据冗余来进行错误恢复以提高系统可靠性</li></ul></li><li><img src="image-20231214205505393.png" alt="image-20231214205505393.png"></li></ul><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p><img src="image-20231214205749592.png" alt="image-20231214205749592.png"></p><ul><li>数据以条带的形式在可用的磁盘上分布</li><li>不采用冗余来改善性能（不是 RAID 家族中的真正成员）</li><li>用途：1.高数据传输率 2.高速响应I&#x2F;O请求</li></ul><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p><img src="image-20231214210100316.png" alt="image-20231214210100316.png"></p><ul><li>采用了数据条带</li><li>采用简单地备份所有数据的方法来实现冗余</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li><li>两组硬盘都可以读取，读速度快</li><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li></ul><h3 id="RAID-2-3"><a href="#RAID-2-3" class="headerlink" title="RAID 2 &amp; 3"></a>RAID 2 &amp; 3</h3><ul><li><p>RAID 2</p><p><img src="image-20231214210342894.png" alt="image-20231214210342894.png"></p><ul><li>采用并行存取技术</li><li>采用<strong>非常小</strong>的数据条带</li><li>所有磁盘都参与每个I&#x2F;O请求的执行</li><li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li><li>对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li></ul></li><li><p>RAID 3</p><p><img src="image-20231214210503149.png" alt="image-20231214210503149.png"></p><ul><li>与RAID 2 不同点：对所有数据盘上同一位置的数据计算奇偶校验码</li></ul></li></ul><h3 id="RAID-4-5"><a href="#RAID-4-5" class="headerlink" title="RAID 4 &amp; 5"></a>RAID 4 &amp; 5</h3><ul><li><p>RAID 4</p><p><img src="image-20231214220218541.png" alt="image-20231214220218541.png"></p><ul><li>采用独立存取技术：每个磁盘成员的操作是独立的，各个I&#x2F;O请求能够并行处理</li><li>采用相对较大的数据条带</li><li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li><li>每次写操作都需要修改校验位，I&#x2F;O请求较大时有优势（可用新数据计算）</li></ul></li><li><p>RAID 5</p><p><img src="image-20231214220451002.png" alt="image-20231214220451002.png"></p><ul><li>与RAID 4组织方式相似</li><li>在所有磁盘上都分布了奇偶校验条带</li></ul></li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><img src="image-20231214220620920.png" alt="image-20231214220620920.png"></p><ul><li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li><li>提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才会造成数据丢失</li><li>写损失：每次写都要影响两个校验块</li></ul><h2 id="第十二讲：虚拟存储器"><a href="#第十二讲：虚拟存储器" class="headerlink" title="第十二讲：虚拟存储器"></a>第十二讲：虚拟存储器</h2><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul><li>分区<ul><li>分区方式将主存分为两大区域</li><li>系统区：固定的地址范围内，存放操作系统</li><li>用户区：存放所有用户程序</li><li>简单固定分区：用户区划分成长度不等的固定长的分区，当一个任务调入主存时，分配一个可用的、能容纳它的最小的分区</li><li>可变长分区：用户区按每个任务所需要的内存大小进行分配，会导致碎片化</li></ul></li><li>分页<ul><li>把主存分成固定长且比较小的存储块，称为页框；每个任务也被划分成固定长的程序块，称为页</li><li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li><li>逻辑地址：指令中的地址</li><li>物理地址：实际主存地址</li></ul></li></ul><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul><li><p>基本思想</p><ul><li>仅将当前需要的的页面调入主存</li><li>通过硬件将逻辑地址转换为物理地址</li><li>未命中时在主存和硬盘之间交换信息</li></ul></li><li><p>分页式虚拟存储器</p><p><img src="image-20231224164127892.png" alt="image-20231224164127892.png"></p><ul><li>主存储器和虚拟地址空间都被划分为大小相等的页面</li><li>页表：页表中包含了所有虚拟页的信息,包括虚拟页的存放位置 、装入位valid、修改位dirty、存取权限位、<strong>物理地址</strong>等等，存储在主存中</li><li>地址 &#x3D; 页号 + 页内偏移量</li><li>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li></ul></li><li><p>快表</p><ul><li>页表的使用增加了主存的访问次数，为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li><li>主存中的页表相应地称之为“慢表”</li></ul></li><li><p>CPU访存过程</p><ul><li><img src="image-20231224164538671.png" alt="image-20231224164538671.png"></li><li><img src="image-20231224165337226.png" alt="image-20231224165337226.png"></li><li><img src="image-20231224165513175.png" alt="image-20231224165513175.png"></li></ul></li><li><p>分段式虚拟存储器</p><ul><li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li><li>虚拟地址：段号 + 段内偏移量</li><li>与分页式虚拟存储器相比：分页式简单，但一个数据或一条指令可能会分跨在两个页面；分段式段的分界与程序的自然分界相对应，易于管理，但段大小不固定</li></ul></li><li><p>段页式虚拟存储器</p><ul><li>将程序和数据分段，段内再进行分页</li><li>每个段都有一个页表</li><li>虚拟地址 &#x3D; 段号 + 页号 + 页内偏移量</li></ul></li></ul><h2 id="第十三讲：指令系统"><a href="#第十三讲：指令系统" class="headerlink" title="第十三讲：指令系统"></a>第十三讲：指令系统</h2><h3 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h3><ul><li><p>指令要素</p><ul><li>操作码：指定将要完成的操作</li><li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li><li>结果操作数引用：操作可能会产生一个结果</li><li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li></ul></li><li><p>操作码</p><ul><li>指令类型：数据传送、算术运算、逻辑运算、转换、输入&#x2F;输出、系统控制、控制转移</li><li>数据传送：指明源和目标操作数的位置、将要传送数据的长度、寻址方式</li></ul></li><li><p>操作数</p><ul><li>大端法和小端法：大端为高位存在小地址，低位存在大地址，小端与之相反</li><li>寻址方式<ul><li>立即寻址：操作数实际出现在指令中</li><li>直接寻址：地址字段含有操作数的有效地址</li><li>间接寻址：地址字段指示一个存储器字地址 , 而此地址出保存有操作数的全长度地址</li><li>寄存器寻址：地址字段指示的是寄存器</li><li>寄存器间接寻址：地址字段指示的是寄存器，寄存器中存操作数地址</li><li>偏移寻址：EA &#x3D; (R) + A，即地址 &#x3D; 偏移量 + 地址，分为三种：相对寻址（R为PC）、基址寄存器寻址(R对应寄存器中为基址，A为偏移量)、变址寻址（A为某主存地址，R中为对于该地址正的偏移量）</li><li>栈寻址：方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li></ul></li></ul></li><li><p>指令设计原则</p><ul><li>指令尽量短</li><li>有足够的操作码位数：要为操作类型不断增加预留</li><li>操作码的编码必须有唯一的解释</li><li>指令长度是字节的整数倍</li><li>合理选择地址字段的个数</li><li>指令尽量规整：简化硬件的实现</li></ul></li><li><p>题型：计算指令系统需要多少位</p><p><img src="image-20240101163022494.png" alt="image-20240101163022494.png"></p><ul><li>先算地址多的，多出来没用的操作码n个给地址少的作为操作码前几位</li><li>地址少的用多出来的地址位k和n算出可用操作码数（2^k * n），与需要的操作码数量对比，如果足够就结束，不够就要增加一位</li><li>所有种类指令都验证完后将位数向上取整变成8的整数倍</li></ul></li></ul><h2 id="第十四讲：指令流水线"><a href="#第十四讲：指令流水线" class="headerlink" title="第十四讲：指令流水线"></a>第十四讲：指令流水线</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><p>指令周期 ：处理单个指令的过程</p><p><img src="image-20231224195348224.png" alt="image-20231224195348224.png"></p><p><img src="image-20231224195406263.png" alt="image-20231224195406263.png"></p></li><li><p>间址周期：把间接地址的读取看成是一个额外的指令子周期</p></li><li><p>CPU寄存器</p><ul><li>1个存储地址寄存器MAR</li><li>1个存储缓冲寄存器MBR&#x2F; 存储数据寄存器MDR</li><li>1个程序计数器PC</li><li>1个指令寄存器IR</li></ul></li><li><p>指令周期数据流</p><ul><li>取指周期<ul><li>控制器先发出控制信号告知存储器，PC使用地址总线传输待取指令地址，存储器得到地址</li><li>存储器将指令数据传入数据总线，存储缓冲寄存器MBR从数据线上得到指令，再传给IR</li><li>控制器告知PC取指完成，使PC中值对应 + 4</li></ul></li><li>间址周期<ul><li>MBR第一次取回的是地址，将它传入MAR再进行一次读取</li></ul></li><li>中断周期<ul><li>终端前要将所有寄存器状态存入存储器</li></ul></li></ul></li></ul><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ul><li><p>指令流水线 ：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成</p></li><li><p>六阶段方法：</p><p><img src="image-20231224200754205.png" alt="image-20231224200754205.png"></p><ul><li>取指令（ Fetch instruction FI ）：读下一条预期的指令到缓冲器</li><li>译码指令（ Decode instruction DI ）：确定操作码和操作数指定符</li><li>计算操作数（ Calculate operands CO ）：计算每个源操作数的有效地址</li><li>取操作数（ Fetch operands FO ）：从存储器取出每个操作数，寄存器中的操作数不需要取</li><li>执行指令（ Execute instruction EI ）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li><li>写操作数（ Write operand WO ）：将结果存入存储器</li><li>问题：不是所有指令都包含6个阶段；不是所有的阶段都能并行完成；若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</li><li>条件转移指令会使若干周期无效</li></ul></li><li><p><img src="image-20231224201109097.png" alt="image-20231224201109097.png"></p></li></ul><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ul><li>结构冒险<ul><li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源</li><li>解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源</li></ul></li><li>数据冒险<ul><li>原因：未生成指令所需要的数据</li><li>解决方案 1 ：插入 nop 指令</li><li>解决方案 2 ：插入 bubble</li><li>解决方案 3 ：转发 forwarding &#x2F; 旁路 bypassing：无需等待数据存入对应寄存器，而是将需要的其他指令执行结果直接传送到对应位置</li><li>解决方案 4 ：交换指令顺序</li></ul></li><li>控制冒险<ul><li>原因：指令的执行顺序被更改（转移、中断、异常、调用&#x2F;返回）</li><li>解决：取多条指令、分支预测</li></ul></li></ul><h2 id="第十五讲：控制器"><a href="#第十五讲：控制器" class="headerlink" title="第十五讲：控制器"></a>第十五讲：控制器</h2><h3 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h3><p><img src="image-20240101162745149.png" alt="image-20240101162745149.png"></p><ul><li>用户可见寄存器<ul><li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li><li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回</li><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：仅可用于保持数据而不能用于操作数地址的计算</li><li>地址寄存器：可以是自身有某些通用性，或是专用于某种具体的寻址方式</li><li>条件码寄存器&#x2F;标志寄存器：CPU硬件设置这些条件位作为操作的结果</li></ul></li><li>控制和状态寄存器<ul><li>由控制器来控制 CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li><li>大多数控制和状态寄存器在大多数机器上是用户不可见的</li><li>程序计数器PC（Program counter）：通常在每次取指令之后， PC 的内容即被CPU更改，因此总指向将被执行的下一条指令（用户可见）</li><li>指令寄存器IR（Instruction register）：存有最近取来的指令，在其中分析操作码和操作数</li><li>存储器地址寄存器MAR（Memory address register）：直接与地址总线相连，存有存储器位置的地址</li><li>存储器缓冲寄存器MBR（Memory buffer register）：直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR交换数据</li><li>ALU 可对MBR和用户可见寄存器直接存取</li></ul></li><li>程序状态字<ul><li>一个或一组包含状态信息的寄存器 包含条件码加上其他状态信息</li><li>符号、零、进位、等于、溢出、中断禁止&#x2F;允许、监管</li></ul></li></ul><h3 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h3><ul><li><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令，每个指令周期又可以看作是由几个更小的子周期组成（取指、间址、执行、中断），每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些步骤称为微操作</p></li><li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p><p><img src="image-20231225192443296.png" alt="image-20231225192443296.png"></p><ul><li>事件的流动顺序必须是恰当的</li><li>必须避免冲突</li><li>满足上述条件下 所用的时间单位尽可能少</li></ul></li><li><p>间址周期：如果指令采用间接寻址，则在指令执行前有一个间址周期</p><p><img src="image-20231225192951356.png" alt="image-20231225192951356.png"></p></li><li><p>执行周期：对于不同的操作码，会出现不同的微操作序列</p><img src="计组整理.assets/image-20231225193031697.png" alt="image-20231225193031697" style="zoom: 50%;" /><p><img src="image-20231225193031697.png" alt="image-20231225193031697.png"></p></li><li><p>中断周期：在完成执行周期时，要确定是否有允许的中断产生，如果有，则出现一个中断周期</p></li><li><p>指令周期代码：假设一个 2 位的ICC寄存器，明确 CPU 处于指令周期哪个阶段</p><p><img src="image-20231225193941116.png" alt="image-20231225193941116.png"></p><ul><li>00 ：取指</li><li>01 ：间址</li><li>10 ：执行</li><li>11 ：中断</li></ul></li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li><p>CPU内部总线</p><ul><li>ALU和寄存器都连接到CPU内部总线上</li><li>内部总线和寄存器之间有门和控制信号</li></ul></li><li><p>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</p></li><li><p>CPU需要完成的微操作：</p><ul><li>在寄存器之间传送数据</li><li>将数据由寄存器传送到外部接口（如系统总线）</li><li>将数据由外部接口传送到寄存器</li><li>将寄存器作为输入和输出，完成算术和逻辑运算</li></ul></li><li><p>控制器的两个基本任务：定序、执行</p></li><li><p>控制器的输入：</p><ul><li>指令寄存器：当前指令的寻址方式和操作码</li><li>标志：确定CPU的状态和前一个ALU操作的结果</li><li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li><li>来自控制总线的控制信号：向控制器提供控制信号（如中断请求）</li></ul></li><li><p>控制器的输出：CPU内的控制信号、到控制总线的控制信号</p></li><li><p>控制器实现</p><ul><li>硬布线实现：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，<br>即控制信号</li><li>微程序实现：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号</li></ul></li><li><p>硬布线实现</p><ul><li><p>硬布线控制器是将控制部件做成产生专门固定信号的逻辑电路，产生各种控制信号，因而又称为组合逻辑控制器。微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。</p></li><li><p>控制器输入：标志和控制总线信号、指令寄存器、时钟</p></li><li><p>控制器逻辑：为每个输出的控制信号设计一个关于控制器输入的布尔表达式</p></li></ul></li><li><p>微程序实现</p><ul><li><p>基本思路：</p><ul><li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li><li>构造一个<strong>控制字</strong>，每位代表一根控制线，这样每个微操作能用控制字中的不同的 0 和 1 的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li></ul></li><li><p>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址</p></li><li><p>任务：定序和执行</p><p><img src="image-20231225205024319.png" alt="image-20231225205024319.png"></p></li><li><p>微指令编码方式</p><ul><li><p>直接控制方式：在微指令的控制字段里对不同的微命令各自设置一个数位来表示发出与否（”0&#x2F;1”）</p></li><li><p>字段直接编译法：对控制字段进行划分，得到多个不同的字段，这些字段表示多个互斥的控制信号，这些微命令在同一时间只有其中的某一个微命令可以生效。</p><p><img src="image-20240101165541902.png" alt="image-20240101165541902.png"></p></li><li><p>字段间接编译法：同样是对控制字段进行划分，但是字段间接编译法在直接编译法以一个字段来表示一条微命令的基础上，辅以另一个字段来解释这个字段。这样的编译方法，可以使得指令的长度进一步减短，但微指令的并行控制能力被削弱了。</p><p><img src="image-20240101165705537.png" alt="image-20240101165705537.png"></p><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li><li><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p></li></ul></li><li><p>工作流程：</p><ul><li>为执行一条指令，定序逻辑发出一个读命令给控制存储器</li><li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li><li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息</li><li>定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存器中</li></ul></li></ul></li></ul><h2 id="第十六讲：总线"><a href="#第十六讲：总线" class="headerlink" title="第十六讲：总线"></a>第十六讲：总线</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>类型<ul><li>芯片内部总线：连接芯片内部的各个部分</li><li>系统总线：连接CPU、存储器、I&#x2F;O控制器和其他功能设备</li><li>通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</li></ul></li><li>总线结构<ul><li>数据线：在系统组件之间传输数据，数据线的数量决定了一次可以传输的数据的大小</li><li>地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向，地址线的数量决定了寻址空间的大小</li><li>控制线：控制对数据线和地址线的存取和使用</li></ul></li><li>特点<ul><li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</li><li>当总线在被使用过程中，其它设备不可以抢占</li></ul></li></ul><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ul><li><p>用途</p><ul><li>专用总线：始终只负责一项功能，或始终分配给特定的计算机组件</li><li>复用总线：将同一线路用于多种用途</li></ul></li><li><p>总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备</p><ul><li>集中式：由仲裁器或总线控制器负责分配总线使用权</li><li>分布式：每个设备都包含访问控制逻辑，各设备共同作用，分享总线</li></ul></li><li><p>链式查询</p><p><img src="image-20231227191653439.png" alt="image-20231227191653439.png"></p><ul><li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备</li><li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号</li><li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</li></ul></li><li><p>计数器查询</p><p><img src="image-20231227192026850.png" alt="image-20231227192026850.png"></p><ul><li>将总线允许线替换为设备ID线，如果总线空闲，总线仲裁器通过设备ID线发送计数</li><li>如果当前发送请求的设备ID等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为忙</li><li>通过使用不同的初始计数，可以灵活地确定设备优先级（强调优先级从1开始，强调公平性从上次使用总线的下一个设备的ID开始）</li></ul></li><li><p>独立请求</p><ul><li>每个设备都有自己的总线请求线和总线允许线，当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器，总线仲裁器决定哪个设备可以使用总线</li></ul></li><li><p>自举式</p><p><img src="image-20231227194000898.png" alt="image-20231227194000898.png"></p><ul><li>固定优先级，每个设备在其总线请求线上发送请求</li><li>每个设备自行判断自己是否在请求总线的设备中优先级最高</li></ul></li><li><p>时序</p><ul><li><p>确定每个总线事务的开始和结束时间</p></li><li><p>同步时序：事件的发生由时钟决定，所有设备共享同一个时钟</p></li><li><p>异步时序：一个事件的发生取决于前一个事件的发生</p></li><li><p><img src="image-20231227205709273.png" alt="image-20231227205709273.png"></p><p><img src="image-20231227201133777.png" alt="image-20231227201133777.png"></p></li><li><p>半同步时序：为了减少噪声的影响，在异步计时中使用时钟</p></li><li><p>分离事务：将一个总线事件分离为两个过程</p></li></ul></li><li><p>总线带宽（bus bandwidth）：总线的最大数据传输速率</p></li><li><p>数据传输速率：考虑地址传输、握手等因素</p><ul><li><p>同步总线时间：</p><ul><li>发送指令和地址到内存</li><li>内存准备数据时间（时钟周期整数倍，向上取整，例：时钟周期50 ns，230 ns -&gt; 250 ns）</li><li>将数据传输到CPU</li></ul></li><li><p>异步总线时间：</p><ul><li>步骤一握手</li><li>max{步骤2、3、4一起的时间，数据准备时间}</li><li>步骤5、6、7时间</li></ul></li><li><p>不同数据块大小：</p><p><img src="image-20231227212626052.png" alt="image-20231227212626052.png"></p><p><img src="image-20231227212641717.png" alt="image-20231227212641717.png"></p><p><img src="image-20231227212657044.png" alt="image-20231227212657044.png"></p></li><li><p>每秒总线事务数：用1s除以<strong>每个</strong>总线事务所需时间</p></li></ul></li><li><p>总线传输方式</p><ul><li>**猝发&#x2F;突发传输（Burst Transfer）：**在一次总线事务中，通过多个时钟周期连续传输一块数据，而不需要额外的地址和控制信号。这种方式可以提高数据传输的效率，因为它减少了每次传输所需的总线控制开销。</li><li><strong>DMA传输（Direct Memory Access）：</strong> DMA是一种通过专用的DMA控制器直接在主存储器和I&#x2F;O设备之间传输数据的方式，而无需CPU的直接干预。这提高了数据传输的效率。</li><li><strong>同步传输（Synchronous Transfer）：</strong> 在同步传输中，数据在一个统一的时钟信号下传输，根据时钟的边沿进行数据传送。这有助于确保数据的同步性，但要求系统中的各个部件都能保持同步。</li><li><strong>异步传输（Asynchronous Transfer）：</strong> 异步传输不依赖于统一的时钟信号，而是使用起始位和停止位来标识数据的开始和结束。异步传输通常用于短距离通信，例如串口通信。</li><li><strong>串行传输（Serial Transfer）：</strong> 串行传输是指每个时钟周期传输一个比特。虽然每个时钟周期只传输少量的数据，但串行传输通常具有较高的稳定性和较低的成本。典型：<strong>USB</strong></li><li><strong>并行传输（Parallel Transfer）：</strong> 在并行传输中，多个数据位同时在总线上传输。每个时钟周期传输多个比特，这样可以在同一时刻传输更多的数据，提高传输速率。</li></ul></li><li><p>总线层次</p><ul><li>单总线结构：CPU、存储器和I&#x2F;O模块都连接到一条系统总线</li><li>双总线结构：<ul><li>方案一：在 CPU 和存储器中间增加一个存储器总线</li><li>将系统总线分为存储器总线、 I&#x2F;O 总线 和 IOP (input&#x2F;output processor)</li></ul></li><li>多总线结构：<ul><li>方案一：增加一个本地总线（ local bus来连接CPU和cache）</li><li>方案二：将系统总线分为存储器总线、I&#x2F;O总线和DMA总线</li><li>方案三：增加一个高速I&#x2F;O总线来连接高速设备</li></ul></li></ul></li><li><p>注：60%的时间在读40%时间写直接用读写的数据传输速度加权；60%的访问为读40%访问为写需要在分母上对消耗的时钟周期加权然后重新计算数据传输速率</p><p><img src="image-20240102203024170.png" alt="image-20240102203024170.png"></p></li></ul><h2 id="第十七讲：输入输出（I-O）"><a href="#第十七讲：输入输出（I-O）" class="headerlink" title="第十七讲：输入输出（I&#x2F;O）"></a>第十七讲：输入输出（I&#x2F;O）</h2><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h3><ul><li><p>连接情况</p><ul><li>通过系统总线或中央交换器和存储器连接</li><li>通过专用数据线与一个或多个外设连接</li></ul></li><li><p>外部设备接口</p><p><img src="image-20231228163308278.png" alt="image-20231228163308278.png"></p><ul><li>I&#x2F;O模块的接口以控制 、 状态和数据信号的形式出现</li><li>与设备相关的控制逻辑控制外设的操作，以响应来自I&#x2F;O模块的命令</li><li>缓冲器用于缓存I&#x2F;O模块和外设之间传送的数据</li></ul></li><li><p>I&#x2F;O模块功能</p><ul><li>处理器通信<ul><li>命令译码：I&#x2F;O模块接收来自处理器的命令（I&#x2F;O指令），这些命令一般作为信号发送到控制总线</li><li>数据：数据是在处理器（通用寄存器组）和I&#x2F;O模块之间经由数据总线来交换的</li><li>状态报告：由于外设速度很慢 , 所以知道I&#x2F;O模块的状态很重要</li><li>地址识别：I&#x2F;O模块必须能识别它所控制的每个外设的唯一地址</li></ul></li><li>设备通信：通信内容包含命令、状态信息和数据</li><li>数据缓冲：外设的数据传送速度与存储器或处理器不同，有的快有的慢</li><li>控制和定时：处理器会非预期的与一个或几个外设进行通信</li><li>检错：检错并把差错信息报告给处理器</li></ul></li><li><p>结构</p><p><img src="image-20231228165511903.png" alt="image-20231228165511903.png"></p></li><li><p>I&#x2F;O端口和I&#x2F;O模块区别</p><ul><li>I&#x2F;O端口是计算机体系结构中的一个机制，用于通过特定地址进行I&#x2F;O访问，而I&#x2F;O模块表示连接到计算机系统的外部设备及其相关的控制电路。 I&#x2F;O模块通常包含一个或多个I&#x2F;O端口，其中每个端口对应于不同的功能或寄存器。</li></ul></li><li><p>外部接口</p><ul><li>并行接口：多根线连接I&#x2F;O模块和外设，同时传送多位数据</li><li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li></ul></li><li><p>编址方式</p><ul><li><strong>独立编址（Separate Addressing）：</strong> 在独立编址中，内存和I&#x2F;O设备拥有不同的地址空间。系统使用不同的地址范围来访问内存和I&#x2F;O设备，这意味着CPU使用不同的指令或地址范围来读写内存和I&#x2F;O设备。</li><li><strong>统一编址（Unified Addressing）：</strong> 在统一编址中，内存和I&#x2F;O设备共享相同的地址空间。系统使用相同的地址范围来访问内存和I&#x2F;O设备，使得CPU可以使用相同的指令和地址范围来读写内存和I&#x2F;O设备。</li></ul></li></ul><h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h3><ul><li><p>编程式I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</p><ul><li>当处理器在执行过程中遇到一条与I&#x2F;O操作有关的指令时，它通过发送指令到对应I&#x2F;O模块来执行这条指令</li><li>I&#x2F;O模块将执行所要求的动作，然后在I&#x2F;O状态寄存器中设置一些适当的位</li><li>I&#x2F;O不会中断处理器 因此处理器需要周期性地检查I&#x2F;O模块的状态 直到发现该操作完成</li></ul></li><li><p>中断驱动式I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令；并且当I&#x2F;O模块完成其工作后，才去中断处理器工作</p><p><img src="image-20231228171431496.png" alt="image-20231228171431496.png"></p><ul><li>处理器发送一个I&#x2F;O命令到模块，然后去处理其它有用的工作</li><li>当I&#x2F;O模块准备和处理器交换数据时，它中断处理器以请求服务</li><li>处理器执行数据传送，最后恢复它原先的处理工作</li><li>响应优先级和处理优先级<ul><li>响应优先级：中断被触发时，系统多快能够响应并开始执行相应的中断服务程序</li><li>处理优先级：在处理器已经响应中断并开始执行中断服务程序后，不同中断服务程序之间的执行顺序</li><li>过程：当中断同时来临时先按照响应优先级顺序响应中断，然后按该顺序处理，准备好当前响应优先级最高的中断所需环境后，比较处理优先级，如果有比当前中断处理优先级高的，插入该中断，完成后再回到原中断。在此过程中新的中断来了正常响应加入队列，但只在每次处理前检查队列的处理优先级</li><li>掩码字&#x2F;屏蔽字：该位为1表示可屏蔽对应的中断（自己一定可以屏蔽自己），即当前处理优先级高于该位对应中断的优先级</li></ul></li><li>设备识别方法：多条中断线、软件轮询、菊花链、独立请求</li></ul></li><li><p>直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与主存直接交换数据，而不需要处理器的干涉</p><ul><li>处理器通过发送以下信息向DMA模块发出命令：读&#x2F;写、I&#x2F;O设备地址、内存中的起始位置、字数，然后处理器继续进行其他工作</li><li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出而无需经过处理器</li><li>当传输完成时DMA模块向处理器发送一个中断信号</li><li><strong>DMA使用总线优先级高于CPU</strong></li></ul></li><li><p>DMA访问方法</p><ul><li>CPU停止法：控制简单，但影响CPU，没有充分利用内存</li><li>周期窃取：充分利用CPU和内存，及时响应I&#x2F;O请求，但每次都要申请总线，且一次只传输一个字</li><li>交替分时访问：CPU未停止或等待，DMA不请求总线</li></ul></li><li><p>查询式I&#x2F;O</p><ul><li>在轮询方式中，CPU定期地检查I&#x2F;O设备是否准备好进行数据传输。这种方式包括以下步骤：<ul><li><strong>步骤1：CPU发起请求</strong> CPU向I&#x2F;O设备发送一个请求，询问设备是否准备好进行数据传输。</li><li><strong>步骤2：等待设备准备</strong> CPU在一定的时间间隔内不断轮询（检查）设备的状态，看是否已经准备好执行请求。</li><li><strong>步骤3：数据传输</strong> 一旦I&#x2F;O设备准备好，CPU开始执行实际的数据传输。</li></ul></li><li>在此方式下，CPU全程参与数据传输，占用率为100%</li></ul></li></ul><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法整理"><a href="#数据结构与算法整理" class="headerlink" title="数据结构与算法整理"></a>数据结构与算法整理</h1><h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><ul><li>数据结构概念<ul><li>A data structure is a data object together with the relationships among the data members that compose the object</li><li>Data Structure &#x3D; {D，R}，D为数据，R为所有数据间的关系</li><li>抽象数据结构ADT：数据 + 对应操作</li></ul></li></ul><span id="more"></span><ul><li>线性结构<ul><li><img src="image-20240106150547680.png" alt="image-20240106150547680" style="zoom: 50%;" /></li></ul></li><li>算法<ul><li>an operation sequence of solving a problem</li></ul></li><li>递归<ul><li>递归的两条基本规则: (1) Base cases (2) Making progress</li><li>直接递归：函数或过程直接调用自身。</li><li>间接递归：函数或过程调用其他函数，而这些其他函数中又调用原始函数，最终形成一个递归循环。</li></ul></li><li>泛型<ul><li>泛型（Generic）是一种编程范式，它允许在编写代码时使用一种抽象的方式来操作数据类型。</li></ul></li></ul><h2 id="第二章-算法分析"><a href="#第二章-算法分析" class="headerlink" title="第二章 算法分析"></a>第二章 算法分析</h2><ul><li><p>空间复杂度</p><ul><li><p>用来衡量算法在执行过程中所需存储空间的度量。它表示算法的额外空间需求与输入规模之间的关系。</p></li><li><p>组成部分</p><ul><li>指令空间</li><li>数据空间</li><li>运行环境栈空间</li></ul></li><li><p>分类</p><ul><li>固定部分：指令、简单变量、定长复合变量、常量</li><li>可变部分：复合变量、动态分配空间、递归栈</li></ul></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">SequentialSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> [] a, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length &amp;&amp;a[i]!=x; i++) ;<br>        <span class="hljs-keyword">if</span>(i= = a.length) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据空间：12 bytes : x，i，a[i]，0，1，a.length</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">float</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> sum(a, n - <span class="hljs-number">1</span>) + a[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归栈空间：（参数 + 返回地址）* 递归深度</li></ul></li></ul></li><li><p>时间复杂度</p><ul><li><p>用来衡量算法执行时间随输入规模增长而变化的度量，描述的是随着输入规模的增大，算法的运行时间将如何增长。</p></li><li><p>最优、最差与平均复杂度：平均复杂度一般难以计算，因此多用最差和最优情况分析</p></li><li><p>计算</p><ul><li>统计基本操作的执行次数： 首先，确定算法中的基本操作，例如赋值、比较、循环迭代等。然后，统计这些基本操作的执行次数，以及它们与输入规模的关系。</li><li>忽略常数项： 在计算时间复杂度时，通常会忽略常数项，即忽略执行次数中与输入规模无关的常数因子。这是因为在大规模输入时，常数项对总体复杂度的增长影响较小。</li><li>关注主导因子： 确定算法执行步骤中占主导地位的因子，即最大影响复杂度增长的部分。通常，我们关注循环中执行次数最多的部分或递归算法的递归关系。</li></ul></li><li><p>秩排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RankSort</span> &#123;<br>    <span class="hljs-comment">// Rank the elements in the array a[0:n-1] and store ranks in the array r</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rank</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            r[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[j] &lt;= a[i]) &#123;<br>                    r[i]++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r[j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rearrange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (r[i] != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> r[i];<br>                swap(a[i], a[t]);<br>                swap(r[i], r[t]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>数据比较：n * (n - 1) &#x2F; 2</p></li><li><p>元素交换次数：2 * n（每次循环中至少有一个元素的秩被正确放置，故不超过n次）</p></li></ul></li><li><p>注意点</p><ul><li>在计算数据移动次数时，一次swap需要移动元素3次</li><li>循环里的变量初始赋值以及循环条件里的赋值也各算一次移动，当存在多重循环时需要考虑（一般只考虑循环体里的赋值）</li></ul></li></ul></li><li><p>大O表示法</p><ul><li>定义：对于一个函数 f(n)，如果存在正常数 c 和正整数 n0，使得对于所有的 n &gt; n0，都有 f(n) &lt;&#x3D; c * g(n)，其中 g(n) 是某个已知函数，那么我们就说 f(n) 的渐近上界是 O(g(n))，记作 f(n) &#x3D; O(g(n))。</li><li>Ω表示法：渐近下界</li><li>θ表示法：介于中间</li></ul></li><li><p>折半查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 如果目标值等于中间值，找到目标值</span><br>        <span class="hljs-keyword">if</span> (array[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果目标值小于中间值，在左侧继续查找</span><br>        <span class="hljs-keyword">if</span> (target &lt; array[mid]) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果目标值大于中间值，在右侧继续查找</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br>    <span class="hljs-comment">// 如果未找到目标值，返回 -1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SelectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> n; size &gt; <span class="hljs-number">1</span>; size --)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Max(a,size);<span class="hljs-comment">//寻找a[0 : size - 1]中的最大值,O(n)</span><br>swap(a[j],a[size-<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Max数据比较次数：n * (n - 1) &#x2F; 2</li><li>数据交换次数：3 * (n - 1)</li></ul></li><li><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//sort a[0:n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">1</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j &lt; i - <span class="hljs-number">1</span>, j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &gt; a[j+<span class="hljs-number">1</span>])swap(a[j],a[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据比较次数和选择排序一样</li></ul></li><li><p>插入排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j+<span class="hljs-number">1</span>]&lt;arr[j])&#123;swap(&amp;arr[j],&amp;arr[j+<span class="hljs-number">1</span>]);&#125; <br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第三章-线性表"><a href="#第三章-线性表" class="headerlink" title="第三章 线性表"></a>第三章 线性表</h2><ul><li><p>定义</p><ul><li><p>L &#x3D; (e1, e2, ···, en), size 为n，n &#x3D; 0 -&gt; 空表</p></li><li><p>操作：<img src="image-20240106173001935.png" alt="image-20240106173001935" style="zoom:50%;" /></p></li></ul></li><li><p>数组实现的线性表</p><ul><li><img src="image-20240106173658855.png" alt="image-20240106173658855" style="zoom:50%;" /></li><li>search(x) ：O(length)</li><li>remove( k,x)：O(n)</li><li>insert (x , i)：O(n)</li><li>缺点：插入和删除时间长</li></ul></li><li><p>单链表实现的线性表</p><ul><li><img src="image-20240106210937444.png" alt="image-20240106210937444" style="zoom:50%;" /></li><li>操作方法和链表一样</li></ul></li><li><p>单链表操作</p><ul><li>删除：<ul><li>若为头节点直接将head指针指向下一个节点</li><li>将下一个节点的值复制到当前节点，覆盖当前节点的值。</li><li>将当前节点的 next 指针指向下一个节点的下一个节点。</li></ul></li><li>插入<ul><li>创建一个新节点，将新节点的next指针指向目标节点的下一个节点。</li><li>将目标节点的 next指针指向新节点。</li></ul></li><li>交换<ul><li>设有abcd四个节点</li><li>先让a指向c，再让b指向d，最后再让c指向b（b有额外指针，即已知）</li></ul></li><li>单链表类<ul><li>ListNode：链表结点类</li><li>LinkedList：链表本身的类isEmpty()、makeEmpty()、zeroth()、first()、find(object x)、remove()、insert(Object x, LinkedListItr p)、findprevious(Object x)</li><li>LinkedListItr：一个迭代器（类比读卡器），用来读取链表节点isPastEnd()、retrieve()、advance()</li></ul></li></ul></li><li><p>带表头结点的单链表</p><ul><li>头结点是链表的第一个结点，但不存储实际的数据。它的存在使得链表的插入、删除等操作在任何位置都可以统一为一种操作，无需特殊处理头结点。</li><li>空链表表示为头结点的 next 指针为 null</li></ul></li><li><p>链表的数组实现</p><img src="image-20240106210926230.png" alt="image-20240106210926230" style="zoom:50%;" /></li><li><p>基数排序</p><ul><li><img src="image-20240106212447675.png" alt="image-20240106212447675" style="zoom:40%;" /></li><li>按从低位到高位依次放入桶中，n（最高位数）次后排序完成</li><li>实现：原始要排序的数据、桶中的数据都可以用链表或数组来实现。</li></ul></li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><ul><li>定义<ul><li>插入和删除都在同一侧的线性表</li><li>末端叫top，另一端叫bottom</li></ul></li><li>方法<ul><li><img src="image-20240107091929146.png" alt="image-20240107091929146" style="zoom:50%;" /></li><li>pop()：出栈</li><li>push()：入栈</li></ul></li></ul><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h3><ul><li>定义<ul><li>插入和删除在两端的线性表</li><li>也叫先进先出列表</li><li>新元素进入的端叫rear，旧元素出队的端叫front</li></ul></li><li>方法<ul><li><img src="image-20240107093052919.png" alt="image-20240107093052919" style="zoom:50%;" /></li><li>数组实现：<img src="image-20240107093427609.png" alt="image-20240107093427609" style="zoom:50%;" /></li><li>enqueue()：入队</li><li>dequeue()：出队</li></ul></li></ul><h2 id="第四章-树"><a href="#第四章-树" class="headerlink" title="第四章 树"></a>第四章 树</h2><ul><li>定义<ul><li>节点的集合，由一个根节点和若干子树构成</li><li>节点的度degree：孩子的个数</li><li>树的度：节点度的最大值</li><li>枝和叶：度为0的节点称为叶，度数不为0的节点称为枝</li><li>级level：根的级为0&#x2F;1，其他节点的级为父节点的级+1</li><li>树的深度&#x2F;高度：最大的级</li></ul></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><p>二叉树</p><ul><li>定义：有根节点且其余每个节点构成两棵子树，称为左子树和右子树</li><li>定理<ul><li>二叉树的边数 &#x3D; 节点数 - 1</li><li>第i层的节点数最多为2 ^ i</li><li>高度为h的二叉树节点个数：h + 1 到 2 ^ (h + 1) - 1</li><li>叶节点数量 &#x3D; 度为2节点个数 + 1</li><li>有n个节点的树高度范围：n - 1 到 log2(n + 1) - 1</li></ul></li><li>满二叉树：高度为h且有2 ^ (h + 1) - 1个节点的树</li><li>完全二叉树：<img src="image-20240107111044518.png" alt="image-20240107111044518" style="zoom:50%;" /></li><li>数组实现：二叉树被看作完全二叉树缺失了部分节点，完全二叉树按顺序填入数组</li><li>链表实现：节点结构为数据 + 左子树 + 右子树</li><li>cursor实现：<img src="image-20240107115634904.png" alt="image-20240107115634904" style="zoom: 33%;" /></li><li>方法：<img src="image-20240107115801585.png" alt="image-20240107115801585" style="zoom:40%;" /></li></ul></li><li><p>二叉树的遍历</p><ul><li><img src="image-20240107120939766.png" alt="image-20240107120939766" style="zoom:50%;" /></li><li><p>前序遍历：根-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历：左子树-&gt;根-&gt;右子树</p></li><li><p>后序遍历：左子树-&gt;右子树-&gt;根</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Preorder traversal递归写法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BinaryNode&lt;T&gt;* t)</span></span>&#123;<br>    <span class="hljs-comment">// preorder traversal of *t.</span><br><span class="hljs-keyword">if</span>(t)&#123;<br>        <span class="hljs-built_in">visit</span>(t);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Left);<br><span class="hljs-built_in">PreOrder</span>(t-&gt;Right);<br>        <span class="hljs-comment">//InOrder和PostOrder只需要换顺序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法：<img src="image-20240107123919487.png" alt="image-20240107123919487" style="zoom: 40%;" /></p></li><li><p>用遍历结果建树</p><ul><li><img src="image-20240107123115144.png" alt="image-20240107123115144" style="zoom:45%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  void CreateBT(String pres, String ins, BinaryNode<Type>* &amp; t){<br>      int inpos;<br>      String prestemp, instemp;</p><pre><code class="hljs">  if (pres.length() == 0)      t = NULL;  else &#123;      t = new BinaryNode;      t-&gt;element = pres.ch[0];      inpos = 0;      while (ins.ch[inpos] != t-&gt;element)inpos++;      //对左子树建树      prestemp = pres(1, inpos);      instemp = ins(0, inpos-1);      CreateBT(prestemp, instemp, t-&gt;left);      //对右子树建树      prestemp = pres(inpos + 1, pres.length() - 1);      instemp = ins(inpos + 1, pres.length() - 1);      CreateBT(prestemp, instemp, t-&gt;right);  &#125;</code></pre><p>  }<br>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 如果为后序+中序：建根节点时和移动inpos时注意后序最后一个元素为根,递归部分如下：<br><br>  ````c++<br>  posttemp = posts(<span class="hljs-number">0</span>, inpos - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(0, </span>inpos - <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;left);<br>  <br>  posttemp = posts(inpos, posts.length() - <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">instemp </span>= <span class="hljs-keyword">ins(inpos </span>+ <span class="hljs-number">1</span>, <span class="hljs-keyword">ins.length() </span>- <span class="hljs-number">1</span>);<br>  CreateBT(posttemp, <span class="hljs-keyword">instemp, </span>t-&gt;right);<br></code></pre></td></tr></table></figure></p></li></ul><h3 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h3><ul><li>树的存储方式<ul><li><strong>左子女右兄弟表示法</strong>（重点）<ul><li>每个节点除了存储自己的信息外，还存储了其<strong>最左边</strong>的子节点和<strong>最靠近</strong>的右兄弟节点的指针。</li><li><code>TreeNode *firstchild, *nextsibling;</code></li></ul></li><li>双亲表示法：在树节点中存储父节点的位置</li><li>广义表（基本不考）：如a(b(f,g),c,d(h,i,j),e)</li></ul></li><li>森林<ul><li>若干树的集合</li><li>森林-&gt;树：先将树全部转成二叉树，再将树的根节点用右链相连</li><li>树-&gt;森林：依次剪断根节点和右子树，形成新的树</li><li>把一棵树转化为二叉树：从这棵树的根结点开始，从上到下，看每一个结点，把你正在看的结点的孩子放在左子树，兄弟放在右子树。（将节点的孩子放在左子树，将节点的兄弟放在右子树）</li></ul></li><li>树的遍历<ul><li>深度优先遍历<ul><li>先序次序遍历：先访问树的根，再按先序遍历根的第一棵子树，第二棵子树，……</li><li>后序次序遍历：按先序遍历根的第一棵子树，第二棵子树，……，最后访问树的根</li></ul></li><li>广度优先遍历<ul><li>分层访问</li></ul></li><li>森林的遍历：先把森林转化成二叉树，再进行树的遍历</li></ul></li></ul><h3 id="特殊的树"><a href="#特殊的树" class="headerlink" title="特殊的树"></a>特殊的树</h3><ul><li><p>线索树</p><ul><li><p>n个结点的二叉树有2n个链域，其中真正有用的是n - 1 个，其它 n + 1 个都是空域。为了充分利用结点中的空域，使得对某些运算更快，用这些空域存储额外的信息</p></li><li><p>一个节点内增加两个标记：左子女|左线索|数据|右线索|右子女</p></li><li><p>若左线索为0，左子女指针正常指向左子女；若左线索为1，左子女指向前驱（某线性序列）</p></li><li><p>若右线索为0，右子女指针正常指向右子女；若右线索为1，右子女指向后继</p></li><li><p>中序线索树节点A的<strong>前驱</strong>为A左子树中的最右节点或者A的某个右子树包含A的祖先节点</p></li><li><p>中序线索树节点A的<strong>后继</strong>为A的右子树中的最左节点，或者是A的某个左子树包含A的祖先节点</p></li></ul><blockquote><p>注：这里的左右看的是垂直位置</p><p>​             1</p><p>如： &#x2F;        \     中从左到右为2-&gt;1-&gt;3</p><p>​     2              3</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadedTreeNode prev;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createThreadedTree</span><span class="hljs-params">(ThreadedTreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            createThreadedTree(root.left);<br><span class="hljs-comment">//左子女为空填前驱</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                root.left = prev;<br>                root.leftThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//pre右子女为空填当前节点</span><br>            <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span> &amp;&amp; prev.right == <span class="hljs-literal">null</span>) &#123;<br>                prev.right = root;<br>                prev.rightThread = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            prev = root;<span class="hljs-comment">//更新前驱</span><br><br>            createThreadedTree(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>霍夫曼树</p><p><a href="https://blog.csdn.net/qinglongzhan/article/details/80983492">Huffman编码算法详解_哈夫曼编码怎么算-CSDN博客</a></p><ul><li>增长树：对原二叉树中度为1的结点，增加一个空树叶；对原二叉树中的树叶，增加两个空树叶</li><li>外通路长度(外路径)E：根到每个外结点(增长树的叶子)的路径长度的总和(边数)；与之类似，内路径长度I对应内节点(非叶子)</li><li>结点的带权路径长度：一个结点的权值与结点的路径长度的乘积，用于算带权的外(内)路径长度</li><li>霍夫曼树：给出 m 个实数作为m个外结点的权构造一棵增长树，使得带权外路径长度最短</li><li>霍夫曼算法<ul><li><strong>初始化：</strong> 将每个字符看作一个独立的树，节点的权重为字符的频率。</li><li><strong>选择两棵权重最小的树：</strong> 从当前的树集合中选择两棵权重最小的树，合并成一棵新的树，新树的权重为两棵树的权重之和。</li><li><strong>重复步骤2：</strong> 不断重复步骤2，直到只剩下一棵树为止。</li><li>注意: 当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。</li></ul></li></ul></li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li><p>定义：二叉搜索树（Binary Search Tree，简称BST）是一种二叉树，其中每个节点都包含一个键值，并且满足以下性质：</p><ol><li>对于每个节点，其左子树中所有节点的键值都小于该节点的键值。</li><li>对于每个节点，其右子树中所有节点的键值都大于该节点的键值。</li><li>对于每个节点，其左右子树都是二叉搜索树。</li></ol></li><li><p>Indexed binary search tree：在二叉搜索树基础上每个节点增加一个leftsize &#x3D; 左子树节点个数 + 1</p></li><li><p>查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">find</span><span class="hljs-params">( Comparable x, BinaryNode t )</span>&#123;<br>    <span class="hljs-keyword">if</span>( t = = <span class="hljs-literal">null</span> )&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-keyword">if</span>( x. compareTo( t.element ) &lt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.left );&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo( t.element ) &gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-keyword">return</span> find( x, t.right );&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> t;&#125; <span class="hljs-comment">//Match</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>插入：<code>if( t = = null )&#123;t = new BinaryNode( x, null, null );&#125;</code>其他与查找相同</p></li><li><p>删除</p><ul><li>待删节点为叶节点：直接删</li><li>待删节点有一个非空子树：删除该节点后将它的子树接在被删节点的位置</li><li>待删节点有两个非空子树：找出左子树的最大值或右子树的最小值，将这个节点与待删节点互换位置，然后删除换位后的待删节点</li></ul></li><li><p>查找时间复杂度：worst-&gt;O(n)，best-&gt;O(log2 n)</p></li></ul><h3 id="AVL树（自平衡的二叉搜索树）"><a href="#AVL树（自平衡的二叉搜索树）" class="headerlink" title="AVL树（自平衡的二叉搜索树）"></a>AVL树（自平衡的二叉搜索树）</h3><ul><li>平衡因子：左子树和右子树的高度（或深度）之差，不能超过1</li><li>AVL的插入与删除：与二叉搜索树相同，但插入和删除若破坏平衡，要进行<strong>旋转</strong></li><li>AVL的旋转<ul><li>最小失衡树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。只需要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</li><li>左外侧不平衡：右单旋</li><li>右外侧不平衡：左单旋</li><li>左内侧不平衡：左双旋转</li><li>右内侧不平衡：右双旋转</li><li><img src="image-20240107185808987.png" alt="image-20240107185808987"  /></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><ul><li><p>m-路搜索树</p><ul><li>在m路搜索树中，每个内部节点可以有多达m个子树。它有以下特性：<ol><li>每个节点最多有m个子树。</li><li>除根节点和叶子节点外，每个节点至少有m &#x2F; 2个子树。</li><li>所有叶子节点都在同一层次上。</li></ol></li></ul></li><li><p>B-树：平衡的m-路搜索树</p><ul><li><p>查找：</p><ul><li><strong>从根节点开始：</strong> 从B树的根节点开始，逐级向下搜索。</li><li><strong>在节点中查找关键字：</strong> 在当前节点中查找目标关键字。如果目标关键字等于当前节点中的某个关键字，则查找成功，返回相应的信息或指针。</li><li><strong>选择子树：</strong> 如果目标关键字小于当前节点中的所有关键字，选择当前节点的第一个子树。如果目标关键字大于当前节点中的某个关键字，选择该关键字右侧的子树。</li><li><strong>递归：</strong> 递归地在所选择的子树上执行查找操作，回到步骤2。</li><li><strong>叶子节点：</strong> 如果当前节点是叶子节点，表示到达了树的底部，但仍未找到目标关键字。查找失败，返回相应的提示或空值。</li></ul></li><li><p>插入（假设为3阶B-树）</p><ul><li>首先与查找操作一样，找到待插入节点</li><li>若目标插入节点关键字数量小于2（m - 1），直接插入</li><li>若目标插入节点关键字数量已经为2进行<strong>分裂</strong></li><li>分裂：分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</li><li><img src="image-20240107194100165.png" alt="image-20240107194100165" style="zoom: 60%;" /></li></ul></li><li><p>删除</p><ul><li><p>若该节点删除前关键字个数大于m &#x2F; 2，直接删除</p></li><li><p>若该节点关键字个数等于m &#x2F; 2，即删除后不满足B-树要求，按从左到右顺序从相邻的兄弟节点借一个数据</p><img src="image-20240107200008343.png" alt="image-20240107200008343" style="zoom: 40%;" /></li><li><p>若相邻兄弟节点关键字个数为m &#x2F; 2，则将两个节点合并（把父节点里根位置关键字也合并进来），若此过程使父节点也不满足B-树定义，递归向上进行</p><img src="image-20240107200139516.png" alt="image-20240107200139516" style="zoom: 67%;" /></li></ul></li></ul></li></ul><h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><ul><li>装载因子<ul><li>定义：装载因子（Load Factor）是哈希表中用于衡量已经存储的元素数量与哈希表容量之比的一个指标，表示为：Load Factor &#x3D; 哈希表容量已存储的元素数量 &#x2F; 哈希表容量</li><li>装载因子大于1碰撞概率大，小于1碰撞概率小</li></ul></li></ul><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><ul><li><p>取余法：</p><img src="image-20240107201105493.png" alt="image-20240107201105493" style="zoom: 67%;" /></li><li><p>平方取中法</p><img src="image-20240107201206982.png" alt="image-20240107201206982" style="zoom: 67%;" /></li><li><p>乘法杂凑法：使用[M * ( k * A % 1) ]作为哈希地址，其中A是一个在0和1之间的常数。</p><img src="image-20240107201240355.png" alt="image-20240107201240355" style="zoom: 67%;" /></li></ul><h3 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h3><ul><li>线性探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 2 ··· m - 1，0 ··· d - 1号位置，若检测到空闲，则占据该位置</li><li>简单地说就是从原位置沿数组找第一个空位置插入</li></ul></li><li>二次探测<ul><li>插入元素时若检测到哈希表该位置已被占据，hash(key) &#x3D; d，则依次检测d + 1，d + 4，d + 9··· 号位置，若检测到空闲，则占据该位置</li></ul></li><li>双哈希<ul><li>使用两个独立的哈希函数来计算下一个探测位置。这两个哈希函数分别为h1(key)和h2(key)</li><li>若发生冲突，探测d + c, d + 2c, d + 3c······号位置</li></ul></li><li>再散列：当哈希表中的元素数量达到一定阈值时，再散列会触发，引发哈希表的重新构建。主要步骤：<ul><li><strong>创建新的哈希表：</strong> 当哈希表中的元素数量达到一定的阈值（例如，装载因子超过某个预定的阈值），再散列会创建一个新的更大的哈希表。</li><li><strong>重新哈希：</strong> 将哈希表中的所有元素重新插入到新的哈希表中。这个过程会使用新的哈希函数，通常是一个更大的哈希表大小对应的函数。</li><li><strong>替换原有哈希表：</strong> 重新哈希完成后，新的哈希表替换了原有的哈希表，成为存储元素的主要数据结构。</li></ul></li><li>分离链接<ul><li><img src="image-20240107205422549.png" alt="image-20240107205422549" style="zoom:50%;" /></li></ul></li></ul><h2 id="第六章-优先级队列（堆）"><a href="#第六章-优先级队列（堆）" class="headerlink" title="第六章 优先级队列（堆）"></a>第六章 优先级队列（堆）</h2><ul><li>定义<ul><li>类似于普通的队列或堆栈，但是每个元素都关联有一个优先级。在优先级队列中，元素按照其优先级被处理，而不是按照插入的顺序。</li><li>查找、删除最高优先级的叫最大优先级队列，反之称为最小优先级队列</li></ul></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>定义：一个最大（小）堆是所有节点值都比其孩子节点值大（小）的<strong>完全二叉树</strong></p></li><li><p>插入：新插入的元素插在堆的最后，若插入后不满足最大（小）堆的要求，向上调整，即不断交换</p><img src="image-20240107211422734.png" alt="image-20240107211422734" style="zoom:67%;" /></li><li><p>删除：堆只能删除顶部元素，删除后将底部元素提到顶部，再从上向下调整（例：若为最大堆则每次选择两个孩子中更大的进行交换）</p><img src="image-20240107211726374.png" alt="image-20240107211726374" style="zoom:67%;" /></li><li><p>方法：<img src="image-20240107211909366.png" alt="image-20240107211909366" style="zoom:50%;" /></p></li><li><p>向下调整算法建堆</p><ul><li><p>向下调整算法：如图，以下二叉树经过以下步骤转换为大堆</p><ul><li>选出孩子节点中大的值大的与父结点比较，如孩子节点大于父结点则交换，如小于则停止。</li><li>持续向下比较，比较到叶子结点或者孩子结点小于父结点则停止。</li></ul><p><img src="image-20240107212509783.png" alt="image-20240107212509783"></p></li><li><p>从后向前建堆：找到数组最后一个元素的父节点，为图中编号为1的子树，从后向前执行向下调整算法。</p><img src="image-20240107212531304.png" alt="image-20240107212531304" style="zoom: 67%;" /></li></ul></li><li><p>向上调整算法建堆</p><ul><li><p>向上调整算法建堆的过程与向下调整算法相似，从下标为1（即顶部）的结点开始向后调整：</p><ul><li>如孩子节点大于父结点就进行交换，直到与根结点比较完毕。</li><li>如孩子节点小于父节点也停止调整，让下一结点进行调整。</li></ul><p><img src="image-20240107213231846.png" alt="image-20240107213231846"></p></li></ul></li><li><p>堆排序</p><ul><li>第一步：将给定数据按顺序建成完全二叉树，然后调整成最大堆（从小到大排序用最大堆，从大到小排序用最小堆）</li><li>第二步：堆分为有序区和无序区，每次把无序区的最后一个元素与堆顶元素交换，此时有序区扩增，然后对无序区进行向下调整让它重新成为最大（小）堆</li><li>重复进行第二步直到排序完成</li></ul><img src="image-20240107213415919.png" alt="image-20240107213415919" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        percDown(a, i, a.length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        swapReferences(a, <span class="hljs-number">1</span>, i);<br>        percDown(a, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(Comparable[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    Comparable tmp;<br>    <br>    <span class="hljs-keyword">for</span> (tmp = a[i]; leftChild(i) &lt; n; i = child) &#123;<br>        child = leftChild(i);<br>        <br>        <span class="hljs-keyword">if</span> (child != n - <span class="hljs-number">1</span> &amp;&amp; a[child].compareTo(a[child + <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>            child++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (tmp.compareTo(a[child]) &lt; <span class="hljs-number">0</span>) &#123;<br>            a[i] = a[child];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    a[i] = tmp;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第七章-并查集"><a href="#第七章-并查集" class="headerlink" title="第七章 并查集"></a>第七章 并查集</h2><ul><li><p>等价类：指集合中的元素按照某个等价关系被划分成若干个子集，其中每个子集内的元素在这个等价关系下是相互等价的。一个等价关系是满足以下三个性质的关系：自反性、对称性、传递性</p></li><li><p>并查集定义：用于处理集合的数据结构，主要用于解决元素的等价关系和集合合并的问题。每个元素都被分配一个唯一的标识符，并且每个集合由一棵树来表示，其中树的根节点是集合的代表元素。</p></li><li><p>操作</p><ul><li>find(e)：在并查集中寻找e</li><li>union(a, b)：将a、b两个等价类合并，通常把其中一个的根节点连到另一个的根节点上</li><li>combine(a, b)：i&#x3D;Find(a)；j&#x3D;Find(b)；if(i !&#x3D; j) Union(i, j)；</li></ul></li><li><p>实现：每个等价类取出一个代表元素作为根，其他元素按层级结构作为孩子</p><ul><li><img src="image-20240108093433682.png" alt="image-20240108093433682" style="zoom:50%;" /></li><li><pre><code class="language-c++"></code></pre></li></ul><p>  int Find(int e){<br>      while(parent[e])<br>          e &#x3D; parent[e];<br>      return e;<br>  }</p><p>  void Union(int i, int j){<br>      parent[j]&#x3D;i;<br>  }<br>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>    - 时间复杂度：find-&gt;<span class="hljs-built_in">O</span>(h)，<span class="hljs-keyword">union</span>-&gt;θ(<span class="hljs-number">1</span>)<br><br>+ <span class="hljs-keyword">union</span>算法的提升<br><br>    - 重量规则：将树中节点多的根作为合并后的新根<br>    - 高度规则：将树高更高的根节点作为合并后的新根，用一个数组实现，根结点中放负数，绝对值代表高度<br><br>  ````c++<br>  <span class="hljs-comment">//重量规则</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>      root = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//指示该节点是否为根</span><br>      parent = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//存放树节点个数</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">1</span>; e &lt;= n; e++) &#123;<br>          parent[e] = <span class="hljs-number">1</span>;<br>          root[e] = <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (!root[e]) &#123;<br>          e = parent[e];<br>      &#125;<br>      <span class="hljs-keyword">return</span> e;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (parent[i] &lt; parent[j]) &#123; <span class="hljs-comment">// i becomes subtree of j</span><br>          parent[j] = parent[j] + parent[i];<br>          root[i] = <span class="hljs-literal">false</span>;<br>          parent[i] = j;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          parent[i] = parent[i] + parent[j];<br>          root[j] = <span class="hljs-literal">false</span>;<br>          parent[j] = i;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//高度规则</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[root2] &lt; s[root1]) &#123;<br>        s[root1] = root2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (s[root1] == s[root2]) &#123;<br>            s[root1] = root2;<br>            s[root2] = root1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>find的提升：路径压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(parent[e] == e)&#123;<span class="hljs-keyword">return</span> e;&#125;<br>    <span class="hljs-keyword">return</span> parent[e] = <span class="hljs-built_in">find</span>(parent[e]);<br>&#125;<br><span class="hljs-comment">//第一次find没有压缩，以后的都压缩过了</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="第八章-图"><a href="#第八章-图" class="headerlink" title="第八章 图"></a>第八章 图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>定义：Graph&#x3D;(V, E)；V：非空有限点集；E：边集合</p><ul><li>无向图：边(v1, v2) &#x3D; (v2, v1)</li><li>有向图与无向图相反</li></ul></li><li><p>完全图：有n个点和n * (n - 1) &#x2F; 2条边的无向图（有向图n * (n - 1)条边），即每个点都和其他点直接相连</p></li><li><p>度</p><ul><li>入度：以该点为终点的边的条数</li><li>出度：以该点为起点的边的条数</li><li>对无向图，度就是节点连接的边的条数</li></ul></li><li><p>子图：V’ 包含于V，E’ 包含于E，则(V’, E’)为(V, e)的子图</p></li><li><p>简单路径与简单回路：一个简单路径是指图中不包含重复节点的路径，简单回路是起始点相同的简单路径</p></li><li><p>连通图</p><ul><li>一个图是连通图，如果图中的任意两个节点之间存在至少一条路径</li><li>一个有向图是强连通图，如果图中的任意两个节点之间存在双向路径</li></ul></li><li><p>连通分量</p><ul><li>一个图的连通分量是指图中的一个最大连通子图</li><li>强连通分量是指有向图中的一个极大强连通子图，即一个最大的子图，其中任意两个节点都是强连通的。</li></ul></li><li><p>权重图：边上带有权值，表示对象之间的关系具有权重。</p></li><li><p>网络：连通的权重图和子图</p></li><li><p>生成树：无环连通图的一种特殊子图。对于一个连通图 G，它的生成树是 G 的一个子图，包含了图中的所有节点，并使得这个子图是一个树（无环连通图）。</p><p>生成树有以下特性：</p><ol><li>包含了图中的所有节点。</li><li>是一个树，即无环连通图。</li><li>保留了原图中的边，但是边的数量是节点数减一。</li></ol></li><li><p>方法：<img src="image-20240108103611106.png" alt="image-20240108103611106" style="zoom: 60%;" /></p></li><li><p>邻接矩阵（Adjacency Matrix）： 用二维数组表示节点之间的关系，矩阵中的元素表示边的存在或权值。</p><ul><li>aij &#x3D; 1表示存在(i, j)这条边</li><li>无向图的邻接矩阵是对称矩阵</li><li>若图为网络（权重图），则将0换为∞，1换为权重</li></ul></li><li><p>邻接表</p><ul><li>如果边的数量少，使用邻接表可以减少内存消耗</li><li><img src="image-20240108104520940.png" alt="image-20240108104520940" style="zoom:50%;" /></li><li><img src="image-20240108104535783.png" alt="image-20240108104535783" style="zoom:50%;" /></li></ul></li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li><p>深度优先遍历 DFS</p><ul><li><p>沿着图的深度尽可能远的方式遍历图的节点，直到无法再继续前进为止，然后回溯到之前的节点，继续探索其他路径。</p><img src="image-20240108110219014.png" alt="image-20240108110219014" style="zoom:67%;" /></li><li><p>步骤：</p><ul><li>选择一个起始节点作为当前节点。</li><li>访问当前节点，并标记为已访问。</li><li>对当前节点的每个邻接节点，如果该邻接节点未被访问，递归地应用 DFS。</li><li>若该节点向下的邻接节点都已被访问，返回到上一步，继续对其他未访问的节点应用 DFS。</li></ul></li><li><p>使用辅助数组visited[]实现</p></li></ul></li><li><p>广度优先遍历</p><ul><li>思想：从图中某顶点v0出发，在访问了v0之后依次访问v0的各个未曾访问过的邻接点，然后分别从这些邻接点出发广度优先遍历图，直至图中所有顶点都被访问到为止</li><li><img src="image-20240108110234403.png" alt="image-20240108110234403" style="zoom:50%;" /></li><li>使用辅助数组visited[]实现</li></ul></li><li><p>连通分量</p><ul><li>当无向图(以无向图为例)为非连通图时，从图的某一顶点出发进行遍历(深度&#x2F;广度)只能访问到该顶点所在的最大连通子图(即连通分量)的所有顶点</li><li><img src="image-20240108110814458.png" alt="image-20240108110814458" style="zoom:40%;" /></li></ul></li></ul><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul><li><p>最小代价生成树：各边权的总和为最小的生成树</p></li><li><p>逐步求解(Grandy)策略：</p><ul><li>设：连通网络<br>N&#x3D;{V,E}, V 中有 n 个顶点。<ul><li>先构造 n 个顶点， 0 条边的森林 F&#x3D;{T0 ,T1 ,…..,Tn-1}</li><li>每次向 F 中加入一条边。该边是一端在 F 的某棵树Ti上而另一端不在Ti上的所有边中具有最小权值的边。这样使F中两棵树合并为一棵，树的棵数 - 1</li><li>重复n - 1次</li></ul></li></ul></li><li><p>Kruskal算法</p><ul><li><img src="image-20240108114809407.png" alt="image-20240108114809407" style="zoom:50%;" /></li><li><p>图用邻接矩阵表示，顶点信息在顶点表Verticelist中，取最小的边利用最小堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> edgesAccepted;<br>    DisjSet s;<br>    PriorityQueue h;<br>    Vertex u, v;<br>    SetType uset, vset;<br>    Edge e;<br>    <span class="hljs-comment">// 从图中读取边并构建最小堆</span><br>    h = readGraphIntoHeapArray();<br>    h.buildHeap();<br>    <span class="hljs-comment">// 初始化并查集和边的数量</span><br>    s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisjSet</span>(NUM_VERTICES);<br>    edgesAccepted = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环直到生成树中的边数量达到 NUM_VERTICES - 1</span><br>    <span class="hljs-keyword">while</span> (edgesAccepted &lt; NUM_VERTICES - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从最小堆中取出权值最小的边</span><br>        e = h.deleteMin(); <span class="hljs-comment">// Edge e = (u, v)</span><br>        <span class="hljs-comment">// 查找边两端节点所在的集合</span><br>        uset = s.find(u);<br>        vset = s.find(v);<br>        <span class="hljs-comment">// 如果两个节点不在同一集合，说明加入这条边不会形成环</span><br>        <span class="hljs-keyword">if</span> (uset != vset) &#123;<br>            edgesAccepted++;<br>            <span class="hljs-comment">// 合并两个点集合</span><br>            s.union(uset, vset);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Prim算法</p><ul><li><img src="image-20240108115459395.png" alt="image-20240108115459395" style="zoom:50%;" /></li><li><img src="image-20240108115748149.png" alt="image-20240108115748149" style="zoom:50%;" /></li><li>算法实现<ul><li><img src="image-20240108121334560.png" alt="image-20240108121334560" style="zoom:50%;" /></li><li><img src="image-20240108121352722.png" alt="image-20240108121352722" style="zoom:50%;" /></li></ul></li></ul></li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li><p>含非负权值的单源最短路径(Dijkstra)</p><ul><li><p>目标：得到指定点V0到所有其他点的最短路径</p></li><li><p>第一步：先排出V0点到所有目标点的直接路径（不可达用∞）</p></li><li><p>第二步：从中挑出最短的那一条，放入结果区，即V0到该点最短路径</p></li><li><p>第三步：根据新加入结果区的那一条路径更新路径表（比较取短的）</p></li><li><p>重复以上步骤n - 1次即可得到结果</p></li><li><img src="image-20240108141408779.png" alt="image-20240108141408779" style="zoom:50%;" /></li></ul></li><li><p>边上权值为任意值的单源最短路径（贝尔曼-福特）</p><ul><li><p>目标：在边上权值可以为负数的情况下，寻找指定点V0到所有其他点的最短路径</p></li><li><p>算法内容：构造一个最短路径长度数组，dist 1[u]，dist 2[u]，···，dist n-1[u]，其中dist k[u]表示从V0出发最多经过k条边到达终点u的最短路径长度，并且不允许负权重边参与构成回路</p></li><li><p>递推公式：dist 1[u]&#x3D;Edge[v] [u] ;</p><p>[dist k[u] &#x3D; min{dist k-1[u] , min{dist k-1[j] + Edge[j] [u] } }      {j &#x3D; 0,1,2,…,n - 1}</p></li><li><img src="image-20240108143316318.png" alt="image-20240108143316318" style="zoom:50%;" /></li></ul></li><li><p>所有顶点之间的最短路径(Floyed)</p><ul><li>前提：各边权值均大于0的带权有向图。</li><li>算法内容：<ul><li>设A为原邻接矩阵，在A上作n次迭代，设每次迭代结果分别为A1，A2······An</li><li>迭代方法（自己理解的）：对于An，取矩阵An-1的第n行和第n列为基准，对于aij（基准行列上的可以剔除），用以它为中心的十字与基准行列交叉得到两个数据相加，若结果小于当前的aij，则更新aij</li><li>最后得到的An对应的path矩阵aij对应i-&gt;j最短路径的 j 前最后一个点</li></ul></li></ul></li></ul><h3 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h3><ul><li><p>用顶点表示活动的网络（AOV网络）</p><ul><li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网</li><li>直接前驱、直接后继：&lt;i,j&gt; 是网中一条弧，则 i 是 j 的直接前驱，j是 i 的直接后继</li><li>前驱、后继：从顶点 i 到顶点 j 有一条有向路径，则称 i 是 j 的 前驱，j 是 i 的后继</li><li>不能出现有向环</li><li>有向图G&#x3D;(V,E),V 里结点的线性序列（vi1 ,vi2 ,…,vin）如果满足：在 G 中从结点vi 到vj 有一条路径，则序列中结点vi 必先于结点vj，称这样的线性序列为一拓扑序列。</li><li>拓扑排序：求拓扑序列<ul><li>从图中选择一个入度为 0 的结点输出之。（如果一个图中，同时存在多个入度为0的结点，则随便输出哪一个结点）</li><li>从图中删掉此结点及其所有的出边。</li><li>反复执行以上步骤，直到所有结点都输出了，则算法结束；如果图中还有结点，但入度不为 0 ，则说明有环路</li></ul></li></ul></li><li><p>用边表示活动的网络（AOE网络）</p><ul><li><p>顶点：表示事件(event)，它的入边代表的活动已完成，它的出边代表的活动可以开始</p></li><li><p>有向边：表示活动，边上的权表示完成一项活动需要的时间</p></li><li><p>有唯一的入度为0的开始结点，唯一的出度为0的完成结点</p></li><li><p><strong>关键路径（Critical Path）：</strong> 是指由一系列关键活动组成的路径，即具有从开始顶点(源点)-&gt;完成顶点(汇点)的最长的路径，其总持续时间等于项目的最短完成时间。</p></li><li><p>找关键活动算法中一些量的定义</p><ul><li>Ve[i]：表示事件 V i 的可能最早发生时间，定义为从源点V0到Vi 的最长路径长度 , 如 Ve[4]&#x3D;7 天</li><li>Vl[i]：表示事件 Vi 的允许的最晚发生时间。是在保证汇点Vn-1在Ve[n-1] 时刻完成的前提下，事件<br>Vi允许发生的最晚时间＝ Ve[n-1] - Vi到Vn-1的最长路径长度。</li><li><img src="image-20240108161745262.png" alt="image-20240108161745262" style="zoom: 40%;" /></li><li>e[k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的可能的最早开始时间。即等于事件Vi 的可能最早发生时间。e[k]&#x3D;Ve[i]</li><li>l [k]：表示活动 ak &#x3D; &lt;Vi, Vj&gt; 的允许的最迟开始时间。l[k] &#x3D; Vl [j] - &lt;i, j&gt;</li><li>e[k] - l [k]表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间</li><li>若松弛时间为0，则ak为关键事件</li></ul></li><li><p>找关键活动算法步骤</p><ul><li><p>求各事件的可能最早发生时间：从Ve[0]&#x3D;0开始，向前推进求其它事件的Ve</p><p>（Ve[i] &#x3D; max{ Ve[j] + dur(&lt;Vj ,Vi &gt;) }<img src="image-20240108203531665.png" alt="image-20240108203531665" style="zoom:40%;" /></p></li><li><p>求各事件的允许最晚发生时间：从Vl [n-1] &#x3D; Ve[n-1]开始，反向递推</p><p>Vl [i]&#x3D;min{ Vl[j] - dur (&lt;Vi ,Vj &gt;) } <img src="image-20240108203823440.png" alt="image-20240108203823440" style="zoom:40%;" /></p></li><li><p>求e[k]和l [k]，若e[k] &#x3D; l [k]则ak为关键活动</p></li></ul></li></ul></li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><img src="image-20240108155038706.png" alt="image-20240108155038706" style="zoom:67%;" /></li><li><img src="image-20240108155112178.png" alt="image-20240108155112178" style="zoom: 67%;" /></li><li>分类<ul><li>内排序：对内存中的 n 个对象进行排序 。(插入排序，交换排序，选择排序，归并排序，基数排序)</li><li>外排序：内存放不下，还要使用外存的排序。</li></ul></li><li>稳定性：如果待排序的对象序列中，含有多个关键码值相等的对象，用某种方法排序后，这些对象的相对次序是不变的，则是稳定的，否则为不稳定</li><li>算法分析：<ul><li>时间开销：比较次数 + 移动次数</li><li>所需的附加空间</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>直接插入排序：<img src="image-20240108195151936.png" alt="image-20240108195151936" style="zoom:50%;" /><ul><li>最优：原数据按大小顺序排列，比较次数n - 1，移动次数0</li><li>最差：原数据按大小逆序排列，比较次数1 + 2 + ··· + n - 1 &#x3D; O(n^2)，移动次数(1 + 2) + ··· + (n - 1 + 2) &#x3D; O(n^2)</li></ul></li><li><del>折半插入排序</del> <strong>不考</strong><ul><li>对于已排序的部分，使用二分查找的方法，将插入位置的搜索范围缩小一半，从而提高排序的效率。</li><li>O(n * log2 n)</li></ul></li><li>希尔排序<ul><li>取一增量（间隔 gap&lt;n ），按增量分组，对每组使用直接插入排序或其他方法进行排序。</li><li>减少增量（分的组减少，但每组记录增多）。直至增量为1，即为一个组时。</li><li><img src="image-20240108200440789.png" alt="image-20240108200440789" style="zoom:50%;" /></li><li>算法分析：与选择的缩小增量有关，但到目前还不知如何选择最好结果的缩小增量序列。</li></ul></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ul><li>冒泡排序<ul><li>从头到尾做一遍相邻两元素的比较有颠倒则交换，记下交换的位置。一趟结束，一个或多个最大(小)元素定位。</li><li>去掉已定位的的元素，重复上一步，直至一趟无交换。</li><li>算法分析：最优n-1 次比较，0次移动；最差：(n - 1) + (n - 2) + ··· + 1次比较和交换</li></ul></li><li>快速排序 <strong>重要</strong><ul><li>在 n 个对象中，取一个对象(如第一个对象 -&gt; 基准pivot),按该对象的关键码把所有&lt;&#x3D;该关键码的对象分划在它的左边。&gt; 该关键码的对象分划在它的右边。</li><li>对左边和右边（子序列）分别再用快速排序。</li><li><img src="image-20240108210555872.png" alt="image-20240108210555872" style="zoom:50%;" />- j指针一直左移，直到它指的数比i指的数(基准)小，然后交换i、j所指数，i右移一位，继续该过程- 当i、j相遇，本轮快排完成</li><li>算法分析<ul><li><img src="image-20240108210823462.png" alt="image-20240108210823462" style="zoom:50%;" /><img src="image-20240108210953952.png" alt="image-20240108210953952" style="zoom:50%;" /></li><li>平均时间复杂度：O(n * log2 n)</li></ul></li></ul></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>直接选择排序<ul><li>思想：首先在n个记录中选出关键码最小（最大）的记录，然后与第一个记录（最后第n 个记录）交换位置，再在其余的n-1 个记录中选关键码最小（最大）的记录，然后与第二个记录（第n-1个记录）交换位置，直至选择了n-1个记录。</li><li>比较次数：n - 1 + n - 2 + ··· + 1 &#x3D;n * (n - 1) &#x2F; 2&#x3D;O(n^2)</li></ul></li><li>堆排序<ul><li>思想：第一步，建堆，根据初始输入数据，利用堆的调整算法，形成初始堆。第二步，一系列的对象交换和重新调整堆</li><li>算法分析：调整n - 1次(FilterDown)，时间为 O(n * log2 n)；交换次数为2n次，时间为O(n)；总复杂度为O(n * log2 n)</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>步骤</p><ul><li><strong>分解（Divide）：</strong> 将待排序的序列分解成两个子序列，通常是平均划分。这一步鼓励递归的应用，直到每个子序列只有一个元素。</li><li><strong>解决（Conquer）：</strong> 递归地对每个子序列进行排序。当子序列长度为1时，它已经是有序的。</li><li><strong>合并（Combine）：</strong> 将已排序的子序列合并成一个新的有序序列。这是归并排序的关键步骤。</li></ul></li><li><p>算法分析：合并趟数 log 2 n, 每趟比较 n 次，所以为 O(n log2 n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>    Comparable[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[a.length];<br>    mergeSort(a, tmpArray, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        mergeSort(a, tmpArray, left, center);<br>        mergeSort(a, tmpArray, center + <span class="hljs-number">1</span>, right);<br>        merge(a, tmpArray, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Comparable[] a, Comparable[] tmpArray, <span class="hljs-type">int</span> leftPos, <span class="hljs-type">int</span> rightPos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftEnd</span> <span class="hljs-operator">=</span> rightPos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpPos</span> <span class="hljs-operator">=</span> leftPos;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numElements</span> <span class="hljs-operator">=</span> rightEnd - leftPos + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;<br>        <span class="hljs-keyword">if</span> (a[leftPos].compareTo(a[rightPos]) &lt;= <span class="hljs-number">0</span>) &#123;<br>            tmpArray[tmpPos++] = a[leftPos++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpArray[tmpPos++] = a[rightPos++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt;= leftEnd) &#123;<br>        tmpArray[tmpPos++] = a[leftPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (rightPos &lt;= rightEnd) &#123;<br>        tmpArray[tmpPos++] = a[rightPos++];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numElements; i++, rightEnd--) &#123;<br>        a[rightEnd] = tmpArray[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计网重点"><a href="#计网重点" class="headerlink" title="计网重点"></a>计网重点</h1><span id="more"></span><img src="OSI.jpg" style="zoom:100%;" /><img src="transfer.png" style="zoom:100%;" /><img src="transfer2.jfif" style="zoom:100%;" /><ul><li><p>数据传输过程梳理</p><p>发送方：</p><ul><li>第一步：发送方从应用程序出发，应用层产生数据，表示层进行格式转换，会话层管理应用程序间的连接</li><li>第二步：数据进入传输层，如果是UDP，直接加上首部后进入网络层；如果是TCP，将数据进行切片变成数据段（segment），先建立连接，然后加上TCP报文首部，进入网络层</li><li>第三步：网络层IP协议加上IP报头封装成IP数据包</li><li>第四步：数据链路层的LLC和MAC子层先后加上其对应的报头，将数据包封装成数据帧<ul><li>此过程中若未知MAC地址，通过ARP协议获取</li></ul></li><li>第五步：数据帧进入物理层，作为比特流开始发送</li></ul><p>分情况：</p><ul><li>局域网内：比特流传给目标主机解析</li><li>局域网外：比特流传给路由器连接本网段的端口（网关），路由器的物理层、数据链路层、网络层等对其进行解析，根据目标IP地址进行路由决策，然后从对应的端口再次封装成数据包，进行转发（线路传播时以比特流形式）；对应网络的路由器收到后再进行这些过程之后把数据包再传输给目标主机</li></ul><p>接收方：</p><ul><li><strong>物理层：</strong><ul><li><strong>比特流接收：</strong> 接收方的物理层负责从传输媒介（电缆、光纤等）接收比特流。</li></ul></li><li><strong>数据链路层：</strong><ul><li><strong>帧解析：</strong> 物理层传递的比特流被数据链路层接收，数据链路层负责解析帧，提取出帧头和帧尾，确保帧的完整性。</li><li><strong>MAC地址比对：</strong> 数据链路层检查帧中的目标MAC地址，与接收设备的MAC地址进行比对，以确定是否是发给自己的帧。</li><li><strong>数据帧提取：</strong> 如果目标MAC地址匹配，数据链路层提取出帧中的数据部分。</li></ul></li><li><strong>网络层：</strong><ul><li><strong>IP头解析：</strong> 数据链路层提供的数据帧中包含IP数据包，网络层解析IP头，提取源IP地址和目标IP地址。</li></ul></li><li><strong>传输层：</strong><ul><li><strong>TCP&#x2F;UDP头解析：</strong> 如果使用TCP或UDP协议，传输层解析TCP或UDP头，提取端口号等信息。</li></ul></li><li><strong>应用层：</strong><ul><li><strong>数据交付应用程序：</strong> 最终，数据交付给应用层，应用层根据协议和数据的特定格式进行解析，将数据交付给目标应用程序进行进一步处理</li></ul></li></ul></li><li><p>网络拓扑</p><img src="17.png" style="zoom:50%;" /><ul><li>最可靠的是网状拓扑（mesh）</li></ul></li><li><p>多层ISP结构的Internet</p><img src="5.png" style="zoom: 40%;" /><ul><li>互联网服务提供商(ISP,Internet Service Providers)</li><li>第一层ISP是核心层，主要负责远距离连通。</li><li>这种多层ISP结构可以将大量的流量本地化</li><li>NAP(Network Access Point):第一二层之间的接入点,也可以是google(大公司)直接和第一层ISP进行链接</li><li>ICP(Internet Content Provider):互联网内容提供商,不提供接入服务</li><li>在低层次的ISP可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li></ul></li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="局域网介质"><a href="#局域网介质" class="headerlink" title="局域网介质"></a>局域网介质</h3><ul><li>UTP (无屏蔽双绞线 Unshielded Twisted Pair)<ul><li>由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限)</li><li>易于安装且成本较低，线薄接口小</li><li>与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声和干扰</strong></li><li>双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)<strong>短</strong></li></ul></li><li>同轴电缆 Coaxial<ul><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，比双绞线传输更加远，成本也要高一点</li></ul></li><li>光缆 Fiber-Optic<ul><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ul></li><li>光缆模式<ul><li>单模式：单个光传输</li><li>多模式：多根光不同角度传输 Multi-mode</li></ul></li><li>无线通信<ul><li>激光</li><li>红外线</li><li>无线电波</li></ul></li></ul><h3 id="UTP-for-Ethernet"><a href="#UTP-for-Ethernet" class="headerlink" title="UTP for Ethernet"></a>UTP for Ethernet</h3><blockquote><p>UTP线分类见笔记</p></blockquote><h3 id="介质和信号问题"><a href="#介质和信号问题" class="headerlink" title="介质和信号问题"></a>介质和信号问题</h3><ul><li>信令和通信问题<ul><li>传播(本质是电磁波)延迟</li><li>衰减 Attenuation</li><li>反射 Reflection</li><li>噪声(电子干扰) Noise</li></ul></li><li>冲突和冲突域<ul><li>当两个位元在同一网路上同时传播时，会发生碰撞</li><li>分割冲突域：将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中</li><li>通过添加中继器和集线器<strong>扩展</strong>冲突域。</li><li>可以通过添加智能设备(如网桥、交换机和路由器)来<strong>分割</strong>冲突域</li></ul></li></ul><h3 id="数据通信基础概念"><a href="#数据通信基础概念" class="headerlink" title="数据通信基础概念"></a>数据通信基础概念</h3><ul><li><p>概念</p><ul><li><p>码元(code)：在使用<strong>时间域</strong>(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形，是传输基本单位，并不一定只包含一位</p></li><li><p>香农公式：C &#x3D; W log<sub>2</sub>(1 + S&#x2F;N) bps（C：最高数据传输速率，W：带宽Hz，S：信号功率，N：噪声功率）</p></li><li><p>波特率(调制速率)：波信号每秒钟变化的次数</p></li><li><p>比特率：每秒钟传送的二进制位数</p></li><li><p>传输过程：</p><img src="16.png" style="zoom:50%;" /></li></ul></li><li><p>数字数据编码</p><ul><li>将数字数据转换到模拟信号：调制</li><li>将数字数据转换到数字信号：线路编码<ul><li>线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波</li></ul></li></ul></li><li><p>编码方式的分类</p><ul><li><p>单极性编码:一个正极或者负极，用0电平表示”0”，正电平表示”1”</p></li><li><p>极化编码：不归零制码(NRZ: Non-Return to Zero)</p><ul><li>不归零电平编码：用负电平表示”0”，正电平表示”1” (或相反)，一定的中和</li><li>不归零反相编码：信号电平的一次<strong>翻转</strong>代表比特1，无电平变化代表0</li></ul></li><li><p>极化编码：归零制码(RZ: Return to Zero)</p><img src="19.png" style="zoom: 80%;" /><ul><li>用负电平表示”0”，正电平表示”1”(或 相反)，比特中位跳变到零电平，从而提供同步</li></ul></li><li><p>极化编码：曼彻斯特码(Manchester)</p><img src="20.png" style="zoom: 80%;" /><ul><li>每一位中间都有一个跳变，从低跳到高表示”0”，从高跳到低表示”1”</li></ul></li><li><p>极化编码：差分曼彻斯特码(Differential Manchester)</p><img src="21.png" style="zoom:50%;" /><ul><li>每一位中间跳变：表示时钟</li><li>每一位位前跳变：表示数据：有跳变表示”0”，无跳变表示”1”</li></ul></li><li><p>双极性编码：双极性传号交替反转码(AMI)</p><img src="22.png" style="zoom: 80%;" /><ul><li>采用三个电平：正、负与零，零电平表示”0”，正负电平的跃迁表示 “1”，实现对”1”电平的交替反转</li></ul></li></ul></li><li><p>多路复用</p><ul><li><p>时分复用TDM：时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙</p><img src="25.png" style="zoom:50%;" /></li><li><p>统计时分复用 STDM (Statistic TDM)</p><img src="26.png" style="zoom:50%;" /></li><li><p>频分复用 FDM：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p></li><li><p>波分复用 WDM：波分复用就是光的频分复用：频率和波长是成倒数关系的</p></li><li><p>码分复用 CDM：用户采用相同频率，但是对于数据编码进行变换</p></li></ul></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>主要任务</p><ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li><strong>流控制</strong>(Flow control)</li></ul></li><li><p>用帧组织比特流</p></li><li><p>提供三种服务</p><ul><li><p>不带有确认的无连接服务</p></li><li><p>带有确认的无连接服务：无线网</p></li><li><p>带有确认的有连接服务：蓝牙</p></li></ul></li><li><p>与物理层的对比</p></li></ul><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织&#x2F;分组比特</td></tr></tbody></table><ul><li>局域网三种传输方式<ul><li>单播：将单个数据包从源发送到网络上的单个目标</li><li>多播：由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播：单个数据包传输到网络上的所有节点</li></ul></li><li>多播地址<ul><li>IPv4 中的多播地址是从 224.0.0.0 到 239.255.255.255 的范围</li><li><strong>224.0.0.0 - 224.0.0.255：</strong> 为系统保留，用于本地网络控制块。</li><li><strong>224.0.1.0 - 224.0.1.255：</strong> 为路由信息协议（Routing Information Protocol, RIP）的用途保留。</li><li><strong>224.0.0.0&#x2F;4：</strong> 称为预留地址空间，用于各种用途。</li><li><strong>232.0.0.0 - 232.255.255.255：</strong> 为源特定多播（Source-Specific Multicast, SSM）保留。</li></ul></li></ul><h3 id="以太网与带冲突检测的载波侦听多路访问（CSMA-CD）"><a href="#以太网与带冲突检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）"></a>以太网与带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）</h3><ul><li><p>IEEE 802.2、802.3、802.5</p><ul><li><p>LLC子层（802.2）</p><ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li><li><p>MAC子层（802.3）</p><ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li><li><strong>802.3 覆盖了物理层和第二层下半层</strong></li></ul></li><li><p>令牌环（802.5）</p><ul><li>在令牌环网络中，计算机连接成一个物理环或逻辑环，数据包通过一个称为“令牌”的特殊控制帧在环上传递。令牌是一种允许持有它的设备在网络上传递数据包的权限标记。</li></ul></li></ul></li><li><p>帧结构</p><ul><li>前同步码：8字节（不算在帧长度里）</li><li>目标地址：6字节</li><li>源地址：6字节</li><li>长度&#x2F;类型：2字节</li><li>数据：46(18 + 46 &#x3D; 64字节) ~ 1500字节</li><li>FCS字段（包含循环冗余校验码）：4字节</li></ul></li><li><p>最短帧长：64字节</p></li><li><p>LLC子层对数据包进行封装并添加控制信息，然后交给MAC子层进一步封装</p></li><li><p>MAC子层</p><ul><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong></li><li>广播目标MAC：全1(FFFF.FFFF.FFFF)，仅在未知目的主机MAC和目的主机为全部主机时使用</li><li>以太网是广播网络</li></ul></li><li><p>以太网的CSMA&#x2F;CD</p><img src="11.png" style="zoom:50%;" /><ol><li>首先设备要发送数据</li><li>开始侦听链路是否忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam signal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完链路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol></li></ul><h3 id="无线局域网的CSMA-CA"><a href="#无线局域网的CSMA-CA" class="headerlink" title="无线局域网的CSMA&#x2F;CA"></a>无线局域网的CSMA&#x2F;CA</h3><ul><li><p>无线局域网分类</p><ul><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ul></li><li><p>一些名词</p><ul><li>BSS：基础服务集</li><li>BS：基站</li><li>AP：无线接入点</li></ul></li><li><p>无线局域网标准</p><ul><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5 GHz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为”速率加倍”的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ul><img src="13.png" style="zoom:50%;" /></li><li><p>数据帧结构</p></li><li><p>无线网络的CSMA&#x2F;CA</p><ul><li>A向B发送RTS(Request To Send，请求发送)帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A；</li><li>B向A回答CTS(Clear To Send，清除发送)帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据；</li><li>A开始发送</li><li>若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。(A和C同时发送RTS)</li></ul></li></ul><img src="16-1746703648396.png" style="zoom: 50%;" /><ul><li><img src="data_link_layer-1-CSMACA.png" style="zoom: 33%;" /></li><li><p>WLAN和以太网区别</p><table><thead><tr><th>Ethernet</th><th>WLAN</th></tr></thead><tbody><tr><td>信号被传输到连接在线缆上的所有站点上</td><td>信号只被传输到接近发送站点的站点</td></tr><tr><td></td><td>接受站点检测冲突</td></tr><tr><td>只会有一个有效帧在信道上传播</td><td>会有多个有效帧同时在信道上传播</td></tr><tr><td></td><td>MAC协议必须尽可能保证只有发送站点接近接收站点</td></tr></tbody></table></li></ul><h3 id="第二层设备"><a href="#第二层设备" class="headerlink" title="第二层设备"></a>第二层设备</h3><ul><li><p>网桥、交换机：具体见笔记</p></li><li><p>分割冲突域：</p><p><strong>网桥</strong></p><ul><li>用网桥来分割局域网的以太网，给每个用户提供更多带宽，因为每个网段上用户更少</li><li>网桥增加了10%~30%的网络延迟，因为需要做决定</li></ul><p><strong>交换机</strong></p><ul><li>交换机比网桥更快，因为他们在硬件中交换，然而网桥在软件中交换</li><li>局域网交换机减小了冲突域的大小</li><li>所有连接到交换机的主机仍然在同一个广播域中</li></ul><p><strong>路由器</strong>（第三层）</p><ul><li>路由器可以创建最高级别的细分：<ol><li>创建较小的<strong>冲突域</strong></li><li>创建较小的<strong>广播域</strong>：除非经过编程，否则路由器不会转发广播。</li></ol></li><li>路由器通过检查数据包上的<strong>目标逻辑地址</strong>，然后在其路由表中查找转发指令来完成数据包的转发</li><li>由于路由器比网桥执行更多的功能，因此它们以更高的延迟率运行。</li><li>路由器可以用作<strong>网关</strong>，用于连接不同的网络媒体和不同的LAN技术</li><li>是根据逻辑地址(IP地址)进行转发，不再是MAC</li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)    <strong>Q：到底能不能流量控制</strong></li><li>路由器<ul><li>互连网段或网络(不同网段的分割)</li><li>根据IP地址做出合理的决定</li><li>确定最佳路径，根据路由表。</li><li>将数据包从入站端口切换到出站端口</li></ul></li><li>广播域划分：如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发送的是<strong>本网段</strong>的广播地址，路由器则不会进行转发</li></ul><h3 id="IP地址和子网划分"><a href="#IP地址和子网划分" class="headerlink" title="IP地址和子网划分"></a>IP地址和子网划分</h3><ul><li><p>IPv4报文结构（具体见笔记）</p><img src="3.png" style="zoom:50%;" /></li><li><p>IP地址</p><ul><li><p>IP地址为32位长(IPv4中)</p></li><li><p>它们以点分十进制格式表示为四个八位字节：133.14.17.0</p></li><li><p>IP地址包含两个组成部分：</p><ol><li>网络ID</li></ol></li></ul><ol start="2"><li>主机ID</li></ol><ul><li><p>分类：</p><ul><li>0–127 Class A address A类地址</li><li>128-191 Class B address B类地址</li><li>192–223 Class C address C类地址</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)</li><li>240–255 Class E - Research  E类地址：研究</li><li>host不能全取0，也不能全取1。全取0：网络地址；全取1：广播地址</li></ul></li><li><p>专用地址&#x2F;私有地址：用于局域网内部网段</p><blockquote><p>10.0.0.0 - 10.255.255.255<br>172.16.0.0 - 172.31.255.255<br>192.168.0.0 - 192.168.255.255</p></blockquote></li></ul></li><li><p>子网</p><img src="11-1746703659590.png" style="zoom: 67%;" /><img src="12.png" style="zoom: 50%;" /><ul><li><p>借用的最小位数是2，为什么？</p><ol><li>如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。</li><li>两位的时候，01和10给Host，00为网络ID，11为广播地址</li><li>全0可能导致误判</li></ol></li><li><p>子网掩码：网络位全1，主机位全0</p><p>计算子网网络地址：子网地址和子网掩码按位与</p><p>计算过程见笔记</p></li></ul></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul><li>端口与网关<ul><li>接口是路由器连接到网络的附件，在IP路由中也可以称为<strong>端口。</strong></li><li>这个IP地址往往被作为这个<strong>网络的网关</strong></li><li>每个接口必须具有一个单独的唯一网络地址</li></ul></li><li>IP地址分配<ul><li>静态地址分配</li><li>动态地址分配：<ul><li>RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。ARP为IP到MAC的转换，而RARP为MAC到IP的转换，向RARP服务器请求分配IP。主要流程：发出要反向解析的物理地址并希望返回其对应的IP地址。发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个 IP 地址。 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的 IP 地址。 如果存在，RARP服务器器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用; 如果不存在，RARP服务器对此不做任何的响应。 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯;如果一直没有收到RARP 服务器的响应信息，表示初始化失败。</li><li>BOOTstrap协议。用于工作栈</li><li>DHCP: Dynamic Host Configuration Protocol. (比较多用)动态主机配置协议</li></ul></li></ul></li><li>ARP协议（地址解析协议）<ul><li>源主机访问目的主机不知道对方MAC，优先查找本地ARP表（时效性）</li><li>若ARP表中没有，将目标MAC设为全1进行广播，发送ARP请求<ul><li>若目标主机在局域网内，它收到ARP请求后检查IP地址发现与自己IP一致，将自己的MAC放进帧中发送给源主机</li><li>若目标主机处于另一个网络，则路由器会将自己的MAC作为目标主机MAC给源主机，此后源主机的帧由路由器转发给目的主机（代理ARP）</li><li>此过程中所有收到帧的主机都会将发送方MAC存进自己的ARP表</li></ul></li></ul></li><li>默认网关<ul><li>除了代理ARP，还可以通过默认网关与另一网络设备通信</li><li>默认网关是路由器上连接到源主机所在网段的<strong>接口的IP地址</strong></li><li>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong></li></ul></li></ul><h3 id="网络协议操作"><a href="#网络协议操作" class="headerlink" title="网络协议操作"></a>网络协议操作</h3><ul><li>Routed protocol 被动可路由协议<ul><li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li><li>然后请求路由表可以发现目的网段对应端口</li><li>再次将报文封装转发给对应的主机</li><li>路由表是存储在内存中的</li></ul></li><li>管理距离<ul><li>管理距离（Administrative Distance）是路由选择过程中一个用于衡量路由可信度的参数。在多路由协议环境中，可能存在多个路由到达相同目的地的候选项，管理距离用于确定使用哪个路由信息。较低的管理距离值表示路由更可信。</li><li>直接连接（Connected）：0</li><li>静态路由（Static Route）：1</li><li>Enhanced Interior Gateway Routing Protocol (EIGRP)：90</li><li>Open Shortest Path First (OSPF)：110</li><li>Routing Information Protocol (RIP)：120</li><li>Border Gateway Protocol (BGP)：200</li><li>当未指定管理距离时，使用以上默认值（default）</li></ul></li><li>静态路由和动态路由的区别<ul><li>静态路由<ol><li>用于<strong>隐藏</strong>部分网络。安全(不必进行路由表的交换)</li><li>测试网络中的特定链接。</li><li>用于仅在到达目标网络的路径时维护路由表。</li></ol></li><li>动态路由<ol><li>维护路由表。</li><li>以路由更新的形式及时分发信息。</li><li>依靠路由协议共享知识。</li><li>路由器可以调整以适应不断变化的网络状况。</li><li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li></ol></li></ul></li><li>被动路由协议和主动路由协议<ul><li>Routed Protocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。</li><li>Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。</li><li>Routing Protocol 决定 Routed Protocols</li></ul></li><li>动态路由协议的分类<ul><li>内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)：可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司网络，学区的网络或政府机构的网络。</li><li>外部网关协议(Exterior Gateway Protocols，EGP，BGP)：用于在<strong>自治系统之间路由数据包</strong>。</li></ul></li><li>内部网关协议的分类：DVP and LSP<ul><li>距离矢量协议(Distance-Vector Protocols，RIP, IGRP):<ol><li>从<strong>邻居</strong>的角度查看网络拓扑，只知道到达一个网段的最少跳数(注意不基于全局)</li><li>在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次)</li><li>经常定期(periodic)更新，即与邻居交换路由信息</li><li>将整个路由表的<strong>副本</strong>传递到邻居路由器。</li></ol></li><li>链路状态协议(Link State Protocols, OSPF):<ol><li>获取整个网络拓扑的通用视图。(全局的视角，会有代价)</li><li>计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据)</li><li><strong>事件</strong>触发的更新。如果没有事件发生那么就不会更新</li><li>将链接状态路由更新传递给其他路由器。</li><li>LSP操作过程:<ol><li>相互交换彼此学到对应的Topological Database(是全局的信息)</li><li>之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li><li>根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。</li></ol></li></ol></li></ul></li><li>RIP（典型DVP）<ul><li>基于DVP</li><li>唯一的指标是跳数。</li><li>最大跳数为15。(评判依据简单，是一个短板)</li><li><strong>每30秒更新一次(广播)，可以修改</strong></li><li>并非总是选择最快的路径(而是走跳数最短的路径)。</li><li>产生大量的网络流量。</li></ul></li><li>OSPF(Open Shortest Path First)：典型LSP<ul><li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li><li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，<strong>本科阶段只考虑带宽的。</strong></li><li><strong>事件触发更新</strong></li><li>在LSP中用的比较多。它节约了带宽资源，需要host的CPU资源来执行算法。将最小生成树转化成路由表</li><li>最快和什么有关？(最快指的是带宽)<ol><li>和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关</li><li>带宽表示为代价，带宽和代价成<strong>反比</strong></li></ol></li></ul></li><li>IGRP (Interior Gateway Routing Protocol)和EIGRP (Enhanced IGRP)<ul><li>思科开发的一种用于在较大的企业网络中进行内部路由选择的距离矢量路由协议。它是专有协议，用于在局域网（LAN）和广域网（WAN）中的路由器之间交换路由信息。</li><li>IGRP最大跳数为255，每90秒更新一次。</li><li>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</li></ul></li></ul><h3 id="VLSM（可变长子网掩码）"><a href="#VLSM（可变长子网掩码）" class="headerlink" title="VLSM（可变长子网掩码）"></a>VLSM（可变长子网掩码）</h3><ul><li><h4 id="经典路由-Classful-routing，有类路由-无子网掩码"><a href="#经典路由-Classful-routing，有类路由-无子网掩码" class="headerlink" title="经典路由(Classful routing，有类路由) 无子网掩码"></a>经典路由(Classful routing，有类路由) 无子网掩码</h4><ol><li>有类的路由协议要求单个网络使用相同的子网掩码。</li><li>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</li><li>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</li></ol></li><li><p>VLSM特点</p><ul><li>VLSM允许组织<strong>在同一网络地址空间内使用多个子网掩码</strong></li><li>实施VLSM通常被称为”子网划分”，可用于最大化寻址效率</li><li>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一</li><li>会导致地址空间的浪费:广播地址和网络号都无法被使用</li><li>更好的路由聚合(aggregation):构建超网</li><li>全0子网是否可用看题目，全1子网不可用</li></ul></li><li><p>计算过程**（重要）**</p><ul><li>第一步：先对划分的子网按主机需求量排序，按从大到小计算</li><li>第二步：分别对每个子网进行计算<ul><li>每个子网第一个为网络地址，最后一个为广播地址</li><li>下一个子网从前一个最后的地址（广播）后一个开始</li><li>在每个子网分配完后，最后需要对WAN分配地址，每个WAN（两两连接）需要2个网络地址（两个路由器双方的端口），所以需要2位主机号（还需要网络号和广播地址）</li></ul></li><li>总结<ul><li>重要的是要记住，只有未使用的子网才能进一步划分子网。</li><li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li><li>一般是从主机多大到主机少(路由间网络)进行划分</li></ul></li></ul></li><li><p>CIDR（Classless Inter Domain Routing，无类域间路由）</p><ul><li><strong>无类别地址块：</strong> CIDR不再依赖于固定的类别，而是将IP地址块视为连续的一段。这样，IP地址可以更灵活地分配，而不受限于A、B、C类别。</li><li><strong>前缀表示法：</strong> CIDR使用前缀表示法，例如，192.168.1.0&#x2F;24，其中“&#x2F;24”表示子网掩码中的前24位是网络部分，剩余的8位是主机部分。</li><li><strong>地址聚合：</strong> CIDR支持对相邻的地址块进行聚合，减少了路由表的大小。这对于减少路由表的条目数量，提高路由表的效率非常重要。</li></ul></li><li><p>路由聚合</p><ul><li>多个路由条目汇聚成小的路由条目，使用了CIDR和VLSM</li><li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少</li><li>方法</li></ul><img src="60.png" style="zoom:50%;" /><blockquote><p>如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果</p></blockquote></li></ul><h3 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议 ICMP"></a>因特网控制报文协议 ICMP</h3><ul><li>概述<ul><li>ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)</li><li>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</li><li>ICMP 只是IP层的协议</li><li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li><li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个<strong>ICMP差错报文</strong>。</li></ul></li></ul><img src="61.png" style="zoom: 50%;" /><ul><li><p>分类</p><ul><li>查询报文</li><li>差错报告报文</li></ul></li><li><p>差错报告报文内容</p><ul><li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li><li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li><li>然后添加一个首部作为IP数据报进行发送</li></ul><img src="63.png" style="zoom: 50%;" /></li><li><p>不应发送 ICMP 差错报告报文的几种情况</p><ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol><li>127.0.0.0:逻辑回路地址</li><li>0.0.0.0:确认路由地址</li></ol></li></ul></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><ul><li>第四层功能<ul><li>分割上层应用程序数据(新的数据单元-数据段)，<strong>第四层只会在终端上有</strong></li><li>建立端到端(end to end)的运营</li><li>从一个终端主机向另一个终端主机发送段**(第三层和第二层不进行可靠性检验，第四层完成可靠性检验）**，接受方认为数据错误，在第四层进行要求重传)</li><li>流量控制和可靠性</li></ul></li><li>第四层重要协议<ul><li>传输控制协议(TCP, Transmission Control Protocol)  <strong>可靠传输</strong>，使用<strong>数据段</strong>作为传输单位</li><li>用户数据报协议(UDP, User Datagram Protocol)，使用<strong>用户数据报</strong>作为传输单位</li><li>SCTP(Stream Control Transmission Protocol)：流控制传输协议，用于<strong>视频和音频的传输</strong></li></ul></li><li>端口<ul><li>TCP和UDP都使用<strong>端口</strong>来跟踪(track)同时穿越网络的<strong>不同会话（即不同进程）</strong></li><li>进程通过端口号来标识</li><li>端口分配规范<ul><li>低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)</li><li>0-1023是熟知端口，有分发的规范，不应当被随意使用</li><li>1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</li><li>49152~65535即为短暂端口号，用于和远端通信</li><li>基于端口号的不同，进行不同的包的分发</li></ul></li></ul></li><li>套接字 Socket<ul><li>第四层进行通信的单位是进程，由IP和端口共同指定。socket是第四层的地址</li><li>套接字表示为(IP地址，端口)</li><li>通讯被认为<strong>是以一个socket和另一个socket之间的连接</strong></li></ul></li></ul><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><ul><li>概述<ul><li><strong>TCP不支持多播和广播</strong></li><li>TCP解决问题：<ul><li>可靠传输</li><li>流传输<ol><li>滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)</li><li>避免拥塞</li></ol></li><li>连接控制<ol><li>建立连接:三次握手</li><li>断开连接:四次握手</li></ol></li></ul></li></ul></li><li>TCP数据报结构</li></ul><img src="2.png" style="zoom:50%;" /><ul><li><p>段的大小必须与IP数据包匹配，并且还必须满足底层的需求</p><ol><li>例如，以太网的MTU(最大传输单位)为1500字节</li><li>是面向字节的传输。</li></ol></li><li><p>每个段都有：</p><ol><li>标头为20个字节(可选部分除外)</li><li>0或更多数据字节(请求连接的时候)</li></ol></li><li><p>TCP建立连接：三次握手</p><img src="8.png" style="zoom:50%;" /><blockquote><p>英文缩写含义：</p><p>SYN：控制信号之一，表示同步序号用于建立连接</p><p>ACK：控制信号之一，表示确认号是否有效</p><p>seq：序号（4字节），标识发送方发送的数据字节的顺序</p><p>ack：确认号（4字节），期望收到的下一个数据段的序号</p></blockquote><ul><li>第一次：<ul><li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li><li>客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求</li></ul></li><li>第二次：服务器检查是否存在监视端口的服务进程<ul><li>如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段</li><li>如果存在进程，则决定拒绝或接受请求</li><li>如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段</li></ul></li><li>第三次：<ul><li>客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接</li><li>为了避免出现延时之类的情况(如果只有两次会浪费服务器资源)</li></ul></li></ul><blockquote><p>有时候我们会选择，第三次握手的时候同时携带数据</p></blockquote></li><li><p>连续ARQ协议</p><ul><li>ARQ (Automatic Repeat reQuest) 自动重传请求：这表示”重新发送请求”为自动发送并且接收方无需请求发送方重新发送错误段</li></ul><img src="12-1746703681176.png" style="zoom:50%;" /><ul><li><p>多个数据同时发送过去(一次发送多个)</p></li><li><p>窗口大小是双方协商的，通过TCP报文中的<strong>窗口字段</strong>表示</p></li><li><p><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong></p></li><li><p>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离</p><img src="14.png" style="zoom:50%;" /></li><li><p>此过程中接收方可在回复报文中设置WIN字段值来改变发送方窗口大小</p></li></ul></li><li><p>TCP结束连接：四次握手</p><img src="21-1746703684266.png" style="zoom: 50%;" /><ul><li>步骤<ul><li>客户端：发起断开连接请求（FIN &#x3D; 1）</li><li>服务器端：Ack &#x3D; 1:允许断开，但是此时并不是断开连接，而是说不在发送新的数据，此时我们需要<strong>完成之前未处理完成的数据的处理</strong>。(这里只是说我已经收到了你请求停止传输的请求)</li><li>服务器端：FIN &#x3D; 1:数据处理完成，注意需要的变化(此时表示<strong>所有的需要处理的数据已经处理完了</strong>，此时表示正式确认断开)</li><li>客户端：确认收到B的断开信息（ACK &#x3D; 1）</li><li>在完全断开连接前，等待最大的网路往返时间(保证能处理到B最后发送的报文)</li></ul></li><li>为什么必须等待2 MSL？（MSL：最大报文段生存时间）<ol><li>为了确保A发送的最后一个ACK可以到达B</li><li>防止出现任何无效的连接请求段：等待2 MSL之后，我们可以确保连接上的所有段（最后一个ACK）均已消失，以免与后续的新连接产生混淆</li></ol></li></ul></li><li><p>TCP中的计时器</p><ul><li>重传计时器：当发送方发送一个数据段后，会启动一个重传计时器。如果在规定的时间内没有收到对应的确认（ACK）或者接收方没有成功接收数据，发送方会认为数据段可能丢失了，就会触发重传机制，重新发送该数据段。</li><li>坚持计时器：在TCP中，发送方可能会使用持续计时器来处理窗口大小为零的情况。当发送方的窗口大小为零时，表明接收方的缓冲区已满，但发送方仍然希望保持连接的活动性。在这种情况下，发送方会启动持续计时器，定期发送窗口探测段以维持连接。</li><li>保持计时器：保活计时器用于检测连接是否仍然处于活动状态。如果在一段时间内没有收到任何数据，保活计时器会触发，并发送保活探测段。这有助于检测连接是否断开，并在必要时终止连接。</li><li>时间等待计时器：在TCP的四次握手结束后，连接的一方会进入TIME-WAIT状态，等待2倍的最大报文段生存时间（2MSL）。这个等待时间由时间等待计时器控制。它确保在TIME-WAIT状态期间，之前的连接的所有报文都已经从网络中消失，以防止新连接与旧连接的报文混淆。</li></ul></li></ul><h3 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h3><ul><li><p>概述</p><ul><li>没有建立连接(避免延时)</li><li>没有拥塞控制：UDP可以按照期望的速度传输</li><li>常用于流媒体、多媒体应用（<strong>速率敏感</strong>）</li><li>应用：RIP（路由信息协议）、DNS（域名解析协议）、SNMP（简单网络管理协议，位于应用层）、TFTP（简单文件传输协议，位于传输层）、DHCP（动态主机配置协议，位于应用层）</li></ul></li><li><p>数据帧格式</p><img src="23.png" style="zoom:67%;" /><ul><li>UDP只有8个字节的首部，所以UDP报文最少是8个字节</li><li>源端口、目的端口、长度、校验(data)、Data</li><li>校验也要对data一并校验，如果出现错误，直接丢弃。</li><li>应用层进行数据切片，决定如何进行发送，UDP直接发送，UDP不会再自己分片了</li></ul></li><li><p>TCP与UDP比较</p><ul><li>TCP<ul><li>不是立即交给上层校验，而是需要先和对方沟通</li><li><strong>缓存满了才统一交付</strong></li></ul></li><li>UDP<ul><li>直接转发报文，保留报文边界</li><li>应用程序会发送比较合适的UDP报文大小进行发送</li></ul></li></ul></li></ul><h3 id="NAT-和-PAT"><a href="#NAT-和-PAT" class="headerlink" title="NAT 和 PAT"></a>NAT 和 PAT</h3><ul><li><p>NAT是在IP数据包头中将一个地址交换为另一个地址的过程</p><ol><li>网络地址转换</li><li>是网络地址即将用完的解决方案</li><li>内部主机发送报文给网关，网关根据NAT Table进行翻译，转换成内部全局地址，然后进行转发</li><li>主要设备：路由器</li></ol><ul><li>在NAT 路由器将局域网地址转换成网络上的地址(双向转换，有一个NAT表)</li><li>路由器会将IP数据包中的地址字段进行修改</li></ul></li><li><p>NAT类型</p><ul><li>静态NAT：固定的内部地址(internal address)到注册地址(registered address)的映射(一开始就写死)</li><li>动态NAT：映射以先到先得的方式动态进行(不是写死，配一个地址池,不断更新)</li><li>PAT(过载，Port address translation)：端口地址转换用于允许许多内部用户共享一个”内部全局”地址(基于Socket映射，而不是IP地址，多个内网主机映射到一个公网地址)</li></ul></li><li><p>NAT地址类型</p><img src="25-1746703689130.png" style="zoom: 50%;" /><ul><li>Inside Local address (内部本地地址):内网IP地址</li><li>Inside Global address (内部全局地址): 注册IP地址, 对外部展示的内部地址</li><li>Outside Global address (外部全局地址):由主机所有者分配的IP地址。通常是注册地址。(对内网而言的外部，是目的地址)</li></ul></li><li><p>PAT</p><img src="29.png" style="zoom:40%;" /><img src="28.png" style="zoom:50%;" /></li></ul><ul><li>基于socket映射</li><li>出口IP相同，通过端口号来区别</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：会话层</h3><ul><li>职责<ul><li>基于令牌进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li><li>进行数据分段、拼接，保证传输的有效。</li><li>同步技术，保证故障恢复</li></ul></li><li>服务<ul><li><strong>半双工通信（Half-Duplex）：</strong> 在半双工通信中，数据可以在通信双方之间进行双向传输，但同一时刻只能有一个方向上的数据传输。这意味着通信的两端能够交替发送和接收数据，但不能同时进行。对讲机就是一个常见的半双工通信的例子，一方说话时，另一方必须听，不能同时说话。</li><li><strong>全双工通信（Full-Duplex）：</strong> 在全双工通信中，通信双方能够同时进行双向数据传输。这意味着每一方都可以独立地发送和接收数据，而不会干扰对方。典型的电话通信就是全双工通信的例子，双方可以同时说话和听对方说话。</li><li><strong>多点通信（Multipoint Communication）：</strong> 多点通信是指多个设备之间进行通信的情境。在多点通信中，一个设备可以与多个其他设备进行通信，而不仅仅是与一个设备进行通信。这包括点对点通信（两个设备之间的直接通信）、广播通信（发送方向网络上的所有设备广播消息）以及多播通信（发送方向特定组中的多个设备发送消息）。</li></ul></li></ul><h3 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：表示层</h3><ul><li>表示层负责以接收<strong>设备可以理解</strong>的形式表示数据</li><li>表示层具有3个主要功能：<ol><li>数据格式(format)</li><li>数据压缩(compression):早期网络比较慢，倾向于先压缩在发送</li><li>数据加密(encryption)</li></ol></li><li>图像文件格式<ul><li>图形交换格式(GIF，Graphic Interchange Format)</li><li>联合图像专家组(JPEG，Joint Photographic Experts Group)。</li></ul></li></ul><h3 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h3><img src="5-1746703695119.png" style="zoom:50%;" /><ol><li><p>上图中各层的一些协议和使用：会话层对端口进行管理</p></li><li><p>第七层对应了应用界面，第六层对应了各种协议</p></li><li><p>应用程序层(最接近用户)支持应用程序的通信组件</p></li></ol><ul><li><p>超文本传输协议 (HTTP，HyperText Transfer Protocol)</p><ul><li><p>统一资源定位符 URL(Uniform Resource Locator)</p><ol><li>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</li><li>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</li><li>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</li><li>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</li><li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ol><li>访问方式:协议HTTPS 或者 HTTP</li><li>主机:域名的方式</li><li>端口对应进程</li><li>路径对应具体的文件</li></ol></li></ol></li><li><p>HTTP</p><ol><li>HTTP 是<strong>面向事务</strong>的客户服务器协议。</li><li>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)。<ol><li>每一次请求是独立的，不记录上一次请求信息。</li><li>Cookie是征求同意的存储(维持登录状态)，可以保证在多个应用之间维持登录状态。</li></ol></li><li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为HTTP daemon， 有的文献将它缩写为 HTTPD。</li><li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户</li></ol></li><li><p>http报文结构</p><img src="7.png" style="zoom: 50%;" /></li><li><p>HTML(HyperText Markup Language)</p><ol><li>定义了许多用于排版的命令(标签)。</li><li>HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。</li><li>仅当HTML文档是以.html或.htm为后缀时，浏览器才对此文档的各种标签进行解释。</li><li>当浏览器从服务器读取HTML文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li><li>HTML用一对标签(一个开始标签和一个结束标签)或几对标签来标识一个元素。</li></ol></li></ul></li><li><p>FTP(File Transfer Protocol) and TFTP(Trivial File Transfer Protocol)</p><ol><li>FTP是一种可靠的，面向连接的服务，它使用TCP传输文件。<ol><li>FTP首先在客户端和服务器(端口21)之间建立<strong>控制连接</strong></li><li>然后，建立第二个连接，这是计算机之间通过其传输数据的链接。(端口20)</li></ol></li><li>TFTP是使用UDP的无连接服务(简化的FTP)<ol><li>体积小，易于实施。更加方便</li><li>例如。 TFTP在路由器上用于传输配置文件和Cisco IOS映像</li><li>不支持交互，没有目录浏览功能</li></ol></li></ol></li><li><p>Telnet 协议</p><ul><li>Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能</li></ul></li><li><p>简单邮件传输协议 SMTP(Simple Mail Transfer Protocol) and POP(Post Office Protocol)</p><ul><li><p>电子邮件服务器使用SMTP发送和POP接收邮件相互通信</p><ul><li>SMTP (Simple Mail Transfer Protocol) SMTP(简单邮件传输协议)邮件发送，登录发送等操作</li><li>POP 3 (Post Office Protocol version 3) 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。</li><li>两者都使用TCP</li></ul></li></ul><blockquote><p>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器，然后用户登录后通过POP3协议收邮件到本地</p></blockquote></li><li><p>简单网络管理协议 SNMP(Simple Network Management Protocol)</p><img src="11-1746703699380.png" style="zoom: 67%;" /><ul><li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li><li>通过管理数据库(MIB)进行信息交流</li><li>使用<strong>UDP</strong>通过广播进行实现。</li></ul></li><li><p>域名系统(DNS, Domain Name System)</p><ul><li><p>多数使用UDP，少数情况TCP（大型网络）</p></li><li><p>Domain Name 域名</p><img src="13-1746703701223.png" style="zoom:67%;" /><ul><li>使用<code>.</code>将字符串进行分隔开，字符串不应该太长</li><li>越靠后域名级别越高</li><li>www就是对应到主机群</li></ul></li><li><p>顶级域 ：TLD (Top Level Domain)</p><ul><li>如<code>.cn</code>、<code>.com</code>、 <code>.edu</code>等，具体见笔记</li></ul></li><li><p>Domain Name Server 域名服务器</p><img src="14-1746703702903.png" style="zoom:50%;" /><ul><li>顶级域名底下的域名就是由顶级域名下面进行管理</li><li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li></ul></li><li><p>结合域名服务器查找IP地址</p><img src="15.png" style="zoom: 67%;" /><ul><li>DNS系统以层次(hierarchy)结构设置，该层次结构创建不同级别的DNS服务器。</li><li>此级别的DNS服务器判断其自身是否能够将域名转换为关联的IP地址：<ol><li>如果可以，则将结果返回给客户端</li><li>如果没有，它将请求发送到更高级别。(向上级请求)</li></ol></li><li>递归地进行查找，下面递归，上面迭代</li></ul></li></ul></li><li><p>应用层沟通的方式</p><ul><li>通信处理发生的一种方式：(无上下文，请求后就断开)<ol><li>当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端。</li><li>处理完成后，连接断开</li></ol></li><li>第二种方式：(有上下文)<ol><li>作为Telnet和FTP，建立与服务器的连接并保持该连接，直到执行所有处理。</li><li>当用户确定他&#x2F;她已完成时，客户端将终止连接。</li></ol></li><li>所有的交流活动都属于这两类之一</li></ul></li><li><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)</p><ul><li><p>概述</p><ul><li>一个协议软件在使用之前先作正确协议配置，具体配置内容取决于协议。</li><li>接到因特网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址</li><li>子网掩码</li><li>默认路由器的 IP 地址</li><li>域名服务器的 IP 地址</li></ol></li><li>Dynamic Host Configuration Protocol可以高效地分配IP地址<ol><li>局域网的网络协议</li><li>使用UDP来实现</li></ol></li><li>目前一般都是自动获取IP地址，而不需要手动去获取IP地址等信息</li></ul></li><li><p>工作过程</p><img src="16-1746703706866.png" style="zoom:60%;" /><ul><li><p>Client先广播Discover报文去搜索（广播携带地址是MAC地址，因为未知server地址）</p></li><li><p>所有Server在IP地址池中查找合法的IP地址，返回一个Offer报文</p></li><li><p>Client选择优先返回的Offer来优先服务</p></li><li><p>Client进行广播，告知接受谁的服务</p></li><li><p>然后B返回一个Ack报文</p></li><li><p>到了时间之后，选择release或者续租</p><ol><li><p>在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP 参数更新自己的配置，IP租用更新完成</p></li><li><p>当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约到时间后，Server会主动询问，如果没有应答会自动释放</p></li></ol></li></ul></li><li><p>DHCP报文类型</p><ul><li>DHCP Discover：发现</li><li>DHCP Offer：提供</li><li>DHCP Request：告知决定</li><li>DHCP ACK：租约确认</li><li>DHCP NAK：租约不确认</li><li>DHCP Release：释放租约</li><li>DHCP Decline:收到Ack后，Client告诉服务器不接受</li><li>DHCP Inform:客户端向服务器端请求详细信息</li></ul></li><li><p>DHCP欺骗：见笔记</p></li></ul></li></ul><h2 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器的内部组件"><a href="#路由器的内部组件" class="headerlink" title="路由器的内部组件"></a>路由器的内部组件</h3><img src="1.png" style="zoom:60%;" /><ul><li><h4 id="随机存取存储器-RAM-Random-Access-Memory"><a href="#随机存取存储器-RAM-Random-Access-Memory" class="headerlink" title="随机存取存储器(RAM, Random Access Memory)"></a>随机存取存储器(RAM, Random Access Memory)</h4><ul><li><p>路由器配置文件的临时存储，一般做为内存使用</p></li><li><p>断电或重新启动时RAM内容丢失</p></li><li><p>存储:</p><ul><li>路由表</li><li>ARP缓存</li><li>快速切换缓存</li><li>报文缓存:可能前面有正在处理的，需要等待</li><li>数据包保留队列</li></ul></li><li><p>根据地址位就可以读到地址内容(访问比较快)</p></li></ul></li><li><h4 id="非易失随机存取存储器-NVRAM-Non-volatile-RAM"><a href="#非易失随机存取存储器-NVRAM-Non-volatile-RAM" class="headerlink" title="非易失随机存取存储器(NVRAM, Non-volatile RAM)"></a>非易失随机存取存储器(NVRAM, Non-volatile RAM)</h4><ul><li><p>存储备份(backup)&#x2F;启动(startup)配置文件</p></li><li><p>路由器掉电或重启时内容不会丢失。</p></li><li><p>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</p></li><li><p>保证快速访问，但是存储空间有限</p></li></ul></li><li><h4 id="Flash-相当于台式机硬盘"><a href="#Flash-相当于台式机硬盘" class="headerlink" title="Flash (相当于台式机硬盘)"></a>Flash (相当于台式机硬盘)</h4><ul><li><p>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</p></li><li><p>存储了Cisco IOS(互联网操作系统)</p></li><li><p>允许更新软件而无需更换闪存芯片</p></li><li><p>可以存储多个版本的IOS</p></li><li><p>断电保持</p></li></ul></li><li><h4 id="只读存储器-ROM-Read-Only-Memory"><a href="#只读存储器-ROM-Read-Only-Memory" class="headerlink" title="只读存储器(ROM, Read-Only Memory)"></a>只读存储器(ROM, Read-Only Memory)</h4><ul><li><p>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</p></li><li><p>引导程序(加载Cisco IOS)</p></li><li><p>系统软件</p><ul><li>IOS的备份，精简(trimmed down)版本</li><li>升级需要安装新的芯片组</li></ul></li></ul></li><li><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>数据包通过其进入和离开路由器的网络连接口</p></li><li><p>附在主板(motherboard)上或作为单独的模块。</p></li><li><p>大部分是网口，主要是用来支持网络的</p></li><li><p>0&#x2F;0第一个，串口接口可能还分多个</p></li></ul></li></ul><h3 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h3><ul><li>系统启动程序<ul><li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li><li>验证CPU，内存和网络接口端口的基本操作</li><li>软件初始化</li></ul></li><li>软件启动程序<ul><li>步骤1：让ROM中的通用引导加载程序(bootstrap)在CPU卡上执行</li><li>步骤2：可以在以下几个位置之一找到操作系统：<ul><li>先从Flash找，也就只有一个image文件，将image导入内存</li><li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li><li>如果TFTP也没有配置，则去ROM中导出IOS</li></ul></li><li>步骤3：将保存在NVRAM中的<strong>配置文件</strong>加载到主存储器中，并一次执行一行<ul><li>先看NVRAM中有没有配置(start.config)</li><li>然后看TFTP Server有没有配置，如果有则下载一个</li><li>如果都没有，用console进行配置</li></ul></li><li>步骤4：如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong></li></ul></li><li>路由器初始化过程<ul><li>设置不用作在路由器中输入复杂协议功能的模式。</li><li>对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序</li></ul></li></ul><h3 id="路由和配置"><a href="#路由和配置" class="headerlink" title="路由和配置"></a>路由和配置</h3><ul><li><p>路由器功能：路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。</p><ul><li><p><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></p></li><li><p><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</p></li></ul></li></ul><h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><ul><li>当只有一条路径可访问网络时，到网络的静态路由就足够了</li></ul><ul><li>管理距离<ul><li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)<ul><li>数字越大，可信度(trustworthiness)越低。</li><li>因此静态路由的管理距离通常很短(默认值为1)</li><li>管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高</li></ul></li></ul></li><li>配置命令<ul><li><code>ip route [目标网络] [子网掩码] [下一跳地址]</code></li><li><code>ip route 192.168.2.0 255.255.255.0 10.0.0.1</code></li><li>这个命令指定了将数据包发送到目标网络192.168.2.0&#x2F;24时，下一跳路由器的IP地址是10.0.0.1</li></ul></li></ul><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><ul><li><p>收敛时间:</p><ul><li><p>从刚启动到网络达到稳定的时间</p></li><li><p>从发生变化到再次稳定的时间</p></li></ul></li><li><p>动态路由协议分类</p><ul><li>距离矢量(DV,Distance Vector)</li><li>链路状态(LS,Link State)</li><li>混合路由(HR,Hybrid Routing)</li></ul></li><li><p>距离矢量协议 DVP</p><ul><li><p>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></p></li><li><p>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递<em><strong>路由表</strong></em>的周期性副本。</p><ul><li><p>邻居交换Routing Table</p></li><li><p>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</p></li></ul></li><li><p>代表：RIP</p></li></ul></li><li><p>路由环路问题：<strong>有名词解释题目</strong></p><img src="18.png" style="zoom: 50%;" /><ul><li><p>解决方案</p><ul><li><p>路由环路解决方案一：定义最大值</p><p>1.设置最大跳数，比如最多转发15跳，16跳以上为不可达</p></li><li><p>路由环路解决方案二：路由中毒(Route Poisoning)</p><img src="21-1746703714747.png" style="zoom:67%;" /><ol><li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li><li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li><li>最终所有的路由器都知道不可达</li><li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li></ol></li><li><p>路由环路解决方案三：水平分隔(Split Horizon)</p><img src="22-1746703716393.png" style="zoom:50%;" /><ol><li>从某个端口收到的报文信息，不能再从端口发送回去</li><li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的</li><li>如果B和D接收到一个到达目的网段1的更好的路径，A会接收</li></ol></li><li><p>路由环路解决方案四：计时器(Hold-Down Timers)</p><ol><li>收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li><li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li><li>计时器结束后，删除掉对应的条目，避免出现问题</li><li>每一条路由表的记录都有<strong>有效时间</strong></li></ol></li></ul></li></ul></li><li><p>链接状态协议(LSP, Link-state Protocol)</p><ul><li>过程<ul><li><strong>邻居发现：</strong> 路由器首先通过一些机制（例如Hello消息）发现它的直接邻居。这些邻居是直接连接的路由器。</li><li><strong>链路状态信息收集：</strong> 每个路由器收集关于它与邻居之间链路的状态信息。这包括链路的带宽、延迟、可靠性等信息。</li><li><strong>链路状态信息传播：</strong> 路由器将它所知道的链路状态信息通过链路状态通告（Link State Advertisement, LSA）广播给所有邻居。LSA包含了路由器所连接的链路的信息，以及这些链路的状态。</li><li><strong>LSA数据库维护：</strong> 每个路由器维护一个LSA数据库，其中包含了它所收到的所有LSA。这个数据库用于构建整个网络的拓扑图。</li><li><strong>拓扑图建立：</strong> 路由器使用LSA数据库中的信息构建整个网络的拓扑图。这是一个图形表示，显示了网络中所有路由器和它们之间的链路关系。</li><li><strong>最短路径计算：</strong> 一旦拓扑图建立完成，路由器使用某种最短路径算法（如Dijkstra算法）计算到达网络中每个路由器的最短路径。</li><li><strong>路由表更新：</strong> 路由器根据最短路径计算结果更新它的路由表。路由表包含了到达网络中每个目的地的最佳路径。</li><li><strong>定期更新：</strong> 为了保持网络状态的实时性，链路状态协议定期发送Hello消息并交换LSA。这有助于检测链路状态的变化，并及时更新路由表。</li></ul></li><li>当发生事件导致链路变化，路由器广播一个LSU消息（一种用于传递链路状态信息的消息类型）</li><li>传递的是链路信息，不是路由表（与DVP区别）</li></ul></li><li><p>Routing Protocols 主动路由协议</p><table><thead><tr><th>英文缩写</th><th>英文解释</th><th>中文解释</th><th>备注</th></tr></thead><tbody><tr><td>RIP</td><td>a distance-vector routing protocol</td><td>距离矢量协议</td><td>DV</td></tr><tr><td>IGRP</td><td>Cisco’s distance-vector routing protocol IGRP</td><td>思科的距离矢量路由协议</td><td>DV，基本启用</td></tr><tr><td>OSPF</td><td>Open Shortest Path First</td><td>开放式最短路径优先</td><td>LSP</td></tr><tr><td>EIGRP</td><td>Enhanced IGRP</td><td>平衡的混合路由协议</td><td>杂合</td></tr></tbody></table></li><li><p>路由协议的主要目标</p><ul><li>最佳(Optimal)路线:选择最佳路线</li></ul></li></ul><ul><li>效率(Efficiency):最少使用带宽和路由器处理器资源<ul><li>快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。</li></ul></li><li>灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由</li></ul><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><ul><li>默认路由使路由表更短。(很多路由被省略)</li><li>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</li><li>命令：<code>ip route 0.0.0.0 0.0.0.0 [默认下一跳地址]</code></li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="RIP-v1-v2"><a href="#RIP-v1-v2" class="headerlink" title="RIP v1 &#x2F; v2"></a>RIP v1 &#x2F; v2</h3><ul><li>RIP v1<ul><li>RIP v1被认为是一种<strong>内部网关协议</strong>，它是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器。默认间隔为<strong>30秒</strong>。</li><li>RIP使用<strong>跳数</strong>作为度量标准，最大跳数为<strong>15</strong>，达到16跳的报文自动抛弃</li><li>RIP v1能够在多达六个等价路径上进行<strong>负载平衡(Load Balancing)</strong>，默认情况下为四个路径，最多6个，跳数相同才能完成负载均衡，跳数不同不满足条件</li><li>负载平衡：在多条路径之间分配网络流量，以确保网络资源的均衡利用和提高网络性能</li><li>更新中不发送子网掩码：不支持VLSM</li><li>不支持身份验证，安全性差</li><li>以255.255.255.255的广播形式发送更新:只能发给邻居，不能通过路由器转发</li></ul></li><li>RIP v2<ul><li>RIP v2是RIP v1的改进版本，并且新增了以下的功能：<ul><li>这是一种使用<strong>跳数指标</strong>的距离矢量协议。</li><li>它使用<strong>抑制计时器</strong>来防止路由循环-默认值为<strong>180秒</strong>,6倍于交换时间</li><li>它使用水平分割(Split Horizon)来防止路由循环(Routing Loops)。</li><li>它使用16跳作为<strong>无限距离的度量</strong>。(15跳及以内可达)</li></ul></li></ul></li><li>RIP v1和RIP v2之间的区别<ul><li>支持有类路由:可以携带子网掩码</li><li>使用组播地址进行发送广播:<strong>特定给RIP接受，避免了接受后发现没有启动RIP进程耽误时间</strong></li><li>需要身份认证才确定是否继续进行接收</li></ul></li></ul><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ul><li><p>概述</p><ul><li>链接的状态是对<strong>接口</strong>及其与其<strong>相邻路由器关系</strong>的描述</li><li>链接状态的集合形成一个<strong>链接状态数据库</strong>，有时也称为<strong>拓扑数据库</strong></li><li>路由器应用<strong>Dijkstra最短路径优先</strong>(SPF)算法来构建以自己为根的SPF树</li><li>路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放置在<strong>路由表</strong>中</li></ul></li><li><p>特征</p><img src="10.png" style="zoom:67%;" /><ul><li>将大的网络分成多个area，每一个area只和area 0相连，<strong>保证area没有回路</strong></li><li><strong>层次最多只有2个</strong>，只存在一个area 0。其它area都和area 0相连。</li><li>层次维持树的关系</li><li>在一个Area中才算是neighbours，neighbour之间交换Topology Databases（存的是link-state）</li><li>一个Area中获得全部LS(Link State)后计算Tree，生成表</li></ul></li><li><p>OSPF与RIP对比</p><ul><li><img src="image-20231223162518274.png" alt="image-20231223162518274" style="zoom:67%;" /></li><li><img src="9.png" style="zoom: 50%;" /></li><li>上面带宽大，2跳达到，下面带宽小，1跳到达。</li><li>OSPF从上面走，RIP从下面走，但是上面会快一些，因此OSPF选择的路径是更加优越的</li></ul></li><li><p>名词</p><ul><li>区域：有着同样区域ID的网络&#x2F;路由器集合。在同一个区域的每个路由器有着同样的链路状态信息</li><li>开销：固定值除以带宽</li><li>链路状态:物理链路的信息，路由器连接关系、通过什么接口、链路带宽、网络类型(点对点、多路复用)等</li><li>自治系统：一组具有相同的路由政策的IP网络和路由器的集合</li><li>DR：指定路由器，只有在多路复用的链路下使用，被选举出来</li><li>BDR：备份指定路由器，如果DR坏了，再次选举会出现问题，如果DR损坏，BDR立即成为DR</li><li>ABR(Area Border Router):区域边界路由器，有一定的约束(一个路由器最多不连接超过3个以上的路由器)</li></ul></li><li><p>OSPF域</p><img src="20-1746703728020.png" style="zoom: 60%;" /><ul><li>区域用32位数字标识：可以是IP格式（标准定义），也可以是一个十进制值</li><li>区域0：区域编号为0的单个区域。 area是OSPF两层结构划分的单位</li><li>OSPF使用2级分层模型：逻辑上必须是2层结构，而物理实现上可能有一定的差异，如果更多需要进行逻辑配置</li><li>在多区域OSPF网络中，要求所有区域都连接到区域0(主干)</li></ul></li><li><p>成为邻居的条件</p><ul><li>**Hello协议匹配：**OSPF邻居的建立依赖于Hello协议。路由器必须能够相互发送和接收Hello消息，并且这些消息中的参数必须匹配，包括Hello定时器、Dead定时器等。</li><li>**IP配置正确：**路由器必须配置正确的IP地址，并且它们之间能够相互通信。这通常包括确保两个路由器在同一个子网内，并且能够通过IP层相互到达。</li><li>**区域号匹配：**OSPF使用区域的概念，路由器必须在同一区域内才能成为邻居。如果两个路由器的区域不同，它们将无法建立邻居关系。</li></ul></li><li><p>OSPF过程</p><ul><li>步骤1：建立邻接关系<ul><li>路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播（TTL每经过一个路由器减一）</li><li>如果邻居被发现了：将邻居添加到邻居数据库</li><li>发现网络类型<ol><li>如果是多路复用网络，进入DR&#x2F;BDR选举过程，然后进入步骤2。</li><li>如果是点对点或点对多点网络，则不会举行DR&#x2F;BDR选举过程，并跳过步骤2。</li><li>如果hello数据包标头中的DR&#x2F;BDR字段已被占用(即DR &#x2F; BDR对已经存在)，则不会进行DR&#x2F;BDR选举，并跳过步骤2</li></ol></li></ul></li><li>步骤2：选择DR和BDR(如果需要):<strong>多路复用的时候才需要</strong><ul><li>如果没有其他路由器联机，则该路由器将成为DR。下一个要”启动”的路由器将是BDR</li><li>如果多个路由器(两个或更多)同时联机，进行选举</li></ul></li><li>步骤3：发现路线<ul><li>路由器确定”主&#x2F;从(master&#x2F;slave)”关系</li><li>多路复用网络中的DR&#x2F;BDR交换LSA(Type 2)，并且所有其他路由器将其Type 2 DBD发送给DR&#x2F;BDR</li><li>如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态：所有路由器必须在”加载状态”中等待，直到完全更新请求的路由器</li></ul></li><li>步骤4：选择适当的路线<ul><li>与网络上的所有其他路由器并行地计算SPF算法</li><li>在发生这种情况之前，所有路由器必须具有相同的链接状态数据库</li><li>SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树，OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享</li></ul></li><li>步骤5：维护路线信息<ul><li>常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制</li><li>根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)<ol><li>对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接</li><li>对于小于T1的链接，每30秒：非广播多路访问链接</li><li>“死间隔”是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)</li></ol></li></ul></li></ul></li><li><p>DR和BDR选举</p><ul><li><p>为什么要选择DR和BDR？</p><ul><li>如果不选择DR和BDR会导致每一个路由器都和其他所有路由器交流</li><li>每一个都要建立n * n - 1 &#x2F; 2个链接，对于链路的复杂比较高，如果有了DR就只需要(n-1)个连接</li><li>BDR是DR的备份，其他路由器之间就不用通信了</li></ul></li><li><p>选举方法</p><ul><li>优先级+路由器ID，最大的是DR，第二大的是BDR</li><li>路由器ID：手动配置、自动分配</li><li>自动分配时，如果有一个已经分配的回环接口（Loopback Interface），OSPF会选择其中最高的回环IP地址作为路由器ID，如果没有分配回环接口，OSPF将选择路由器上最高的活动接口的IP地址作为路由器ID</li><li>回环接口：是网络设备上的虚拟接口，通常用于本地主机内部进行测试和通信。它是一个虚构的网络接口，不连接到任何物理硬件，而是直接与本地设备的内部协议栈进行通信。</li></ul></li><li><p>过程</p><img src="25-1746703731030.png" style="zoom:60%;" /><ul><li>每个路由器与DR和BDR形成邻接关系</li><li>对于所有OSPF路由器，DR使用224.0.0.5(自己的IP)的<strong>主播地址</strong>向该网段上的所有其他路由器发送链接状态信息</li><li>为确保DR&#x2F;BDR看到所有路由器在网段上发送的链接状态，<strong>给所有DR&#x2F;BDR的多播地址是224.0.0.6</strong> <strong>(DR和BDR之间)</strong></li><li>几个Area有几个DR和BDR(是在不同Area上)</li></ul></li></ul></li><li><p>OSPF报文</p><ul><li><img src="26-1746703735937.png" style="zoom:50%;" /></li><li>Hello报文<ul><li>路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔（<strong>每10秒</strong>）发送hello</li><li>Hello数据包的地址为224.0.0.5</li></ul></li><li>DBD与LSA区别<ul><li>DBD消息是用于同步链路状态数据库的摘要信息，而LSA是用于传递链路状态数据库中详细的拓扑信息。</li><li>一旦通过DBD消息同步了LSDB（链路状态数据库）的状态，路由器之间就会进行LSA的交换。在LSA交换过程中，路由器可以请求缺失的LSA，也可以发送新的或者更新的LSA。</li></ul></li></ul></li></ul><h2 id="局域网交换与VLAN"><a href="#局域网交换与VLAN" class="headerlink" title="局域网交换与VLAN"></a>局域网交换与VLAN</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>基本功能<ul><li>根据MAC地址建立和维护<strong>交换表</strong>(类似于网桥表)</li><li>将帧切换出接口到目标</li><li>若收到的帧目的地址不在MAC表中，从所有端口转发</li></ul></li><li>对称交换与非对称交换<ul><li>对称交换可在具有相同带宽的端口之间提供交换连接</li><li>非对称交换通过将带有服务器的网段连接到更高带宽的端口，减少了服务器上潜在瓶颈的可能性</li></ul></li><li>内存缓冲<ul><li>作用：交换机中临时存储目标和传输数据的内存区域，直到可以将其切换出正确的端口为止</li><li>基于端口(Port)的内存缓冲<ul><li>数据包存储在每个端口的队列中</li><li>由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输，其他端口可能会空闲，存在不均衡的问题</li><li>每个端口都有一个buffer</li></ul></li><li>共享内存缓冲<ul><li>所有端口共享的公用内存缓冲</li><li>允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。</li><li>需要自己记录端口的信息</li></ul></li></ul></li><li><strong>交换方式</strong><ul><li>存储转发：交换机<strong>接收整个帧</strong>，先将其计算为循环冗余校验码（CRC），校验正确后再将其发送到目的地</li><li>直通：快速转发切换：<strong>仅在立即转发帧之前检查目标MAC(只看到帧的目的地址就转发，而不看帧的后面的部分)</strong></li><li>无碎片转发：交换机在接收到数据包的前64字节后，再开始进行数据包的转发。这意味着交换机会检查数据包的前64字节以确保没有任何碎片</li></ul></li><li>分层交换机<ul><li>第二层交换机：大规模集成电路，保证链路效率，低时延，低成本，有MAC地址</li><li>第三层交换机：基于硬件的帧转发机制，较高的帧转发性能，低时延（路由器是针对路由表进行转发），<strong>对数据流进行路由</strong>，<strong>生成MAC和IP的映射</strong>能够划分广播域，支持更复杂的网络拓扑</li><li>第四层交换机：可以根据端口主机的应用特点进行一定的流量控制，识别到前80个字节的数据报长度，对指定应用进行管理</li></ul></li></ul><h3 id="生成树协议-STP-The-Spanning-Tree-Protocol"><a href="#生成树协议-STP-The-Spanning-Tree-Protocol" class="headerlink" title="生成树协议(STP, The Spanning-Tree Protocol)"></a>生成树协议(STP, The Spanning-Tree Protocol)</h3><ul><li><p>桥环路：网络环路可能导致数据包在网络中无限循环，造成网络拥塞和性能问题，主要由第二层交换机冗余造成。STP通过自动选择和维护一棵”生成树”，从而阻止环路的产生。</p></li><li><p>概述</p><ul><li>主要功能：在<strong>交换&#x2F;桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</li><li>STP通过计算<strong>稳定的生成树</strong>网络拓扑<strong>来防止环路</strong></li><li><strong>生成树帧</strong>：桥协议数据单元BPDU(bridge protocol data unit)用于确定生成树拓扑</li></ul></li><li><p>STP决策顺序</p><ul><li>生成树始终使用相同的四步决策序列：<ul><li>在拓扑里面最低的root BID(网桥标识)</li><li>找到 Root bridge的最低路径成本</li><li>每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子</li><li>每个路径再指定一个最低的ID端口</li></ul></li><li>这些信息的得取都是靠的BPDU帧的交换</li></ul></li><li><p>BPDU(Bridge Protocol Data Unit)</p><ul><li>STP建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</li><li>不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)</li><li>在阻塞的链接上收到的数据帧将被丢弃。</li><li>交换机发送的允许形成无环逻辑拓扑的消息是BPDU</li></ul></li><li><p><strong>端口状态：</strong> STP定义了几种端口状态，包括：</p><ul><li><strong>指定端口（Designated Port）：</strong> 被选中作为某个网络段上的主端口，用于传输数据。</li><li><strong>根端口（Root Port）：</strong> 每个非根桥上选择通往根桥的最短路径的端口。</li><li><strong>阻塞端口（Blocked Port）：</strong> 阻塞状态的端口，用于防止环路的形成。</li></ul></li><li><p>选举根交换机</p><ul><li>交换机通过查找具有<strong>最低BID</strong>（较小的优先级值表示更高的优先级）的交换机(通常称为根战争)来选择单个根交换机。</li><li>如果所有交换机都使用默认的网桥优先级32768，则最低的MAC地址将作为根交换机。</li></ul></li><li><p>路径代价 Cost</p><ul><li>桥梁使用成本的概念来评估它们与其他桥梁的距离。</li><li>和OSPF算法相同的，这个标准是比较合适的，比之前OSPF要新，<strong>用固定的数值除以带宽来获得代价</strong></li></ul></li><li><p>STP状态的默认顺序为：</p><ol><li>阻塞：不转发帧，接收BPDU</li><li>监听：不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了</li><li>学习：不转发帧，学习地址</li><li>转发：转发帧，学习地址</li><li>禁用：不转发帧，不接收BPDU</li></ol></li><li><p>步骤</p><ul><li><p>步骤一：根交换机决定</p><ul><li>每个交换机都有一个优先级（Priority）值和一个唯一的MAC地址。首先，所有交换机都假定自己是根桥，广播一个BPDU（Bridge Protocol Data Unit）消息，其中包含了自己的优先级和MAC地址信息。</li><li>当其他交换机收到BPDU消息时，它们会比较收到的BPDU的根桥信息和自身的根桥信息，选择具有最小优先级和最小MAC地址的交换机作为根桥。这个过程会逐级传递，最终网络中的所有交换机都能得知根桥的信息。</li></ul></li><li><p>步骤2：选择根端口</p><ul><li><p>每个非根桥必须选择一个根端口</p></li><li><p>桥的根端口是最接近根桥的端口。</p></li><li><p>根路径成本是到根网桥的<strong>所有链接的累积成本。</strong></p></li></ul></li><li><p>步骤3：选择网段的指定端口</p><ul><li>每个网络段（两台交换机间的链路）上都会有一个指定端口，用于连接到生成树上。指定端口是具有最小根路径开销的端口。</li><li>如果有多个端口的根路径开销相同，则选择具有最小端口ID的端口作为指定端口。</li></ul></li></ul></li><li><p>解题技巧</p><ul><li>计算cost时，不能穿过自己</li><li>包含根的网段的指定端口一定是根交换机自己的端口</li></ul></li></ul><h3 id="VLAN-Virtual-Local-Area-Network-虚拟局域网"><a href="#VLAN-Virtual-Local-Area-Network-虚拟局域网" class="headerlink" title="VLAN(Virtual Local Area Network 虚拟局域网)"></a>VLAN(Virtual Local Area Network 虚拟局域网)</h3><ul><li><p>VLAN特点</p><ul><li>在第2层和第3层工作</li><li>控制网络广播，提供更严格的网络安全性</li><li>允许用户由网络管理员分配</li><li>VLAN<strong>创建一个不限于物理网段</strong>的单个广播域，并且将其视为子网</li><li>广播帧仅在具有相同VLAN ID的一个或多个交换机的端口之间切换。(VLAN ID属于端口)</li></ul></li><li><p>虚拟局域网中路由器的作用</p><ul><li>路由器为不同VLAN提供网关以实现不同VLAN之间的连接，可以用子接口，也可以用多个接口</li><li>交换机与路由器连接的端口设置为trunk：节约交换机端口，否则每个VLAN都需要一个端口</li><li>路由器将一个VLAN的帧转发到另一个VLAN时，接受帧的子接口会先解析标识，然后交给对应目标VLAN的子接口加上新的标记后转发</li></ul></li><li><p>设备连线</p><ul><li>PC控制路由器、交换机用全反线连接console口</li><li>同种类型（同层）设备之间使用交叉线连接，不同类型（不同层）设备间使用直通线连接</li><li>特例：PC和路由器看作同层，用交叉线连接</li></ul></li><li><p>虚拟局域网中帧的使用</p><ul><li><p>骨干网（BackBone）：用于VLAN间通信的区域，速度快</p></li><li><p>交换机根据帧中的数据做出过滤和转发决策</p></li><li><p>帧过滤：检查有关每个帧的特定信息（MAC地址或第3层协议类型）,特定的VLAN记录或者映射</p></li><li><p>帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符</p></li><li><p>标记过程：在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符，当帧到达终端之前删除该标记</p></li></ul></li><li><p>静态VLAN</p><ul><li>静态VLAN是指将交换机上的端口管理性地分配给VLAN</li><li>VLAN信息是写死在交换机的端口上的，基于端口</li></ul></li><li><p>动态VLAN</p><ul><li>当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口</li><li>基于MAC地址</li></ul></li><li><p>以端口为中心的VLAN</p><ul><li>同一VLAN的所有节点连接到路由器的同一个端口</li><li>使管理更容易</li></ul></li><li><p>交换机端口分类</p><ul><li>访问链接（access link）：只属于一个VLAN，且仅向该VLAN转发数据帧，一般与客户机连接</li><li>汇聚链接（Trunk Link）：主干链路能够支持多个VLAN，通常用于将交换机连接到其他交换机或路由器<ul><li><strong>一般Trunk就是BackBone</strong></li><li>骨干链路不属于特定的VLAN：充当交换机和路由器之间VLAN的通道</li><li>trunk口可以理解为两台交换机或路由器之间的通道，若无trunk口，每个VLAN都需要消耗交换机的一个接口，trunk相当于它们的汇集</li><li>一般将两台交换机间的连接端口设置为trunk，在帧出trunk端口时会被加上标记（VLAN标识符），进入另一个trunk端口后标记会在解析后被删除</li></ul></li></ul></li><li><p>解题注意</p><ul><li>同一VLAN中的两台主机可以跨越多台交换机</li><li>必须是第三层及以上的交换机才能用来构建VLAN</li><li>新交换机会有一个默认的vlan 1</li><li>vlan只能分割广播域，不能分割冲突域</li><li>每个vlan中都有一个分离的桥接表（bridging table）</li></ul></li></ul><h2 id="WAN-广域网"><a href="#WAN-广域网" class="headerlink" title="WAN(广域网)"></a>WAN(广域网)</h2><h3 id="广域网技术和服务"><a href="#广域网技术和服务" class="headerlink" title="广域网技术和服务"></a>广域网技术和服务</h3><ul><li><p>WAN Services 广域网服务</p><ul><li>定义:WAN是通过WAN服务提供商连接LAN的通信网络</li><li>WAN在OSI的前三层运行，但<strong>主要集中在物理和数据链路层</strong></li><li>广域网的最小单位是公司，一般由运营商完成</li></ul></li><li><p>物理结构</p><ul><li>通过Network远程接入，通过WSP提供的CO Switch来连接到中心局</li><li>CPE:位于公司本地的设备(主要是接入设备)，安装在用户的场所，用于连接到服务提供商网络</li><li>CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案</li><li>Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理</li><li>实际上实现了点对点的连接</li></ul></li><li><p>广域网虚拟电路</p><ul><li><p>广域网虚拟电路是一种在广域网中建立的逻辑通信路径，它允许在远距离的地理位置之间进行数据通信。虚拟电路是一种面向连接的通信方式，其中数据通过在网络中建立的虚拟通道进行传输。</p></li><li><p>三个阶段：</p><ol><li><p>电路建立–创建虚拟电路(逻辑确定)</p></li><li><p>数据传输–发送和接收用户数据(含有虚电路号等)，<strong>不会出现丢失和乱序问题，实现了可靠传输</strong></p></li><li><p>电路中断–拆除虚拟电路</p></li></ol></li></ul></li><li><p>广域网设备</p><ul><li>为了连接到专线(leased line)，客户必须具备以下条件：<ol><li>访问服务提供商的电路</li><li>可用的适当路由器端口</li><li>CSU&#x2F;DSU，调制解调器，ISDN终端适配器等</li></ol></li><li><img src="6.jpg" style="zoom:67%;" />- CSU：负责在用户设备和数字线路之间提供物理层连接的设备- DSU：负责在用户设备和数字线路之间提供数据链路层连接的设备- 这两者通常一起使用，合称为 "CSU/DSU"，它们提供了一个完整的连接，确保用户设备与数字通信线路之间的兼容性和有效通信</li></ul></li></ul><h3 id="广域网和OSI模型"><a href="#广域网和OSI模型" class="headerlink" title="广域网和OSI模型"></a>广域网和OSI模型</h3><ul><li>设备：<ul><li>DCE：代表 “Data Circuit-terminating Equipment”，它是用于连接到数字通信线路的设备，工作在物理层、数据链路层。DCE 通常是一种数字通信设备，负责提供物理连接、数据格式转换和时钟同步等功能，如调制解调器、CSU&#x2F;DSU。</li><li>DTE：代表 “Data Terminal Equipment”，数据终端设备。DTE 是指在数字通信系统中生成、处理或终结数据的设备，如计算机、终端、打印机、路由器或其他生成或处理数字数据的设备，工作在应用层、表示层和部分会话层</li><li><strong>DCE与 DTE 的连接：</strong><ul><li>用户设备（DTE，如计算机、路由器等）通过一个数据接口连接到 DCE。</li><li>DCE 然后连接到数字通信线路</li></ul></li></ul></li><li>物理层协议<ul><li>描述如何为WAN服务提供电气，机械，操作和功能连接的协议</li><li>描述数据终端设备和数据电路终端设备之间的接口</li><li>在此模型中，通过调制解调器或CSU&#x2F;DSU提供给DTE的服务</li></ul></li><li>数据链路层协议<ul><li>WAN数据链路协议描述了如何在单个数据链路上的系统之间承载帧</li><li><strong>点对点协议(PPP,Point-to-Point Protocol)</strong>：PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议)，根据不同的网络协议对帧做控制与检查</li><li><strong>高级数据链路控制(HDLC, High-Level Data Link Control)</strong>：不同供应商之间不兼容HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点&#x2F;多点配置(抽象规范和约束，各个厂商不同)</li><li><strong>帧中继(Frame Relay)</strong>：使用简化的封装，对高质量的数字设备不进行纠错</li><li><strong>ISDN</strong>：通过现有电话线传输语音和数据的一组数字服务</li><li><strong>平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)</strong>：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制。</li></ul></li></ul><h3 id="广域网访问方法"><a href="#广域网访问方法" class="headerlink" title="广域网访问方法"></a>广域网访问方法</h3><ul><li><p>PPP&#x2F;HDLC</p><ul><li>点对点的标准，工作在串行链路上（数据链路层）</li><li>如果都是同一个厂商的可以用HDLC，不然使用PPP</li><li>两者都是广域网点对点链路中的封装方式</li></ul></li><li><p>PPP 点对点协议  <strong>考点</strong></p><ul><li>串行链路上使用最广泛的第2层协议</li><li><strong>多协议支持：</strong> PPP 支持多种网络层协议，如 IP、IPv6等。</li><li><strong>可靠性：</strong> PPP 提供了一系列的错误检测和纠正机制，以确保数据的可靠传输。</li><li><strong>认证：</strong> PPP 支持用户身份验证，可以使用用户名和密码进行认证。</li></ul></li><li><p>PPP组件</p><ul><li>HDLC：封装第3层数据报的基础</li><li>LCP(链接控制协议Link Control Protocol)：建立连接、连接配置选项、链接质量测试</li><li>NCP(网络控制协议Network Control Protocol)：选择和配置第3层协议</li></ul></li><li><p>PPP帧格式</p><img src="10.jpg" style="zoom:50%;" /><ul><li>Flag: 01111110 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li><li>Address ：11111111，广播地址</li><li>Control ：00000011，用户数据作为无序帧传输</li><li>Protocol: 数据字段中的协议类型（既可以指网络层，又可以指数据链路层）</li><li>Data: 数据报，最大默认值为1500字节</li><li>FCS: 2或者4字节</li></ul></li><li><p>PPP会话建立&#x2F;终止</p><ul><li>为了通过点对点链路建立通信，PPP经历四个不同的阶段：<ol><li>步骤一:链接建立和配置协商(negotiation)(LCP)。</li><li>步骤二:链接质量测试。</li><li>步骤三:网络层协议配置(NCP)。</li><li>步骤四:链接终止。</li></ol></li><li><strong>链路建立阶段：</strong><ul><li>通信的第一步是链路建立阶段。在这个阶段，通信的两端（通常是两个路由器或计算机）通过 PPP 协议建立连接。</li><li>LCP（Link Control Protocol）运行在这个阶段，它负责协商链路的特性。这包括链路的最大帧大小、帧起始标志、帧校验序列（FCS）类型等。LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如<strong>压缩和身份验证协议</strong>等。</li></ul></li><li><strong>链路质量和参数协商：</strong><ul><li>在链路建立阶段，LCP 还负责检测链路的质量，发送和接收LCP数据包以测量链路上的错误率，并根据需要进行调整。它可以选择性地协商和改变链路特性，以适应网络的需求。</li><li>身份验证(如果使用)在网络层协议配置阶段开始之前进行</li><li>一旦 LCP 完成成功，链路建立阶段就结束，进入 NCP（Network Control Protocol）阶段。</li></ul></li><li><strong>网络层协议配置：</strong><ul><li>NCP 运行在链路建立后的阶段，其目标是协商和配置网络层协议。在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。</li><li>通信的两端通过 NCP 协商确定要在 PPP 连接上使用的网络层协议。一旦协商成功，通信的两端就可以开始在 PPP 连接上发送来自每个网络层协议的数据报。</li></ul></li><li><strong>连接终止阶段：</strong><ul><li>当数据传输完成或者需要终止连接时，通信的一方可以发起连接的终止。</li><li>LCP可以随时终止链接：应用户要求(一方请求终止)、链接质量、超时</li><li>LCP 可能会再次参与，协商关闭链路。在 PPP 连接终止阶段，LCP 和 NCP 都可能发挥作用。</li></ul></li></ul></li><li><p>PPP安全认证</p><ul><li>PAP 安全认证协议<ul><li>链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。</li><li>远程节点使用双向握手PAP建立其身份。</li><li>远程节点<strong>重复</strong>发送用户名&#x2F;密码对，直到确认身份验证或连接终止</li><li>密码以明文形式通过链接发送。</li><li>在建立连接阶段之后，仅对远程节点进行一次身份验证</li></ul></li><li>CHAP(Challenge Handshake Authentication Protocol)<ul><li><strong>挑战：</strong> 在连接建立时，认证服务器向客户端发送一个挑战，这是一个随机生成的字符串。挑战的目的是验证客户端是否知道共享的密钥。</li><li><strong>响应：</strong> 客户端收到挑战后，使用共享的密钥（通常是密码）对挑战进行哈希运算，生成一个响应字符串。客户端将这个响应字符串发送回认证服务器。</li><li><strong>验证：</strong> 服务器收到客户端的响应后，使用与客户端共享的密钥进行相同的哈希运算，然后比较计算出的响应与客户端发送的响应是否匹配。如果匹配，认证成功；否则，认证失败。</li><li><strong>周期性挑战：</strong> 为增强安全性，CHAP可以使用周期性挑战。在初始认证成功后，认证服务器可以定期发送新的挑战给客户端，要求客户端再次提供响应，以确保连接仍然是合法的。</li></ul></li></ul></li><li><p>综合数字服务网络(ISDN, Integrated Services Digital Networks)</p><ul><li>集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接</li><li>可以携带语音，视频和数据</li><li>服务有两种：BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP；PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD</li><li>BRI是ISDN的基本服务接口，提供两个B通道（Bearer Channels）和一个D通道（Data Channel）。每个B通道的带宽为<strong>64 Kbps</strong>，D通道的带宽为<strong>16 Kbps</strong>。因此，BRI总带宽为<strong>144 Kbps</strong>。</li><li>PRI是ISDN的高级服务接口，通常用于更大规模的组织。它提供了更多的B通道和更高的总带宽，通常为23个B通道和1个D通道，总带宽为1.544 Mbps（T1）或30个B通道和1个D通道，总带宽为2.048 Mbps（E1）。</li></ul></li><li><p>非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)</p><ul><li>xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</li><li>xDSL 的几种类型<ul><li>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</li><li>HDSL (High speed DSL)：高速数字用户线</li><li>SDSL (Single-line DSL)：1 对线的数字用户线</li><li>IDSL：ISDN用户线</li><li>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率</li></ul></li><li>ADSL的极限传输距离：与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系(用户线越细，信号传输时的衰减就越大)</li><li>ADSL特点：<ul><li>上行和下行带宽不对称:上行指从用户到ISP，而下行指从ISP 到用户，下载速度通常比上传速度快</li><li>ADSL在用户线(铜线)的两端各安装一个ADSL调制解调器，在用户端，调制器将数字数据转换为模拟信号，以适应电话线的传输特性。在ISP端，解调器将模拟信号转换回数字数据。</li><li>我国目前采用的方案是离散多音调（DMT） 调制技术，采用频分复用的方法</li><li>通常下行数据率在 32 kb&#x2F;s 到 6.4 Mb&#x2F;s 之间，而上行数据率在 32 kb&#x2F;s 到 640 kb&#x2F;s 之间。</li></ul></li></ul></li><li><p>其他广域网连接技术（应该不考，仅简写）</p><ul><li>同步光纤网SONET和同步数字系列SDH</li><li>光纤同轴混合网 HFC (Hybrid Fiber Coax)</li></ul></li></ul><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>被动攻击：截获信息的攻击称为被动攻击(并不改变通讯的过程)</li><li>主动攻击：更改信息和拒绝用户使用资源的攻击称为主动攻击</li><li>恶意程序<ul><li>计算机病毒:会”传染”其他程序的程序，”传染” 通过修改其他程序来把自身或其变种复制进去而完成。</li><li>计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)</li><li>特洛伊木马:一种程序，它执行的功能超出所声称的功能。运作木马获得特殊的权限</li><li>逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li></ul></li><li><img src="2-1746703748557.png" style="zoom:50%;" /></li></ul><h3 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h3><ul><li><strong>密码编码学</strong>(cryptography)：密码体制的设计学(设计密码)</li><li><strong>密码分析学</strong>(cryptanalysis)：在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。</li><li>对称密钥密码体系：常规密钥密码体制，即加密密钥与解密密钥是<strong>相同</strong>的密码体制</li><li>数据加密标准(DES Data Encryption Standard)：一种分组密码，属于常规密钥密码体制，详细略</li><li>公钥密码体制：使用<strong>不同的加密密钥与解密密钥(非对称密码体系)</strong></li><li>任何加密方法的安全性取决于<strong>密钥的长度</strong>，以及<strong>攻破密文所需的计算量</strong></li><li>数字签名：<ul><li>数字签名必须保证以下三点：<ol><li>报文鉴别:接收者能够核实发送者对报文的签名</li><li>报文的完整性:发送者事后不能抵赖对报文的签名</li><li>不可否认:接收者不能伪造对报文的签名</li></ol></li></ul></li></ul><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul><li><p>防火墙在互连网络中的位置</p><img src="6.png" style="zoom: 50%;" /></li><li><p>防火墙的功能与分类</p><ul><li>防火墙的功能有两个：<strong>阻止和允许</strong>。<ol><li><strong>阻止</strong>就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)</li><li><strong>允许</strong>的功能与<strong>阻止</strong>恰好相反</li></ol></li><li>防火墙的分类<ul><li><strong>网络级防火墙</strong>:用来防止整个网络出现外来非法的入侵。属于这类的有<strong>分组过滤和授权服务器</strong><ol><li>前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据</li><li>后者则检查用户的登录是否合法</li></ol></li><li><strong>应用级防火墙</strong>:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过</li></ul></li></ul></li></ul><h3 id="访问控制列表ACL-Access-Control-Lists"><a href="#访问控制列表ACL-Access-Control-Lists" class="headerlink" title="访问控制列表ACL(Access Control Lists)"></a>访问控制列表ACL(Access Control Lists)</h3><ul><li><p>概述</p><ul><li>ACL是指令列表，它告诉<strong>路由器</strong>允许或拒绝什么类型的数据包</li><li>如果要让路由器拒绝某些数据包，则必须配置ACL。否则只要链路打开，路由器将接受并转发所有数据包</li></ul></li><li><p>入站ACL过程</p><ul><li>收到数据包时，按照ACL列表逐个语句比对</li><li>当一个语句”匹配”时，<strong>不再评估任何语句</strong>。(前面的语句先匹配，处理掉)</li><li>ACL末尾有一个隐含的”deny any”语句：如果数据包与ACL中的任何语句都不匹配，则将其丢弃</li></ul></li><li><p>出站ACL过程</p><ul><li>检查数据包是否可路由。如果是这样，请在路由表中查找路由</li><li>检查出站接口的ACL：如果没有ACL，则将数据包切换出目标接口；如果有ACL，匹配<strong>源地址</strong></li></ul></li><li><p>ACL分类</p><img src="8-1746703752741.png" style="zoom:50%;" /><ul><li><p>ACL命令：<code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></p><ul><li><p>在ACL的<code>&#123;test condition&#125;</code>部分中，大多数访问列表的共同点是源地址和通配符掩码</p></li><li><img src="image-20231229125458373.png" alt="image-20231229125458373" style="zoom:67%;" /></li><li><p>通配符掩码和子网掩码是取反关系（如子网掩码为255.255.255.224，通配符掩码为0.0.0.31）</p></li><li><p>源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为IP掩码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">//拒绝来自192.168.2.0/24的流量<br>Router(config)# access-list 2 deny 192.168.2.0 0.0.0.255<br>Router(config)# access-list 2 permit any<br><br>//拒绝来自主机 192.168.1.10 的流量<br>Router(config)# access-list 1 deny host 192.168.1.10<br>Router(config)# access-list 1 permit any<br>//拒绝某主机也可用：<br>Router(config)#access-list 1 permit 192.5.5.10 0.0.0.0<br></code></pre></td></tr></table></figure></li></ul></li><li><img src="10-1746703757308.png" style="zoom:67%;" /><blockquote><ol><li>IP mask ：IPv4的地址</li><li><strong>Wildcard mask</strong>:和netmask是不同的，指示哪些位置被检查</li></ol></blockquote></li></ul></li></ul><ul><li><p>标准ACL：序号通常在1到99之间，仅检查源IP地址</p></li><li><p>扩展ACL：序号通常在100到199之间，可检查源和目标IP地址、协议类型、端口号等信息</p></li><li><p><strong>标准ACL靠近目的，拓展ACL靠近源</strong></p></li></ul><ul><li><p>常见端口号</p><ul><li><img src="13-1746703759203.png" style="zoom:67%;" /></li><li><strong>DHCP (Dynamic Host Configuration Protocol):</strong><ul><li>服务端口：67</li><li>客户端端口：68</li></ul></li><li><strong>HTTP (HyperText Transfer Protocol):</strong><ul><li>默认端口：80</li></ul></li><li><strong>HTTPS (HTTP Secure):</strong><ul><li>默认端口：443</li></ul></li><li><strong>POP3 (Post Office Protocol version 3):</strong><ul><li>默认端口：110</li></ul></li><li>注：20也是FTP的端口号，21用于建立连接，20用于传输数据</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/12/05/test/"/>
    <url>/2023/12/05/test/</url>
    
    <content type="html"><![CDATA[<p>RPC</p><ul><li>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</li><li>步骤：客户端调用-&gt;请求发送(序列化) -&gt; 服务器接受并处理(反序列化) -&gt; 结果返回(序列化) -&gt; 客户端接收结果(反序列化)</li><li>常见的 RPC 框架：gRPC、Thrift、Dubbo</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
