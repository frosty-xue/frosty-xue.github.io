

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/fluid.png">
  <link rel="icon" href="../../../../img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Frosty">
  <meta name="keywords" content="">
  
    <meta name="description" content="2. Java2.1 Java基础 Java的特点：平台无关性、面向对象、内存管理  JVM、JRE、JDK   JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JRE是Java运行时环境，JDK是Java开发工具包   Java解释和编译  编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用 解释性">
<meta property="og:type" content="article">
<meta property="og:title" content="Java八股">
<meta property="og:url" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Frosty的技术博客">
<meta property="og:description" content="2. Java2.1 Java基础 Java的特点：平台无关性、面向对象、内存管理  JVM、JRE、JDK   JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JRE是Java运行时环境，JDK是Java开发工具包   Java解释和编译  编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用 解释性">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/image-20250331094625361.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/image-20250331121506850.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/image-20250331121606829.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/image-20250412111148416.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/05/13/Java%E5%85%AB%E8%82%A1/image-20250421194434463.png">
<meta property="article:published_time" content="2025-05-13T10:22:30.000Z">
<meta property="article:modified_time" content="2025-05-13T11:08:27.068Z">
<meta property="article:author" content="Frosty">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java虚拟机">
<meta property="article:tag" content="Java集合">
<meta property="article:tag" content="Java并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png">
  
  
  
  <title>Java八股 - Frosty的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"frosty-xue.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Frosty的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java八股"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-13 18:22" pubdate>
          May 13, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          59 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java八股</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="2-Java"><a href="#2-Java" class="headerlink" title="2. Java"></a>2. Java</h2><h3 id="2-1-Java基础"><a href="#2-1-Java基础" class="headerlink" title="2.1 Java基础"></a>2.1 Java基础</h3><ul>
<li><p>Java的特点：平台无关性、面向对象、内存管理</p>
</li>
<li><p>JVM、JRE、JDK</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" srcset="/img/loading.gif" lazyload alt="image-20240725230247664" style="zoom: 33%;" /></li>
<li>JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JRE是Java运行时环境，JDK是Java开发工具包</li>
</ul>
</li>
<li><p>Java解释和编译</p>
<ul>
<li>编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用</li>
<li>解释性：JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件</li>
<li><img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>使用BigDecimal而不是double的情景：涉及金钱等需要精确计算的情况</p>
</li>
<li><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，如int和Integer。在Java中，泛型只能使用引用类型，而不能使用基本类型，因此需要使用包装类。基本类型数据在读写效率方面，要比包装类高效，且占用空间少。</p>
</li>
<li><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。</p>
</li>
<li><p>Java面向对象的三大特性包括：<strong>封装、继承、多态</strong></p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。</li>
<li><strong>继承</strong>：继承是一种可以使得子类自动共享父类数据结构和方法的机制，是代码复用的重要手段</li>
<li><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写），接口和对象类型转换也体现了多态。</li>
</ul>
</li>
<li><p>面向对象编程中的六大原则：</p>
<ul>
<li><img src="image-20250331094625361.png" srcset="/img/loading.gif" lazyload alt="image-20250331094625361"></li>
</ul>
</li>
<li><p>普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。抽象类中的方法可以有实现也可以没有实现。抽象类用于描述类的共同特性和行为，接口只描述行为。</p>
</li>
<li><p>Java不允许多继承，但是可以实现多个接口。接口成员变量默认为public static final，必须赋初值，不能被修改，所有的成员方法都是public、abstract的。在接口中，不可以有构造方法。</p>
</li>
<li><p>静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</p>
</li>
<li><p>使用静态变量、方法的好处</p>
<ul>
<li>不依赖对象实例，节省内存，提高性能</li>
<li>方便全局访问，易于调用和管理</li>
<li>实现类级别的数据共享</li>
</ul>
</li>
<li><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p>
</li>
<li><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类（不能继承）、方法（不能重写）和变量（不能再赋值）。</p>
</li>
<li><p>实现对象深拷贝的方法：实现 Cloneable 接口并重写 clone() 方法、实现 Serializable 接口进行序列化和反序列化、手动递归复制</p>
</li>
<li><p>Java中创建对象的方式：new、反射（Class类的newInstance()和Constructor类的newInstance()）、clone()、序列化和反序列化</p>
</li>
<li><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性</p>
</li>
<li><p>Java注解：注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的<strong>动态代理类</strong>。作用域为类、方法、字段。</p>
</li>
<li><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" /></li>
<li><p>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。throws关键字：用于在方法声明中声明可能抛出的异常类型。</p>
</li>
<li><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理。finally子块中的代码<strong>一定会执行</strong>，即使在try&#x2F;catch中写了return语句也会被finally覆盖</p>
</li>
<li><p>重写 <code>equals</code> 方法时必须重写 <code>hashCode</code> 方法，equals为true则hashcode一定相同，反之不成立（哈希冲突）</p>
</li>
<li><p><code>StringBuilder</code> 不是线程安全的，<code>StringBuffer</code> 是线程安全的（用了synchronized）</p>
</li>
<li><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。它对应的并行流是 ParallelStream。</p>
</li>
<li><p>把一个对象从一个jvm传到另一个jvm：序列化和反序列化、消息队列、网络套接字、rpc、共享数据库或缓存</p>
</li>
<li><p>单例模式</p>
</li>
</ul>
<ul>
<li>lazy初始化的含义是指在调用<code>getInstance()</code>时才进行初始化<ul>
<li>volatile主要包含两个功能：保证修饰的变量对所有线程的可见性，禁止指令重排序优化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123; <br>    	<span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <br>	        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>    	        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <br>        	        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>            	&#125; <br>        	&#125; <br>    	&#125; <br>    	<span class="hljs-keyword">return</span> singleton;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Java NIO（non-blocking IO）、AIO（Asynchronous IO）、BIO（blocking IO）</p>
<ul>
<li>NIO是一种<strong>同步非阻塞</strong>的I&#x2F;O模型，也是<strong>I&#x2F;O多路复用</strong>的基础，可以只用一个线程处理多个客户端I&#x2F;O。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务</li>
<li>AIO是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，是基于事件和回调机制实现的</li>
<li>BIO是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里</li>
<li><img src="image-20250331121506850.png" srcset="/img/loading.gif" lazyload alt="image-20250331121506850"></li>
</ul>
</li>
<li><p>native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码</p>
</li>
</ul>
<p><img src="image-20250331121606829.png" srcset="/img/loading.gif" lazyload alt="image-20250331121606829"></p>
<h3 id="2-2-Java集合"><a href="#2-2-Java集合" class="headerlink" title="2.2 Java集合"></a>2.2 Java集合</h3><ul>
<li><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
<li><p>线程安全集合</p>
<ul>
<li><strong>Vector</strong>：线程安全的动态数组，内部方法基本都经过synchronized修饰</li>
<li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体。其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素</li>
<li><strong>Hashtable</strong>：线程安全的哈希表，给每个方法加上 synchronized 关键字。由于同步导致的性能开销，所以已经很少被推荐使用，可以用ConcurrentHashMap。</li>
<li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是二者加锁粒度的不同。JDK1.7加段锁，1.8换成行级锁</li>
<li><strong>ConcurrentSkipListMap</strong>：实现了一个基于SkipList（跳表）的可排序的并发集合</li>
<li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li>
<li><strong>CopyOnWriteArraySet</strong>：是线程安全的Set实现，它是线程安全的无序的集合</li>
<li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。</li>
<li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。它提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。生产进程同理。</li>
<li>同样也有<strong>ConcurrentLinkedDeque</strong>和<strong>BlockingDeque</strong></li>
</ul>
</li>
<li><p>集合遍历方法：普通带索引for循环、for-each、迭代器、forEach方法、Stream API</p>
</li>
<li><p>hashmap的put过程：</p>
<ul>
<li>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。</li>
<li>第二步：检查该位置是否为空（即没有键值对存在）</li>
<li>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</li>
<li>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键。如果找到了相同的键，则使用新的值取代旧的值。如果没有找到相同的键，则将新的键值对添加到链表的头部。红黑树同理。</li>
<li>第五步：检查链表长度是否达到阈值（默认为8），达到要转换成红黑树</li>
<li>第六步：检查负载因子是否超过阈值（默认为0.75）</li>
<li>第七步：扩容操作<img src="image-20250412111148416.png" srcset="/img/loading.gif" lazyload alt="image-20250412111148416" style="zoom: 67%;" /></li>
<li>第八步：完成添加操作。</li>
</ul>
</li>
<li><p>HashMap在多线程下可能会出现的问题：JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。此外，多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p>
</li>
<li><p>HashMap默认容量：JDK1.7的时候初始容量是16，但是JDK1.8的时候初始化HashMap的时候并没有指定容量大小，而是在第一次执行put数据，才初始化容量。</p>
</li>
<li><p>ConcurrentHashMap实现：</p>
<ul>
<li>JDK 1.7 中使用是数组加链表的形式实现，而数组又分为：大数组 Segment 和小数组 HashEntry。一个 ConcurrentHashMap 里包含一个 Segment <strong>数组</strong>，一个 Segment 里包含一个 HashEntry <strong>数组</strong>。分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li>JDK 1.8 使用了数组 + 链表&#x2F;红黑树的方式优化了实现，主要通过 volatile + CAS 或者 synchronized 来实现线程安全</li>
<li>CAS是指compare and swap，意识是指一个旧的预期值A,主内存的值是B，要修改的值C，当且仅当A&#x3D;&#x3D;B的时候，A的值才会被修改成C，而且这个操作是<strong>原子性</strong>的，是一个非阻塞性的 <strong>乐观锁</strong>。在Java中，CAS操作主要依赖于<em>Unsafe</em>类，该类提供了硬件级别的原子操作支持。Unsafe类中的<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>方法用于实现CAS操作</li>
<li>添加元素时首先会判断容器是否为空：<ul>
<li>如果为空则使用 <strong>volatile 加 CAS （乐观锁）</strong> 来初始化</li>
<li>如果容器不为空，则根据存储的元素计算该位置是否为空(键值)</li>
<li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点</li>
<li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-Java并发编程"><a href="#2-3-Java并发编程" class="headerlink" title="2.3 Java并发编程"></a>2.3 Java并发编程</h3><ul>
<li>Java的线程安全在三个方面体现：原子性、可见性、有序性</li>
<li>保证数据的一致性的方案：事务机制、锁、版本号</li>
<li>线程的创建方式：继承thread类、实现runnable接口、使用线程池（Executor框架）</li>
<li>调用 <code>Thread.sleep()</code> 时，线程会释放 CPU，主动让出 CPU 时间片，但不会释放持有的锁。调用<code>wait</code>方法时，线程<strong>会释放持有的对象锁</strong>，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它</li>
<li>blocked状态不会使进程释放之前持有的锁，而waiting状态会</li>
<li>线程间通信方式<ul>
<li>Object 类的 wait()、notify() 和 notifyAll() 方法</li>
<li><code>Lock</code> 和 <code>Condition</code> 接口。<code>Lock</code> 接口提供了比<code>synchronized</code> 更灵活的锁机制，<code>Condition</code> 接口则配合 <code>Lock</code> 实现线程间的等待 &#x2F; 通知机制。Condition相当于条件变量，执行<code>await()</code>方法和<code>signal()</code>方法；Lock是锁，执行<code>lock()</code>和<code>unlock()</code>。</li>
<li><code>volatile</code> 关键字。当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新的值。</li>
<li>Semaphore。<code>Semaphore</code> 是一个计数信号量，它可以控制同时访问特定资源的线程数量。构造函数为<code>Semaphore(int permits)</code>，<code>acquire()</code>对应P操作，<code>release()</code>对应V操作</li>
<li>CountDownLatch和CyclicBarrier略。</li>
</ul>
</li>
<li>Thread的<code>interrupt()</code>方法不会立刻终止线程，只是设置中断标志位。线程需手动检查中断状态（<code>isInterrupted()</code>）或触发可中断操作（如<code>sleep()</code>，<code>wait()</code>，<code>join()</code>)响应中断。阻塞操作中收到中断请求时，会抛出 <code>InterruptedException</code> 并清除中断状态</li>
<li>在多线程编程中，join() 方法用于确保一个线程在另一个线程完成之前不会继续执行。具体来说，当一个线程调用另一个线程的 join() 方法时，调用线程将被阻塞，直到被调用的线程完成执行</li>
<li>线程池相关类<ul>
<li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等</li>
<li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池</li>
</ul>
</li>
<li><code>ThreadLocal</code>类<ul>
<li>可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</li>
<li><img src="1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></li>
<li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key<strong>是</strong>ThreadLocal<strong>本身</strong>，value是ThreadLocal的泛型对象值。</li>
<li>当一个线程结束时，其<code>ThreadLocalMap</code>也会随之销毁，但是<code>ThreadLocal</code>对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。因此，在使用<code>ThreadLocal</code>时需要注意，如果不显式调用<code>remove()</code>方法，或者线程结束时未正确清理<code>ThreadLocal</code>变量，可能会导致内存泄漏</li>
</ul>
</li>
<li>实现线程同步的方法：synchronized、Lock(ReentrantLock)、volatile、Atomic类</li>
<li>Atomic类在实现细节上利用了CAS实现无锁的线程安全</li>
<li>锁机制相关<ul>
<li><strong>乐观锁和悲观锁</strong>：悲观锁通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。<code>synchronized</code>和<code>ReentrantLock</code>都是悲观锁的例子。乐观锁通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用CAS、版本号或时间戳来实现。</li>
<li><strong>自旋锁</strong>是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但<strong>过度自旋会浪费CPU资源</strong>。</li>
<li>“<strong>可重入</strong>”意味着同一个线程对同一把锁可以多次获取而不会死锁</li>
<li><strong>公平锁和非公平锁</strong>：公平锁指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。非公平锁中多个线程加锁时先通过 <strong>CAS</strong> 尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。非公平锁避免了线程休眠和恢复的操作，减少了内核态和用户态的切换，因此吞吐量更大。</li>
<li>偏向锁：对象在被某个线程第一次获取锁（例如 synchronized）时，JVM 会把这个线程的ID记录在对象头（Mark Word）中，将锁“偏向”这个线程。之后这个线程再次进入同步块时，只需检查对象头中记录的线程ID等于自己，无需做任何同步操作。</li>
<li>轻量级锁：将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁，该过程可以自旋（有次数限制）。出临界区同样也要用CAS进行替换。</li>
<li>重量级锁：线程会被操作系统调度然后挂起，这可以节约CPU资源。</li>
<li><img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" srcset="/img/loading.gif" lazyload alt="image.png" style="zoom:40%;" /></li>
</ul>
</li>
<li>Lock类相关<ul>
<li><code>ReentrantLock</code> 是 Java 并发包（<code>java.util.concurrent.locks</code>）中的一个可重入互斥锁实现，它提供了比 <code>synchronized</code> 关键字更灵活、更强大的锁机制。它支持设置超时时间，公平和非公平策略(默认是非公平锁)，且支持多个条件变量（<code>Condition condition = lock.newCondition();</code>）。</li>
<li><code>ReadWriteLock</code>接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</li>
<li><code>ReentrantLock</code>基于AQS(AbstractQueuedSynchronizer)实现。AQS 是一个用于构建锁和同步器的基础框架，它通过一个先进先出的等待队列管理多个线程的同步操作。</li>
<li>ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。</li>
<li>ReentrantLock的tryLock() 方法不遵守设定的公平原则</li>
</ul>
</li>
<li>synchronized相关<ul>
<li>synchronized修饰普通方法锁的是当前实例，而修饰静态方法锁的是class对象</li>
<li>synchronized 工作原理：基于对象的监视器锁。监视器锁是关联在某个对象上的锁，当线程执行同步代码时需要先获得该对象的监视器锁。主要依赖于字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>，分别是获取和释放监视器锁</li>
<li>synchronized 属于<strong>非公平锁</strong></li>
<li>synchronized是可重入锁，底层是利用系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。</li>
<li>锁膨胀：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，属于JVM对synchronized的优化</li>
</ul>
</li>
<li>CAS<ul>
<li>CAS 是一种乐观锁机制，它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS 操作的逻辑是，如果内存位置 V 的值等于预期值 A，则将其更新为新值 B，否则不做任何操作。</li>
<li>CAS的缺点主要有3点：<ul>
<li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A。</li>
<li><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行</li>
</ul>
</li>
<li>Java 提供的工具类会在 CAS 操作中增加<strong>版本号</strong>以避免ABA问题</li>
</ul>
</li>
<li>volatile并不能解决多线程并发下的复合操作问题，比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。</li>
<li>死锁条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>，即给资源设置全局获取顺序。</li>
<li>线程池<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 80%;" /></li>
<li>线程池参数：<ul>
<li><strong>corePoolSize</strong>：线程池核心线程数量</li>
<li><strong>maximumPoolSize</strong>：线程池中最多可容纳的线程数量。</li>
<li><strong>keepAliveTime</strong>：线程数超过核心数时启用，空闲时间超过被销毁</li>
<li><strong>unit</strong>：就是keepAliveTime时间的单位</li>
<li><strong>workQueue</strong>：工作队列。</li>
<li><strong>threadFactory</strong>：线程工厂。可以用来给线程取名字等等</li>
<li><strong>handler</strong>：拒绝策略。可以用预置的也可以自定义</li>
</ul>
</li>
<li>预置拒绝策略<ul>
<li>CallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务</li>
<li>AbortPolicy，直接抛出一个任务被线程池拒绝的异常</li>
<li>DiscardPolicy，不做任何处理，静默拒绝提交的任务</li>
<li>DiscardOldestPolicy，抛弃最老的任务，然后执行该任务</li>
</ul>
</li>
<li>线程池种类<ul>
<li>ScheduledThreadPool：可以定期执行任务，比如每隔 10 秒钟执行一次</li>
<li>FixedThreadPool：核心线程数和最大线程数一样</li>
<li>CachedThreadPool：线程数是几乎可以无限增加的</li>
<li>SingleThreadExecutor：它会使用唯一的线程去执行任务，任务按被提交的顺序依次执行</li>
<li>SingleThreadScheduledExecutor：定期 + 唯一线程</li>
</ul>
</li>
<li>线程池关闭方法：shutdown ()，shutdownNow()。前者使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断，再提交任务会抛异常。后者置状态为STOP，并通过调用 Thread.interrupt() 方法，试图停止所有正在执行的线程（可能无法成功），不再处理还在池队列中等待的任务，它会返回那些未执行的任务列表(<code>List&lt;Runnable&gt;</code>)</li>
<li>提交的任务可以通过返回的Future对象的<code>cancel(boolean mayInterruptIfRunning)</code>方法取消，参数为ture允许中断正在执行的任务</li>
</ul>
</li>
</ul>
<h3 id="2-4-Java虚拟机"><a href="#2-4-Java虚拟机" class="headerlink" title="2.4 Java虚拟机"></a>2.4 Java虚拟机</h3><ul>
<li><p>JVM内存模型</p>
<ul>
<li>根据 JDK 8 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，通过 NIO 类引入，属于操作系统的本地内存，也是可以直接操作的。</li>
<li><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" /></li>
<li><strong>程序计数器</strong>：存储当前线程正在执行的 Java 方法的 JVM 指令地址</li>
<li><strong>虚拟机栈</strong>：每个线程都有自己独立的 Java 虚拟机栈，生命周期与线程相同，用于存储局部变量表、操作数栈、动态链接、方法出口</li>
<li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务</li>
<li><strong>堆</strong>：被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</li>
<li><strong>元空间</strong>：从Java 8开始，永久代被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息、方法的字节码等）。</li>
<li>一些细节<ul>
<li>创建一个对象时，对象的<strong>引用</strong>在当前方法的栈上，对象的<strong>实例</strong>在堆上</li>
<li>类的<strong>class对象</strong>存储在<strong>堆</strong>上(Java 8及以后)，元空间存的是类的<strong>字节码和类元数据</strong>而非对象。而在Java7及以前这两个都存在永久代中</li>
<li>在 Java 8 及以后，静态变量存储在<strong>堆</strong>中，和它所在的class对象在一起</li>
<li>在 Java 8 及以后，字符串常量池被移动到 Java <strong>堆</strong>中（实际的字符串值），而这些常量的符号引用存储在元空间</li>
</ul>
</li>
</ul>
</li>
<li><p>堆相关</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" /></li>
<li><strong>新生代</strong>：新生代分为Eden Space和Survivor Space。大多数新创建的对象首先存放在Eden Space中，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间</li>
<li><strong>老年代</strong>：存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低</li>
<li>大对象通常会直接分配到老年代，有助于减少内存碎片的产生</li>
</ul>
</li>
<li><p>引用类型主要分为强引用（一般的赋值）、软引用（内存溢出前回收）、弱引用（每次GC都会回收，用于缓存系统）、虚引用四种</p>
</li>
<li><p>内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。发生情景：静态属性、未关闭的资源、ThreadLocal</p>
</li>
<li><p>创建对象过程</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>类加载器与双亲委派模型</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 40%;" /></li>
<li><strong>启动类加载器</strong>：最顶层的类加载器，负责加载Java的核心库，是JVM的一部分</li>
<li><strong>扩展类加载器</strong>：是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录下的包和类库。扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</li>
<li><strong>系统类加载器&#x2F; 应用程序类加载器</strong>：是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是我们平时编写Java程序时默认使用的类加载器。</li>
<li>双亲委派模型：核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</li>
<li>双亲委派模型的作用：保证类的唯一性，防止用户自定义类覆盖核心类库；保证安全性，只加载信任的类；支持不同层次的类加载器服务于不同的类加载需求，简化流程</li>
</ul>
</li>
<li><p>类加载过程</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 55%;" /></li>
<li>加载：将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象）</li>
<li>连接：验证（符合JVM规范）、准备（创建并为静态变量赋0值）、解析（将符号引用转换为直接引用）</li>
<li>初始化：执行类的构造器方法（编译器自动生成的）</li>
</ul>
</li>
<li><p>判断垃圾算法</p>
<ul>
<li>引用计数法：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。无法处理循环引用。</li>
<li>可达性分析算法（主要）：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连，那么这个对象就被认为是不可达的，可以被回收。</li>
<li><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>垃圾回收算法</p>
<ul>
<li><strong>标记-清除算法</strong>：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。缺点是效率不高和内存碎片。</li>
<li><strong>复制算法</strong>：将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上，然后将然后再把已使用的内存整个清理掉。缺点是只能用一半，内存利用率不足</li>
<li><strong>标记-整理算法</strong>：“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理，而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</li>
<li><strong>分代回收算法</strong>：分代收集是将内存划分成了新生代和老年代。当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。年龄超过阈值（默认15）进入老年代。</li>
</ul>
</li>
<li><p>垃圾回收器</p>
<ul>
<li><img src="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" /></li>
<li>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段</li>
<li>STW(Stop The World)：指垃圾回收时停止应用线程的阶段，G1中包括初始标记阶段、再标记阶段、清理阶段、复制(转移)阶段<ul>
<li><img src="image-20250421194434463.png" srcset="/img/loading.gif" lazyload alt="image-20250421194434463" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>GC分类</p>
<ul>
<li>Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC</li>
<li>Full GC触发条件：直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法、Minor GC时老年代放不下存活的对象、元空间的空间不足时</li>
</ul>
</li>
<li><p>除了堆，GC也会对元空间（方法区）进行垃圾回收</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" class="category-chain-item">Java面试八股文</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/Java/" class="print-no-link">#Java</a>
      
        <a href="../../../../tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="print-no-link">#Java虚拟机</a>
      
        <a href="../../../../tags/Java%E9%9B%86%E5%90%88/" class="print-no-link">#Java集合</a>
      
        <a href="../../../../tags/Java%E5%B9%B6%E5%8F%91/" class="print-no-link">#Java并发</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java八股</div>
      <div>https://frosty-xue.github.io/2025/05/13/Java八股/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Frosty</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 13, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" title="计网八股">
                        <span class="hidden-mobile">计网八股</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
