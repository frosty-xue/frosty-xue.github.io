

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/fluid.png">
  <link rel="icon" href="../../../../img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Frosty">
  <meta name="keywords" content="">
  
    <meta name="description" content="软件系统设计整理(架构部分)">
<meta property="og:type" content="article">
<meta property="og:title" content="软件系统设计整理(架构部分)">
<meta property="og:url" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="Frosty的技术博客">
<meta property="og:description" content="软件系统设计整理(架构部分)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/1.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250528202710016.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/45ed3af0f45c4fdb8500c92a0d7455a3.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530192359706.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/7.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529195836443.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/5.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529153004954.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529154100715.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529153805503.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529183555510.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529185634800.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529183844839.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529184529017.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529185615365.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529185027406.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529185416629.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529185703769.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529191237976.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529191903342.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529192206966.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529192602450.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529192822172.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529193135500.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529194315617.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529194826560.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529195328527.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529195644114.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530200152966.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529202144119.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/v2-03b6d52599d7a97b4362ca83bbffd96d_r.jpg">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529202959043.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250529203220288.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530103446068.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/v2-d01cefd6ccd37b11d6bd6192349a31fb_1440w.jpg">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530104235595.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530105059192.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530110643885.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530111230616.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530111902992.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530122749200.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530123151554.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530142622943.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530144434061.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530162639760.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530163124749.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530163341259.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250531122914808.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250531122934220.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530164414125.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250602174120502.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250531124625876.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250530171428382.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/image-20250531144609140.png">
<meta property="article:published_time" content="2025-06-03T00:50:12.000Z">
<meta property="article:modified_time" content="2025-06-03T07:08:55.718Z">
<meta property="article:author" content="Frosty">
<meta property="article:tag" content="软件系统设计">
<meta property="article:tag" content="软件架构">
<meta property="article:tag" content="质量属性">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://frosty-xue.github.io/2025/06/03/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86/1.png">
  
  
  
  <title>软件系统设计整理(架构部分) - Frosty的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"frosty-xue.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Frosty的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="软件系统设计整理(架构部分)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-03 08:50" pubdate>
          June 3, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          138 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">软件系统设计整理(架构部分)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="软件系统设计整理-架构部分"><a href="#软件系统设计整理-架构部分" class="headerlink" title="软件系统设计整理(架构部分)"></a>软件系统设计整理(架构部分)</h1><span id="more"></span>

<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><ul>
<li>理解软件工程<ul>
<li>软件和硬件：<ul>
<li>软件是不可见的：软件是虚拟的，而硬件是实体的。</li>
<li>软件制作出来就是为了被修改和改变的(软件的演化是他的本质属性)</li>
</ul>
</li>
<li>科学和工程<ul>
<li>科学的研究是研究这个世界既有的部分，而工程是研究的是人类创造新的世界(是不是因为人才产生的)，下面的图是很重要的。</li>
<li><img src="1.png" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：Architecture可以翻译为架构，也可以是体系结构</p>
</blockquote>
<ul>
<li><p><strong>什么是软件架构</strong> Software Architecture 重要</p>
<ul>
<li>定义1：程序或计算系统的软件架构是系统的一个或多个结构，其中包括<strong>软件组件</strong>，这些<strong>组件的外部可见属性</strong>以及<strong>它们之间的关系</strong></li>
<li>定义2：系统的基本组织，体现在其<strong>组件</strong>，<strong>它们之间的相互关系</strong>以及<strong>环境</strong>以及<strong>支配其设计和演进的原则</strong>。</li>
<li>架构的一些概念<ul>
<li>Module，模块 是还没有实现出来的软件部分。</li>
<li>Component，组件 是已经实现出来的软件部分。</li>
<li>Connector，连接件 ：连接组件的部分</li>
<li>Element，元素：包含 Component和 Connector。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>架构与设计</strong> Architecture vs. Design 重要</p>
<ul>
<li>架构是属于软件设计的<ul>
<li>所有的架构都是软件设计，但不是所有的软件设计都是架构</li>
<li>架构是设计过程的一个部分</li>
</ul>
</li>
<li>其他观点<ul>
<li>架构是更高层的设计</li>
<li>架构是设计决策的组合</li>
<li>架构是根据不同项目而不同的</li>
</ul>
</li>
<li>系统的结构或组织<ul>
<li>元素(Elements)：部件(Components)和连接件(Connectors)</li>
<li>关系：静态(static)和动态(dynamic)的关系</li>
<li>属性：元素，元素组和整个系统</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>架构与结构</strong> Architecture vs. Structure 重要</p>
<ul>
<li>架构是包含结构信息的。结构是一种静态的、逻辑的、是关于系统如何构成的。架构除了包含结构，还会包含组件之间的相关的关系结构，还会定义一些动态的行为（组件可能和谁进行交互）</li>
<li>架构将系统分解成组件、模块和子系统，降低每一个部分的复杂度</li>
<li>架构定义了组件接口（组件可以干什么）、 组件交流和依赖（组件间如何沟通交流） 、 组件职责 （当我们询问它时，组件能明确知道自己的职责）</li>
<li>架构确定通信、通信需要<br>i. 数据通过机器传递，比如函数调用、 RMI、异步信息等<br>ii. 控制流， 组件的信息流来满足 需要的功能，比如序列化、并发并行和同步等。</li>
<li>架构强调 NFA（非功能性需求）<br>i. 功能性需求定义了系统能做什么，NFA定义了系统运行的多好<br>ii. NFA（又名架构需求 Architecture requirements 很少在功能性需求中被发现 ，必须由架构引出，包括：技术约束、商业约束、质量属性</li>
</ul>
</li>
<li><p>架构与软件架构</p>
<ul>
<li>架构的作用仍然保持一致： 倾听用户理解需求、 检查灵活性、形成实际结构版本创建蓝图 、监督构建过程保证计划符合规范、引导暴风雨式的设计变更、危机和歧义。</li>
<li>软件架构是监督软件的构造过程：开发人员、工程师和设计者。</li>
</ul>
</li>
<li><p><strong>软件系统架构的来源</strong> 重要</p>
<ul>
<li>NFRs、ASRs（<strong>关键架构需求</strong> architecturally significant requirement，ASR）、质量需求、涉众、组织、技术环境等等</li>
</ul>
</li>
<li><p><strong>架构师的职责</strong> 重要</p>
<ul>
<li><strong>联络</strong><ul>
<li>在客户、技术团队和业务&#x2F;需求分析师之间</li>
<li>与管理层或市场部门</li>
</ul>
</li>
<li><strong>软件工程</strong><ul>
<li>软件工程最佳实践</li>
</ul>
</li>
<li><strong>技术知识</strong><ul>
<li>对技术领域的深入理解</li>
</ul>
</li>
<li><strong>风险管理</strong><ul>
<li>与设计、技术选择相关的风险</li>
</ul>
</li>
</ul>
</li>
<li><p>如何创建一个设计</p>
<ul>
<li>设计活动目标：生成一个适应约束并且达到系统质量和业务目标的设计</li>
<li>广义设计策略<ol>
<li>分解 ：针对某一个系统关注点进行分解后处理。<ul>
<li>质量属性可以分解 ，并分配给分解后的元素</li>
<li>如何对非 ASR进行设计 ASR仅意味着需求的优先级仍然可以满足非 ASR 需求来满足其他人 ，除非您即将满足需求 、需要重新确定需求优先级并重新设计，和您不能满足需求</li>
<li>一次设计所有的ASR还是一个ASR？通过经验和教育 ，我们会有直观的设计方法 ，并使用模式&#x2F;策略来设计多个ASR</li>
</ul>
</li>
<li>抽象：使用抽象让设计师关注本身结构而不是实现</li>
<li>分而治之：对于一个大规模系统，每次聚焦一部分。</li>
<li>生成和测试</li>
<li>迭代和细化：使用迭代的方法，每次对上一迭代进行精化。</li>
<li>重用元素：复用在设计过程中出现的可以复用的元素。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>架构视图</strong> 重要</p>
<ul>
<li><p>为什么使用架构视图？ 架构视图主要是为了应对软件不可见的问题，屏蔽其他没有影响的部分，将关注点分离。</p>
</li>
<li><p>什么是架构视图？一组系统元素和它们之间的关系表示（不是所有的系统元素 ，而是特定类型的元素）</p>
</li>
<li><p>**为什么软件系统架构需要用不同的视图来文档化？**不同的视图支持不同的目标和用途 ，突出不同的系统元素和关系，在不同程度上暴露了不同的质量属性。</p>
</li>
<li><p><strong>K.Kruchen的4+1视图模型</strong>（会画图）</p>
<ul>
<li><p>逻辑视图：描述了体系结构中在体系结构上明显重要的元素以及他们之间的关系</p>
</li>
<li><p>进程视图：描述了体系结构中的并发和交流元素</p>
</li>
<li><p>物理视图：描述了主要过程和部件是如何映射到应用硬件上的</p>
</li>
<li><p>开发视图：描述了软件部件是如何在软件内部组织的，比如配置管理工具</p>
</li>
<li><p>用例场景(Use Case Scenarios)：捕获架构需求，与一个或多个特定视图相关</p>
</li>
<li><p><img src="image-20250528202710016.png" srcset="/img/loading.gif" lazyload alt="image-20250528202710016"></p>
</li>
<li><p><img src="45ed3af0f45c4fdb8500c92a0d7455a3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29068607/article/details/143194772">https://blog.csdn.net/qq_29068607/article/details/143194772</a></p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>视图名</th>
<th>关注点</th>
<th>面向对象角色</th>
<th>表示方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣ 逻辑视图</strong></td>
<td>功能划分，类的结构和交互</td>
<td>开发人员</td>
<td>UML 类图、对象图</td>
</tr>
<tr>
<td><strong>2️⃣ 开发视图（实现视图）</strong></td>
<td>模块结构，代码组织</td>
<td>开发&#x2F;构建者</td>
<td>包图、组件图</td>
</tr>
<tr>
<td><strong>3️⃣ 进程视图</strong></td>
<td>运行时行为，多线程、通信</td>
<td>测试&#x2F;性能分析者</td>
<td>活动图、通信图</td>
</tr>
<tr>
<td><strong>4️⃣ 物理视图（部署视图）</strong></td>
<td>部署拓扑、服务器结构</td>
<td>运维工程师</td>
<td>部署图、网络图</td>
</tr>
<tr>
<td><strong>➕ 场景视图（用例视图）</strong></td>
<td>主要功能场景、用例驱动</td>
<td>所有人（尤其是客户）</td>
<td>用例图、文本</td>
</tr>
</tbody></table>
</li>
<li><p>软件架构 Software Architecture</p>
<ul>
<li>定义：上面有了，此处不重复</li>
<li>活动：<ul>
<li>创建系统的商业案例</li>
<li>理解用户的需求</li>
<li>创建和选择架构</li>
<li>沟通体系结构（在涉众、开发商之间）</li>
<li>分析或评估架构（整体方法论和具体技术的质量）</li>
<li>实现架构</li>
<li>保证架构的一致性</li>
</ul>
</li>
<li>软件系统架构担当的角色：<ul>
<li>代表决定如何实现需求的决策的第一批人工制品 （早期设计决策），代表了最难更改的设计决策，值得最详细的考虑。</li>
<li>架构是完成产品生产线工程 (Product line Engineering) 的关键， 与独立开发每个系统相比，以较少的工作量、成本和风险来对一系列相似系统进行严格的开发。</li>
<li>当人开始在系统上工作时， 构架通常是首先要检查的设计工件。</li>
<li>软件架构为<strong>维护和修改</strong>决策提供了参考框架</li>
</ul>
</li>
<li>为什么软件架构是重要的<ul>
<li>软件架构提供了沟通的工具：是可以确定和谈判利益冲突的参考框架</li>
<li>软件架构表现了最早期的决策集合</li>
<li>软件架构促进或阻碍质量属性的实现</li>
<li>软件架构会影响质量</li>
<li>软件架构引发有关潜在变更的讨论：软件架构将更改分为三种类型，本地（单组件修改）、 非本地（多组件修改）、架构（修改系统基本结构、通信和协调结构）</li>
<li>软件架构是一种可迁移和可重用的抽象</li>
<li>软件架构是产品通用性的基础： 整个产品线共享一个软件架构</li>
<li>可以通过体系结构集成独立开发组件来开发系统</li>
</ul>
</li>
<li><strong>软件架构过程(活动)</strong> 重要<ul>
<li><img src="image-20250530192359706.png" srcset="/img/loading.gif" lazyload alt="image-20250530192359706"></li>
<li>通过 StackHolder获取到 ASRs</li>
<li>通过分析得到 Prioritized Quality Attribute Scenarios(高优先级质量属性场景 )和 Requirements Constraints(需求和约束 )</li>
<li>将上述部分，结合模式和策略，综合可以得到架构的设计</li>
<li>根据架构的设计得到由模式决定的候选视图的示意图，之后完成文档化</li>
<li>选择、组合视图，将文档进行进一步的评估，这一部分需要 StackHolder的参与、也需要 Prioritized Quality Attribute Scenarios和文档等作为参考。</li>
</ul>
</li>
<li>体系结构生命周期<ul>
<li>Systhesis：合成，混合，综合</li>
<li><img src="7.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></li>
</ul>
</li>
<li>架构知识域<ul>
<li>上下文（ Context）：软件开发生命周期，需求、设计、构造、测试</li>
<li>关键点：并发、控制和处理时间、分布式、异常处理、交互系统、持久化</li>
<li>软件设计方法：架构方法 ADD、设计方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-质量属性-Quality-Attributes"><a href="#2-质量属性-Quality-Attributes" class="headerlink" title="2. 质量属性 Quality Attributes"></a>2. 质量属性 Quality Attributes</h2><p><img src="image-20250529195836443.png" srcset="/img/loading.gif" lazyload alt="image-20250529195836443"></p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>需求分类<ul>
<li>功能性需求 functional requirements</li>
<li>质量需求 quality requirements，也叫非功能需求NFR</li>
<li>约束 constraints</li>
</ul>
</li>
<li>功能性需求<ul>
<li>定义系统必须做什么，并且强调系统如何提供价值给涉众</li>
<li>功能是系统完成其预期工作的能力，很大程度上与结构无关</li>
</ul>
</li>
<li><strong>质量需求</strong>（替代术语：非功能需求、体系结构需求） 重要<ul>
<li>系统应在功能性需求之上提供的整个系统的合乎需求的特性</li>
<li>质量属性是由软件系统的<strong>业务目标</strong>所决定的</li>
<li>如果质量需求很重要，软件系统架构会将其映射到各种结构上</li>
<li>分为两类：<ul>
<li>执行过程中可观察（外部）：系统满足其行为要求的程度如何 ？例如性能 、安全性、 可用性等</li>
<li>执行期间不可观察（内部）：系统的维护 、集成或测试有多容易 ？例如可修改性、 可移植性、可重用性和可测试性等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>约束</strong> 重要<ul>
<li>约束是具有<strong>零自由度</strong>的设计决策</li>
<li>约束是已经做出的<strong>预先</strong>指定的设计决策</li>
<li>通过<strong>接受</strong>设计决策并将其与其他受影响的设计决策进行<strong>协调</strong>，可以满足约束条件</li>
</ul>
</li>
<li>为什么软件系统结构被认为是解决质量问题的最合适层次：<ul>
<li>开发完成后，质量不能被添加到软件密集型系统中，软件开发的所有阶段都需要解决质量问题：即没有办法先实现功能，然后再尝试实现非功能性需求。</li>
<li>软件体系结构限制了各种质量属性的实现，例如性能、安全性和可用性等。</li>
</ul>
</li>
<li>质量属性 Quality Attributes<ul>
<li><strong>开发完成后</strong>，质量<strong>不能</strong>添加到软件密集型系统中</li>
<li>在<strong>软件开发的所有阶段</strong>都需要解决质量问题</li>
<li>业务目标确定系统必须具备的质量</li>
<li>质量属性是<strong>系统功能的基础</strong>，而功能是系统功能、服务和行为的基本说明</li>
<li>软件体系结构限制了各种质量属性的实现，例如性能，安全性，可用性等</li>
</ul>
</li>
<li><strong>质量属性分类</strong> 重要<ul>
<li>内部属性：对于开发人员而言的，例如可测试性</li>
<li>外部属性：对于用户而言的，例如性能</li>
</ul>
</li>
<li>如何定义质量属性<ul>
<li>为了在架构级别对其进行<strong>评估</strong>，必须对质量属性进行<strong>精确定义</strong>。</li>
<li>可以使用质量属性场景(Quality attribute scenarios)定义所需的质量属性</li>
</ul>
</li>
<li><strong>质量属性场景</strong> Quality attribute scenarios 重要<ul>
<li>场景是具有一定结构的简单句子。场景的两个主要类别是：<ul>
<li><strong>通用场景</strong>是与<strong>系统无关</strong>的方案，用于指导质量属性要求的规范</li>
<li><strong>具体场景</strong>是系统<strong>特定</strong>方案，用于指导特定系统的质量属性要求的规范。它们是通用场景的<strong>实例</strong></li>
</ul>
</li>
<li>这个场景就是4+1视图中的1(Use Case)</li>
</ul>
</li>
<li>通用场景 General Scenarios<ul>
<li>通用方案提供了一个<strong>框架</strong>，用于生成<strong>大量</strong>通用的，独立于系统的，质量属性特定的方案</li>
<li>每种情况都可能，但不一定与我们所关注的系统相关</li>
<li>为了使一般情况对特定系统有用，我们必须使它们<strong>特定于系统</strong></li>
<li>使通用场景系统特定于特定环境意味着将其<strong>转换</strong>为特定系统的具体术语</li>
</ul>
</li>
<li><strong>质量属性场景建模</strong> 重要<ul>
<li><img src="5.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></li>
<li>刺激(Stimulus)：到达系统时需要考虑的<strong>条件</strong></li>
<li>刺激源(Source of Stimulus)：产生刺激的<strong>实体</strong>(人，系统或任何促动器)</li>
<li>响应(Response)：刺激措施到来之后开展的<strong>活动</strong></li>
<li>响应度量(Response Measure)：对刺激的响应应以某种方式进行<strong>测量</strong>，以便可以<strong>测试</strong>需求</li>
<li>环境(Environment)：发生刺激时系统的状况，例如过载，正常运行等</li>
<li>工件(Artifact)：需求适用的<strong>整个</strong>系统或系统的一部分</li>
<li>只要定义好这6个元素，就能锁定架构的一个场景，之后可以用来进行架构的设计</li>
</ul>
</li>
<li>策略&#x2F;战术(原子级别的最小的决定) Tactics<ul>
<li>Tactics是影响质量属性相应控制的设计决策，比如冗余。</li>
<li>体系结构策略 Architecture Strategy：策略的集合。</li>
<li>像模式(pattern)一样，策略也可以由其他策略组成，例如，冗余可以由数据的冗余，计算的冗余组成。设计人员根据需求选择一个或另一个</li>
</ul>
</li>
<li>质量设计决策 Quality Design Decisions<ul>
<li>架构是设计决策的集合</li>
<li>七种设计决策<ul>
<li><strong>职责分配</strong> Allocation of responsibilities：将大的职责进行分配</li>
<li><strong>协调模型</strong> Coordination model：各部分之间的沟通、交互</li>
<li><strong>数据模型</strong> Data model：数据格式、存储方式(缓存等)</li>
<li><strong>资源管理</strong> Management of resources：CPU、网络、内存、<strong>时间(部分时间敏感的场景)等资源</strong></li>
<li><strong>架构元素之间的映射</strong> Mapping among architecture elements：将架构元素如何映射到软件的实现上</li>
<li><strong>绑定时间决策</strong> Binding time decisions：<ol>
<li>系统的变化可以在什么时间点前需要固定下来，也就是这个时间前，系统还是可以变化的，但是这个时间之后就不可以变化了</li>
<li>比如选择安装环境是需要在一个时间点前完成的，技术是否添加、编译时间、初始化时间，运行时绑定，但运行时是弹性最大的</li>
<li>实际上我们希望绑定时间越往后越好，但是也就要付出相应的代价。</li>
</ol>
</li>
<li><strong>技术选择</strong> Choice of technology：前面的部分都确定后，我们可以选择技术栈的相对比较局限，解空间已经被压缩了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>课上涉及的7个质量属性都要会，尤其是可用性</p>
</blockquote>
<h3 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h3><ul>
<li><p>可用性是应用程序的关键要求，以可用的时间来度量</p>
</li>
<li><p>一些指标</p>
<ul>
<li>MTBF Mean Time Between Failure</li>
<li>MTTR Mean Time To Repair</li>
<li>可用性：MTBF &#x2F; (MTBF + MTTR)</li>
</ul>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529153004954.png" srcset="/img/loading.gif" lazyload alt="image-20250529153004954" style="zoom: 50%;" /></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>内部&#x2F;外部：人员，硬件，软件，物理基础设施，物理环境</td>
</tr>
<tr>
<td>刺激</td>
<td>故障：遗漏，崩溃，错误时序，错误响应</td>
</tr>
<tr>
<td>工件</td>
<td>处理器，通信渠道，持久存储，进程</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作，启动，关闭，修复模式，降级运行，超负荷运行</td>
</tr>
<tr>
<td>响应</td>
<td>防止故障成为故障。 检测故障：1.记录故障 2. 通知适当的实体 故障恢复：1.禁用引发故障事件的源 2. 在修复过程中暂时不可用 3. 修复或掩盖故障&#x2F;失败或抑制其造成的损害 4. 在修复过程中以降级模式运行</td>
</tr>
<tr>
<td>响应度量</td>
<td>系统必须可用的时间或时间间隔、可用百分比（如99.999%）、检测故障时间、修复故障时间、系统可在降级模式运行的时间或时间间隔、预防某类故障或处理不失败的比例（如99%）或速率（如每秒最多100次）</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529154100715.png" srcset="/img/loading.gif" lazyload alt="image-20250529154100715"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>心跳监视器</td>
</tr>
<tr>
<td>刺激</td>
<td>服务器无响应</td>
</tr>
<tr>
<td>工件</td>
<td>处理流程</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作</td>
</tr>
<tr>
<td>响应</td>
<td>通知操作组件继续操作</td>
</tr>
<tr>
<td>响应度量</td>
<td>无下线时间</td>
</tr>
</tbody></table>
</li>
<li><p>可用性策略</p>
<ul>
<li><img src="image-20250529153805503.png" srcset="/img/loading.gif" lazyload alt="image-20250529153805503" style="zoom: 80%;" /></li>
<li>输入：Fault</li>
<li>可用性策略：检测错误、错误恢复、预防错误</li>
<li>一些重要的策略<ul>
<li>错误检测<ul>
<li>Ping&#x2F;Echo：隔一段时间交流一次状态信息</li>
<li>HeartBeat：持续传输状态信息</li>
<li>Exception：抛出异常并捕获处理</li>
</ul>
</li>
<li>错误恢复<ul>
<li>Vote：多个处理器同时执行相同的计算。一个“投票器”机制会比较这些处理器的结果；如果有一个处理器的输出与其他的显著不同，它会被认为是故障并被忽略。系统会采用其他处理器一致的结果。这是一种容错方式，可以屏蔽单个组件的错误。</li>
<li>主动冗余（Active Redundancy）：所有冗余组件都处于活动状态，并同时处理相同的输入。但只会使用其中一个组件的输出，其余的则被丢弃。如果某个组件出现故障，其他组件会立即继续，无需中断，因为备用始终就绪，几乎没有停机时间。</li>
<li>被动冗余（Passive Redundancy）：一个主组件承担工作，另一个从组件处于被动监控状态。如果主组件故障，从组件接管工作。但从组件需要先同步最新状态以确保一致性，因此在切换过程中会有短暂的停机时间。</li>
<li>备用（Spare）：准备一个完整的备用系统，以便在多个组件发生故障时，能够整体替换。</li>
<li>Shadow operation：之前出现过错误的组件先以Shadow operation模式运行，确认正常后再恢复它的地位</li>
<li>Checkpoint&#x2F;Rollback：错误发生后回滚到检查点</li>
</ul>
</li>
<li>预防错误<ul>
<li>Removal from service：将一些高风险组件移出服务组</li>
<li>Transaction：以事务方式服务，一旦出错立刻回滚</li>
<li>Process monitor：监控器可以检测到不正常的进程，并创建一个新的实例，将其初始化为某个适当的状态，就像备用策略一样。</li>
</ul>
</li>
</ul>
</li>
<li>输出：Fault被屏蔽或完成恢复</li>
</ul>
</li>
</ul>
<h3 id="互操作性（Interoperability"><a href="#互操作性（Interoperability" class="headerlink" title="互操作性（Interoperability)"></a>互操作性（Interoperability)</h3><ul>
<li><p>互操作性是指两个或多个系统可以在特定的上下文中通过接口有效交换有意义的信息的程度，包括语法可操作性（ 交换数据的能力）和语义可操作性 （能够正确解释数据）。互操作性需要确定谁、什么以及在什么情况下（上下文）。</p>
</li>
<li><p>影响因素：发现（发现服务位置、身份和接口）、处理响应（返回、转发、广播）</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529183555510.png" srcset="/img/loading.gif" lazyload alt="image-20250529183555510"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>系统发起与另一个系统进行互操作的请求</td>
</tr>
<tr>
<td>刺激</td>
<td>请求在系统之间交换信息</td>
</tr>
<tr>
<td>工件</td>
<td>希望进行互操作的系统</td>
</tr>
<tr>
<td>环境</td>
<td>希望互操作的系统在运行时被发现或在运行前已知</td>
</tr>
<tr>
<td>响应</td>
<td>以下之一或多个：1.请求被（适当地）拒绝，并通知了适当的实体（人员或系统）2.请求被（适当地）接受，信息交换成功 3.请求被参与的一个或多个系统记录</td>
</tr>
<tr>
<td>响应度量</td>
<td>以下之一或多个：1.正确处理信息交换的百分比 2.正确拒绝信息交换的百分比</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529185634800.png" srcset="/img/loading.gif" lazyload alt="image-20250529185634800"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>车辆的信息系统</td>
</tr>
<tr>
<td>刺激</td>
<td>发送当前位置</td>
</tr>
<tr>
<td>工件</td>
<td>交通流量检测系统</td>
</tr>
<tr>
<td>环境</td>
<td>系统知道运行情况</td>
</tr>
<tr>
<td>响应</td>
<td>系统结合当前位置信息和谷歌地图、卫星数据等</td>
</tr>
<tr>
<td>响应度量</td>
<td>信息准确率达到99.9%</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529183844839.png" srcset="/img/loading.gif" lazyload alt="image-20250529183844839" style="zoom:67%;" /></li>
<li>输入：信息交换请求</li>
<li>具体策略：<ul>
<li>定位：发现服务</li>
<li>管理接口：编排、定制界面</li>
</ul>
</li>
<li>输出：请求被正确处理</li>
</ul>
</li>
</ul>
<h3 id="可修改性-Modifiability"><a href="#可修改性-Modifiability" class="headerlink" title="可修改性 Modifiability"></a>可修改性 Modifiability</h3><ul>
<li><p>可修改性涉及到更改以及进行更改所需花费的时间或金钱，包括这种可变更性影响其他功能或质量属性的程度</p>
</li>
<li><p>影响因素：变更是什么？变更可能性？何时谁进行变更？变更成本？</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529184529017.png" srcset="/img/loading.gif" lazyload alt="image-20250529184529017"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>终端用户，开发人员，系统管理员</td>
</tr>
<tr>
<td>刺激</td>
<td>指令去增加&#x2F;删除&#x2F;修改功能，或更改质量属性、容量或技术</td>
</tr>
<tr>
<td>工件</td>
<td>代码，数据，接口，组件，资源，配置等</td>
</tr>
<tr>
<td>环境</td>
<td>运行阶段，编译阶段，构建阶段，启动阶段，设计阶段</td>
</tr>
<tr>
<td>响应</td>
<td>以下之一或多个：1.进行修改 2.测试修改 3.部署修改</td>
</tr>
<tr>
<td>响应度量</td>
<td>以以下方面衡量的成本：1.受影响工件的数量、大小、复杂性 2.所需努力 3. 需要的时间 4. 花费的金钱 5. 修改影响其他功能或质量属性的程度 6. 引入的新缺陷</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529185615365.png" srcset="/img/loading.gif" lazyload alt="image-20250529185615365"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>开发者</td>
</tr>
<tr>
<td>刺激</td>
<td>想要修改UI</td>
</tr>
<tr>
<td>工件</td>
<td>代码</td>
</tr>
<tr>
<td>环境</td>
<td>设计阶段</td>
</tr>
<tr>
<td>响应</td>
<td>完成修改并通过测试</td>
</tr>
<tr>
<td>响应度量</td>
<td>在3小时内完成</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529185027406.png" srcset="/img/loading.gif" lazyload alt="image-20250529185027406"></li>
<li>输入：更改到来</li>
<li>具体策略：<ul>
<li>减小模块大小：拆分模块</li>
<li>增强内聚：增加语义一致性</li>
<li>降低耦合：封装、使用中介打破依赖、重构</li>
<li>推迟绑定</li>
</ul>
</li>
<li>输出：在时间和预算范围内完成更改</li>
</ul>
</li>
</ul>
<h3 id="性能-Performance"><a href="#性能-Performance" class="headerlink" title="性能 Performance"></a>性能 Performance</h3><ul>
<li><p>性能与时间有关，和系统满足时序要求的能力有关（单位时间能做多少事情）</p>
</li>
<li><p>影响要素：处理时间（正在响应）和阻塞时间（无法响应）</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529185416629.png" srcset="/img/loading.gif" lazyload alt="image-20250529185416629"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>系统内部或外部</td>
</tr>
<tr>
<td>刺激</td>
<td>周期性事件、零星事件或随机事件的到来</td>
</tr>
<tr>
<td>工件</td>
<td>系统或系统中的一个或多个组件</td>
</tr>
<tr>
<td>环境</td>
<td>操作模式：正常、紧急、峰值负载、超负荷</td>
</tr>
<tr>
<td>响应</td>
<td>处理事件，改变服务级别</td>
</tr>
<tr>
<td>响应度量</td>
<td>延迟、截止时间、吞吐量、抖动、错失率</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529185703769.png" srcset="/img/loading.gif" lazyload alt="image-20250529185703769"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>用户</td>
</tr>
<tr>
<td>刺激</td>
<td>初始事务</td>
</tr>
<tr>
<td>工件</td>
<td>系统</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作</td>
</tr>
<tr>
<td>响应</td>
<td>事务执行</td>
</tr>
<tr>
<td>响应度量</td>
<td>平均延迟为2秒</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529191237976.png" srcset="/img/loading.gif" lazyload alt="image-20250529191237976"></li>
<li>输入：事件到达</li>
<li>具体策略<ul>
<li>控制资源请求：管理采样频率、限制事件响应（排队）、事件优先级排序、减少过载、限制处理时间、提高资源利用率。</li>
<li>管理资源：增加资源、引入并发、计算资源多备份、 数据资源多备份、限制队列长度、调度资源。</li>
</ul>
</li>
<li>输出：在一定时间限制内生成响应</li>
</ul>
</li>
</ul>
<h3 id="安全性-Security"><a href="#安全性-Security" class="headerlink" title="安全性 Security"></a>安全性 Security</h3><ul>
<li><p>安全性衡量系统保护数据和信息免遭未授权应用的能力，同时仍提供对授权人员和系统的访问权限</p>
</li>
<li><p>影响要素：保密性（Confidentiality 防止未授权访问）、完整性（Integrity 防止未授权操作）、可用性（Availability 系统可供合法使用）</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529191903342.png" srcset="/img/loading.gif" lazyload alt="image-20250529191903342" style="zoom: 80%;" /></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>人或其他系统，之前可能被正确或错误地识别，或当前未知。攻击者可能来自组织外部或内部。</td>
</tr>
<tr>
<td>刺激</td>
<td>未授权尝试显示数据、更改或删除数据、访问系统服务、更改系统行为或降低可用性。</td>
</tr>
<tr>
<td>工件</td>
<td>系统服务、系统内的数据、系统组件或资源、系统产生或消费的数据。</td>
</tr>
<tr>
<td>环境</td>
<td>系统是在线还是离线；连接或断开连接到网络；在防火墙后面或开放网络；完全运行、部分运行或不运行。</td>
</tr>
<tr>
<td>响应</td>
<td>事务以如下方式进行： 1.保护数据或服务不被未经授权访问 2.防止未经授权的数据或服务操作 3.参与事务方明确识别，确保可靠 4.事务参与方无法否认其参与 5.数据、资源和系统服务可用于合法使用  系统通过以下方式追踪活动： 1.记录访问或修改 2.记录访问数据、资源或服务的尝试 3.在明显攻击发生时通知适当实体(人员或系统)</td>
</tr>
<tr>
<td>响应度量</td>
<td>以下之一或多个： 1.系统在特定组件或数据值被破坏时的损失程度 2.从攻击检测到的时间 3.成功抵御多少次攻击 4.从成功攻击中恢复所需时间 5.特定攻击下的数据易受损害程度</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529192206966.png" srcset="/img/loading.gif" lazyload alt="image-20250529192206966"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>远程的恶意用户</td>
</tr>
<tr>
<td>刺激</td>
<td>试图修改支付率</td>
</tr>
<tr>
<td>工件</td>
<td>系统数据</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作</td>
</tr>
<tr>
<td>响应</td>
<td>系统维持审计踪迹</td>
</tr>
<tr>
<td>响应度量</td>
<td>正确数据在一天内恢复并且攻击来源被标识</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529192602450.png" srcset="/img/loading.gif" lazyload alt="image-20250529192602450"></li>
<li>输入：攻击</li>
<li>具体策略<ul>
<li>检测攻击： 发现入侵（通过流量或签名） 、检测服务拒绝、检查消息完整性（ 通过校验或哈希)、检查消息延迟</li>
<li>防御攻击：验证(Identity)、授权(Authorize)、认证(Authenticate)请求者、限制资源访问、限制暴露、加密数据、分离实体、修改默认设置</li>
<li>响应攻击：撤销对敏感资源访问、锁定电脑、告知请求者</li>
<li>从攻击中恢复：对系统的追踪、 快照存储</li>
</ul>
</li>
<li>输出：系统检测、防御、响应或恢复</li>
</ul>
</li>
</ul>
<h3 id="可测试性-Testability"><a href="#可测试性-Testability" class="headerlink" title="可测试性 Testability"></a>可测试性 Testability</h3><ul>
<li><p>可测试性是指可以使软件通过（通常是基于执行）测试来证明其故障的难易程度</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529192822172.png" srcset="/img/loading.gif" lazyload alt="image-20250529192822172"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>单元测试员、集成测试员、系统测试员、验收测试员、终端用户，手动执行测试或使用自动化测试工具</td>
</tr>
<tr>
<td>刺激</td>
<td>由于编码增量的完成而执行一组测试，如类层或服务，子系统完整集成、整个系统的完整实现或系统交付给客户。</td>
</tr>
<tr>
<td>工件</td>
<td>系统正在被测试的部分</td>
</tr>
<tr>
<td>环境</td>
<td>设计阶段、开发阶段、编译阶段、集成阶段、部署阶段、运行阶段</td>
</tr>
<tr>
<td>响应</td>
<td>以下之一或多个：1.执行测试套件并记录结果 2.记录导致故障的活动 3.控制并监控系统状态。</td>
</tr>
<tr>
<td>响应度量</td>
<td>以下之一或多个：1. 找到故障或故障类别的工作量 2. 实现给定状态空间覆盖百分比的工作量 3. 故障被下一个测试揭示的概率 4. 执行测试所需时间 4.发现故障需要的工作量 5. 测试中的最长依赖链长度 6. 准备测试环境所需时间 7. 降低风险暴露（损失大小×出现概率）</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529193135500.png" srcset="/img/loading.gif" lazyload alt="image-20250529193135500" style="zoom: 80%;" /></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>单元测试人员</td>
</tr>
<tr>
<td>刺激</td>
<td>代码单元完成</td>
</tr>
<tr>
<td>工件</td>
<td>代码单元</td>
</tr>
<tr>
<td>环境</td>
<td>开发环境</td>
</tr>
<tr>
<td>响应</td>
<td>捕获测试结果</td>
</tr>
<tr>
<td>响应度量</td>
<td>3小时内达到85%路径覆盖率</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529194315617.png" srcset="/img/loading.gif" lazyload alt="image-20250529194315617" style="zoom: 80%;" /></li>
<li>输入：执行测试</li>
<li>具体策略<ul>
<li>控制和观察系统状态：专用界面、记录或回放故障、本地化状态存储、沙盒（保证实验消除后果）</li>
<li>限制复杂度：限制结构复杂性（减少依赖关系、继承深度、多态和动态调用、限制行为不确定性。</li>
</ul>
</li>
<li>输出：检测到错误</li>
</ul>
</li>
</ul>
<h3 id="易用性-Usability"><a href="#易用性-Usability" class="headerlink" title="易用性 Usability"></a>易用性 Usability</h3><ul>
<li><p>易用性与用户完成所需任务的难易程度以及系统提供的用户支持的类型相关。</p>
</li>
<li><p>影响因素：学习系统功能、有效使用系统、 最小化错误影响、 使 系统适应 用户需求、增强 信息和满意度。</p>
</li>
<li><p>通用场景</p>
<ul>
<li><img src="image-20250529194826560.png" srcset="/img/loading.gif" lazyload alt="image-20250529194826560"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>最终用户，可能在一个专门化角色中</td>
</tr>
<tr>
<td>刺激</td>
<td>最终用户尝试高效使用系统、学习使用系统、最小化错误影响、调整或配置系统。</td>
</tr>
<tr>
<td>工件</td>
<td>系统或用户正在交互的特定系统部分</td>
</tr>
<tr>
<td>环境</td>
<td>运行阶段或配置阶段</td>
</tr>
<tr>
<td>响应</td>
<td>系统应为用户提供所需功能或预见用户需求</td>
</tr>
<tr>
<td>响应度量</td>
<td>以下之一或多个：任务时间、错误数量、完成任务数量、用户满意度、用户知识获取、成功操作与总操作的比例、错误发生时丢失的时间或数据量</td>
</tr>
</tbody></table>
</li>
<li><p>具体场景</p>
<ul>
<li><img src="image-20250529195328527.png" srcset="/img/loading.gif" lazyload alt="image-20250529195328527"></li>
</ul>
<table>
<thead>
<tr>
<th>场景要素</th>
<th>可能的值</th>
</tr>
</thead>
<tbody><tr>
<td>刺激源</td>
<td>用户</td>
</tr>
<tr>
<td>刺激</td>
<td>下载一个新应用</td>
</tr>
<tr>
<td>工件</td>
<td>系统</td>
</tr>
<tr>
<td>环境</td>
<td>运行时</td>
</tr>
<tr>
<td>响应</td>
<td>用户高效使用系统</td>
</tr>
<tr>
<td>响应度量</td>
<td>在2分钟的试用之后</td>
</tr>
</tbody></table>
</li>
<li><p>策略</p>
<ul>
<li><img src="image-20250529195644114.png" srcset="/img/loading.gif" lazyload alt="image-20250529195644114" style="zoom:80%;" /></li>
<li>输入：用户请求</li>
<li>具体策略<ul>
<li>支持用户操作： 取消、撤销、暂停恢复、 将对象成组操作</li>
<li>支持系统操作：维护任务模型（确定上下文对任务建模）、 维护用户模型（预期的知识)、维护系统模型（预期的系统行为）</li>
</ul>
</li>
<li>输出：用户被给出正确的反馈和帮助</li>
</ul>
</li>
</ul>
<h2 id="3-架构模式"><a href="#3-架构模式" class="headerlink" title="3. 架构模式"></a>3. 架构模式</h2><h3 id="架构攸关的需求-ASR"><a href="#架构攸关的需求-ASR" class="headerlink" title="架构攸关的需求 ASR"></a>架构攸关的需求 ASR</h3><ul>
<li><p><strong>什么是ASR</strong>(Architecturally Significant Requirements) 重要：架构攸关需求是对体系结构产生深远影响的需求（影响了关键体系结构设计决策）。大部分的质量需求和所有的约束就是ASR</p>
</li>
<li><p><strong>如何系统地识别ASR和其他因素</strong> 重要</p>
<ul>
<li><p><strong>从需求文档中收集 ASR</strong>：可以使用“ MoSCoW”法则或用户故事来收集需求（不过难以收集质量需求 ）,但它对于质量需求的定义是很有限的</p>
</li>
<li><p><strong>通过采访涉众来收集 ASR</strong>：可以使用质量属性工作坊（QAW，Quality Attribute Workshop，用于在软件架构初期阶段识别、澄清并优先排序系统的质量属性需求）</p>
</li>
<li><p><strong>通过了解业务目标来收集 ASR</strong></p>
</li>
<li><p><strong>通过质量属性效能树（Utility Tree）来管理 ASR</strong>：把Utility拆分成质量属性和场景，最后变成指标，叶节点要有两个维度评价：对用户的重要程度和开发难易程度。它以“树”的形式，从高层的质量属性（如性能、安全性）向下展开为更具体的场景，使得系统性分析质量需求变得可视、清晰且可评估。</p>
<ul>
<li><img src="image-20250530200152966.png" srcset="/img/loading.gif" lazyload alt="image-20250530200152966"></li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">    Utility</span><br><span class="hljs-section">       |</span><br><span class="hljs-section">---------------------</span><br>|         |         |<br>性能      安全性     可用性<br><span class="hljs-code">  |         |         |</span><br>首页加载≤2s   拒绝SQL注入   宕机≤5分钟<br><span class="hljs-code"> (重要5/难度2) (重要4/难度3) (重要5/难度4)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><ul>
<li><strong>架构模式</strong> Architecture pattern 重要<ul>
<li>定义：架构模式是在实践中反复发现的一套设计决策，具有允许重复使用的已知属性，并且描述了一类架构</li>
<li>架构模式关联了如下三种角色：<ul>
<li>上下文(Context)：世界上经常发生问题的场景。</li>
<li>问题(Problem)：在给定上下文中出现经过适当概括的问题。</li>
<li>解决方案(Solution)：针对问题的成功的经过适当抽象的解决方案。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分类</strong> 重要<ul>
<li>模块化模式 Module Patterns<ul>
<li>特指开发态（静态）</li>
<li>例如：分层模式 layered pattern、微内核模式 micro-kernel pattern</li>
</ul>
</li>
<li>组件-连接器模式 Component-Connector(C&amp;C) Patterns<ul>
<li>倾向于描述运⾏态（动态）</li>
<li>其中 Component 可以连接 1 对多的关系，Connector 只能连接⼀对⼀的关系</li>
<li>例如：中继器模式 Broker Pattern、MVC 模式、管道-过滤器模式 Pipe-Filter Pattern、客户端-服务端 client-server 模式、P2P 模式、服务优先模式 service-oriented pattern、发布-订阅模式 publish-subscribe pattern、共享数据模式 share-data pattern 、SOA 模式</li>
</ul>
</li>
<li>分配模式 Allocation Patterns<ul>
<li>把软件的元素部署&#x2F;分配到⾮软件的环境当中</li>
<li>⽐如：<ul>
<li>Map-reduce Pattern：充分引⼊并⾏，在不同计算资源上部署</li>
<li>Multi-tier Pattern：把⼀组运⾏在相同计算资源上的元素进⾏不同的组合（逻辑关系）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分层模式"><a href="#分层模式" class="headerlink" title="分层模式"></a>分层模式</h3><ul>
<li><p>概述</p>
<ul>
<li>分层模式用来构造可以分解为子任务组的程序，每个子任务组都处于一个特定的抽象级别，每层都为下一个提供更高层次的服务。分层模式的关键点在于<strong>确定依赖</strong>，核心是<strong>关注点分离</strong>（必须逐层访问）</li>
<li>上下文：一般桌面应用、 Web（OSI的七层网络模型）</li>
<li>优点：高内聚、松耦合、易于维护</li>
<li>缺点：降低系统的性能，导致级联修改增加开发成本</li>
</ul>
</li>
<li><p>分层模式变体</p>
<ul>
<li><img src="image-20250529202144119.png" srcset="/img/loading.gif" lazyload alt="image-20250529202144119"></li>
</ul>
</li>
<li><p>微内核模式：</p>
<ul>
<li><p>微内核架构（Microkernel Architecture），也被称为插件化架构（Plugin-in Architecture），是一种面向功能进行拆分的可扩展架构。</p>
</li>
<li><p>微内核架构包含两类核心的组件：核心系统（Core System）和插件模块（Plug-in modules）。核心系统负责与具体功能无关的通用功能，例如应用生命周期的管理、插件模块的管理；插件模块负责实现具体的功能，每个模块都通过插件实现，每一个插件都只做一件事情。</p>
</li>
<li><img src="v2-03b6d52599d7a97b4362ca83bbffd96d_r.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></li>
</ul>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li>概述<ul>
<li>Broker Pattern，属于组件-连接器模式</li>
<li>代理体系结构模式可以用于构建分布式软件系统，其中具有通过RMI交互的分离组件，代理组件负责协调通信，如转发请求，以及传输结果和异常。</li>
<li>上下文：多个同步或异步交互的远程对象组成的系统。</li>
<li>解决方案：通过提供隔离通讯相关的代理，将系统通信功能与主应用程序分开</li>
<li>优点：提高了 Client和 Server之间的交互性，提高可伸缩性和可扩展性，整体大集群的性能可能会提高 (QPS等提高 )，但是局部单点性能会下降，多次网络请求、多次匹配，有可能会抵消。</li>
<li>缺点：代理增加前期复杂度 、 可能成为通信的屏障 、 可能成为安全攻击的目标 、 难以测试。</li>
</ul>
</li>
<li><img src="image-20250529202959043.png" srcset="/img/loading.gif" lazyload alt="image-20250529202959043"></li>
</ul>
<h3 id="模型-视图-控制器模式"><a href="#模型-视图-控制器模式" class="headerlink" title="模型-视图-控制器模式"></a>模型-视图-控制器模式</h3><ul>
<li>概述<ul>
<li>MVC： Model，View，Controller</li>
<li>使用运行时、动态、相互之间的关系来审视，集成到了开发框架中，也是分层架构的变种 （强调模块间约束关系 model不可以直接返回到 controller），分为 model（业务逻辑）、 view（处理用户展示，接收用户操作）、 controller（对用户操作进行处理，将信息通知给model）</li>
<li>优点：耦合性低，重用性高 ，生命周期成本低，部署快，可维护性高，方便管理</li>
<li>缺点：没有明确定义，不适于中小型应用程序，增加实现复杂度，视图和控制器过于紧密，视图对模型访问低效</li>
</ul>
</li>
<li>概述图<ul>
<li><img src="image-20250529203220288.png" srcset="/img/loading.gif" lazyload alt="image-20250529203220288" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h3 id="管道和过滤模式"><a href="#管道和过滤模式" class="headerlink" title="管道和过滤模式"></a>管道和过滤模式</h3><ul>
<li>Pipe-and-Filter Pattern，属于组件-连接器模式</li>
<li>管道和过滤器模式应用在顺序处理结构中，有一系列filter体现依赖关系。</li>
<li>Filter 相当于 Component，起数据处理、计算作用，每个 Filter 有 input 和多个 output，将数据处理后传递给后续部分。</li>
<li>Pipe 相当于 Connector，连接 filter，将 output 导入到其他的 filter 的 input 中去，不会独立存在。</li>
<li>缺点：不适用于互动式系统，过多的过滤器导致大量的计算开销。</li>
<li>结构图<ul>
<li><img src="image-20250530103446068.png" srcset="/img/loading.gif" lazyload alt="image-20250530103446068"></li>
<li><img src="v2-d01cefd6ccd37b11d6bd6192349a31fb_1440w.jpg" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>每一个组件表示filter 连接组件的部分是 pipe，任何一个 filter都依赖于前一个filter的输出（没有其他机会接收外部交互），不适合 交互 的场景（破坏依赖关系）</li>
</ul>
</li>
</ul>
<h3 id="客户端服务器模式"><a href="#客户端服务器模式" class="headerlink" title="客户端服务器模式"></a>客户端服务器模式</h3><ul>
<li>Client-Server Pattern 属于组件-连接器模式</li>
<li>客户端-服务器模型是一种分布式应用程序结构，它在资源或服务（称为服务器）和服务请求者（称为客户端）的提供者之间划分任务或工作负载。客户端和服务器通常通过计算机网络在单独的硬件上进行通信，但客户端和服务器可能位于同一系统中。服务器主机运行一个或多个与客户共享资源的服务器程序。客户端不共享其任何资源，但请求服务器的内容或服务功能。因此，客户端启动与等待传入请求的服务器的通信会话</li>
<li>包含了两类不同的Component，没有 broker可以动态改变 Client 和 Server 的关系，成对的关系相对固定。</li>
<li>上下文：Windows的客户端应用（桌面应用）</li>
<li>缺点：服务器成为性能瓶颈、可能单点失效、决定在哪里实现功能的决定也是复杂的（并且难以修正）</li>
<li>结构图<ul>
<li><img src="image-20250530104235595.png" srcset="/img/loading.gif" lazyload alt="image-20250530104235595" style="zoom: 67%;" /></li>
<li>ATM验证身份，某一个验证 Server可以给很多设备提供服务</li>
<li>ATM操作安全监控、 盗刷之类，通过 monitoring可以发现问题找到记录。</li>
<li>对于银行工作人员，需要添加新的业务，policy发生变化，银行工作人员可以定义ATM的操作</li>
<li>银行负责安全金融的可以根据ATM、对照用户操作行为是否有安全隐患，多对多</li>
</ul>
</li>
<li>与代理模式(Broker Pattern)的比较<ul>
<li>Broker也存在 Client和 Server之间的关系 但Client-Server架构导致互操作性有所降低（没有 broker，需要人为制定固定连接），而 CS不采用 broker 可能导致被拦截</li>
<li>而在小型局域网（互联网还没有普及）时，规模有限，直接联系，性能与安全性平衡可能带来更大的收益。</li>
</ul>
</li>
</ul>
<h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><ul>
<li>Peer-to-Peer Pattern 属于组件-连接器模式</li>
<li>点对点模式中的组件，可能这一时刻为提供者，下一时刻是消费者（对等的）。同时点对点模式不仅仅提供服务，还能提供物流 ，每个 peer可能有一个规定对的连接数。</li>
<li>上下文：分布式应用程序体系结构，应用于对等体之间划分任务或工作负载。</li>
<li>缺点：安全性管理、数据持久化、数据&#x2F;服务可用性（availability）、备份、修复更复杂 、 小型点对点系统不能持续实现质量目标，类似性能（ performance）和可用性(availability)</li>
<li>结构图<ul>
<li><img src="image-20250530105059192.png" srcset="/img/loading.gif" lazyload alt="image-20250530105059192" style="zoom:80%;" /></li>
<li><strong>安全性</strong>：节点既是Client又是 Server，被攻击的可能性提高。</li>
<li><strong>可用性</strong>：数据分布在不同节点上，相同数据多处拷贝，可能导致数据不一致 ，但是能保证个别数据出现问题不影响整体。</li>
<li><strong>性能</strong>：多个节点同时提供服务，性能好</li>
</ul>
</li>
<li>客户端-服务器架构与点对点架构的比较<ul>
<li>除了客户端-服务器模型之外， 分布式计算应用程序通常使用点对点 (P2P) 应用程序架构。</li>
<li>在客户端-服务器模型中，服务器通常设计为作为为许多客户端提供服务的集中式系统运行。服务器的计算能力，内存和存储要求必须适当地缩放到预期的工作负载（即同时连接的客户端数量）。负载平衡和故障转移系统通常用于扩展服务器实现</li>
<li>在点对点网络中，两个或多个计算机（对等体）汇集其资源并在分散的系统中进行通信。 对等体是非分层网络中的同等节点或等效节点。与客户端 -服务器或客户端-队列-客户端 网络中的客户端不同，对等体直接相互通信。在对等网络中，对等通信协议中的算法平衡负载，即使是具有适度资源的对等体也可以帮助共享负载。<strong>如果节点变得不可用，则只要其他节点提供服务，其共享资源就保持可用</strong>。理想情况下，对等体不需要实现享资源就保持可用</li>
<li>客户端 -服务器和主 -从都被视为分布式对等系统的子类。</li>
</ul>
</li>
</ul>
<h3 id="面向服务的模式"><a href="#面向服务的模式" class="headerlink" title="面向服务的模式"></a>面向服务的模式</h3><ul>
<li>Service-Oriented Pattern SOA，属于组件-连接器模式</li>
<li>面向服务的体系结构（SOA）是一种软件设计风格，其服务通过应用程序组件，通过网络上的通信协议提供给其他组件。</li>
<li>面向服务的体系结构的基本原则独立于供应商，产品和技术。服务是一个独立的功能单元，可以远程访问并独立操作和更新</li>
<li>缺点：构建复杂 、无法管理独立服务的演化 、服务可能成为性能瓶颈（无法提供性能保障）、使用中间件导致的性能开销</li>
<li>结构图<ul>
<li><img src="image-20250530110643885.png" srcset="/img/loading.gif" lazyload alt="image-20250530110643885" style="zoom: 50%;" /></li>
<li>SOAP（简单对象访问协议）：服务提供者和提供者通过 通常在 HTTP之上交换请求&#x2F;答复XML消息进行交互。</li>
<li>REST（代表性状态传输协议）：服务使用者依赖于四个基本状态（ POST、 GET、PUT、 DELETE）的 HTTP请求的 REST</li>
<li>异步消息传递（即发即忘）：参与者不必等待确认。</li>
</ul>
</li>
<li>SOA和其他架构的区别<ul>
<li>SOA具备 Broker的优势（而又不继承Broker）</li>
<li>SOA具有更高的互操作性和更高的伸缩性</li>
<li>出现类似基础设施的组件（代替单一节点 broker），解决单点失效的问题，满足互联网普及、参与人数规模较大的问题。</li>
<li>符合商业模式的变化与技术可用性</li>
</ul>
</li>
</ul>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><ul>
<li>Publish-Subscribe Pattern，属于组件-连接器模式</li>
<li>在软件体系结构中 ，发布 -订阅是一种消息模式 ，其中消息的发送者（称为发布者）不将消息直接发送到称为订阅者的特定接收者，而是将发布的消息送到连接器中（不知道有哪些订阅者）。类似地，订阅者表达对一个或多个类的兴趣并且仅接收感兴趣的消息，会接受到连接器的通知，而不知道哪些发布者（如果有的话）存在。</li>
<li>优点：松耦合、可伸缩性、此模式提供更高的网络可扩展性和更动态的网络拓扑从而降低了修改发布者和已发布数据结构的代价。</li>
<li>缺点：通常会增加延迟并对消息传递时间的可伸缩性和可预测性产生负面影响。对消息排序的控制较少，并且不保证消息的传递。</li>
<li><img src="image-20250530111230616.png" srcset="/img/loading.gif" lazyload alt="image-20250530111230616" style="zoom:67%;" /></li>
</ul>
<h3 id="共享数据模式"><a href="#共享数据模式" class="headerlink" title="共享数据模式"></a>共享数据模式</h3><ul>
<li>Shared-Data Pattern，属于组件-连接器模式</li>
<li>一致性实现：最终一致性（不保证任何时间数据访问都一致但是保证最终结果要一致）、互联网不可能牺牲可用性来保障一致性保障一致性（信号要求高），因此设计难度非常大</li>
<li>缺点：共享数据模型可能存在性能瓶颈、可能存在单点失效、数据的生产者和消费者紧密耦合、中心点被攻击有安全风险</li>
<li><img src="image-20250530111902992.png" srcset="/img/loading.gif" lazyload alt="image-20250530111902992" style="zoom:50%;" /></li>
</ul>
<h3 id="分配模式"><a href="#分配模式" class="headerlink" title="分配模式"></a>分配模式</h3><ul>
<li>Map-Reduce Pattern</li>
<li>Map负责对数据进行抽取所需的信息，完成信息转换。可以有很多个 Map，每个Map处理的数据工作内容不一 样 ，他们互相独立运行。 Reduce负责进行合并，产出最终的答案。</li>
<li>典型示例（词频统计）：每个Partition对应一个 Map，每个 Map分别完成词汇词频的统计，最后由 Reduce合并后进行排序。</li>
<li>缺点：如果没有足够大的数据集，那么 Map-Reduce的开销是不能被接受的；如果不能将数据集切分成相似大小，那么并行的好处会消失；多次归纳是难以编排的。</li>
<li><img src="image-20250530122749200.png" srcset="/img/loading.gif" lazyload alt="image-20250530122749200"></li>
</ul>
<h3 id="多层模式"><a href="#多层模式" class="headerlink" title="多层模式"></a>多层模式</h3><ul>
<li><p>Multi-Tier Pattern 分配模式</p>
</li>
<li><p>Layer是真实存在的，<strong>这里的层是逻辑的组合，没有层次模式的强依赖关系</strong>，在不同的部署环境中分层不同，但是软件完成内容一致。</p>
</li>
<li><p>许多系统的执行结构被组织成一组逻辑组件。每个分组被称为一个层。将组件分组到层中可能基于各种标准，例如组件的类型、共享相同的执行环境或具有相同的运行时目的。</p>
</li>
<li><p>上下文：旅行社</p>
</li>
<li><p>缺点：大量的前期成本和复杂性。</p>
</li>
<li><p>结构图</p>
<ul>
<li><img src="image-20250530123151554.png" srcset="/img/loading.gif" lazyload alt="image-20250530123151554"></li>
<li>三大类Modular类、 Runtime Process动态类、 软件和非软件环境关系（部署关系）</li>
</ul>
</li>
<li><p><strong>多层模式和分层模式比较</strong> 重要</p>
<ul>
<li><p><strong>分层模式（Layered Pattern）</strong>：强调<strong>软件职责的逻辑分离</strong>，主要是<strong>程序结构内部</strong>的组织方式。</p>
</li>
<li><p><strong>多层模式（Multi-Tier Pattern）</strong>：强调<strong>部署结构的物理分离</strong>，主要是<strong>系统运行时在物理环境中的分布方式</strong>。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>分层模式（Layered）</th>
<th>多层模式（Multi-Tier）</th>
</tr>
</thead>
<tbody><tr>
<td>关注点</td>
<td><strong>逻辑结构、职责划分</strong></td>
<td><strong>物理结构、部署分布</strong></td>
</tr>
<tr>
<td>表现形式</td>
<td><strong>在同一进程中组织不同的逻辑层</strong></td>
<td><strong>不同层运行在不同服务器或容器中</strong></td>
</tr>
<tr>
<td>交互方式</td>
<td>方法调用（in-process）</td>
<td>网络通信（HTTP&#x2F;RPC）</td>
</tr>
<tr>
<td>举例</td>
<td>DDD 的四层架构、Spring MVC 结构等</td>
<td>Web客户端 + Nginx + Java服务 + MySQL 等</td>
</tr>
<tr>
<td>通常的关系</td>
<td>分层模式是多层模式的<strong>逻辑基础</strong></td>
<td>多层模式是分层模式的<strong>物理体现</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="架构模式-vs-策略-Tactics"><a href="#架构模式-vs-策略-Tactics" class="headerlink" title="架构模式 vs 策略 Tactics"></a>架构模式 vs 策略 Tactics</h3><ul>
<li><strong>pattern和tactic的关系</strong> 重要<ul>
<li>策略比模式更简单；它们使用单一结构或机制来应对单一架构力量。</li>
<li>模式通常将多个设计决定组合成一个包。</li>
<li>模式和策略共同构成软件架构师的主要工具。</li>
<li>策略是创建架构模式的设计“构件”。</li>
<li>大多数模式由几种不同策略组成，这些策略可能：<ul>
<li>都服务于一个共同目的，</li>
<li>常常被选择以实现不同质量属性的平衡。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-属性驱动设计-ADD"><a href="#4-属性驱动设计-ADD" class="headerlink" title="4. 属性驱动设计 ADD"></a>4. 属性驱动设计 ADD</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul>
<li><p>软件架构生命周期</p>
<ul>
<li><img src="image-20250530142622943.png" srcset="/img/loading.gif" lazyload alt="image-20250530142622943" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>设计策略</strong> 重要，要理解</p>
</li>
</ul>
<ul>
<li>分解 Decomposition：针对某⼀个系统关注点分解后处理，⽐如将整个系统分解或将某个模块分解<ul>
<li>分治 Devide &amp; Conquer：将某个模块分别处理</li>
<li>根据ASR设计 Designing to ASRs：对于非ASR的需求，需要做出调整，因为ASR的优先级更高</li>
<li>⽣成与测试 Generation and Test：将⼀个特定的设计看作是⼀个假设；根据测试路径⽣成测试⽤例</li>
<li>设计过程的核心 The core of the design process：设计过程包含很多设计决策，做出决策是很有挑战性的</li>
<li>不要重新发明轮子 Avoid reinventing the wheel：大部分子问题可以用已有的方法解决，我们需要考虑：<ul>
<li>参考架构 Reference Architectures</li>
<li>部署模式 Deployment Patterns</li>
<li>架构模式或设计模式 Architectural &#x2F; Design Patterns</li>
<li>策略 Tactics</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>ADD 3.0核心概念</p>
<ul>
<li><p>Design Purpose（设计目的）</p>
<ul>
<li>ADD 从设计的目标出发，比如你是为了新系统架构、旧系统演化，或者为了满足某个质量属性（如性能或可扩展性）进行架构设计。</li>
</ul>
</li>
<li><p><strong>Drivers（驱动因素）</strong> 重要，要会分析</p>
<ul>
<li><strong>功能需求（Functional Requirements）</strong>：系统应该做什么。</li>
<li><strong>质量属性（Quality Attributes）</strong>：性能、可用性、安全性、可维护性等非功能需求。</li>
<li><strong>约束（Constraints）</strong>：比如成本和时间、部署在特定平台、采用某种协议等。</li>
</ul>
</li>
<li><p>Module Types（模块类型）</p>
<ul>
<li><strong>Component-and-Connector（C&amp;C）</strong>：关注运行时交互（如微服务、进程、线程、消息通道等）</li>
<li><strong>Module</strong>：关注代码静态结构（如类、包、库等）</li>
<li><strong>Allocation</strong>：关注模块与部署环境的映射（如进程到服务器）</li>
</ul>
</li>
<li><p>Decomposition（分解）</p>
<ul>
<li>根据驱动因素，决定如何将系统分解为子系统或模块。需要明确每个模块的职责、接口、交互方式。每次分解主要考虑：</li>
<li>模块的功能划分<ul>
<li>哪些质量属性受到影响</li>
<li>如何满足这些质量属性（采用哪些架构策略，如缓存、负载均衡、容错等）</li>
<li>如何分配资源和约束（如部署、语言、协议等）</li>
</ul>
</li>
</ul>
</li>
<li><p>Design Decisions（设计决定）</p>
<ul>
<li>ADD 强调<strong>记录每一个设计决定</strong>，包括：</li>
<li>决定内容<ul>
<li>解决的问题</li>
<li>所依据的质量属性或约束</li>
<li>所评估的备选方案</li>
</ul>
</li>
</ul>
</li>
<li><p>Architecture Views（架构视图）</p>
<ul>
<li><strong>模块视图（Module View）</strong>：体现代码结构</li>
<li><strong>组件-连接器视图（C&amp;C View）</strong>：体现运行时结构</li>
<li><strong>分配视图（Allocation View）</strong>：体现物理部署结构</li>
</ul>
</li>
<li><p><strong>Iteration（迭代）</strong> 重要，会分析迭代目标</p>
<ul>
<li><p>ADD 是一个<strong>迭代式过程</strong>，每次迭代：</p>
<ul>
<li>选择一个模块</li>
<li>分析其驱动因素</li>
<li>应用架构策略进行分解</li>
<li>记录设计决策和产生的架构视图</li>
</ul>
</li>
<li><p>这个过程不断重复，直到系统架构满足所有需求，或达到合理的粒度。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ADD步骤 （ADD 3.0）</p>
<ul>
<li><img src="image-20250530144434061.png" srcset="/img/loading.gif" lazyload alt="image-20250530144434061"></li>
<li>第一步：<strong>回顾输入</strong>。确认主要功能和质量属性场景需要已经按照优先级排序，如果没有就QAW和效能树等方式确定。检查在最初的需求获取（分析）过程中是否有任何重要的利益相关者被遗漏。检查自优先级排序完成以来，业务条件是否发生了变化</li>
<li>第二步：<strong>通过选择驱动因素建立迭代目标</strong>。将复杂系统“分解”成可设计的部分，并明确当前迭代的关注点（驱动因素）。系统被分解为子模块，选择一个子模块实现。驱动因素包括关键子系统或组件，高优先级的质量属性场景（如高并发登录模块），和有明确风险或不确定性的部分。</li>
<li>第三步：<strong>选择一个或多个系统要素来完善</strong>。从上一步选出的子模块中，挑选出要进行设计或细化的系统元素</li>
<li>第四步：<strong>选择一个或多个满足驱动因素的架构策略</strong>。</li>
<li>第五步：<strong>分解该模块，并定义其接口和交互</strong>。</li>
<li>第六步：<strong>记录设计决定和构建架构视图</strong>。将每一步的设计结果形成结构化文档和架构视图。</li>
<li>第七步：<strong>评估设计结果是否满足驱动因素</strong>。如果有必要回到第二步进行多轮迭代</li>
</ul>
</li>
<li><p><strong>设计决定中要考虑的因素</strong> 重要：responsibility职责、Coodination协作、操作与服务的mapping、Data和Resources的管理、binding time确定时间（该部分开发完成不再修改）</p>
</li>
</ul>
<h3 id="架构文档化"><a href="#架构文档化" class="headerlink" title="架构文档化"></a>架构文档化</h3><ul>
<li><p>为什么要文档化架构</p>
<ul>
<li>即使是最好的架构，如果需要架构的人不知道它是什么或不能有效理解并使用它，那么它就是无用的</li>
<li>架构团队所有工作、设计、分析都会是无用的</li>
</ul>
</li>
<li><p>架构文档化要求</p>
<ul>
<li>文档要足够透明易懂以被使用者快速理解</li>
<li>文档要足够具体，以作为开发的蓝图</li>
<li>信息要足够充分，以作为分析的基础</li>
</ul>
</li>
<li><p>Notation</p>
<ul>
<li>在软件架构文档化中，<strong>Notation（表示法、符号体系）<strong>是指用来</strong>表达架构元素、它们之间关系、交互和行为的可视化符号或语法</strong></li>
<li>分类<ul>
<li>Informal Notations（非正式表示法）：使用通用绘图工具绘制，没有正式语法规则，<strong>不能进行自动化分析</strong>。</li>
<li>Semiformal Notations（半正式表示法）：有标准图形符号和构图规则（比如 UML），没有完整的形式语义，因此<strong>分析能力有限</strong></li>
<li>Formal Notations（正式表示法）：使用有严格数学语义的语言来描述架构，可以进行<strong>形式化分析和验证</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Views 视图</p>
<table>
<thead>
<tr>
<th>视图类型</th>
<th>Elements</th>
<th>Relations</th>
<th>Constraints</th>
<th>Usage</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Module View</strong></td>
<td>类、模块、包、接口</td>
<td>静态依赖、包含、实现</td>
<td>模块层次、依赖方向、封装</td>
<td>开发构建、代码组织、接口定义</td>
</tr>
<tr>
<td><strong>C&amp;C View</strong></td>
<td>组件、连接器（进程、服务、通信机制）</td>
<td>调用、数据流、事件传播</td>
<td>通信路径、服务可访问性</td>
<td>运行时交互、通信机制设计、性能分析</td>
</tr>
<tr>
<td><strong>Allocation View</strong></td>
<td>软件单元、物理节点、平台资源</td>
<td>部署关系、物理链接</td>
<td>性能、安全、部署限制</td>
<td>部署架构、资源映射、运维支持</td>
</tr>
</tbody></table>
<ul>
<li><p>质量视图 Quality Views：安全视图、性能视图、可靠性视图、沟通视图、异常（错误处理）视图</p>
</li>
<li><p>组合视图 Combining Views：包括各种 C&amp;C视图、带有 SOA或通信进程视图的部署视图、分解视图和任何工作分配、实施、使用或分层视图。</p>
</li>
</ul>
</li>
<li><p>如何选择视图</p>
<ul>
<li>第一步：构建涉众&#x2F;视图表。行为涉众，列为视图，格子填写涉众对视图的细节了解程度。</li>
<li>第二步：合并视图。识别涉众&#x2F;视图表中的边缘视图，通过关联一个视图中的元素和另一个视图中的元素 ，将每个边缘视图与另一个具有更强表示能力的视图相结合。</li>
<li>第三步：确定优先级和完成阶段。</li>
</ul>
</li>
<li><p>架构文档中应该包含 View 和 Beyond 部分，还有系统行为。</p>
</li>
<li><p>如何文档化视图</p>
<ul>
<li>使用视图模板，包括五个部分</li>
<li>第一部分：主要介绍，显示视图的元素和关系 ，以及图例</li>
<li>第二部分：元素介绍 ，详细介绍第一部分中描述的元素、元素属性、关系属性和元素接口和行为</li>
<li>第三部分：上下文图，描述系统如何与环境相关</li>
<li>第四部分：可变性指南，告知视图中可能发生的变化</li>
<li>第五部分：基本原理，为什么设计反映在视图中，并且说明其合理性</li>
</ul>
</li>
<li><p>文档化视图之外的部分(Beyond)</p>
<ul>
<li>⽂档路线图：包含了范围和总结、简单摘要等</li>
<li>视图的⽂档组织⽅式：描述了本⽂档中视图是如何组织的</li>
<li>系统概述：从整体上描述了当前架构的简要说明、业务⽬标（驱动因素）等等</li>
<li>视图之间的映射关系：描述了不同视图之间的映射关系</li>
<li>系统原理：从整体上描述了当前架构的设计原理</li>
<li>⽬录-索引、词汇表、⾸字⺟缩略词表</li>
</ul>
</li>
<li><p>文档化系统行为</p>
<ul>
<li>行为文档化可以通过描述元素之间的交互关系来补充视图</li>
<li>可用的工具：用例图、顺序图、通信图、活动图、信息顺序图、时间图、状态机</li>
</ul>
</li>
</ul>
<h2 id="5-微服务架构"><a href="#5-微服务架构" class="headerlink" title="5. 微服务架构"></a>5. 微服务架构</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>主流架构风格<ul>
<li><img src="image-20250530162639760.png" srcset="/img/loading.gif" lazyload alt="image-20250530162639760"></li>
</ul>
</li>
<li>单体架构<ul>
<li>单体(Monolithic) 架构：单体应用的全部功能被集成在一起作为一个统一的单元，更多作为应用部署架构。</li>
<li>通信方式：进程间通信、方法间调用，无需网络调用</li>
<li>事务管理：单一数据库，所有事务单一上下文，事务提交和回滚操作简单</li>
<li>好处：易于开发、修改、测试、部署、伸缩(多个实例负载均衡)</li>
<li>问题：系统过于复杂、开发速度慢、难以扩展、可靠性差</li>
</ul>
</li>
<li>分层架构<ul>
<li>对复杂系统进行抽象和分层、结构化设计的架构方案</li>
<li>垂直架构（结构简单，易于组织开发、测试和维护）<ul>
<li>表现层、业务层、（持久层）、数据层</li>
<li><img src="image-20250530163124749.png" srcset="/img/loading.gif" lazyload alt="image-20250530163124749" style="zoom: 50%;" /></li>
</ul>
</li>
</ul>
</li>
<li>面向服务架构 SOA<ul>
<li>面向服务架构是一个分布式组件的集合，这些组件为其他组件提供服务或者消费其他组件提供的服务，而无需知道其他组件的细节。</li>
<li>企业服务总线（ESB）为服务间相互调用提供支持环境，路由服务间信息，并对信息和数据进行必要转换。</li>
<li>服务编排引擎（Orchestration Engine）可以根据预定义的脚本对服务消费者与服务提供者之间交互进行指挥。</li>
<li><img src="image-20250530163341259.png" srcset="/img/loading.gif" lazyload alt="image-20250530163341259" style="zoom:150%;" /></li>
<li>面向服务架构实现原则：<ul>
<li>服务契约：服务按照描述文档所定义的服务契约行事</li>
<li>服务封装：除了服务契约所描述内容，服务将对外部隐藏实现逻辑</li>
<li>服务重用：将逻辑分布在不同的服务中，以提高服务的重用性</li>
<li>服务组合：一组服务可以协调工作，组合起来形成定制组合业务需求</li>
<li>服务自治：服务对所封装的逻辑具有控制权</li>
<li>服务无状态：服务将一个活动所需保存的资讯最小化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul>
<li><p>定义：微服务架构是把应用程序功能性分解为一组服务的架构风格，每一个服务都是由一组专注、内聚的功能职责组成。</p>
</li>
<li><p>例子：电商平台和外卖平台</p>
<ul>
<li><img src="image-20250531122914808.png" srcset="/img/loading.gif" lazyload alt="image-20250531122914808" style="zoom:40%;" /></li>
<li><img src="image-20250531122934220.png" srcset="/img/loading.gif" lazyload alt="image-20250531122934220" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>主要特性</strong> 重要，会考简答</p>
<ul>
<li>服务组件化</li>
<li>围绕业务能力组织</li>
<li>内聚和解耦</li>
<li>去中心化：微服务治理、数据存储、数据管理</li>
<li>基础设施自动化</li>
<li>服务设计与演进：高可用设计、演进式设计</li>
</ul>
</li>
<li><p>与SOA对比</p>
<ul>
<li><img src="image-20250530164414125.png" srcset="/img/loading.gif" lazyload alt="image-20250530164414125"></li>
</ul>
</li>
<li><p>微服务架构的问题</p>
<ul>
<li>服务的拆分和定义（粒度问题）：如何拆？怎么评估？</li>
<li>分布式系统带来的复杂性<ul>
<li>进程间通信机制复杂性高于方法调用、局部故障</li>
<li>跨服务的事务和查询</li>
<li>编写包含多项服务在内的自动化测试</li>
<li>运维复杂性（自动化部署工具、产品化PaaS平台、Docker容器编排平台）</li>
<li>部署跨服务的功能需要协调更多开发团队</li>
</ul>
</li>
</ul>
</li>
<li><p>微服务架构的核心设计模式</p>
<ul>
<li>模式 pattern：针对特定上下文中发生的问题的可重用解决方案</li>
<li>核心模式：针对采用微服务系统在特定场景下的特定问题所使用的程序的架构解决方案的集合。</li>
</ul>
</li>
<li><p>核心模式——微服务的拆分和定义</p>
<ul>
<li><p>问题：如何将应用拆分为微服务？</p>
</li>
<li><p>需求：</p>
<ul>
<li>高内聚：实现一组密切相关的功能</li>
<li>松耦合：封装内部细节，API交互</li>
<li>单一职责原则（SRP）</li>
<li>共同封闭原则（CCP）</li>
</ul>
</li>
<li><p><strong>步骤：定义系统操作-&gt;定义微服务（围绕业务概念）-&gt;定义服务API和协作方式 重点</strong></p>
<ul>
<li><p>定义系统操作：将需求提炼为系统必须处理的关键请求，由抽象的领域模型定义</p>
<ul>
<li><p>输入：需求，用户故事&#x2F;相关用户场景&#x2F;源代码恢复等</p>
</li>
<li><p>流程：创建领域模型-&gt;确定系统操作</p>
</li>
<li><p>补充：领域模型</p>
<ul>
<li><p>领域模型是对领域内概念类或现实世界中对象的可视化表示，也称为概念模型。领域模型被描述为一组没有定义操作的类图，是对真实世界中概念类的表示，而不是软件对象的表示</p>
</li>
<li><img src="image-20250602174120502.png" srcset="/img/loading.gif" lazyload alt="image-20250602174120502" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>定义微服务：根据业务能力、子域（<strong>涉及DDD，领域驱动设计，会考</strong>）、动静态调用关系进行拆分</p>
<ul>
<li><p>根据业务能力拆分：业务架构建模的术语</p>
<ul>
<li><p>业务能力是企业产生价值的商业活动，较为稳定</p>
</li>
<li><p>能力可分解为子能力</p>
</li>
<li><img src="image-20250531124625876.png" srcset="/img/loading.gif" lazyload alt="image-20250531124625876" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>子域见下面的补充</p>
</li>
<li><p>根据动静态调用关系拆分</p>
<ul>
<li>收集单体应用动静态调用信息，构建有向带权图（调用频率、变更频率等），最后基于聚类算法拆分</li>
<li>静态：用例分析、字节码解析、API接口</li>
<li>动态：调用链路、数据流图、控制流图</li>
</ul>
</li>
</ul>
</li>
<li><p>定义服务API和协作方式：将标识的系统操作分配给服务，独立或与其他服务协作（涉及通信方式）实现操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>核心模式——服务注册与发现：服务消费者获取服务提供者的机制 ，以实现两者间的解耦服务发现组件</p>
</li>
<li><p>核心模式——API网关： 所有客户端的单一入口点，针对不同客户端提供不同的 API，解决了微服务结构的应用客户端如何访问各项服务。</p>
</li>
<li><p>核心模式——断路器（Circuit Breaker）：避免任何服务或网络出现问题导致的级联故障</p>
<ul>
<li>闭合状态：请求直接引起方法调用</li>
<li>断开状态：请求立即返回错误响应</li>
<li>半断开状态：允许一定数量的请求调用，如成功则切换到闭合状态，否则切换到断开状态。</li>
</ul>
</li>
</ul>
<h3 id="补充：领域驱动设计"><a href="#补充：领域驱动设计" class="headerlink" title="补充：领域驱动设计"></a>补充：领域驱动设计</h3><blockquote>
<p>会结合微服务架构的微服务拆分定义核心模式考</p>
</blockquote>
<ul>
<li>概念：以业务领域为中心进行建模和开发，使技术服务于业务目标。</li>
<li>核心理念</li>
</ul>
<table>
<thead>
<tr>
<th>核心理念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注领域（Domain）</strong></td>
<td>系统的核心是业务逻辑，而不是技术实现。</td>
</tr>
<tr>
<td><strong>模型驱动设计（Model）</strong></td>
<td>使用统一的“模型”作为沟通工具，贯穿分析、设计、实现。</td>
</tr>
<tr>
<td><strong>与专家密切合作</strong></td>
<td>持续与领域专家沟通，提炼出通用语言（Ubiquitous Language）</td>
</tr>
</tbody></table>
<ul>
<li>DDD架构<ul>
<li><img src="image-20250530171428382.png" srcset="/img/loading.gif" lazyload alt="image-20250530171428382"></li>
<li><strong>领域层是重中之重</strong>，业务核心逻辑应尽可能集中于此</li>
</ul>
</li>
<li><strong>DDD与微服务架构</strong> 非常重要，一定会考大题<ul>
<li>微服务架构中的微服务拆分核心模式中，可以根据子域拆分，用到了DDD</li>
<li>DDD解决复杂软件业务领域范围&#x2F;业务边界划分的问题，它从业务出发，以面向对象和领域模型为核心</li>
<li>领域：描述问题域，一种特定的范围，电商、外卖、保险…</li>
<li>子域是领域的细分，例如电商中的订单、商品、物流</li>
<li>领域分为核心域、通用域、支撑域</li>
<li>领域模型：以解决具体问题的方式包含一个领域的知识</li>
<li>限界上下文：领域模型的边界，包括实现模型的代码集合，对应微服务架构中一个或一组服务</li>
<li>统一语言：定义领域内相关团队的词汇表，统一、简单、清晰、准确描述业务规则和业务</li>
<li>DDD流程<ul>
<li>将问题域逐级细分，降低理解和实现的复杂度</li>
<li>从业务需求中提炼统一语言</li>
<li>战略设计：<ul>
<li>构建领域模型，识别限界上下文，确定领域边界</li>
<li>上下文映射建立领域间关系</li>
<li>划分（微）服务的逻辑和物理边界</li>
</ul>
</li>
<li>战术设计：限界上下文内领域建模，指导程序设计、编码和重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补充：微服务部署和运维模式和策略"><a href="#补充：微服务部署和运维模式和策略" class="headerlink" title="补充：微服务部署和运维模式和策略"></a>补充：微服务部署和运维模式和策略</h3><blockquote>
<p>可能会考一个小题</p>
</blockquote>
<ul>
<li>部署模式<ul>
<li>单主机部署多个服务实例<ul>
<li>在主机（物理机或虚拟机）上运行不同服务的多个实例</li>
<li>优点：资源利用率相对较高</li>
<li>缺点：资源需求冲突、依赖冲突、难以监控和限制每个实例资源消耗</li>
</ul>
</li>
<li>单主机部署单个服务实例<ul>
<li>在自己的主机上部署单个服务实例</li>
<li>优点：服务实例彼此隔离，无冲突，监控管理简单</li>
<li>缺点：资源利用效率可能较低</li>
</ul>
</li>
<li>将服务部署到虚拟机<ul>
<li>将服务打包为虚拟机镜像，并将每个服务实例部署为单独的VM</li>
<li>优点：通过增加实例数量来扩展服务很简单；构建服务的技术细节封装好；服务隔离性好</li>
<li>缺点：资源利用效率低，部署慢，系统管理开销（操作系统、运行补丁）</li>
</ul>
</li>
<li>将服务部署到容器<ul>
<li>将服务打包为 (Docker) 容器镜像并将每个服务实例部署到容器</li>
<li>优点：更改容器实例的数量可以管理服务数量；构建服务的技术细节封装好；服务隔离性好；<strong>容器的构建和启动速度非常快</strong></li>
<li>缺点：大量的容器镜像管理工作</li>
</ul>
</li>
<li>服务部署平台<ul>
<li>使用部署平台作为应用程序部署的自动化基础设施，如K8s</li>
</ul>
</li>
<li>无服务器部署<ul>
<li>使用公有云提供的serverless部署机制部署服务。将服务的代码打包到一个 ZIP 文件中，将其上传到 AWS Lambda</li>
<li>优点：AWS服务集成简单；消除系统管理任务；弹性伸缩</li>
<li>缺点：配置和启动应用慢，某些请求延迟高</li>
</ul>
</li>
<li><img src="image-20250531144609140.png" srcset="/img/loading.gif" lazyload alt="image-20250531144609140"></li>
</ul>
</li>
<li>可观测性模式（维护）<ul>
<li>日志聚合<ul>
<li>使用集中式日志记录服务聚合来自每个服务实例的日志</li>
<li>缺点：处理大量日志需要大量的基础设施</li>
</ul>
</li>
<li>审计日志<ul>
<li>向业务逻辑中添加审计日志代码，创建审核日志条目并保存在数据库中</li>
<li>优点：提供用户操作的记录</li>
<li>缺点：审计代码与业务逻辑交织，使业务逻辑复杂化</li>
</ul>
</li>
<li>应用程序指标<ul>
<li>检测服务以收集有关各个操作的统计信息，在集中式指标服务中聚合指标，提供报告和警报（相当于用一个专门的服务来检测其他服务）</li>
<li>优点：提供对应用程序行为的深入洞察</li>
<li>缺点：指标代码与业务逻辑交织在一起，使其更加复杂；需要大量的基础设施</li>
</ul>
</li>
<li>分布式跟踪<ul>
<li>为每个外部请求分配ID，记录请求范围以内的信息，并在集中式服务器中跟踪它</li>
<li>优点：方便查看某个请求的处理路径，发现延迟来源</li>
<li>缺点：聚合和存储追踪数据可能需要大量的基础设施</li>
</ul>
</li>
<li>异常跟踪<ul>
<li>向集中式异常跟踪服务报告所有异常，该服务聚合和跟踪异常并通知开发人员</li>
<li>优点：更容易查看异常并跟踪其解决方案</li>
<li>缺点：额外的基础设施</li>
</ul>
</li>
<li>健康检查API<ul>
<li>服务具有&#x2F;health返回服务健康状况的健康检查 API端点，可以定期“ping”调用端点来检查服务实例的健康状况</li>
<li>优点：定期测试服务实例的健康状况</li>
<li>缺点：不全面，服务实例可能在健康检查之间失败</li>
</ul>
</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/%E6%A0%B8%E5%BF%83%E8%AF%BE/" class="category-chain-item">核心课</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="print-no-link">#软件系统设计</a>
      
        <a href="../../../../tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/" class="print-no-link">#软件架构</a>
      
        <a href="../../../../tags/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/" class="print-no-link">#质量属性</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>软件系统设计整理(架构部分)</div>
      <div>https://frosty-xue.github.io/2025/06/03/软件系统设计-架构部分/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Frosty</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 3, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../../05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%AB%E8%82%A1/" title="分布式八股">
                        <span class="hidden-mobile">分布式八股</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
