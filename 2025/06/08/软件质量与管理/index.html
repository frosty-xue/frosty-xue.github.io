

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/fluid.png">
  <link rel="icon" href="../../../../img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Frosty">
  <meta name="keywords" content="">
  
    <meta name="description" content="软件质量与管理整理1. 概述 软件危机 重要 软件的四大本质困难和挑战（本质属性，驱动力）：复杂性、不可见性、可变性、一致性 软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。 软件工程的两大视角：管理视角（复制成功）、技术视角（将问题解决的更好）">
<meta property="og:type" content="article">
<meta property="og:title" content="软件质量与管理">
<meta property="og:url" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Frosty的技术博客">
<meta property="og:description" content="软件质量与管理整理1. 概述 软件危机 重要 软件的四大本质困难和挑战（本质属性，驱动力）：复杂性、不可见性、可变性、一致性 软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。 软件工程的两大视角：管理视角（复制成功）、技术视角（将问题解决的更好）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250515203452375.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250518202931736.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250518192714432.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250518193541199.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/d8c3a2b8f9d80d9cd7d1def1dd65b7d7.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250518194051832.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/df85b44b1dcf59bf7b5fdea66948a8e6.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1bfee8d4d21944db9a5455c1bf134b20.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/R-C.jfif">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607102225859.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/15.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/16.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607120104805.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607120336736.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/40.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607150946435.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/42.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607144149912.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250607155442034.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519164147432.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519155035917.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519160110780.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519155447441.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519162907182.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519163014476.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519164319362.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519163551397.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519164254131.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250519170240942.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250522151457226.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250522170914180.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250522172352398.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250522175606093.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523151436911.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523153956240.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523162713085.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523162756283.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523171301862.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523171335641.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523171402600.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250523171431393.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250524095352283.png">
<meta property="og:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250524194221201.png">
<meta property="article:published_time" content="2025-06-08T04:10:13.000Z">
<meta property="article:modified_time" content="2025-06-17T13:48:52.057Z">
<meta property="article:author" content="Frosty">
<meta property="article:tag" content="软件质量与管理">
<meta property="article:tag" content="敏捷">
<meta property="article:tag" content="Kanban">
<meta property="article:tag" content="Scrum">
<meta property="article:tag" content="极限编程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://frosty-xue.github.io/2025/06/08/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/image-20250515203452375.png">
  
  
  
  <title>软件质量与管理 - Frosty的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"frosty-xue.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Frosty的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="软件质量与管理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-08 12:10" pubdate>
          June 8, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          191 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">软件质量与管理</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="软件质量与管理整理"><a href="#软件质量与管理整理" class="headerlink" title="软件质量与管理整理"></a>软件质量与管理整理</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><strong>软件危机</strong> 重要<ul>
<li><strong>软件的四大本质困难和挑战（本质属性，驱动力）</strong>：复杂性、不可见性、可变性、一致性</li>
<li>软件危机是指<strong>落后的软件生产方式</strong>无法满足迅速增长的<strong>计算机软件需求</strong>，从而导致软件开发与维护过程中出现一系列严重问题的现象。</li>
<li>软件工程是一门研究用<strong>工程化方法</strong>构建和维护有效的、实用的和高质量的软件的学科。</li>
<li>软件工程的两大视角：<strong>管理视角（复制成功）</strong>、技术视角（将问题解决的更好）</li>
</ul>
</li>
<li><strong>软件项目管理概念(重要)</strong><ul>
<li>管理的三大关键要素：目标、状态(接近目标还是远离目标)、纠偏</li>
<li><strong>软件项目管理</strong>是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li>软件过程<ul>
<li>软件过程(狭义)：软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</li>
<li>广义软件过程包括<strong>技术、人员以及狭义过程</strong></li>
</ul>
</li>
<li><strong>生命周期模型与软件过程</strong> 重要<ul>
<li>软件过程：是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合，这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标</li>
<li>生命周期模型：对软件过程的一种人为的划分。典型生命周期模型：<strong>瀑布模型</strong>、<strong>迭代式模型</strong>、增量模型、螺旋模型、原型法等等</li>
<li>区别：<ul>
<li>生命周期模型是对软件过程的一种人为划分</li>
<li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分</li>
<li>生命周期模型往往不包括技术实践</li>
</ul>
</li>
</ul>
</li>
<li><strong>如何理解瀑布模型</strong> 重要<ul>
<li>瀑布模型不是单一模型，是一系列模型，覆盖最简单场景（过程元素少）到最复杂的场景（过程元素多）</li>
<li>软件项目应该结合实际情况选择合适过程元素的瀑布模型，基本原则是，项目面临困难和挑战越多，选择的模型应该越复杂</li>
<li>软件项目团队往往低估项目的挑战，选择了过于简单的不使用的瀑布模型</li>
</ul>
</li>
<li>软件过程管理与软件项目管理<ul>
<li>软件过程管理的管理对象是软件过程</li>
<li>管理的<strong>目的</strong>是为了让软件过程在开发效率、质量等方面有着更好性能绩效</li>
<li><img src="image-20250515203452375.png" srcset="/img/loading.gif" lazyload alt="image-20250515203452375" style="zoom: 67%;" /></li>
</ul>
</li>
<li>软件过程管理与软件过程改进<ul>
<li>两者意思接近</li>
<li>软件过程管理参考模型 CMM&#x2F;CMMI, SPICE等</li>
<li>软件过程改进参考元模型 <strong>PDCA，IDEAL</strong></li>
</ul>
</li>
<li>以下说法是否正确？为什么？<ol>
<li>软件过程管理是软件项目管理应该要实现的目标：软件过程管理和软件项目管理完全是两回事，因此并不是实现目标，<strong>错误</strong>的。</li>
<li>在公司导入敏捷过程是我们今年过程改进的主要目标：过程管理和过程改进是类似的，这个说法是合理的，<strong>正确</strong>的。</li>
<li>XP与CMM&#x2F;CMMI是对立的两种软件开发方法：CMM和CMMI并不是软件开发方法，而是软件过程管理和改进，CMM和CMMI是没有较大区别的，<strong>错误</strong>的。</li>
<li>CMM&#x2F;CMMI不适合当今互联网环境的项目管理需求：CMM&#x2F;CMMI是用来做过程管理和改进的，根本不是满足项目管理需求的手段，<strong>错误</strong>的。</li>
<li>PDCA和IDEAL不适合在敏捷环境中使用：PDCA，IDEAL是软件过程改进参考元模型，因此是适合在敏捷环境中使用的，<strong>错误</strong>的。</li>
<li>不同的软件开发过程应该使用不同的生命周期模型，反之亦如此：生命周期模型是由人类划分的，不一定，<strong>错误</strong>的。</li>
</ol>
</li>
</ul>
<h2 id="2-软件过程的历史演变和经典工作"><a href="#2-软件过程的历史演变和经典工作" class="headerlink" title="2. 软件过程的历史演变和经典工作"></a>2. 软件过程的历史演变和经典工作</h2><ul>
<li><strong>软件发展三大阶段</strong> 重要<ul>
<li>软硬件一体化阶段（50年代~70年代）：软件完全依附于硬件、软件作坊<ul>
<li>线性顺序过程，事实上是硬件开发流程</li>
<li>Measure twice, cut once</li>
<li>Code and fix</li>
</ul>
</li>
<li>软件成为独立的产品（70年代~90年代）<ul>
<li>结构化程序设计和瀑布模型</li>
<li>成熟度模型</li>
</ul>
</li>
<li>网络化和服务化（90年代中期迄今）<ul>
<li>迭代式开发</li>
<li>敏捷开发（XP、SCRUM、Kanban）</li>
<li>开源软件开发方法</li>
<li>DevOps</li>
</ul>
</li>
</ul>
</li>
<li>软件完全依附于硬件<ul>
<li>软件<strong>应用</strong>典型特征：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更</li>
<li>软件<strong>开发</strong>典型特征：硬件太贵、团队以硬件工程师和数学家为主</li>
<li>典型软件过程和实践：Measure twice, cut once（相同的软件工程实践：code review &amp; inspection）</li>
<li><img src="image-20250518202931736.png" srcset="/img/loading.gif" lazyload alt="image-20250518202931736" style="zoom:50%;" /></li>
</ul>
</li>
<li>软件作坊<ul>
<li>软件<strong>应用</strong>典型特征：功能简单、规模小</li>
<li>软件<strong>开发</strong>典型特征：很多非专业领域的人员涌入、高级程序语言出现、质疑权威文化盛行</li>
<li>典型软件过程和实践：Code And Fix</li>
</ul>
</li>
</ul>
<h3 id="软件成为独立产品"><a href="#软件成为独立产品" class="headerlink" title="软件成为独立产品"></a>软件成为独立产品</h3><ul>
<li>软件<strong>应用</strong>典型特征：摆脱了硬件束缚（OS）、功能强大、规模和复杂度剧增、个人电脑出现使普通人成为软件用户、来自市场的压力</li>
<li>软件典型过程和实践：形式化方法、结构化设计+瀑布模型</li>
<li>瀑布模型与生命周期模型<ul>
<li><img src="image-20250518192714432.png" srcset="/img/loading.gif" lazyload alt="image-20250518192714432" style="zoom: 67%;" /></li>
<li><img src="image-20250518193541199.png" srcset="/img/loading.gif" lazyload alt="image-20250518193541199" style="zoom: 80%;" /></li>
<li>第一张图为瀑布模型，图二为简化的软件生命周期阶段</li>
<li>生命周期模型<ol>
<li>是什么：一个对软件过程的人为划分</li>
<li>主要作用：便于传达，复制成功</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>下面是各种软件过程改进模型</p>
</blockquote>
<ul>
<li><p><strong>成熟度模型</strong> 重要</p>
<ul>
<li>最开始是CMM，现在是CMMI</li>
<li>CMM（Capability Maturity Model），即软件能力成熟度模型，是一种评估和提高组织软件工程能力的标准体系。它可以帮助组织了解自身软件开发过程的成熟度，指导其逐步改进和优化软件开发流程，提高软件产品质量和开发效率。</li>
<li><img src="d8c3a2b8f9d80d9cd7d1def1dd65b7d7.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:40%;" /></li>
<li>CMMI（Capability Maturity Model Integration），即软件成熟度模型集成，是一个<strong>过程改进模型</strong>，旨在帮助组织改进其软件开发和维护过程。CMMI可以看作是CMM的进化版，它扩展了CMM的领域和深度，提供了更全面的过程改进框架。它不仅覆盖了软件开发领域，还涉及了系统工程、硬件开发和服务业务等。</li>
<li><img src="image-20250518194051832.png" srcset="/img/loading.gif" lazyload alt="image-20250518194051832" style="zoom: 67%;" /></li>
<li>CMMI成熟度分级<ul>
<li>初始级(Initial)：过程不可预测、项目管理很少、开发相对混乱；个人英雄主义、救火文化</li>
<li>已管理级(Managed)：以项目为单位进行管理，相对被动的管理；有项目计划和跟踪、需求管理、配置管理等</li>
<li>已定义级(Defined)：以公司为单位进行管理，相对主动的管理；公司层面有标准流程和相应规范，每个项目小组可以基于此定义自己的流程</li>
<li>定量管理级(Quantitatively Managed)：过程被度量和管理；构建预测模型，用统计过程控制的手段来管理过程</li>
<li>优化级(Optimizing)：关注与过程改进；继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>PDCA：软件过程改进模型</strong> 重要</p>
<ul>
<li>PDCA：Plan、Do、Check、Action</li>
<li><img src="df85b44b1dcf59bf7b5fdea66948a8e6.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" /></li>
</ul>
</li>
<li><p><strong>IDEAL：软件过程改进模型</strong> 重要</p>
<ul>
<li>IDEAL模型解决了软件在各种质量改进环境下的需要</li>
<li><img src="1bfee8d4d21944db9a5455c1bf134b20.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>其他模型</p>
<ul>
<li>SPICE模型：软件过程管理模型</li>
<li>ISO&#x2F;IEC：软件过程改进模型</li>
<li>RUP Rational Unified Process：软件过程框架</li>
</ul>
</li>
<li><p>讨论题</p>
<ul>
<li>CMMI是过程改进模型而非软件过程或者软件过程模型（<strong>正确</strong>，CMMI指导软件过程改进，不指导开发。）</li>
<li>CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较（<strong>正确</strong>，CMMI衡量的是相对的水平，CMMI仅仅关注在本公司的目标下的等级）</li>
<li>如何理解CMMI VS. Agile（敏捷）？CMMI 和 Agile 都是用于软件过程管理的模型，它们不是对立的。虽然两者在方法和理念上存在差异，但在实际环境中，这两种方法可以互补，帮助组织实现目标。</li>
</ul>
</li>
</ul>
<h3 id="网络化和服务化"><a href="#网络化和服务化" class="headerlink" title="网络化和服务化"></a>网络化和服务化</h3><ul>
<li>软件<strong>应用</strong>典型特征<ul>
<li>功能更复杂，规模更大</li>
<li>用户数量急剧增加</li>
<li>快速演化和需求不确定</li>
<li>分发方式的变化（SaaS，软件即服务，是一种通过Internet提供软件的模式）</li>
</ul>
</li>
<li>典型软件过程和实践<ul>
<li>迭代式：<strong>大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。</strong></li>
<li><strong>雪鸟会议和敏捷宣言</strong><ul>
<li>个体和互动胜过流程和工具</li>
<li>可以工作的软件胜过详尽的文档</li>
<li>客户合作胜过合同谈判</li>
<li>响应变化胜过遵循计划</li>
<li>也就是说，<strong>尽管右项有其价值，我们更重视左项的价值</strong>。</li>
</ul>
</li>
<li>敏捷软件开发方法：<ul>
<li>XP（eXtreme Programing） 方法：偏重于一些工程实践的描述</li>
<li>SCRUM：管理框架和管理实践</li>
<li>Kanban<ol>
<li>精益生产（丰田制造法）的具体实现</li>
<li>可视化工作流、限定WIP、管理周期时间</li>
<li>马丁提出了微服务架构</li>
</ol>
</li>
<li>开源软件开发方法：是一种基于并行开发模式的软件开发的组织与管理方式<ul>
<li>Linus 定律：如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</li>
<li>早发布，常发布，倾听用户的反馈 、把你的用户当成开发合作者对待</li>
<li>代码管理：严格的代码提交社区审核制度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当前软件发展现状"><a href="#当前软件发展现状" class="headerlink" title="当前软件发展现状"></a>当前软件发展现状</h3><ul>
<li><p>软件应用典型特征</p>
<ol>
<li>进一步服务化和网络化(移动是主流)</li>
<li>用户需求多样化进一步凸显</li>
<li>软件产品和服务的地位变化</li>
<li>错综复杂的部署环境</li>
</ol>
</li>
<li><p>近乎苛刻的用户期望</p>
<ol>
<li>多：功能丰富，个性化</li>
<li>快：快速使用，及时更新，快速解决问题</li>
<li>好：稳定，可靠，安全，可信</li>
<li>省：用户的获得成本低，最好免费</li>
</ol>
</li>
<li><p>空前强大的开发和部署环境——XaaS</p>
</li>
<li><p>盛行共享和开源</p>
</li>
<li><p>典型DevOps实践和方法</p>
<ul>
<li>方法论基础是敏捷软件开发、精益思想以及看板Kanban方法。</li>
<li>以领域驱动设计为指导的微服务架构方式</li>
<li>大量虚拟化技术的使用</li>
<li>一切皆服务XaaS(X as a Service)的理念指导</li>
<li>构建了强大的工具链，支持高水平自动化</li>
</ul>
</li>
</ul>
<h2 id="3-团队动力学"><a href="#3-团队动力学" class="headerlink" title="3. 团队动力学"></a>3. 团队动力学</h2><ul>
<li><p><strong>三大目标</strong> 重要：成本、质量、工期</p>
</li>
<li><p><strong>软件开发特点</strong> （结合软件开发特点谈谈自主型团队的必要性）</p>
<ul>
<li>软件开发是一项既复杂又富有创造性的<strong>知识工作</strong></li>
<li>软件开发是一种<strong>智力劳动</strong><ul>
<li>处理和讨论极其抽象的概念</li>
<li>把不同的部分（不可见）整合成一个可以工作的系统</li>
<li>全身心地参与</li>
<li>努力做出卓越的工作</li>
</ul>
</li>
<li>软件开发是一种智力活动，开发者是智力劳动者，而对于智力劳动者而言，管理的第一准则，就是智力劳动者不能被管理，只能<strong>实现自我管理</strong>。</li>
</ul>
</li>
<li><p><strong>知识工作管理</strong> 重要</p>
<ul>
<li>管理知识工作的关键规则是：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</li>
<li>要自我管理，知识工作者必须(如下是自我管理的前提条件)<ol>
<li>有积极性：不然可能会被其他人替代</li>
<li>能做出准确的估算和计划</li>
<li>懂得协商承诺</li>
<li>有效跟踪他们的计划</li>
<li>持续地按计划交付高质量产物</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>知识工作的领导者</strong> 重要</p>
<ul>
<li><p>知识工作者的管理需要的是领导者，而不是经理</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>善于<strong>倾听</strong>团队成员的想法，并加以分析和改进</li>
<li>善于通过<strong>询问</strong>来诱导团队成员向着正确的方向前进</li>
<li>善于通过<strong>激励</strong>以及设定挑战目标等方式吸引团队成员努力表现</li>
<li>当出现不一致意见的时候，领导者则善于提供各种沟通方式，促成团队<strong>达成一致意见</strong></li>
<li><strong>培养</strong>团队成员技能</li>
<li>鼓励建立起合理的<strong>授权</strong>机制</li>
<li>通过挑战<strong>建立目标</strong>，确定团队努力方向</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>领导者的激励手段</strong> 重要</p>
<ul>
<li>有3种主要的激励方式：<ul>
<li>威逼</li>
<li>利诱</li>
<li>鼓励承诺：位于马斯洛需求理论的4级以上，应当是主要的方式，并且最好以团队为单位做承诺</li>
<li>鼓励承诺效果最好</li>
<li>交易型领导方式<ol>
<li>承诺奖励激励</li>
<li>人们通常能找到新的方式来获得奖励，同时少做工作。</li>
<li><strong>威逼和利诱属于交易型领导方式</strong>。</li>
</ol>
</li>
<li>转变型领导方式<ol>
<li>用成就激励</li>
<li><strong>鼓励承诺属于转变型领导方式</strong>。</li>
</ol>
</li>
<li>由于交易型领导方式很少能产生成功的并且有创造性的团队，因此<strong>转变型领导方式</strong>是首选。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>马斯洛的需求理论</strong> 重要</p>
<ul>
<li><img src="R-C.jfif" srcset="/img/loading.gif" lazyload alt="马斯洛需求层次理论" style="zoom:50%;" />
</li>
<li><p>注：第三层ppt中是social社交需求，图是网上找的</p>
</li>
<li><p>自我实现是最高的层次</p>
</li>
<li><p>激励来自为没有满足的需求而努力奋斗</p>
</li>
<li><p>低层次的需求必须在高层次需求满足之前得到满足</p>
</li>
<li><p>满足高层次的需求的途径比满足低层次的途径更为广泛</p>
</li>
</ul>
</li>
<li><p><strong>期望理论</strong> 重要</p>
<ul>
<li><p>人们在下列情况下能够受到激励并且出大量成果 M &#x3D; V * E</p>
<ol>
<li>相信自己会因为成功得到相应的回报(V)</li>
<li>相信他们的努力很可能会产生成功的结果(E)</li>
</ol>
</li>
<li><p>Motivation &#x3D; Valence x Expectancy(Instrumentality)，即激发力量 &#x3D; 效价 * 期望值</p>
<ol>
<li>M 表示激发力量，是指调动一个人的积极性，激发人内部潜力的强度。</li>
<li>V 表示目标价值（效价），这是一个心理学概念，是指达到目标对于满足他个人需要的价值。同一目标，由于各个人所处的环境不同，需求不同，其需要的目标价值也就不同。同一个目标对每一个人可能有三种效价：正、零、负。效价越高，激励力量就越大</li>
<li>E 是期望值，是人们根据过去经验判断自己达到某种目标的可能性是大还是小，即能够达到目标的概率。目标价值大小直接反映人的需要动机强弱，期望概率反映人实现需要和动机的信心强弱。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>自主团队</strong> 重要</p>
</li>
</ul>
<ul>
<li>内部环境（特点）<ul>
<li>自行定义项目的目标</li>
<li>自行决定团队组成形式以及成员的角色</li>
<li>自行决定项目的开发策略</li>
<li>自行定义项目的开发过程</li>
<li>自行制定项目的开发计划</li>
<li>自行度量、管理和控制项目工作</li>
<li>外部环境<ul>
<li>项目启动阶段获得管理层的支持：</li>
<li>在项目进展过程中获得管理层的支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>TSP(Team Software Process)：团队软件过程</li>
</ul>
<p><strong>TSP角色与职责</strong> 重要</p>
<ul>
<li>项目组长（项目经理）：建设和维持高效率的团队<ul>
<li>激励团队成员努力工作</li>
<li><strong>主持</strong>项目周例会</li>
<li>每周<strong>汇报</strong>项目状态</li>
<li><strong>分配</strong>工作任务</li>
<li>维护项目资料</li>
<li><strong>组织</strong>项目总结</li>
</ul>
</li>
<li>计划经理：开发完整的、准确的团队计划和个人计划<ul>
<li>带领项目小组<strong>开发项目计划</strong></li>
<li>带领项目小组<strong>平衡计划</strong></li>
<li><strong>跟踪项目进度</strong></li>
<li>参与项目总结</li>
</ul>
</li>
<li>开发经理：开发优秀的软件产品<ul>
<li>带领团队<strong>制定开发策略</strong>。</li>
<li>带领团队开展产品规模估算和所需时间资源的<strong>估算</strong>。</li>
<li>带领团队开发<strong>需求规格说明</strong>。</li>
<li>带领团队开发<strong>高层设计</strong>。</li>
<li>带领团队开发<strong>设计规格说明</strong>。</li>
<li>带领团队<strong>实现软件产品</strong>。</li>
<li>带领团队开展<strong>集成测试和系统测试</strong>。</li>
<li>带领团队开发<strong>用户支持文档</strong>。</li>
<li>参与项目总结</li>
</ul>
</li>
<li>质量经理：保证项目团队严格按照质量计划开展工作，开发出高质量的软件产品<ul>
<li>带领团队开发和跟踪<strong>质量计划</strong></li>
<li>向项目组长<strong>警示质量问题</strong></li>
<li>软件产品提交配置管理之前，对其进行评审，以消除<strong>质量问题</strong></li>
<li>项目小组<strong>评审的组织者和协调者</strong></li>
<li>参与项目总结</li>
</ul>
</li>
<li>过程经理：维护所有团队成员准确的记录、报告和跟踪过程数据<ul>
<li>带领团队<strong>定义</strong>和<strong>记录</strong>开发过程并且支持过程改进。</li>
<li><strong>建立</strong>和维护团队的<strong>开发标准</strong>。</li>
<li><strong>记录和维护</strong>项目的<strong>会议记录</strong>。</li>
<li>参与项目总结。</li>
</ul>
</li>
<li>支持经理：保证项目小组在整个开发过程中都有合适的工具和环境<ul>
<li>带领团队识别开发过程中所需要的各类工具和设施。</li>
<li>主持配置管理委员会，<strong>管理配置管理系统</strong>。</li>
<li>维护软件项目的<strong>词汇表</strong>。</li>
<li>维护<strong>项目风险和问题跟踪</strong>系统。</li>
<li>支持软件开发过程中<strong>复用策略</strong>的应用。</li>
<li>参与项目总结。</li>
</ul>
</li>
<li>开发人员：开发</li>
</ul>
<ul>
<li><p><strong>TSP启动过程</strong> 重要</p>
<ul>
<li><img src="image-20250607102225859.png" srcset="/img/loading.gif" lazyload alt="image-20250607102225859" style="zoom: 50%;" />
</li>
<li><p>第一次和第二次会议由项目经理主持</p>
</li>
<li><p>第三次会议</p>
<ul>
<li>TSP灵活：自定义的流程让人相信项目可以成功</li>
<li>开发策略：打算进行几个迭代周期。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Scrum角色和职责</strong>见邵栋部分 重要</p>
</li>
</ul>
<h2 id="4-估算和计划"><a href="#4-估算和计划" class="headerlink" title="4. 估算和计划"></a>4. 估算和计划</h2><ul>
<li><p><strong>估算目的</strong> 重要：估算目的是给各类计划提供决策依据</p>
</li>
<li><p><strong>PROBE估算方法</strong> 重要</p>
<ul>
<li><p>规模度量&#x2F;估算的困境</p>
<ul>
<li><strong>精确度量</strong>方式往往不便于<strong>早期规划</strong>&#x2F;估算；</li>
<li>有助于<strong>早期规划</strong>&#x2F;估算的度量往往难以产生<strong>精确度量</strong>结果；</li>
</ul>
</li>
<li><p>PROBE(PROxy Based Estimation)的作用：<strong>精确度量</strong>和<strong>早期规划</strong>之间的桥梁</p>
</li>
<li><p>要做的估算：规模估算和资源估算</p>
</li>
<li><p>基本原理：设立合理的代理作为精确度量和早期规划之间的桥梁；相对大小而非绝对大小</p>
</li>
<li><p>例子：估算一栋房屋的建造成本，大部分人没有概念。然而，在早期规划中，会有如下认识&#x2F;需求</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>用途</th>
<th>相对大小及数量</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>厨房</td>
<td>1个中等大小</td>
</tr>
<tr>
<td>2</td>
<td>卧室</td>
<td>1个大卧室；2个小卧室</td>
</tr>
<tr>
<td>3</td>
<td>卫生间</td>
<td>1个中等大小；1个小型</td>
</tr>
<tr>
<td>4</td>
<td>书房</td>
<td>1个中等大小</td>
</tr>
<tr>
<td>5</td>
<td>客厅</td>
<td>1个大客厅</td>
</tr>
</tbody></table>
<ul>
<li><p>相对大小矩阵：</p>
</li>
<li><img src="15.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></li>
</ul>
</li>
<li><p>PROBE估算流程</p>
<ul>
<li><img src="16.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></li>
</ul>
</li>
<li><p>概要设计</p>
<ul>
<li>估算的第一步是做出一个概要设计</li>
<li>为了做出概要设计，需要确定产品功能，以及产生这些功能所需的<strong>程序组件&#x2F;模块</strong></li>
<li>然后，将这些<strong>程序组件&#x2F;模块</strong>与你以前写的程序相比较，估算它们的规模</li>
<li>最后，将<strong>程序组件&#x2F;模块</strong>估算综合给出总规模</li>
</ul>
</li>
<li><p><strong>估算要点</strong> 重要</p>
<ul>
<li>尽可能划分详细一些</li>
<li>建立对结果的信心</li>
<li>依赖数据</li>
<li>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</li>
</ul>
</li>
<li><p><strong>Scrum故事点</strong> 重要</p>
<ul>
<li>度量实现一个故事（Story）需要付出的工作量<ol>
<li><strong>抽象的</strong>：混合了对于开发特性（feature）所要付出的努力、开发复杂度、个中风险以及类似东西</li>
<li><strong>相对的</strong>：设定标准之后，考虑其他特性（feature）与标准之间的相对大小关系</li>
</ol>
</li>
<li>Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21,34, 55, 89</li>
</ul>
</li>
<li><p>工作分解结构 WBS</p>
<ul>
<li><img src="image-20250607120104805.png" srcset="/img/loading.gif" lazyload alt="image-20250607120104805" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>开发策略与计划</p>
<ul>
<li>开发策略是在产品组件需求基础之上，明确每个产品组件的获得方式与顺序，从而在项目团队内部建立起大家都理解的产品开发策略。</li>
<li>注意事项<ol>
<li>WBS的使用</li>
<li>产品组件开发顺序的考虑</li>
<li>产品组件获得方式的考虑</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>通用计划框架</strong> 重要</p>
<ul>
<li><img src="image-20250607120336736.png" srcset="/img/loading.gif" lazyload alt="image-20250607120336736" style="zoom: 67%;" /></li>
<li>必须人为干预的步骤<ol>
<li>定义需求</li>
<li>概要设计：划分由人为开始，规模划分好之后估算是自动产生的</li>
<li>日程计划</li>
</ol>
</li>
<li>这会带来什么的好处？比较容易扛住别人的质疑。<ol>
<li>攻击点：资源和时间是否被高估了</li>
<li>解决：估算没有代码行PROBE只有功能点是大中小。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>质量计划</strong> 重要</p>
<ul>
<li>项目的质量计划中应当确定需要开展的质量保证活动。</li>
<li>典型的质量保证活动包括<strong>个人评审、团队评审、单元测试、集成测试、系统测试</strong>以及<strong>验收测试</strong>等。</li>
<li>在质量计划中需要解决的关键的问题是该<strong>开展哪些活动</strong>，以及这些<strong>活动开展的程度</strong>，如时间、人数和目标分别是什么。</li>
</ul>
</li>
<li><p><strong>风险计划</strong> 重要</p>
<ul>
<li>风险管理的目的是在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li>
<li>风险管理大致分成两部分，即<strong>风险识别</strong>和<strong>风险应对</strong>。</li>
</ul>
</li>
<li><p><strong>挣值管理体系</strong> 重要</p>
<ul>
<li><p>项目的挣值管理方法(Earned Value Management，简称EVM)是用来客观度量项目进度的一种项目管理方法。</p>
<ol>
<li>每项任务实现附以一定价值（credit）</li>
<li>100%完成该项任务，就获得相应价值</li>
</ol>
</li>
<li><p>EVM采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p>
<ul>
<li>简单实现：添加挣值（EV）</li>
<li>中级实现：添加成本线（AC）</li>
<li>高级实现：添加预测线（BAC），当任务足够多的时候，我们就可以让预测线尽可能平直，同时我们延伸挣值（EV），找到与预测线（BAC）的交点，我们就可以明确项目的落后时间</li>
</ul>
</li>
<li><p>分析图示</p>
<ul>
<li><img src="40.png" srcset="/img/loading.gif" lazyload></li>
<li>上面的线是为了获取这些挣值付出的实际代价，这个线和挣值之间的差异是成本差异。</li>
<li>中间的线是预算（每天需要完成多少挣值）BAC，理想情况下是一条直线。</li>
<li>下面的线是挣值（实际的进展情况）（EV），和owner value有关，对应plan value</li>
<li><img src="image-20250607150946435.png" srcset="/img/loading.gif" lazyload alt="image-20250607150946435"></li>
</ul>
</li>
<li><p>EVM的变形：燃尽图</p>
<ul>
<li><img src="42.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></li>
<li>燃尽图是简单的挣值管理的变形。</li>
<li><strong>是剩下的工作占的百分比</strong></li>
</ul>
</li>
<li><p>EVM的局限性</p>
<ul>
<li><p>一般不能应用软件项目的质量管理。</p>
</li>
<li><p>需要定量化的管理机制</p>
</li>
<li><p>完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算</p>
</li>
</ul>
</li>
<li><p>挣值管理为什么能适应软件项目：它能够将项目进度和成本结合起来，通过量化的方式动态跟踪项目实际完成情况（挣值）与计划进度和预算的对比，及时发现偏差，便于软件项目灵活调整和有效控制进度与成本，提高可控性和透明度。</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-质量管理"><a href="#5-质量管理" class="headerlink" title="5. 质量管理"></a>5. 质量管理</h2><ul>
<li>质量概念<ul>
<li>软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”。</li>
<li>软件质量为内外两部分的特性：其外部质量特性面向软件产品的最终用户，其内部质量特性则不直接面向最终用户。</li>
<li>用户满意度是最为重要的判断标准，对同一款软件而言，不同的用户对其质量有不同的体验。</li>
</ul>
</li>
<li><strong>面向用户的质量观</strong> 重要<ul>
<li>面向用户的质量观，定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：<ul>
<li>用户究竟是谁？</li>
<li>用户需求的优先级是什么？</li>
<li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li>
<li>怎样来度量这种质量观下的质量水平？</li>
</ul>
</li>
</ul>
</li>
<li><strong>质量管理策略</strong> 重要<ul>
<li>用缺陷管理来替代质量管理</li>
<li>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷；</li>
</ul>
</li>
<li>测试消除缺陷典型流程<ul>
<li>发现待测程序的一个异常行为；</li>
<li>理解程序的工作方式；</li>
<li>调试程序，找出出错的位置，确定出错原因；</li>
<li>确定修改方案，修改缺陷；</li>
<li>回归测试，以确认修改有效；</li>
</ul>
</li>
<li>评审发缺陷典型流程<ul>
<li>遵循评审者的逻辑来理解程序流程；</li>
<li>发现缺陷的同时，也知道了缺陷的位置和原因；</li>
<li>修正缺陷</li>
</ul>
</li>
<li>PSP：个人软件过程</li>
<li><strong>个人评审</strong> 重要<ul>
<li>关键控制因素：单元测试和code review，code review优先</li>
<li>时机选择：编译（UT）之前 VS. 之后</li>
<li>小组评审是由多人组成的小组共同进行的评审活动，其核心目的是通过小组讨论、集体智慧，对项目的流程和过程进行质量把控，确保过程符合质量要求，及时发现和纠正问题，从而提升整体质量管理水平。</li>
</ul>
</li>
<li><strong>质量控制指标</strong> 重要<ul>
<li>指标一：Yield（良品率）<ul>
<li>Yield指标用以度量每个阶段在消除缺陷方面的效率。</li>
<li>Phase Yield &#x3D; 100 * (某阶段发现的缺陷个数)&#x2F;(某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数)</li>
<li>Process Yield &#x3D; 100 * (第一次编译前发现的缺陷个数)&#x2F;(第一次编译前注入的缺陷个数)；</li>
<li><img src="image-20250607144149912.png" srcset="/img/loading.gif" lazyload alt="image-20250607144149912"></li>
</ul>
</li>
<li>指标二：A&#x2F;FR<ul>
<li>A&#x2F;FR &#x3D; PSP质检成本&#x2F;PSP失效成本</li>
<li>帮助团队权衡投入评审、测试等质量活动的成本与后期失效所带来的代价</li>
<li>理论上，A&#x2F;FR的值越大，往往意味着越高的质量。</li>
<li>过高的A&#x2F;FR往往意味着做了过多的评审，反而会导致开发效率的下降。</li>
</ul>
</li>
<li>指标三：PQI<ul>
<li>用于综合反映开发过程中缺陷的密度水平，5个数据乘积(定义成0.0~1.0之间的数值)(以基准值作为1，<strong>最后结果越接近1质量越⾼</strong>)</li>
<li>5个数据<ol>
<li>设计质量：min{设计时间&#x2F;编码时间, 1}</li>
<li>设计评审质量：min{(2 * 设计评审时间 &#x2F; 设计时间), 1}</li>
<li>代码评审质量：min{(2 * 代码评审时间)&#x2F;编码时间 , 1}</li>
<li>代码质量：min{20&#x2F;(编译缺陷密度 + 10), 1}</li>
<li>程序质量：min{10&#x2F;(单元测试缺陷密度 + 5), 1}</li>
</ol>
</li>
</ul>
</li>
<li>指标四：Review Rate<ul>
<li>评审的速度(Review Rate)是一个用以指导软件工程师开展有效评审的指标</li>
<li>高质量的评审需要软件工程师投入足够的时间进行评审</li>
</ul>
</li>
<li>指标五：DRL<ul>
<li>缺陷消除效率比度量的是不同缺陷消除手段消除缺陷的效率。</li>
<li>其计算方式是以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</li>
</ul>
</li>
<li>特点和用途：<ul>
<li><strong>Yield</strong>：衡量各阶段发现缺陷的能力，用于分析流程质量控制效果。</li>
<li><strong>A&#x2F;FR</strong>：比较预防成本与失效成本，用于评估质量投入的经济性。</li>
<li><strong>PQI</strong>：反映开发过程中的缺陷密度，用于整体质量评估。</li>
<li><strong>Review Rate</strong>：衡量评审效率，用于指导合理评审节奏。</li>
<li><strong>DRL</strong>：比较不同方法的缺陷发现效率，用于优化缺陷检测手段。</li>
</ul>
</li>
</ul>
</li>
<li><img src="image-20250607155442034.png" srcset="/img/loading.gif" lazyload alt="image-20250607155442034"></li>
</ul>
<blockquote>
<p>下面是sd部分</p>
</blockquote>
<h2 id="1-Scrum"><a href="#1-Scrum" class="headerlink" title="1. Scrum"></a>1. Scrum</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><ul>
<li><p>定义</p>
<ul>
<li>Scrum <strong>不是构建产品的一种过程或一项技术，而是一个框架</strong>，在这个框架里可以应用各种流程和技术。Scrum 能使产品管理和开发实践的相对功效显现出来,以便随时改进。</li>
<li>Scrum 是一个轻量的框架，它通过提供针对复杂问题的自适应解决方案来帮助人们、团队和组织创造价值</li>
<li>简而言之，Scrum 需要 <strong>Scrum Master</strong> 营造一个环境，从而：<ul>
<li>一名 Product Owner 将解决复杂问题所需的工作整理成一份 Product Backlog。</li>
<li>Scrum Team 在 一个 Sprint 期间将选择的工作转化为价值的 Increment</li>
<li>Scrum Team 和利益攸关者检视结果并为下一个 Sprint 进行调整</li>
<li>重复</li>
</ul>
</li>
<li>Scrum 基于<strong>经验主义和精益思维</strong>。 经验主义主张<strong>知识源自实际经验以及根据当前观察到的事物作出的判断所获得</strong>。</li>
</ul>
</li>
<li><p>Scrum Team</p>
<ul>
<li><p>Scrum Team 由<strong>一名 Scrum Master</strong>，<strong>一名 Product Owner</strong> 和 <strong>Developers</strong> 组成</p>
</li>
<li><p>在 Scrum Team 中，没有子团队或层次结构</p>
</li>
<li><p>Scrum Team 规模足够小以保持灵活，同时足够大以便可以在 一个 Sprint 中完成重要的工作，通常只有 10 人或更少</p>
</li>
<li><p>Scrum Team 是<strong>跨职能</strong>的，这意味着团队成员具有在每个 Sprint 中创造价值而所需的<strong>全部技能</strong>（反例：职能团队，UI团队、业务逻辑团队、测试团队等等）</p>
</li>
<li><img src="image-20250519164147432.png" srcset="/img/loading.gif" lazyload alt="image-20250519164147432" style="zoom:50%;" /></li>
<li><p>微观管理：在对员工的工作管理中，管理者过度关注和控制工作细节的管理风格和管理行为。会导致团队成员失去主观能动性、工作中出现决策等待和低效、影响到团队的积极性和士气</p>
</li>
<li><p>自管理：指个体或团队在明确目标下，通过自我规划、自我监督、自我调整等方式，自主完成任务的机制。</p>
</li>
<li><p>自组织：指复杂系统（如生态系统、社会组织）在没有外部指令干预的情况下，通过内部成员或元素的互动，自发形成有序结构和功能的过程。</p>
</li>
</ul>
</li>
<li><p>用户故事</p>
<ul>
<li>用户故事是产品列表的基础构件</li>
<li><img src="image-20250519155035917.png" srcset="/img/loading.gif" lazyload alt="image-20250519155035917" style="zoom:50%;" /></li>
<li>告诉我们想要这个功能的是谁、预期功能是什么 、为什么用户想要这个功能</li>
<li>用户故事不是完整的需求或说明书，它们是占位符，足以提醒团队有东西要完成</li>
<li>用户故事地图：是一门在需求拆分过程中保持全景图的技术。敏捷软件开发中使用用户故事地图来发现、管理需求</li>
<li><img src="image-20250519160110780.png" srcset="/img/loading.gif" lazyload alt="image-20250519160110780" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>Definition of Done(DoD)</strong></p>
<ul>
<li>DoD用于描述一个用户故事、任务或功能何时可以被认为真正“完成”。它是团队对完成工作的标准化定义，确保开发过程中每个增量都符合质量要求并准备好交付。</li>
<li>作用：提高透明度、保证质量、支持验收流程、防止技术债</li>
<li><img src="image-20250519155447441.png" srcset="/img/loading.gif" lazyload alt="image-20250519155447441" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>行为驱动开发 BDD</p>
<ul>
<li>是一种基于敏捷的软件开发方法论，其核心思想是通过定义软件的行为来驱动开发过程</li>
<li>BDD 是从测试驱动开发（TDD）演化而来的，强调在开发开始之前，用自然语言描述软件应如何行为</li>
<li>过程：编写用户故事 -&gt; 定义验收标准</li>
</ul>
</li>
<li><p>Sprint 管理：白板Scrum任务板</p>
<ul>
<li><img src="image-20250519162907182.png" srcset="/img/loading.gif" lazyload alt="image-20250519162907182" style="zoom: 50%;" /></li>
</ul>
</li>
<li><p>Sprint进度跟踪：燃尽图</p>
<ul>
<li><img src="image-20250519163014476.png" srcset="/img/loading.gif" lazyload alt="image-20250519163014476" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h3 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h3><ul>
<li><p><strong>Scrum 33355</strong>（重要）</p>
<ul>
<li>三大支柱：透明、检视、适应</li>
<li>三个角色：开发人员(Developers)、产品负责人（Product Owner）、Scrum主管(Scrum Master)</li>
<li>三个工件：Product Backlog、Sprint Backlog、增量(Increment)</li>
<li>五个价值：承诺、专注、开放、尊重和勇气</li>
<li>五个事件：Sprint、Sprint 计划会议(Sprint Planning)、每日 Scrum 会议(Daily Scrum)、Sprint 评审会议(Sprint Review)、Sprint 回顾会议(Sprint Retrospective)</li>
</ul>
</li>
<li><p>三大支柱</p>
<ul>
<li>透明：开发的过程和工作必须对执行工作的人员和接受工作的人员都是可见的。在 Scrum 中，重要的决策是基于其 <strong>3 个正式工件</strong>的感知状态。透明使检视成为可能。没有透明的检视会产生误导和浪费。</li>
<li>检视：Scrum 工件和实现商定目标的进展必须经常地和勤勉地检视，以便发现潜在的不良的差异或问题。为了帮助检视，Scrum 以 <strong>5 个事件</strong>的形式提供了稳定的节奏。检视使适应成为可能。没有适应的检视是毫无意义的。</li>
<li>适应：如果过程的任何方面超出可接受的范围或所得的产品不可接受，就必须对当下的过程或过程处理的内容加以调整适应，而且调整工作必须尽快执行。</li>
</ul>
</li>
<li><p>三个角色</p>
<ul>
<li>Developers：致力于创建每个 Sprint 可用 Increment 的任何方面的人员。所需的特定技能通常很广泛，并且会随着工作领域的不同而变化。职责：<ul>
<li>为 Sprint 创建计划，即 Sprint Backlog</li>
<li>通过遵循 Definition of Done 来注入质量</li>
<li>每天根据 Sprint Goal 调整计划</li>
<li>作为专业人士对彼此负责</li>
</ul>
</li>
<li>Product Owner：负责将 Scrum Team 的工作所产生的产品价值最大化。职责：<ul>
<li>开发并明确地沟通 Product Goal</li>
<li>创建并清晰地沟通 Product Backlog 条目</li>
<li>对 Product Backlog 条目进行排序</li>
<li>确保 Product Backlog 是透明的、可见的和可理解的</li>
</ul>
</li>
<li>Scrum Master：负责按照 Scrum 指南的规则来建立 Scrum团队，对 Scrum Team 的效能负责。他们通过帮助 Scrum Team 和组织内的每个人理解 Scrum 理论和实践来做到这一点。职责：<ul>
<li>作为教练在自管理和跨职能方面辅导 Scrum Team 成员</li>
<li>帮助 Scrum Team 专注于创建符合 Definition of Done 的高价值 Increment</li>
<li>促使移除 Scrum Team 工作进展中的障碍，包括协调团队与利益相关者</li>
<li>确保所有 Scrum 事件都发生并且是积极的、富有成效的，并且在时间盒（timebox）内完成</li>
<li>帮助Product Owner有效定义 Product Goal 和管理 Product Backlog</li>
</ul>
</li>
</ul>
</li>
<li><p>三大工件</p>
<ul>
<li><p>Product Backlog</p>
<ul>
<li>是<strong>Scrum的核心</strong>，是按重要性排序的需求或故事（Story）的列表（客户语言描述的客户需求）</li>
<li>能够被 Scrum Team 在一个 Sprint 中完成（Done）的 Product Backlog 条目被认为准备就绪，在Sprint Planning 事件中可供选择。</li>
<li>Product Backlog 精化是将 Product Backlog 条目分解并进一步定义为更小更精确的行为</li>
<li>Product Owner必须参加计划会议</li>
</ul>
</li>
<li><p>Sprint Backlog</p>
<ul>
<li>一个为当前Sprint准备的任务列表，开发团队负责如何实现这些任务</li>
</ul>
</li>
<li><p>Increment</p>
<ul>
<li>每次Sprint结束后交付的工作，应该是“完成”(Done)的并具备可用性</li>
</ul>
</li>
<li><img src="image-20250519164319362.png" srcset="/img/loading.gif" lazyload alt="image-20250519164319362" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>五个价值</p>
<ul>
<li>承诺：专注目标</li>
<li>专注：聚焦Sprint任务</li>
<li>开放：坦诚面对挑战</li>
<li>尊重：认可成员能力</li>
<li>勇气：解决棘手问题</li>
</ul>
</li>
<li><p>五个事件</p>
<ul>
<li>Sprint<ul>
<li>Sprint 是 <strong>Scrum 的核心</strong>，在这里创意转化为价值</li>
<li>它们是固定时长的事件，为期一个月或更短，以保持一致性。前一个 Sprint 结束后，下一个新的Sprint 紧接着立即开始</li>
<li>实现 Product Goal 所需的所有工作，包括 Sprint Planning、Daily Scrum、Sprint Review 和 Sprint Retrospective，都发生在 Sprint 内</li>
<li>当前，<strong>Scrum 周期通常为2个星期</strong>（重要）</li>
</ul>
</li>
<li>Sprint Planning<ul>
<li>所有人都可以编写添加条目，但只有Product Owner才能决定优先级</li>
<li>会议目标：sprint目标、团队成员名单、Sprint backlog(故事列表)、确定好sprint演示日期、确定时间地点(用于每日Sprint会议)</li>
<li>每个故事都含有三个变量：范围(scope)、重要性(importance)、和估算 (estimate)</li>
<li>Story point（故事点）：是一种用于评估和比较用户故事（User Story）或开发任务相对复杂性、难度和工作量的度量单位。选取可识别的最小用例为2个story point，其它估算都是<strong>相对值</strong>，在所有sprint中保持该相对值一致</li>
<li>例子：我们一个迭代周期可以完成20个story point,则我们可以按照优先级顺序在现有product backlog中选取20个story point以内的user story放在本迭代周期内完成。</li>
<li><strong>估算方法</strong>：扑克估算法、金发女孩估算法</li>
</ul>
</li>
<li>Daily Scrum每日站会<ul>
<li>回答三个问题：昨天做了什么、今天准备做什么、遇到了什么障碍需要其他人如何帮你</li>
<li>移动任务板上的即时贴到对应的地方</li>
<li>每日例会一结束就要计算剩余工作故事点并更新燃尽图</li>
</ul>
</li>
<li>Sprint Review 评审会议<ul>
<li>也叫Sprint演示会议，内容是演示你的Scrum团队做的东西</li>
<li><img src="image-20250519163551397.png" srcset="/img/loading.gif" lazyload alt="image-20250519163551397" style="zoom: 50%;" /></li>
</ul>
</li>
<li>Sprint Retrospective 回顾会议<ul>
<li>Sprint回顾是<strong>仅次于Sprint计划会议的第二重要的事件</strong></li>
<li>主题：我们怎样才能在下个Sprint中做的更好，不是追究责任</li>
</ul>
</li>
<li><img src="image-20250519164254131.png" srcset="/img/loading.gif" lazyload alt="image-20250519164254131" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>Scrum的局限</p>
<ul>
<li>没有具体实践</li>
<li>Scrum关注<strong>项目管理和团队过程</strong>，而XP<strong>侧重工程实践和代码质量</strong></li>
</ul>
</li>
<li><p>Scrum的核心优势</p>
<ul>
<li>轻量灵活：仅定义必要规则，兼容多种实践</li>
<li>持续改进：通过事件循环实现经验反馈</li>
<li>价值驱动：以Product Goal为导向，确保交付有效性</li>
<li>协作透明：跨角色协作，信息共享最大化</li>
</ul>
</li>
<li><p>Scrum相关的框架实践</p>
<ul>
<li>大规模敏捷SAFe ：SAFe（Scaled Agile Framework），融合了敏捷和精益思想，为大企业提供一个分层次的敏捷实施蓝图。它定义了团队层等层级，强调通过统一节奏和里程碑来协调多个团队</li>
<li>LeSS(Large-Scale Scrum)：仅在一个产品待办列表下扩展多个Scrum团队，尽量减少额外角色</li>
</ul>
</li>
</ul>
<h2 id="2-XP背景和变更曲线"><a href="#2-XP背景和变更曲线" class="headerlink" title="2. XP背景和变更曲线"></a>2. XP背景和变更曲线</h2><ul>
<li>极限编程（XP）作为一种敏捷开发方法诞生于20世纪90年代后期的软件工程实践。其主要创始人是Kent Beck</li>
<li>最近Scrum成为最主流的敏捷框架，而XP作为一个完整的方法使用相对减少。不过，XP的许多实践（如结对编程、测试驱动开发、持续集成等）已经被广泛接受，并常与Scrum等组合使用</li>
<li>XP的步骤<ul>
<li>编写代码</li>
<li>运行所有测试用例</li>
<li>迭代测试用例和代码</li>
<li>如果需要，进行重构</li>
<li>集成，包括集成测试</li>
</ul>
</li>
<li>说明<ul>
<li>程序员<strong>两两结对编程</strong>。</li>
<li>开发由<strong>测试驱动</strong>。</li>
<li>结对编程不仅仅是让测试用例运行起来。结对编程为系统的分析、设计、实现和测试增加价值。</li>
<li>开发后立即进行集成，包括集成测试</li>
</ul>
</li>
<li>变更成本曲线<ul>
<li>软件工程的一个普遍假设是，随着时间的推移，更改程序的成本呈指数增长。在一段软件中修复一个问题的成本会随时间呈指数增长。这导致传统方法强调“早期做好一切”，试图避免后期修改。</li>
<li><img src="image-20250519170240942.png" srcset="/img/loading.gif" lazyload alt="image-20250519170240942" style="zoom: 67%;" /></li>
<li>XP认为变更成本曲线可以变平</li>
</ul>
</li>
<li>XP的技术前提<ul>
<li>如果变更成本随时间缓慢上升，你的行为将与在成本呈指数增长这一假设下的行为完全不同</li>
<li>你会在工作中尽可能晚地做出重大决策，以推迟做出决策的成本，并使决策正确的可能性尽可能大</li>
<li>你只会实现必须实现的内容</li>
<li>只有当简化现有代码或使编写下一段代码更简单时，你才会将这些设计元素引入代码中</li>
</ul>
</li>
<li>降低变更成本的技术：面向对象、简单设计、自动化测试、重构技术、CICD</li>
</ul>
<h2 id="3-XP实践"><a href="#3-XP实践" class="headerlink" title="3. XP实践"></a>3. XP实践</h2><h3 id="一些基本知识"><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h3><ul>
<li>XP价值观：交流（Communication）、简单（Simplicity）、反馈（FeedBack）、勇气（Courage）</li>
<li>极限编程（XP）强制要求的沟通方式：单元测试、结对编程、任务估算</li>
<li>XP方法论主张——今天采用简单方案实施，明日若有需要再付出少许额外成本进行迭代优化，远胜于当下就构建可能永远派不上用场的复杂方案</li>
<li>反馈<ul>
<li>即时反馈（分钟&#x2F;天级）<ul>
<li>程序员：单元测试</li>
<li>客户：实时估算</li>
<li>团队：进度跟踪反馈</li>
</ul>
</li>
<li>中长期反馈（周&#x2F;月级）<ul>
<li>客户：功能测试</li>
<li>运行软件验证</li>
</ul>
</li>
</ul>
</li>
<li>反馈与其他价值的联系<ul>
<li>反馈增强沟通有效性</li>
<li>简单系统更易测试</li>
<li>测试驱动系统简化</li>
</ul>
</li>
<li>勇气<ul>
<li>简单设计→适度复杂→再简化</li>
<li>沟通支持勇气，因为它为更多高风险、高回报的实验开辟了可能性</li>
<li>简洁支持勇气，因为对于一个简单的系统，你可以更加勇敢</li>
<li>具体的反馈支持勇气，因为如果你按下一个按钮就能看到测试变绿，那么你在对代码进行激进的修改时会感到更加安全</li>
</ul>
</li>
<li>软件开发的基本活动内容：开发的四项基本活动是编码、测试、倾听和设计<ul>
<li>编码：你工作的成果</li>
<li>测试：<ul>
<li>当所有可能的测试用例均已通过且无法再设计出新的失败场景时，即可视为完全完成</li>
<li>长期来看，为什么要测试的答案是测试能让程序的寿命更长；短期原因是提供信心</li>
<li>我们将有程序员编写的单元测试，以使他们自己确信他们的程序按照他们认为的方式工作</li>
<li>我们还将有由客户编写（或至少由客户指定）的功能测试，以使他们自己确信整个系统按照他们认为的整个系统应有的方式工作</li>
</ul>
</li>
<li>倾听：程序员请业务人员说明项目的需求，帮助业务人员了解软件方面哪些容易，哪些困难</li>
<li>设计<ul>
<li>良好的设计会组织逻辑，以便系统的一部分发生变化并不总是需要系统的另一部分发生变化</li>
<li>良好的设计确保系统中的每一段逻辑都有且仅有一个实现位置</li>
<li>良好的设计将逻辑放在它所操作的数据附近</li>
<li>良好的设计允许系统扩展，且仅在一个地方进行更改</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="XP基本实践"><a href="#XP基本实践" class="headerlink" title="XP基本实践"></a>XP基本实践</h3><ul>
<li>计划游戏 Planning Game<ul>
<li>业务人员需要决定：问题范围、优先级、发布的组成、发布日期</li>
<li>技术人员决定以下事项：估算（实现功能需要的时间）、后果（技术后果）、流程（团队和工作的组织）、详细的日程安排</li>
<li>缺陷：你不可能仅凭一个粗略的计划就开始开发工作，不断地更新计划耗时太长</li>
</ul>
</li>
<li>小发布 Small Releases<ul>
<li>每次发布都应尽可能小，包含最有价值的业务需求</li>
<li>发布必须作为一个整体有意义</li>
</ul>
</li>
<li>隐喻 Metaphor<ul>
<li>每个极限编程（XP）软件项目都由一个总体隐喻来指导</li>
<li>在极限编程中，这个隐喻取代了许多其他人所说的 “架构”</li>
<li>选择一个系统隐喻，通过一致地命名类和方法让团队保持同步</li>
<li>例如搜索引擎 —— 一大群蜘蛛，在网上四处寻找要捕捉的东西，然后把东西带回巢穴</li>
</ul>
</li>
<li>简单设计 Simple Design<ul>
<li>运行所有测试</li>
<li>没有重复的逻辑</li>
<li>表明对程序员重要的每一个意图</li>
<li>具有尽可能少的类和方法</li>
</ul>
</li>
<li>测试 TDD：程序员编写单元测试，客户编写功能测试</li>
<li>重构 Refactoring：在实现程序功能时，程序员总是会问是否有办法改变现有程序，以使添加该功能变得简单<ul>
<li>重构是在不改变代码外部可见行为的前提下，<strong>持续优化代码内部结构</strong>的技术</li>
<li>采用简洁的设计，重构起来更加容易</li>
<li>有测试，所以不太可能在不知情的情况下破坏原有功能</li>
<li>有持续集成，所以如果不小心在某个环节破坏了原有功能，或者你们的重构与他人的工作发生冲突，几个小时内就能知晓</li>
</ul>
</li>
<li>结对编程<ul>
<li>所有生产代码的过程中，都有两个人盯着一台机器，共用一个键盘和一个鼠标</li>
<li>其中一个人，即手握键盘和鼠标的那位，思考的是在此处实现这个方法的最佳方式</li>
<li>另一个人则从更具战略性的角度思考</li>
</ul>
</li>
<li>代码集体拥有制 Collective Ownership<ul>
<li><strong>任何人若发现有机会为代码的任何部分增加价值，都应随时这么做</strong></li>
<li>无所有权模式：没有任何人拥有特定的某段代码。如果有人想修改代码，就会按照自己的目的去改，而不管修改后的代码与现有代码是否契合。</li>
<li>个人代码所有权模式：只有代码的正式所有者才能修改某段代码</li>
</ul>
</li>
<li><strong>持续集成</strong> <strong>Continuous Integration</strong><ul>
<li>代码在几小时内 —— 最多一天的开发时间内 —— 完成集成与测试</li>
<li>少量变更的持续集成能快速定位问题：若测试失败，责任明确归属于当前集成人员，因上一轮集成已确保测试通过</li>
</ul>
</li>
<li>40 小时工作制 40-Hour Week</li>
<li>现场客户 On-Site Customer：真正的客户必须与团队坐在一起，随时解答问题、解决争议并确定小规模的优先级</li>
<li>编码标准 Coding Standards：要有相同的编码规范</li>
<li>上述所描述的实践方法都有弱点，需要相互支持弥补缺陷</li>
</ul>
<h2 id="4-TDD和敏捷设计"><a href="#4-TDD和敏捷设计" class="headerlink" title="4. TDD和敏捷设计"></a>4. TDD和敏捷设计</h2><ul>
<li>敏捷测试<ul>
<li>我们将在编码前逐分钟编写测试。我们会永久保留这些测试，并经常一起运行它们。我们还会从客户的角度推导出测试</li>
<li>测试应当是<strong>独立且自动</strong>的</li>
<li>应该编写那些能带来回报的测试，测试那些可能会出问题的东西</li>
</ul>
</li>
<li>程序员测试<ul>
<li>程序员编写的是单元测试</li>
<li>编写测试的情况：接口不清晰、实现复杂、想到特殊情况、发现问题、准备重构</li>
</ul>
</li>
<li>客户测试<ul>
<li>客户编写的是功能测试</li>
<li>客户逐个故事地编写测试，但客户通常无法自行编写功能测试</li>
</ul>
</li>
<li>其他测试<ul>
<li>并行测试：一种旨在证明新系统的运行与旧系统完全一致的测试</li>
<li>压力测试 ：一种旨在模拟可能出现的最恶劣负载情况的测试。压力测试适用于性能特征不易预测的复杂系统</li>
<li>随机测试：一种旨在确保系统在面对无意义输入时能合理响应的测试。</li>
</ul>
</li>
<li>测试驱动开发 TDD<ul>
<li>目标：创建<strong>可测试、可维护、最小化</strong>的代码</li>
<li>通过<strong>先写测试再写实现</strong>的逆向流程驱动代码设计：三阶段循环：红（失败测试）→ 绿（通过实现）→ 重构（优化代码）</li>
<li>标准流程（红绿重构循环）<ul>
<li><strong>编写失败测试</strong>：仅定义接口与预期行为</li>
<li><strong>快速实现通过</strong>：用最简单代码让测试变绿</li>
<li><strong>逐步泛化</strong>：补充更多测试案例，消除硬编码</li>
<li><strong>持续重构</strong>：在测试保护下优化代码结构</li>
</ul>
</li>
<li>核心价值：缺陷预防、设计引导（迫使开发者先思考接口而非实现细节）、降低耦合、活的文档（测试用例显式描述系统行为）</li>
</ul>
</li>
<li>极限编程涉及大量的设计工作，但它采用的方式与传统的软件流程有所不同。极限编程通过一些实践，让演进式设计这一概念重焕生机，使演进成为一种可行的设计策略。</li>
<li>计划设计与演进式设计<ul>
<li><strong>设计是为了长期轻松修改软件</strong></li>
<li>演进式设计：系统设计随实现过程逐渐生长</li>
<li>计划设计：理念源自其他工程领域。设计师提前思考重大问题。他们无需编码，因为其工作是设计而非构建。因此他们可以使用UML等设计技术，摆脱编程细节，在更抽象层面工作。设计完成后可转交给另一团队构建</li>
<li>计划设计方法在许多方面优于“编码-修复”式演进设计，但也有缺陷：<ul>
<li>编程时必然遇到设计未考虑的问题</li>
<li>文化冲突：设计师因技能经验被选中，但忙于设计导致编码时间减少；失去程序员的尊重</li>
</ul>
</li>
</ul>
</li>
<li>XP的赋能实践<ul>
<li>XP倡导演进式设计而非计划设计</li>
<li>赋能实践的核心是<strong>测试</strong>和<strong>持续集成</strong></li>
</ul>
</li>
<li>YAGNI原则<ul>
<li>You aren’t gonna need it</li>
<li><img src="image-20250522151457226.png" srcset="/img/loading.gif" lazyload alt="image-20250522151457226" style="zoom:80%;" /></li>
<li>是否开发 &#x3D; [当前需求强度] × [功能存活率预测] ÷ [技术贬值因子] &gt; 经济阈值（建议≥1.5）</li>
<li><strong>YAGNI不是反对设计，而是要求用经济学证据驱动每行代码的投资决策</strong></li>
</ul>
</li>
<li>重构的纪律性<ul>
<li>与临时调整的本质区别：测试保护下的安全重构</li>
<li>重构不是推倒重写，而是让代码随时间越变越优雅的持续艺术</li>
<li>工具：IDE自动化重构、测试框架、代码质量扫描</li>
</ul>
</li>
<li>生长式架构<ul>
<li>软件架构指系统的核心元素——难以修改的部分，是其余部分的基础</li>
<li>最激进的XP实践者越来越避免前期架构设计：在真正需要前不引入数据库，先用文件后期重构</li>
<li>Martin Fowler建议：<strong>评估可能架构</strong>。若预期海量多用户数据，首日就用数据库；若复杂业务逻辑，引入领域模型。但遵从YAGNI，存疑时倾向简单。随时准备简化未增价值的架构部分</li>
</ul>
</li>
<li>UML与XP：有用则用</li>
<li>通过<strong>降低流程中的不可逆性</strong>来应对复杂性</li>
<li>XP设计需要以下技能：<ul>
<li>持续保持代码清晰简洁的渴望</li>
<li>通过重构自信改进代码的能力</li>
<li>精通模式（design pattern）：不仅理解解决方案，更懂应用时机与演进路径</li>
<li>预见变化的眼光：知晓今日决策终将改变</li>
<li>运用代码、图表及最重要的——对话，向相关人员传达设计</li>
</ul>
</li>
</ul>
<h2 id="5-XP持续集成"><a href="#5-XP持续集成" class="headerlink" title="5. XP持续集成"></a>5. XP持续集成</h2><ul>
<li><p>传统集成的痛点</p>
<ul>
<li>当集成周期很长时，开发者可能会在数周甚至数月的时间里不与主代码库同步。最终尝试集成时会遇到大量问题和错误。</li>
<li>对开发者的影响：迫使开发者在自己的代码逻辑和解决冲突的调试工作之间频繁切换上下文；害怕集成麻烦而避免影响范围较大的重构；尽量减少与其他部分的交互，导致技术债的积累和代码质量的下降</li>
<li>对代码质量和重构的影响：开发者即便意识到结构缺陷也避免进行重要的代码重构；这种对重构的回避，阻止了代码库根据需求变化和经验积累进行健康的演进</li>
</ul>
</li>
<li><p>持续集成概念</p>
<ul>
<li>持续集成 (Continuous Integration, CI) 是一种软件开发实践，团队成员频繁地（通常每天至少一次）将他们的代码更改集成到共享的代码库主线中。</li>
<li>每次集成都会触发一次自动化的构建过程，该过程包括编译、链接以及运行一套全面的自动化测试套件</li>
<li>通过这种方式，任何个体开发者偏离主线的时间都不会超过几个小时。这意味着每次集成涉及的代码量都相对较小，从而显著降低了合并冲突的可能性和复杂性</li>
<li>这样做的核心目的是尽早发现并解决集成过程中可能出现的各种问题，包括代码冲突、编译错误、运行时错误以及逻辑缺陷</li>
<li>CI 旨在降低集成的复杂性和风险，避免在项目后期出现痛苦而漫长的“集成地狱”</li>
</ul>
</li>
<li><p>CI实践步骤</p>
<ul>
<li>第一步：获取最新代码。开发工作的第一步是从中央代码仓库获取最新的产品代码，确保本地开发环境与主线的最新状态保持一致。然后，在本地创建一个工作副本。确保本地环境与中央仓库同步是 CI 的基本前提。</li>
<li>第二步：本地构建与开发。获取了最新代码后，在自己的本地环境中运行完整的自动化构建脚本，需要确保在我开始进行任何代码更改之前，本地构建是成功的，然后才开始着手修改代码</li>
<li>第三步：集成前检查。在推送前必须再拉取主线代码，防止进行开发的同时有新的代码推送到了主线。需要将这些最新的更改合并（Merge）到本地工作副本中，然后再完整运行本地自动化构建</li>
<li>第四步：本地构建通过与推送。在合并了主线的最新更改并再次运行本地构建后，如果构建仍然成功就可以推送了。推送操作会触发中央 CI 服务器自动执行一次集成构建</li>
</ul>
</li>
<li><p>CI的核心实践</p>
<ul>
<li>维护单一的代码库主线：所有开发活动围绕一个共享的主线进行</li>
<li>自动化构建：构建过程（编译、打包等）完全自动化，可一键执行</li>
<li>让构建自测试：构建过程包含自动化测试，验证代码正确性</li>
<li>每个人每天都向主线提交：频繁集成是 CI 的核心</li>
<li>每次主线提交都应触发构建：自动化验证每次集成</li>
<li>保持构建快速：快速反馈是关键</li>
<li>隐含实践：在类生产环境中测试、让获取最新可执行文件更容易、让每个人都能看到构建状态</li>
<li>自动化部署：将构建产物部署到测试或生产环境</li>
</ul>
</li>
<li><p>实践一：版本控制与主线</p>
<ul>
<li>核心原则： 将项目所需的所有东西都纳入版本控制系统，并维护一个单一的、共享的主线</li>
<li><strong>主线</strong>是代码库中一个单一的、共享的分支，它代表了项目当前的、经过集成的状态，通常是准备部署到生产（或下一个环境）的状态</li>
<li>CI 强烈推荐基于主线的开发模式</li>
<li>版本控制内容：任何人用一个干净的环境，只需要clone就可以构建、测试并运行整个产品。因此要包括源码、各种配置文件、脚本、第三方依赖定义文件等</li>
<li>部分依赖包可以放链接，然后在脚本中自动下载依赖</li>
<li>构建产物不应包含在版本控制中</li>
</ul>
</li>
<li><p>实践二：自动化构建</p>
<ul>
<li>在软件开发中，任何可以自动化的重复性任务都应该自动化</li>
<li>单一命令原则：任何人都应该能够检出代码库后，通过执行一个简单、明确的单一命令，就能完成整个系统的构建过程</li>
</ul>
</li>
<li><p>实践三：让构建自测试</p>
<ul>
<li>现代静态类型语言可以在编译时捕获许多错误，但仍有大量逻辑错误和边界情况可能溜过编译器的检查。对于持续集成所要求的高频率集成来说，仅仅编译通过是远远不够的。</li>
<li>核心机制： 在 CI 中，防止错误进入产品的主要技术手段是一个全面的自动化测试套件。每次集成构建时，都会执行这些测试</li>
<li>工具支持： 自动化测试理念的一个重要推动力来自于 Kent Beck 等人在 Smalltalk 和 Java 社区推广的 Xunit 测试框架（如 JUnit, NUnit, PyUnit 等）</li>
<li>信心来源： 自测试构建的目标是，当所有的自动化测试都通过时（即构建是“绿色”的），团队应该有足够的信心认为产品中没有引入重大的、明显的错误</li>
<li>许多编程环境还提供了额外的静态和动态分析工具（代码格式、测试覆盖率等等），可以集成到构建验证流程中</li>
</ul>
</li>
<li><p>实践四：每个人每天提交到主线</p>
<ul>
<li>实践中的经验法则是，每个团队成员<strong>每天</strong>至少向主线提交（并推送）<strong>一次</strong>他们的代码更改</li>
<li>频繁集成有助于快速发现两类冲突：源代码冲突、语义冲突</li>
<li>语义冲突解决方案： 自测试构建是检测语义冲突的关键武器。良好的自动化测试套件应该能够覆盖代码的主要行为路径。当一个语义冲突破坏了程序的预期行为时，相关的测试就应该失败</li>
</ul>
</li>
<li><p>实践五：每次提交触发主线构建</p>
<ul>
<li>需要一种机制来确保每次向主线推送代码时，都会在一致的、独立的环境中自动执行一次完整的集成构建（包括编译和测试）。这通常通过持续集成服务（CI Service）来实现。CI 服务会监控代码仓库的主线分支，一旦检测到新的提交，就会自动触发构建流程</li>
<li>角色与功能： CI 服务（如 Jenkins, GitLab CI, GitHub Actions, CircleCI, Travis CI, Azure Pipelines 等）是实现自动化主线构建的关键工具。功能：</li>
<li><img src="image-20250522170914180.png" srcset="/img/loading.gif" lazyload alt="image-20250522170914180" style="zoom: 67%;" /></li>
<li>构建失败需要<strong>立即</strong>修复</li>
<li>修复构建失败的最快、最安全的方法通常是直接恢复（Revert）导致失败的那个提交。导致问题的开发者可以在他们本地修复代码（基于恢复后的主线），经过充分测试后再重新尝试集成</li>
<li><strong>门禁提交和待定头</strong>：提交先进入一个临时区域进行构建验证，通过后才自动合并到主线。但这可能增加流程复杂性。对于高效团队，直接提交+快速修复&#x2F;恢复通常效果更好。</li>
</ul>
</li>
<li><p>实践六：保持构建快速</p>
<ul>
<li>一个经常被引用的经验法则是，主提交构建（即验证每次提交的核心构建）应该在<strong>十分钟</strong>内完成</li>
<li>主要瓶颈： 对于许多企业级应用来说，自动化构建的主要时间瓶颈通常在于测试，特别是那些需要与外部服务（如数据库、第三方 API）交互的集成测试或端到端测试。</li>
<li>解决方案：<strong>构建流水线</strong> 。流水线将整个构建和验证过程分解为多个阶段（Stage）。第一个阶段是<strong>提交阶段</strong>（Commit Stage）或<strong>提交构建</strong>（Commit Build），它专注于提供最快的反馈。后续阶段则运行更全面但更慢的测试。提交阶段包括编译、快速单元测试、快速的静态检查；后续阶段包括集成测试、端对端测试、性能测试。只有提交阶段失败会阻塞主线。</li>
</ul>
</li>
<li><p>隐藏未完成的工作</p>
<ul>
<li><p>由于需要每天频繁集成，主线上可能随时包含一些未完成的、尚未准备好面向用户发布的代码</p>
</li>
<li><img src="image-20250522172352398.png" srcset="/img/loading.gif" lazyload alt="image-20250522172352398" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>持续集成的好处</p>
<ul>
<li>降低风险：降低集成风险、快速发现错误、更容易定位错误、减少“集成地狱”</li>
<li>促进改进与发布：鼓励并支持重构、提高代码质量、更频繁可靠的发布(主线代码始终接近可发布状态)、发布成为业务决策</li>
</ul>
</li>
<li><p>CI与特性分支</p>
<ul>
<li>严格来说，持续集成与长期存在的特性分支（即开发者在独立分支上工作）是互斥的开发模式。在特性分支上运行 CI 工具只是“特性分支上的自动化构建”</li>
<li>但是短暂的、生命周期不超过一天的特性分支（或个人任务分支）与 CI 是兼容的</li>
</ul>
</li>
<li><p>CI与CD</p>
<ul>
<li><strong>持续交付</strong> <strong>(Continuous Delivery, CD)</strong></li>
<li>持续集成 (CI): 关注点在于开发者将代码更改频繁集成到版本控制系统的主线，并通过自动化构建和测试进行验证。</li>
<li>持续交付 (CD): 是 CI 的自然延伸。它确保了通过 CI 验证的主线代码，能够通过一系列自动化的后续步骤（如更全面的测试、部署到类生产环境、准备发布包），使得任何版本的主线代码都可以部署到生产环境</li>
<li>关系： <strong>CI 是实现 CD 的必要前提</strong>。没有有效的 CI，就无法可靠地进行 CD</li>
</ul>
</li>
<li><p>持续部署</p>
<ul>
<li>Continuous Deployment，注意跟持续交付CD区分</li>
<li>持续部署是持续交付的更进一步。在持续交付中，每次主线构建通过所有自动化测试和验证后，软件处于可发布状态，但最终部署到生产环境通常还需要一次手动触发（例如，业务人员点击按钮）。而在持续部署中，这个手动触发步骤也被自动化了：只要主线构建成功通过了部署流水线中的所有阶段（包括所有自动化测试和检查），它就会自动被部署到生产环境中</li>
<li>总结：<ul>
<li>CI: 代码集成到主线并通过初始验证。</li>
<li>CD: CI 产物可随时按需部署到生产。</li>
<li>Continuous Deployment: CD 产物自动部署到生产</li>
</ul>
</li>
</ul>
</li>
<li><p>CI 与拉取请求 (Pull Requests) 及代码评审</p>
<ul>
<li>拉取请求，尤其是在需要前置代码评审才能合并到主线的流程中，可能会给 CI 带来挑战（会延迟集成）</li>
<li>解决方案：结对编程(编码时就已评审)、集成后评审、优化评审流程</li>
</ul>
</li>
<li><p>CI与数据库管理</p>
<ul>
<li>程序代码变更过程中需要保证数据库结构和状态同步更新</li>
<li>解决方案：进化式数据库设计</li>
<li><img src="image-20250522175606093.png" srcset="/img/loading.gif" lazyload alt="image-20250522175606093" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h2 id="6-Kanban"><a href="#6-Kanban" class="headerlink" title="6. Kanban"></a>6. Kanban</h2><ul>
<li>Kanban基本概念<ul>
<li>Kanban（中文常称“看板方法”）起源于制造业，现已成为IT软件开发和项目管理中广泛应用的敏捷方法之一，强调通过<strong>可视化工作流程</strong>和限制<strong>在制品</strong>（WIP）来实现持续流动（continuous flow）。</li>
<li>Kanban最早起源于20世纪50年代的日本丰田汽车制造业。丰田工程师大野耐一（Taiichi Ohno）受美国超市补货方式启发，在工厂引入以纸卡片传递生产需求信号的系统，命名为“看板”</li>
<li>看板是一种通过使用<strong>可视化</strong>、<strong>拉动式系统</strong>来优化流程中价值流动的策略。定义价值的方式可能多种多样，例如，可以考虑客户、终端用户、组织以及环境的需求</li>
<li>看板由以下三种协同工作的实践组成：<ul>
<li>定义并可视化工作流程</li>
<li>主动管理工作流程中的事项</li>
<li>改进工作流程</li>
</ul>
</li>
<li>在实施过程中，这些看板实践统称为<strong>看板系统</strong>。参与看板系统价值交付的人员称为<strong>看板系统成员</strong></li>
<li>并列框架: Kanban已被普遍视为与Scrum、XP等并列的重要敏捷实践框架</li>
</ul>
</li>
<li>定义并可视化工作流程<ul>
<li>把项目工作内容贴在白板上。每个工作项一个记事贴。我们一般称电子工具为“信息冰箱”</li>
<li><img src="image-20250523151436911.png" srcset="/img/loading.gif" lazyload alt="image-20250523151436911" style="zoom:50%;" /></li>
<li><strong>工作流</strong>：Kanban的工作流是指工作项从开始到完成的过程。Kanban 系统成员对于流的明确且共同的认知，就称为 “工作流的定义” (Definition of Workflow，DoW)</li>
<li><strong>工作项</strong>：在工作流中移动的各个<strong>价值单位</strong>被称为 “<strong>工作项</strong>”，根据工作项的不同，工作流可能有多个起点或终点。每个工作项被表示为一个卡片，描述任务、优先级及其他相关信息。这些卡片在看板上进行移动，以反映工作的实际状态。</li>
<li><strong>在制品</strong>：工作项自开始到结束流动经过⼀个或多个已定义状态，介于开始节点与结束节点间的任何⼀个工作项就称为 “<strong>在制品</strong>”（work in progress， WIP)</li>
<li>快速通道：Kanban中的快速通道是一种策略，用于优先处理紧急或高优先级的工作项。这是在看板上专门设置的一条路径或一个位置，用于标识和加快处理那些需要立即注意并快速完成的任务。快速通道的相关规则：任何时候<strong>最多只能有一个</strong>工作项在快速通道内；<strong>每周最多有一个</strong>紧急工作；快速通道内的工作项<strong>无需计入在制品限制</strong></li>
<li><strong>Kanban看板</strong>：Kanban方法的核心工具，可视化工作及其流程状态。典型看板按流程划分为列（如“待处理”、“进行中”、“待测试”、“已完成”），工作项以卡片形式放置。提供实时透明度，显示任务状态、位置、整体负荷。可以是物理白板或电子工具</li>
<li><strong>Kanban卡片</strong>：代表具体工作项（用户故事、任务、缺陷等）。记录必要信息（标题、负责人、描述、截止日期等）助成员理解任务。电子卡片可含更多属性（子任务、附件、评论）。卡片从左到右移动反映流动。受阻时标记（红标）或入阻塞区提示解决。卡片流动形成拉动信号</li>
<li><img src="image-20250523153956240.png" srcset="/img/loading.gif" lazyload alt="image-20250523153956240" style="zoom:50%;" /></li>
</ul>
</li>
<li>流程阶段与WIP限制<ul>
<li>WIP上限提醒我们要采取行动，改善瓶颈，而不是把没完成的工作堆个没完</li>
<li><strong>工作流程阶段与泳道</strong>：Kanban板根据具体流程定制列（如“待开发”、“开发中”、“代码审查”、“测试中”、“已部署”）。列间可设“等待&#x2F;就绪”子列。可设泳道（swimlane）横向分区，并行展示不同类型工作或服务级别（如“紧急Hotfix”泳道）。有助于管理不同优先级或类别工作，提高可视化清晰度。</li>
<li><strong>在制品限制</strong> (WIP Limit)：给每个工作阶段设WIP限制是Kanban的重要元素。通常在列顶标注数字表示上限。强制团队避免多任务过载，减少排队等待。当某列达上限，需暂停拉入新任务，优先完成现有任务。WIP限制需根据团队能力和工作类型调整，通过观察流动数据优化。</li>
</ul>
</li>
<li>拉动式系统<ul>
<li><strong>拉动式系统</strong>：在拉动式系统中，工作项的完成是由需求触发的，而不是通过事先计划和推测。团队在有容量和能力时，才从工作队列中“拉动”新的任务进行处理。这与传统的“推动”模式不同，后者通常在事前将大量任务规划并分配，甚至可能超过团队的实际承载能力。</li>
<li>Kanban采用<strong>拉动理念</strong>，下游主动拉取上游工作，而非上游推送。看板上体现为：完成任务后，下一阶段负责人才在空闲时拉取新卡片。当下游忙碌（达WIP上限），上游完成的任务在就绪区等待</li>
</ul>
</li>
<li>Kanban度量<ul>
<li>WIP：已开始但未完成的工作项的数量</li>
<li>产能 (Throughput)：每单位时间（如每天、每周或每月）内完成的工作项的数量</li>
<li>工作项存续时长 (Work Item Age)：⼀工作项从开始到当前时刻之间所经过的时间长度</li>
<li>周期时间 (Cycle time)：周期时间指的是一个工作项从正式开始处理到完成交付之间的总时长。区别于存续时长（<strong>未完成</strong>的任务），周期时间统计的是<strong>已经完成</strong>的任务</li>
</ul>
</li>
<li>Kanban与Scrum的差异<ul>
<li>框架：Scrum是<strong>迭代式框架</strong>，通过固定长度Sprint规划交付增量。Kanban是<strong>流动式框架</strong>，无预定迭代周期，工作项持续流动，完成一个拉一个，可连续交付。Scrum适合节奏明确项目，Kanban适合持续流动工作（如支持维护）</li>
<li>角色：Scrum规定3个明确角色，Kanban不指定必须角色，通常保留现有组织架构，成员各司其职，通过看板协同。Scrum提供明确分工，Kanban鼓励自行分配</li>
<li>时间规划：Scrum以Sprint为时间盒进行计划评估。有固定节奏的会议（计划、站会、评审、回顾）。Sprint中通常不接受新需求变更。Kanban无时间盒约束，计划交付连续。需求变更可随时反映在队列，团队按优先级拉取。Kanban对变更反应更灵活，但需自行设定回顾节奏。</li>
<li>流程和工件：Scrum强调规定事件（会议）和工件（Product Backlog, Sprint Backlog, Increment）。Kanban无指定事件工件，唯一主要工件是看板及相关策略。</li>
</ul>
</li>
<li>Kanban与Scrum的融合<ul>
<li>互补性: 两者并非对立，可相互借鉴：Scrum团队常用可视化任务板（Kanban实践），设WIP限制改善流动；Kanban团队可引入定期回顾，借鉴Backlog管理</li>
<li>Scrumban: 最著名的混合实践模式，由Corey Ladas提出，作为Scrum到Kanban的中间态&#x2F;过渡。保留Scrum部分结构（如定期会议），取消固定Sprint承诺，改用Kanban拉动节奏和WIP控制</li>
</ul>
</li>
<li>Kanban与XP的关系<ul>
<li>定位差异: XP（Extreme Programming）侧重<strong>工程实践</strong>，以TDD、重构、持续集成等代表，聚焦“如何开发更好软件”。Kanban关注<strong>流程和可视化管理</strong>，聚焦“如何管理和改进工作流程”，本身不规定技术实践。XP是工程实践集，Kanban是流程管理方法，不在同一维度</li>
<li>兼容并用：可完全同时采用XP实践和Kanban方法。XP保证代码质量和开发技法，Kanban确保工作项流动顺畅及时交付。</li>
</ul>
</li>
</ul>
<h2 id="7-DevOps"><a href="#7-DevOps" class="headerlink" title="7. DevOps"></a>7. DevOps</h2><ul>
<li>DevOps历史<ul>
<li><img src="image-20250523162713085.png" srcset="/img/loading.gif" lazyload alt="image-20250523162713085" style="zoom:67%;" /></li>
<li><img src="image-20250523162756283.png" srcset="/img/loading.gif" lazyload alt="image-20250523162756283" style="zoom:50%;" /></li>
<li>总结: 理念形成 -&gt; 敏捷&#x2F;云&#x2F;工具驱动推广 -&gt; 大规模验证&#x2F;最佳实践 -&gt; 深度融合安全&#x2F;AI。体现软件交付从<strong>瀑布</strong>到<strong>敏捷</strong>持续的范式转变</li>
</ul>
</li>
<li>DevOps概述<ul>
<li>DevOps 不仅是理念: 更是一系列核心实践和技术工具的体系化应用，贯穿软件生命周期（规划、编码、构建、测试、发布、部署、运行、监控、反馈）。形成持续循环的不间断流程</li>
<li>核心实践包括：CI&#x2F;CD、自动化测试、IaC、自动化配置管理、容器化、监控反馈</li>
</ul>
</li>
<li>CI&#x2F;CD<ul>
<li>持续集成 (CI - Continuous Integration):要求开发者频繁 (每天乃至每小时) 将代码变更合并到主干分支，触发自动化构建和测试。</li>
<li>持续交付 (CD - Continuous Delivery):将 CI 产出的构件自动部署到测试或预生产环境。</li>
<li>持续部署 (Continuous Deployment):持续交付的极致，代码通过自动化流程验证后直接部署到生产环境。</li>
</ul>
</li>
<li>自动化测试和IaC<ul>
<li>自动化测试：“测试门禁”只有通过所有自动测试的构建才可部署，前移质量控制</li>
<li>IaC：基础设施即代码 。使用代码化方式管理和配置基础设施 (服务器、网络等)，将手动运维操作转为可编程脚本&#x2F;配置。可以以声明式配置文件定义所需基础架构环境，自动化部署和变更管理。<strong>效果</strong>：确保环境配置一致性和可重复性，避免“环境漂移”</li>
<li>IaC工具示例：Chef, Puppet, Ansible, Terraform</li>
</ul>
</li>
<li>配置管理：自动化配置，配置管理工具 (Chef, Puppet) 确保不同服务器系统配置统一</li>
<li>容器化<ul>
<li>容器化技术 (Docker)：推动“一次构建，到处运行”。应用及其依赖打包为镜像，保证开发、测试、生产环境一致运行，减少“在我机器上能跑”问题</li>
<li>容器编排 (Kubernetes)：自动部署、管理容器集群，提供服务发现、弹性伸缩等，使微服务落地更容易</li>
</ul>
</li>
<li>监控反馈<ul>
<li>实时监控：DevOps 生命周期后半段强调对应用运行状态的<strong>实时监控</strong></li>
<li>持续反馈：不仅是故障响应 (传统运维关注 MTTR)，更要将正常运行数据用于改进 (分析部署频率与失败率关系、用户行为反馈新功能等)</li>
<li>工具示例：Prometheus, Nagios, Grafana</li>
<li>实践：收集系统性能指标、日志、用户行为数据；设置警报及时通知异常</li>
</ul>
</li>
<li>DevOps与敏捷<ul>
<li>敏捷 (Agile)：<ul>
<li>核心：项目和产品开发方法学，提高开发过程灵活性和响应速度</li>
<li>关注点：开发团队内部效率，与客户持续反馈，快速响应需求变更</li>
<li>目标：“如何更有效地开发软件”</li>
</ul>
</li>
<li>DevOps<ul>
<li>核心：扩展敏捷理念，范围从开发延伸到软件交付和运维全生命周期</li>
<li>关注点：开发与运维协作，打破壁垒，实现从开发到部署的持续流动</li>
<li>目标：“如何更快更可靠地交付软件”</li>
</ul>
</li>
<li>互补性：敏捷提供快速交付增量功能的框架，DevOps 确保功能顺畅、安全部署上线</li>
<li>实践差异：敏捷强调<strong>组织结构</strong>和<strong>开发流程</strong>敏捷性，DevOps 强调<strong>跨职能协作</strong>和<strong>交付流程自动化</strong>。敏捷遵循 Scrum&#x2F;Kanban，短迭代交付增量；DevOps 在敏捷产出基础上引入 CI&#x2F;CD、自动化部署、监控等，快速推向生产</li>
</ul>
</li>
<li>DevOps与CI&#x2F;CD<ul>
<li>关系：CI&#x2F;CD (持续集成&#x2F;持续交付) 是技术实践，DevOps 是文化和流程理念。CI&#x2F;CD 是实现 DevOps 目标的核心实践手段之一</li>
<li>区别：没有 CI&#x2F;CD 很难实现 DevOps，但仅有 CI&#x2F;CD 工具不代表完成 DevOps 转型。CI&#x2F;CD 关注代码构建、测试、部署自动化；DevOps 涵盖人、流程、工具范围更广，包括组织和文化</li>
</ul>
</li>
<li>DevOps与云原生<ul>
<li><strong>云原生定义</strong>：利用云计算优势设计部署应用的架构理念 (容器化、微服务、不可变基础设施等)。强调应用如何构建运行以适应云环境弹性和分布式特性</li>
<li>DevOps 定义：强调应用如何快速可靠交付</li>
<li>二者<strong>目标一致</strong>，都为提升交付速度和弹性；<strong>切入点不同</strong>，云原生关注<strong>架构</strong>，DevOps 关注<strong>流程</strong></li>
<li><strong>相互促进</strong>：Cloud Native 应用天然需要 DevOps 实践支撑 (如微服务需要 CI&#x2F;CD)。DevOps 需要弹性云资源支持频繁部署测试。云的弹性需 DevOps 自动化才能高效利用。</li>
<li>总结：DevOps 是过程方法，Cloud Native 是应用架构。二者高度协同，都以加速交付为目标，都推崇自动化和协作。</li>
</ul>
</li>
<li>DevOps与AIOps<ul>
<li>AIOps 定义：利用 AI 技术提升 <strong>IT 运维</strong>智能化水平 (机器学习分析监控数据、自动发现异常、定位根因等)。是运维领域 AI 工具集和实践集</li>
<li>DevOps 为敏捷高效运维提供机制和文化基础，AIOps 为复杂运维场景提供智能化手段</li>
<li>实施使数据收集和流程自动化成为可能，为 AI 算法提供用武之地 (监互相支撑：DevOps控日志性能指标等大数据)。AIOps 工具可基于数据做模式识别、预测故障、自动恢复，与 DevOps 目标一致</li>
</ul>
</li>
<li>DevSecOps<ul>
<li>DevSecOps &#x3D; 开发 (Dev) + 安全 (Sec) + 运维 (Ops) 的融合</li>
<li>随着 DevOps 实践深入，意识到安全 (Security) 应融入 DevOps 过程，而非最后检查</li>
<li>核心目标：将安全保障集成到软件开发生命周期各阶段，而非仅上线前被动检查</li>
<li>观念转变: 安全不再是独立团队责任，而是 DevOps 团队共享责任，需“<strong>左移</strong>”到开发之初就考虑</li>
<li>安全需求融入规划: 计划阶段评估风险合规，<strong>用户故事同时定义安全验收标准</strong>。开发&#x2F;运维&#x2F;安全共同参与需求讨论</li>
<li>实践<ul>
<li>安全编码实践: 开发人员接受培训，遵循规范 (防 SQL 注入&#x2F;XSS)。引入静态代码分析 (SAST) 工具，代码合并前自动扫描漏洞。</li>
<li>自动化安全测试: CI 流水线加入 SAST 和 DAST (动态应用安全测试) 工具。容器镜像安全扫描(检查已知漏洞&#x2F;不合规配置)。安全测试同普通测试一样，每次构建&#x2F;部署运行</li>
<li>基础设施和依赖安全: 利用 IaC 对基础设施配置应用安全策略 (端口限制&#x2F;加密) 并代码审查&#x2F;扫描。</li>
<li>持续监控与防护: 部署入侵检测、WAF 防火墙，安全日志入集中监控。安全事件发生时，团队快速响应、修复、触发 CI&#x2F;CD 紧急更新。形成闭环反馈</li>
</ul>
</li>
</ul>
</li>
<li>常用 DevOps 术语表<ul>
<li><strong>蓝绿部署</strong> (Blue-Green Deployment)<ul>
<li>定义：<strong>零停机部署策略</strong>。维护两套环境：蓝 (当前生产)，绿 (部署新版)</li>
<li>流程：测试验证绿环境正常后，流量从蓝切到绿。切换<strong>瞬时完成</strong></li>
<li>优缺点：切换快，回退易 (切回蓝)；需双倍资源；一次性切换有风险</li>
<li>适用：要求短暂无缝切换场景，成本较高</li>
</ul>
</li>
<li><strong>金丝雀发布</strong> (Canary Deployment)<ul>
<li>定义：渐进式部署策略</li>
<li>流程：<strong>仅将一小部分用户&#x2F;流量切换到新版本</strong>，其余仍用旧版。观察新版运行情况，无异常则逐步扩大新版流量比例，最终 100% 迁移。有问题可及时止损&#x2F;回滚</li>
<li>优缺点：更安全可控，常与 A&#x2F;B 测试结合；需实现按用户&#x2F;流量分割的路由机制</li>
<li>适用：风险最低的发布策略之一</li>
</ul>
</li>
<li>基础设施即代码 (IaC, Infrastructure as Code)：同上</li>
<li>微服务 (Microservices)<ul>
<li>定义：软件架构风格，将应用拆分为一组小的、独立部署的服务，每个服务专注单一业务能力</li>
<li>与 DevOps 关系：相辅相成。服务粒度小，可独立开发部署，使 CD 更易。每个服务由小团队负责全生命周期</li>
<li>特点：部署频率高，需成熟 CI&#x2F;CD 和监控。通过 DevOps 实现弹性伸缩和故障隔离</li>
</ul>
</li>
<li>持续监控 (Continuous Monitoring)：同上</li>
<li>MTTR (Mean Time to Recovery&#x2F;Restore)<ul>
<li>定义：<strong>平均恢复时间</strong>，从故障发生到修复完成的平均时长</li>
<li>意义：DevOps 度量中反映发布稳定性和运维效率的关键指标。高绩效团队 MTTR 在小时内，低绩效需数天</li>
<li>改进方式：自动化监控、快速回滚、高效协作可大幅降低 MTTR</li>
</ul>
</li>
</ul>
</li>
<li>DORA评价指标<ul>
<li>DORA：DevOps Research and Assessment</li>
<li>部署频率<ul>
<li>是指团队或组织在给定时间范围内将代码成功部署到生产环境的频率，通常以每日、每周、每月或更低的频率进行统计</li>
<li><img src="image-20250523171301862.png" srcset="/img/loading.gif" lazyload alt="image-20250523171301862" style="zoom: 67%;" /></li>
</ul>
</li>
<li>变更前置时间<ul>
<li>从代码提交到代码成功部署到生产环境所需的时间，也即<strong>从开发人员开始写代码到客户真正获得该变更</strong>的间隔时长。</li>
<li><img src="image-20250523171335641.png" srcset="/img/loading.gif" lazyload alt="image-20250523171335641" style="zoom: 67%;" /></li>
</ul>
</li>
<li>变更失败率<ul>
<li>部署到生产环境后的代码变更引发故障或问题，导致需要紧急修复、回滚或出现服务降级等情况的比例</li>
<li><img src="image-20250523171402600.png" srcset="/img/loading.gif" lazyload alt="image-20250523171402600" style="zoom:67%;" /></li>
</ul>
</li>
<li>平均恢复时间<ul>
<li>当生产环境出现故障或服务降级时，从故障发生到完全恢复正常服务所需的平均时间</li>
<li><img src="image-20250523171431393.png" srcset="/img/loading.gif" lazyload alt="image-20250523171431393" style="zoom:67%;" /></li>
</ul>
</li>
<li><strong>部署频率</strong>和<strong>变更前置时间</strong>体现了交付的<strong>速度和效率</strong></li>
<li><strong>变更失败率</strong>和<strong>平均恢复时间</strong>则体现了交付的<strong>质量和稳定性</strong></li>
</ul>
</li>
</ul>
<h2 id="8-敏捷概述"><a href="#8-敏捷概述" class="headerlink" title="8. 敏捷概述"></a>8. 敏捷概述</h2><ul>
<li>为什么敏捷与精益出现在软件开发行业？<ul>
<li><strong>软件开发本质属性</strong>：复杂性、一致性、可变性、不可见性</li>
<li>敏捷与精益本质上是帮助我们处理软件开发的复杂性、可变性</li>
</ul>
</li>
<li>软件项目成功标准<ul>
<li>传统观点<ul>
<li>成功的：按时完成，费用不超过预算，而且所有特性和功能都符合原先的设计规格</li>
<li>不太成功的：已完成并且可以运行，但费用超出了预算，没有如期完成，拥有的特性和功能少于原先的设计规格</li>
<li>失败的：在开发周期的某个时刻被取消了</li>
</ul>
</li>
<li>敏捷观点<ul>
<li>为客户创造价值是评价成功的最重要标准</li>
<li><strong>所有软件开发实践都应该以提升项目收益为首要目标！</strong></li>
</ul>
</li>
</ul>
</li>
<li>敏捷开发知识体系<ul>
<li><img src="image-20250524095352283.png" srcset="/img/loading.gif" lazyload alt="image-20250524095352283" style="zoom:50%;" /></li>
</ul>
</li>
<li>敏捷宣言历史<ul>
<li>2001年，17位超级极客齐聚犹他州的雪鸟滑雪山庄，共同探索有关软件开发未来发展的共同理念。其中包括Scrum、极限编程、水晶、特性驱动开发等一些新生方法论的发起者</li>
<li>与会者达成了一致意见，将这场“运动”命名为“敏捷”。他们授予自己“敏捷联盟”的称号，草拟出一份言简意赅的《敏捷宣言》</li>
</ul>
</li>
<li><strong>敏捷宣言</strong> 重要<ul>
<li>个体和互动胜过流程和工具</li>
<li>可以工作的软件胜过详尽的文档</li>
<li>客户合作胜过合同谈判</li>
<li>响应变化胜过遵循计划</li>
<li>也就是说，<strong>尽管右项有其价值，我们更重视左项的价值</strong>。</li>
</ul>
</li>
<li>个体和互动胜过流程和工具<ul>
<li>敏捷力的基本宗旨之一就是，干活的人最清楚该如何完成工作</li>
<li>不要规定团队一定要使用某个方法或工具</li>
<li>流程和工具必须是为人服务的，而不是反过来</li>
</ul>
</li>
<li>可以工作的软件胜过详尽的文档<ul>
<li>如果文档着眼于创造价值和以有利方式推动项目进展，那就没问题。例如，对大多数产品来说，用户文档都是很有价值的组成部分</li>
<li>但如果关注焦点不再是产品本身，而变成了流程文档，就有问题了</li>
<li><strong>敏捷团队也是会做计划的</strong>，因为计划需要不断地进行细化和更新。敏捷软件项目中的计划以各种形式出现在我们身边，例如用户故事、列表(backlog)、验收测试、和大型可视图表，它们组成了富沟通环境</li>
</ul>
</li>
<li>客户合作胜过合同谈判<ul>
<li>敏捷价值观着重强调，开发团队和客户之间要保持尽可能公开和顺畅的对话</li>
<li>基于合同的项目侧重方向不对。相关各方就像是一群合伙人，齐心协力在规定时间和预算范围内努力构建最有价值的系统</li>
</ul>
</li>
<li>响应变化胜过遵循计划<ul>
<li>计划驱动型组织通常都有“变化控制”流程</li>
<li>只有在变更可控的情况下，变化控制才会有效果</li>
<li>创造价值才是衡量软件开发成功的标准</li>
</ul>
</li>
</ul>
<h2 id="9-新方法学"><a href="#9-新方法学" class="headerlink" title="9. 新方法学"></a>9. 新方法学</h2><ul>
<li>从无到繁重到敏捷<ul>
<li>有一些根本性的原则是所有敏捷方法的共同之处，这些 原则与那些传统软件工程方法的前提假设是截然相反的</li>
<li>code and fix 这种模式对小系统开发其实很管用，但是当系统变得越大越复杂时，要想加入新的功能就越来越困难。同时错误故障越来越多，越来越难于排除</li>
<li>软件行业中最初的一场运动是要改变这种情况，而引入了“<strong>正规方法</strong>”的概念。这些（正规）方法对开发过程有着严格而详尽的规定，以期使软件开发更有可预设性并提高效率，这种思路是借鉴了其他工程领域的实践，因此我把它们称为<strong>工程方法</strong>，也叫<strong>计划驱动方法</strong></li>
<li>工程方法最常听见的批评就是它们的<strong>官僚繁琐</strong>，要是按照它的要求来，那有做太多的事情需要做，而延缓整个开发进程</li>
<li>敏捷方法的发展是对这些工程方法的反弹，它们在无过程和过于繁琐的过程中达到了一种平衡，使得能以不多的步骤过程获取较满意的结果</li>
</ul>
</li>
<li>敏捷方法与工程方法的区别<ul>
<li>表面区别：敏捷型不是很面向<strong>文档</strong>，对于一项任务，它们通常只要求尽可能少的文档。从许多方面来看，它们更象是“面向源码”（code-oriented）。事实上，最根本的文档应该是源码</li>
<li>本质区别<ul>
<li>敏捷型方法是“<strong>适应性</strong>”而非“预见性”。工程方法试图对一个软件开发项目在很长的时间跨度内<strong>作出详细的计划</strong>，然后<strong>依计划进行开发</strong>。这类方法在一般情况下工作良好，但（需求、环境等）有变化时就不太灵了。而敏捷型方法则<strong>欢迎变化</strong>，它们的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化</li>
<li>敏捷型方法是“<strong>面向人</strong>”的而非“<strong>面向过程</strong>”的。工程型方法的目标是<strong>定义一个过程</strong>，而敏捷型方法则认为<strong>没有任何过程能代替开发人员的技能</strong>，过程起的作用是对开发人员的工作提供支持</li>
</ul>
</li>
</ul>
</li>
<li>软件开发与工程<ul>
<li>传统的软件开发正规方法的基本思路一般是从其他<strong>工程领域</strong>借鉴而来。</li>
<li><strong>设计</strong>是难于预见的，并且需要昂贵的有创造性的人员，<strong>建造</strong>则要易于预设。我们有了设计之后，便可对建造进行计划了。而有了建造计划后，我们进行建造则可以是非常可预见性的了。</li>
<li>软件工程方法：我们想要可预见的生产进度计划，以便能使用技能较低的人员</li>
<li>要达到这一点，我们必须得把设计与建造分离开来。因此，在软件开发中，我们得想法作出这样的设计，使得计划一经完成，建造将会是直接而明确的，例如使用UML进行设计</li>
<li>在软件开发中，具体建造费用非常低，所有工作都是设计，而创造性的过程是不太容易计划的</li>
</ul>
</li>
<li>需求的不可预见性<ul>
<li>在建造商用软件系统中，需求变更是常态，问题是我们如何来处理它</li>
<li>一种方法是把需求变更看成是因需求工程没作好而导致的结果。需求工程（或进行需求分析）是要在着手建造软件之前，获取一幅已完全理解了的待建系统的画面，然后取得客户认可签发，并且还要建立一套规章来限制需求变更</li>
<li>人们期待需求应该是可变的。软件开发的一切都取决于系统需求，如果需求不固定，你就不能制订出一个可预见性的计划</li>
<li>如果你不能遵循一个可预见性方法，而你强装能够，那么这是非常危险的。因此在不可预见性的环境中是不能使用预见性方法的</li>
<li>你所需要的是另一类过程，它们可以让你对不可预设性进行控制，这就是“适应性”的作用了</li>
</ul>
</li>
<li>不可预见的控制过程——<strong>迭代</strong><ul>
<li>如何对付一个不可预测的世界呢？最重要，也是最困难的是要随时知道我们在开发中的情形处境。这种机制的关键之点是“<strong>迭代式</strong>”（iterative）开发方法。</li>
<li>迭代式开发的要点是经常不断地生产出最终系统的工作版本，这些版本逐步地实现系统所需的功能。</li>
<li>需求变更使得长期计划是不稳定的，一个稳定的计划只能是短期的，这通常是一个“<strong>迭代周期</strong>”</li>
<li>预见性项目是否成功是由它是否很好地按计划执行来衡量的，一个项目如果在规定的时间和预算内完成，那就是成功的。对于敏捷型项目实践者来说，最重要的是商业价值</li>
<li><strong>一个好的预见性项目是依计划而行，而一个好的敏捷型项目会建造出一个与最初计划不太一样却是更好的软件</strong></li>
</ul>
</li>
<li>把人放在第一位<ul>
<li>传统正规方法的目标之一是发展出这样一种过程，使得一个项目的参与人员成为可替代的部件。个体是不重要的，只有角色（例如分析员、测试员）才是重要的</li>
<li>Alistair Cockburn对软件项目的研究导致了如下结论：人是软件开发中最重要的因素</li>
<li>泰勒主义的一个关键的理念是认为干活的人并非是那些知道怎样才能把这件活干的好的人。泰勒主义让计划部门来决定如何干好一件工作的作法只有当计划者比实际操作者更能知道怎样作时才有效</li>
<li>而敏捷软件开发是面向人的过程管理。实施敏捷型过程的一个关键之处是让大家接受一个过程而非强加一个过程，另一点是开发人员必须有权作技术方面的<strong>所有</strong>决定</li>
</ul>
</li>
<li>度量的困难性<ul>
<li>如果有一个过程，<strong>规定工作应该如何来做的人不是具体去干的人</strong>，那么你需要一些方法来度量干工作的人是否工作有效</li>
<li><strong>度量软件是非常困难的</strong></li>
<li>Austin的结论是你得在这两种方法中作选择：<strong>基于度量的管理</strong>，或是**“委托式”管理**（干工作的人决定该怎么干）</li>
<li>基于度量的管理是非常适合简单的、重复性的工作，知识要求低并且易于度量输出－－这恰恰与软件开发相反</li>
</ul>
</li>
<li>自适应过程<ul>
<li>除了前文说过的适应性（应对需求变更），另一种适应性，即是过程本身随着时间推移变化。例如随着时间的推移，开发团队会发现什么方式对他们的工作最好，然后改变过程以适应之</li>
<li><img src="image-20250524194221201.png" srcset="/img/loading.gif" lazyload alt="image-20250524194221201" style="zoom:50%;" /></li>
</ul>
</li>
<li>是否应该选择敏捷<ul>
<li>找到合适的项目来全面试验敏捷方法</li>
<li>让客户接受敏捷型方法</li>
<li>从一个便于管理的小系统开始</li>
<li>选择对业务影响小的项目开始</li>
<li>不应该用的情况：这主要是取决于人。如果有关人员对敏捷方法所要求的密切的合作不感兴趣的话，那么，驱赶他们来做敏捷式开发会是一场苦战。因此，我认为，你绝不能把敏捷方法强加给一个不想试用该方法的团队</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/%E6%A0%B8%E5%BF%83%E8%AF%BE/" class="category-chain-item">核心课</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/" class="print-no-link">#软件质量与管理</a>
      
        <a href="../../../../tags/%E6%95%8F%E6%8D%B7/" class="print-no-link">#敏捷</a>
      
        <a href="../../../../tags/Kanban/" class="print-no-link">#Kanban</a>
      
        <a href="../../../../tags/Scrum/" class="print-no-link">#Scrum</a>
      
        <a href="../../../../tags/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B/" class="print-no-link">#极限编程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>软件质量与管理</div>
      <div>https://frosty-xue.github.io/2025/06/08/软件质量与管理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Frosty</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 8, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../06/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%83%A8%E5%88%86/" title="软件系统设计(设计模式部分)">
                        <span class="hidden-mobile">软件系统设计(设计模式部分)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
