<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://frosty-xue.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="css/style.css">

  
    
<link rel="stylesheet" href="fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://frosty-xue.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计组整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2025/05/08/%E8%AE%A1%E7%BB%84%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-05-08T09:58:16.000Z" itemprop="datePublished">2025-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2025/05/08/%E8%AE%A1%E7%BB%84%E6%95%B4%E7%90%86/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机组成原理整理"><a href="#计算机组成原理整理" class="headerlink" title="计算机组成原理整理"></a>计算机组成原理整理</h1><h2 id="第一讲：计算机概述"><a href="#第一讲：计算机概述" class="headerlink" title="第一讲：计算机概述"></a>第一讲：计算机概述</h2><ul>
<li>冯诺依曼结构<ul>
<li>计算机由运算器、存储器、控制器、输入设备、输出设备组成<ul>
<li>主存储器：地址和存储的内容</li>
<li>算术逻辑单元 &#x2F; 处理单元：执行信息的实际处理</li>
<li>程序控制单元 &#x2F; 控制单元：指挥信息的处理</li>
<li>输入设备：将信息送入计算机中</li>
<li>输出设备：将处理结果以某种形式显示在计算机外</li>
</ul>
</li>
<li>指令和数据以同等地位存放在存储器内，并可按地址访问</li>
<li>指令和数据均用二进制表示</li>
</ul>
</li>
<li>计算机性能标准<ul>
<li>CPU ：速度</li>
<li>存储器：速度，容量</li>
<li>I&#x2F;O ：速度，容量</li>
</ul>
</li>
<li>CPU性能<ul>
<li>时钟频率 &#x2F; 时钟速度（单位：Hz） ：计算机在单位时间内执行最基本操作的次数</li>
<li>时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间</li>
<li>CPI：执行程序时平均每条指令所需的时钟周期数</li>
<li><img src="image-20231205151251333.png" alt="image-20231205151251333"></li>
</ul>
</li>
<li>字长<ul>
<li>机器字长：计算机能直接处理的二进制数据的位数。机器字长通常与主存单元的位数一致。计算机中运算器进行算术运算和逻辑运算，机器字长也就是进行定点数运算的字长，通常也是CPU内部数据通路的宽度。</li>
<li>指令字长：一个指令字中包含二进制代码的总位数。指令字长取决于操作码的长度、操作码地址的长度和操作码地址的个数。</li>
<li>存储字长：一个存储单元存储二进制代码的位数。</li>
</ul>
</li>
</ul>
<h2 id="第三讲：数据的机器级表示"><a href="#第三讲：数据的机器级表示" class="headerlink" title="第三讲：数据的机器级表示"></a>第三讲：数据的机器级表示</h2><ul>
<li>原码、反码、补码<ul>
<li>无符号整数只有原码</li>
<li>正数三码合一</li>
<li>负数补码 &#x3D; 绝对值原码取反 + 1</li>
</ul>
</li>
<li>浮点数的二进制表示<ul>
<li>S： 1位标志，表示正负</li>
<li>E： 8位阶码（指数），无符号整数<ul>
<li>计算指数要减偏移量127</li>
</ul>
</li>
<li>B： 23位尾数</li>
<li>规格化数：2^-126 <strong>~</strong> (2 - 2 ^ -23) * 2^128，隐藏位为1</li>
<li>非规划数：阶码全0，尾数不全为0，2^-149 ~ 2^-126</li>
</ul>
</li>
</ul>
<p><img src="image-20231205154100699.png" alt="image-20231205154100699.png"></p>
<p><img src="image-20231205154159726.png" alt="image-20231205154159726.png"></p>
<ul>
<li>十进制数的BCD码<ul>
<li>符号（4位）：正数1100，负数1101</li>
<li>后面每四位表示十进制数的一位</li>
</ul>
</li>
</ul>
<h2 id="第四讲：数据校验码"><a href="#第四讲：数据校验码" class="headerlink" title="第四讲：数据校验码"></a>第四讲：数据校验码</h2><blockquote>
<p>本课程不考虑两位及以上出错</p>
</blockquote>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul>
<li>在数据结尾增加一位表示数据中1的数量是奇数还是偶数</li>
<li>数据输入<ul>
<li>奇校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1⊕1（偶数个1校验码为1）</li>
<li>偶校验： 𝐶&#x3D;𝐷𝑀⊕⋯⊕𝐷2⊕𝐷1（奇数个1校验码为1）</li>
</ul>
</li>
<li>数据输出<ul>
<li>奇校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1⊕1</li>
<li>偶校验： 𝐶′′&#x3D;𝐷′𝑀⊕⋯⊕𝐷′2⊕𝐷′1</li>
</ul>
</li>
<li>检错： S&#x3D;𝐶′′⊕𝐶′<ul>
<li>若S ≠ 1：出错，数量为奇数</li>
<li>若S &#x3D; 0：正确</li>
</ul>
</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><ul>
<li><p>将数据分成几组 对每一组都使用奇偶校验码进行检错</p>
</li>
<li><p>过程：</p>
<ul>
<li><p>将M位数据分为K组</p>
<ul>
<li><p>2^K &gt;&#x3D; M + K + 1</p>
</li>
<li><p>数据错：M；校验码错：K；无错：1</p>
</li>
<li><p>分组方法：</p>
<p><img src="image-20231205160431994.png" alt="image-20231205160431994.png"></p>
<ol>
<li>插入位置：原数据2的指数倍（1，2，4，8……）</li>
<li>校验码Ci等于所有对应故障字号低i位为1的数据位异或（例：C2 &#x3D; D1 ⊕ D3 ⊕ D4 ⊕ D6 ⊕ D7）</li>
</ol>
</li>
</ul>
</li>
<li><p>数据输入：为数据D中每组生成1位校验码，合并得到K位校验码C</p>
</li>
<li><p>数据输出：为数据 𝐷′中 每组生成1位校验码，合并得到新的 𝐾位校验码 𝐶′′</p>
</li>
<li><p>检错：将校验码 𝐶′′和取出的校验码 C’ 按位进行异或，生成𝐾位故障字</p>
<ul>
<li>故障字含两个及以上1：对应数据位错</li>
<li>故障字含一个1：校验码错，忽略</li>
<li>故障字全0：正确</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><ul>
<li><p>适用于以流格式存储和传输大量数据</p>
</li>
<li><p>假设数据有M位，左移数据<strong>K</strong>位（右侧补0），并用<strong>K+1</strong>位生成多项式除它（模2运算）</p>
</li>
<li><p>K位余数为校验码，若无余数则正确</p>
<p><img src="image-20231205162055616.png" alt="image-20231205162055616.png"></p>
</li>
</ul>
<h2 id="第五讲：整数运算"><a href="#第五讲：整数运算" class="headerlink" title="第五讲：整数运算"></a>第五讲：整数运算</h2><h3 id="加法（减法）"><a href="#加法（减法）" class="headerlink" title="加法（减法）"></a>加法（减法）</h3><ul>
<li><p>串行进位加法器</p>
<p><img src="image-20231205162812144.png" alt="image-20231205162812144.png"></p>
<ul>
<li><p>延迟：</p>
<ul>
<li>Cn: 2n ty</li>
<li>Sn:（2n + 1）ty</li>
</ul>
</li>
</ul>
</li>
<li><p>全先行进位加法器（CLA）：比串行快，缺点为复杂</p>
</li>
<li><p>部分先行进位加法器：取多个CLA串联，取得平衡</p>
</li>
<li><p>减法：将C0置为1</p>
</li>
<li><p>加法溢出判断</p>
<ul>
<li>𝑋𝑛&#x3D;𝑌𝑛且𝑆𝑛≠𝑋𝑛,𝑌𝑛: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D; [𝑋𝑛 &amp; 𝑌𝑛 &amp; ( ~ 𝑆𝑛 ) ] | [ (~ 𝑋𝑛 ) &amp; ( ~ 𝑌𝑛 ) &amp; 𝑆𝑛 ]</li>
<li>𝐶𝑛≠𝐶𝑛−1: 𝑜𝑣𝑒𝑟𝑓𝑙𝑜𝑤&#x3D;𝐶𝑛⊕𝐶𝑛−1</li>
<li>减法同理</li>
</ul>
</li>
</ul>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul>
<li><p>计算机乘法与手算不同：</p>
<p><img src="image-20231205165157005.png" alt="image-20231205165157005.png"></p>
<ul>
<li>每步都计算部分积求和结果</li>
<li>右移部分积，而不是左移</li>
<li>若Yi（当前乘的位）为0，直接移位</li>
</ul>
</li>
<li><p>布斯算法</p>
<p><img src="image-20231205165944658.png" alt="image-20231205165944658.png"></p>
<ul>
<li>增加Y0 &#x3D; 0</li>
<li>根据Yi - Yi+1 决定是否增加 X , -X , +0</li>
<li>右移部分积（移前第一位为0前面补0，反之补1）</li>
<li>重复上两步n次</li>
</ul>
</li>
</ul>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li><p>判断是否够减</p>
<p><img src="image-20231205203705216.png" alt="image-20231205203705216.png"></p>
</li>
<li><p>恢复余数除法过程</p>
<ul>
<li><p>通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄存器中</p>
</li>
<li><p>将余数和商左移，判断是否够减</p>
<ul>
<li>如果“够”，则做减法（同号）或者加法（异号），并上商为1</li>
<li>如果“不够”，则上商为 0</li>
</ul>
</li>
<li><p>重复以上步骤</p>
</li>
<li><p>如果除数和被除数不同号，则将商替换为其相反数</p>
<p><img src="image-20231205204154289.png" alt="image-20231205204154289.png"></p>
</li>
</ul>
</li>
<li><p>不恢复余数除法过程</p>
<ul>
<li><p>思路：如果余数 𝑅𝑖足够大，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；如果余数 𝑅𝑖不够大，𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌−𝑌&#x3D;2𝑅𝑖+𝑌</p>
</li>
<li><p>如果除数和被除数符号相同，则做减法；否则，做加法</p>
<ul>
<li>如果余数和除数符号相同，则商𝑄𝑛&#x3D;1；否则， 𝑄𝑛&#x3D;0</li>
</ul>
</li>
<li><p>如果余数和除数符号相同，𝑅𝑖+1&#x3D;2𝑅𝑖−𝑌；否则， 𝑅𝑖+1&#x3D;2𝑅𝑖+𝑌</p>
<ul>
<li>如果新的余数和除数符号相同，使商为 1 ；否则，使商为 0</li>
</ul>
</li>
<li><p>重复以上步骤</p>
</li>
<li><p>将商左移一位，若商为负，商加1</p>
</li>
<li><p>若余数与被除数符号不同修正余数：</p>
<ul>
<li><p>若被除数和除数符号相同，最后余数加除数；否则，最后余数减除数</p>
<p><img src="image-20231205205029238.png" alt="image-20231205205029238.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第六讲：浮点数运算"><a href="#第六讲：浮点数运算" class="headerlink" title="第六讲：浮点数运算"></a>第六讲：浮点数运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><ul>
<li><p>步骤</p>
<ul>
<li>检查是否为0</li>
<li>对齐</li>
<li>加减操作</li>
<li>规格化</li>
</ul>
<p><img src="image-20231206162424022.png" alt="image-20231206162424022.png"></p>
</li>
<li><p>加法</p>
<ul>
<li>若最高位有进位，则<strong>溢出</strong></li>
<li>符号与被加数相同</li>
</ul>
</li>
<li><p>减法</p>
<ul>
<li>若最高位有进位，正确（符号与被减数相同）</li>
<li>若最高位无进位，须计算结果补码（符号与被减数不同）</li>
</ul>
</li>
<li><p>对阶</p>
<ul>
<li>先计算ΔE &#x3D; Ex - Ey（均为补码）</li>
<li>若ΔE &lt; 0则Ex小，反之Ey小</li>
<li>对小的那个进行右移操作，右移过程中移出的位需保留用于尾数运算</li>
</ul>
</li>
<li><p>尾数加减</p>
<ul>
<li>隐藏位需加入运算</li>
</ul>
</li>
<li><p>规格化</p>
<ul>
<li>结果一：1.bb……b + 1.bb……b &#x3D; ±1b.bb……b<ul>
<li>右规：尾数右移一位；阶码加一</li>
<li>若阶码为127，加一后发生上溢</li>
<li>最后一位移出要考虑<strong>舍入</strong></li>
</ul>
</li>
<li>结果二：1.bb……b - 1.bb……b &#x3D; ±0.00…01b…b<ul>
<li>左规：尾数不断左移，阶码减一，直到最前面的1移到小数点前</li>
<li>若此过程中阶码小于0，发生下溢</li>
</ul>
</li>
</ul>
</li>
<li><p>舍入处理</p>
<ul>
<li>就近舍入：结果被舍入成最近的可表示的数</li>
<li>朝+∞舍入：结果朝正无穷大方向向上舍入</li>
<li>朝-∞舍入：结果朝负无穷大方向向下舍入</li>
<li>朝 0 舍入：结果朝 0 舍入</li>
</ul>
</li>
<li><p>溢出判断</p>
<ul>
<li>上溢：右规</li>
<li>下溢：左规</li>
</ul>
</li>
</ul>
<h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><ul>
<li><p>过程</p>
<ul>
<li>尾数相乘，指数相加</li>
<li>尾数规格化</li>
<li>舍入处理</li>
<li>溢出判断</li>
</ul>
</li>
<li><p>尾数相乘，指数相加</p>
<ul>
<li>计算时将隐藏位1还原</li>
<li>乘积符号位为操作数符号位异或结果</li>
<li>指数：e &#x3D; e1 + e2 - 127</li>
</ul>
</li>
<li><p>尾数规格化</p>
<ul>
<li>尾数小数点前有三种：10、11、01（不用规格化）</li>
<li>10&#x2F;11:右规，位数右移一位，阶码加一</li>
<li>右规需要考虑溢出（与加法相同）</li>
</ul>
</li>
<li><p>尾数舍入</p>
<ul>
<li>对右规后的2n - 2位进行舍入</li>
<li>规则与加法一样</li>
</ul>
</li>
<li><p>溢出判断</p>
<ul>
<li>指数相加：上溢&#x2F;下溢</li>
<li>舍入：上溢</li>
<li>右规：上溢</li>
</ul>
</li>
</ul>
<h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ul>
<li><p>过程</p>
<ul>
<li>尾数相除，阶相减</li>
<li>尾数规格化</li>
<li>尾数舍入处理</li>
<li>溢出判断</li>
</ul>
</li>
<li><p>尾数相除，阶相减</p>
<ul>
<li>符号位为原操作数异或结果</li>
<li>阶码e &#x3D; e1 - e2 + 127</li>
<li>尾数还原隐藏位1后作为无符号整数相除</li>
</ul>
</li>
<li><p>尾数规格化</p>
<ul>
<li>结果范围：0.5~2</li>
<li>若第一位为0，小数点右边第一位必为1</li>
<li>若第一位为0，进行左规，尾数左移一位，阶码减一</li>
<li>左移时判断下溢</li>
</ul>
</li>
<li><p>尾数舍入</p>
<ul>
<li>与加减相同</li>
</ul>
</li>
<li><p>溢出判断</p>
<ul>
<li>左规：下溢</li>
<li>舍入：上溢</li>
<li>指数相减：上溢&#x2F;下溢</li>
</ul>
</li>
</ul>
<h2 id="第八讲：内部存储器"><a href="#第八讲：内部存储器" class="headerlink" title="第八讲：内部存储器"></a>第八讲：内部存储器</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul>
<li>地址：单元唯一标识符</li>
<li>地址空间：可标识单元总数</li>
<li>寻址能力：存储在每个单元中信息位数</li>
<li>位元：半导体存储器的基本元件，用于存储1位数据</li>
</ul>
<h3 id="RAM（随机存取存储器）"><a href="#RAM（随机存取存储器）" class="headerlink" title="RAM（随机存取存储器）"></a>RAM（随机存取存储器）</h3><ul>
<li>特点<ul>
<li>可快速进行读写操作</li>
<li>易失</li>
</ul>
</li>
<li>DRAM<ul>
<li>在电容器上用电容充电的方式存储数据</li>
<li>需要周期地充电刷新以维护数据存储</li>
</ul>
</li>
<li>SRAM<ul>
<li>使用传统触发器、逻辑门配置来存储二进制值</li>
<li>有电源就能一直保持</li>
</ul>
</li>
<li>两者对比<ul>
<li>DRAM比SRAM具有更简单、更小的位元，但要求能支持刷新的电路</li>
<li>DRAM比相应的SRAM密度更高，价格更低</li>
<li>SRAM通常比DRAM快</li>
<li>DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高速缓存（Cache），DRAM用于主存</li>
</ul>
</li>
<li>SDRAM<ul>
<li>传统DRAM与处理器异步，及CPU需要等待DRAM内部存取数据操作</li>
<li>SDRAM与处理器同步时钟信号</li>
</ul>
</li>
<li>DDR SDRAM<ul>
<li>每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在<br>下降沿</li>
</ul>
</li>
</ul>
<h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><ul>
<li>特点<ul>
<li>非易失</li>
<li>只读，一般不能写入</li>
<li>随机存取（与RAM相同）</li>
</ul>
</li>
<li>PROM（可编程ROM）<ul>
<li>非易失</li>
<li>只能写入一次</li>
<li>通过电信号写入</li>
</ul>
</li>
</ul>
<h3 id="主要进行读操作的存储器"><a href="#主要进行读操作的存储器" class="headerlink" title="主要进行读操作的存储器"></a>主要进行读操作的存储器</h3><ul>
<li>EPROM<ul>
<li>光擦除：在写操作前将封装芯片暴露在紫外线下，需要20分钟</li>
<li>电写入</li>
<li>比PROM贵</li>
</ul>
</li>
<li>EEPROM（电可擦除可编程“只读”存储器）<ul>
<li>可以随时写入而不删除之前的内容</li>
<li>只更新寻址到的一个或多个字节</li>
<li>写操作每字节需要几百微秒</li>
<li>比EPROM更贵，且密度低，支持小容量芯片</li>
</ul>
</li>
<li>Flash Memory（快闪存储器）<ul>
<li>电可擦除：与EEPROM相同，优于EPROM</li>
<li>擦除时间为几秒：优于EPROM，不如EEPROM</li>
<li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM</li>
<li>达到与EPROM相同的密度：优于EEPROM</li>
<li>价格介于EPROM和EEPROM之间</li>
</ul>
</li>
</ul>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul>
<li><p>寻址单元（Addressable unit）：由若干相同地址的位元组成（一个存储单元）</p>
</li>
<li><p>寻址模式</p>
<ul>
<li>字节（常用）Byte</li>
<li>字Word</li>
</ul>
</li>
<li><p>存储阵列（Memory Array）：由大量寻址单元组成</p>
</li>
<li><p>地址译码器</p>
<p><img src="image-20231208194708017.png" alt="image-20231208194708017.png"></p>
<ul>
<li>一个n位译码器有2^n种输出</li>
<li>当所有n个寻址位都满足条件时，该输出为1</li>
<li>任何时候，只有一个输出是1其他的都是0</li>
</ul>
</li>
</ul>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul>
<li>集中式刷新：停止读写，刷新所有行，刷新过程中不能读写<ul>
<li>芯片刷新按每块芯片每行刷新：先算每块芯片是多少乘多少，得到有多少行，即为刷新次数</li>
</ul>
</li>
<li>分散式刷新：在每个存储周期中，当读写操作完成时进行刷新</li>
<li>异步刷新：每一行各自以64 ms间隔刷新</li>
</ul>
<h3 id="从位元到主存的架构"><a href="#从位元到主存的架构" class="headerlink" title="从位元到主存的架构"></a>从位元到主存的架构</h3><ul>
<li><img src="image-20231208195217394.png" alt="image-20231208195217394.png"></li>
<li>位扩展：地址线不变，数据线增加：使用8块 4K * 1bit的芯片组成 4K * 8bit的存储器</li>
<li>字扩展：地址线增加，数据线不变：使用4个16K * 8bit 的芯片组成64K * 8bit的存储器</li>
<li>字、位同时扩展：地址线增加，数据线增加：使用8个16K * 4bit 的芯片组成64K * 8bit的存储器</li>
<li>位元-&gt;寻址单元-&gt;存储阵列-&gt;芯片-&gt;模块组织-&gt;主存</li>
<li>DRAM与SRAM地址线与数据线计算<ul>
<li>SRAM : log2存储单元数量</li>
<li>DRAM : log2存储单元数量 &#x2F; 2（使用了地址复用技术）</li>
<li>数据线：该芯片一个存储单元有几位就几根</li>
</ul>
</li>
</ul>
<h2 id="第九讲：Cache"><a href="#第九讲：Cache" class="headerlink" title="第九讲：Cache"></a>第九讲：Cache</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li><p>检查：检查该字是否在Cache中</p>
<ul>
<li>命中：如果在cache中，则把这个字传送给 CPU</li>
<li>未命中：如果不在cache中 , 则将主存中包含这个字固定大小的块读入cache中，然后再从cache传送该字 给CPU</li>
</ul>
</li>
<li><p>判断是否命中</p>
<ul>
<li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li>
</ul>
</li>
<li><p>程序访问的局部性原理</p>
<ul>
<li>时间局部性 ：在相对较短的时间周期内重复访问特定的信息，也就是访问相同位置的信息</li>
<li>空间局部性 ：在相对较短的时间周期内访问相邻存储位置的数据</li>
</ul>
</li>
<li><p>平均访问时间</p>
<ul>
<li>注意点：即使未命中也需存取Cache</li>
</ul>
<p><img src="image-20231209093818319.png" alt="image-20231209093818319.png"></p>
<p><img src="image-20231231100740150.png" alt="image-20231231100740150.png"></p>
</li>
</ul>
<h3 id="Cache的设计"><a href="#Cache的设计" class="headerlink" title="Cache的设计"></a>Cache的设计</h3><ul>
<li>Cache行的构成<ul>
<li>标记 + 有效位 + (脏位) + 替换算法控制位 + 数据部分</li>
</ul>
</li>
<li>映射<ul>
<li>直接映射<ul>
<li>将主存中的每个块映射到一个固定可用的cache行中</li>
<li>假设i是cache行号，j是主存储器的块号，C是 cache 的行数，i &#x3D; j % C</li>
<li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2𝐶位标记位，第二部分为𝑙𝑜𝑔2𝐶位Cache行号，第三部分为块内地址（位数由块大小决定）</li>
</ul>
</li>
<li>(全)关联映射<ul>
<li>一个块可以装入Cache内任意一行</li>
<li>主存地址分为标记和块内地址</li>
</ul>
</li>
<li>组关联映射<ul>
<li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行</li>
<li>组号 &#x3D; 块号 % 组数</li>
<li>K-路组关联：K &#x3D; Cache行数&#x2F;组数</li>
<li>主存分为三块：第一部分为𝑙𝑜𝑔2𝑀−𝑙𝑜𝑔2S位标记位，第二部分为𝑙𝑜𝑔2S位Cache组号，第三部分为块内地址（位数由块大小决定）</li>
<li>如果 𝐾&#x3D;1，组关联映射等同于直接映射</li>
<li>如果 𝐾&#x3D;𝐶，组关联映射等同于关联映射</li>
</ul>
</li>
<li>关联度：一个主存块映射到cache中可能存放的位置个数<ul>
<li>直接映射：1</li>
<li>关联映射：C</li>
<li>组关联映射：K</li>
<li>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小</li>
</ul>
</li>
</ul>
</li>
<li>替换算法<ul>
<li>最近最少使用算法LRU<ul>
<li>策略：替换掉在cache中最长时间未被访问的数据块</li>
</ul>
</li>
<li>先进先出算法FIFO<ul>
<li>策略：替换掉在Cache中停留时间最长的块</li>
</ul>
</li>
<li>最不经常使用算法LFU<ul>
<li>策略：替换掉cache中被访问次数最少的数据块</li>
</ul>
</li>
<li>随机替换算法</li>
</ul>
</li>
<li>写策略<ul>
<li>写直达<ul>
<li>所有写操作都同时对cache和主存进行</li>
<li>确保主存中的数据总是和cache中的数据一致，总是最新的</li>
<li>产生大量的主存访问，减慢写操作</li>
</ul>
</li>
<li>写回法<ul>
<li>先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存</li>
<li>利用脏位</li>
<li>减少了访问主存的次数，但数据不一定最新</li>
</ul>
</li>
</ul>
</li>
<li>多级Cache<ul>
<li>当L1未命中时减少处理器对总线上DRAM或ROM的访问</li>
<li>使用单独的数据路径代替系统总线在L2缓存和处理器之间传输数据部分处理器将L2 cache结合到处理器芯片上</li>
</ul>
</li>
</ul>
<h2 id="第十讲：外部存储器"><a href="#第十讲：外部存储器" class="headerlink" title="第十讲：外部存储器"></a>第十讲：外部存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>特点<ul>
<li>非易失</li>
<li>用于存储不经常使用的、数据量较大的信息</li>
</ul>
</li>
<li>类型<ul>
<li>磁盘存储器</li>
<li>光存储器</li>
<li>磁带</li>
<li>U盘、固态硬盘</li>
</ul>
</li>
</ul>
<h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><ul>
<li><p>磁盘是由涂有可磁化材料的非磁性材料 （基材）构成的圆形盘片</p>
</li>
<li><p>玻璃基材优势</p>
<p><img src="image-20231209100435594.png" alt="image-20231209100435594.png"></p>
</li>
<li><p>结构</p>
<p><img src="image-20231209100647883.png" alt="image-20231209100647883.png"></p>
<ul>
<li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动</li>
<li>在任何时候，所有磁头都位于距磁盘中心等距离的磁道上</li>
</ul>
</li>
<li><p>磁头：对盘片进行读写操作的装置</p>
<ul>
<li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li>
<li>磁头越窄，离盘片的距离就越近（飞行高度）</li>
<li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li>
<li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li>
<li>现代磁盘采用双磁头：读磁头和写磁头</li>
</ul>
</li>
<li><p>读写机制</p>
<ul>
<li>读：读取磁头是由一个部分屏蔽的磁阻MR敏感器组成其电阻取决于在其下移动的介质的磁化方向，通过电流后产生的电压指示其电阻</li>
<li>写：电流脉冲被发送到写入磁头，变化的电流激发出磁场，变化的电流激发出磁场</li>
</ul>
</li>
<li><p>数据组织结构</p>
<p><img src="image-20231209101418029.png" alt="image-20231209101418029.png"></p>
<ul>
<li>磁道：盘片上的数据组织呈现为一组同心圆环，称为磁道track</li>
<li>数据以扇区（sector）的形式传输到磁盘或从传出磁盘：扇区默认512B</li>
<li>相邻磁道之间有 间隙，相邻的扇区之间也留有间隙</li>
<li>所有盘片上处于相同的相对位置的一组磁道被称为柱面</li>
</ul>
</li>
<li><p>访问时间</p>
<ul>
<li><p>寻道时间：磁头定位到所需移动到的磁道所花费的时间</p>
</li>
<li><p>旋转延迟：等待响应扇区的起始处到达磁头所需的时间，<strong>通常为旋转半圈时间</strong></p>
</li>
<li><p>传送时间：数据传输所需的时间</p>
</li>
<li><p><img src="image-20231209101754880.png" alt="image-20231209101754880.png"></p>
<img src="计组整理.assets/image-20231209101819663.png" alt="image-20231209101819663" style="zoom:50%;" />

<p><img src="image-20231209101819663.png" alt="image-20231209101819663.png"></p>
</li>
</ul>
</li>
<li><p>磁头寻道算法</p>
<ul>
<li>先来先服务FCFS<ul>
<li>按照请求访问磁盘的先后次序进行处理</li>
</ul>
</li>
<li>最短寻道时间优先SSTF<ul>
<li>优先处理起始位置与当前磁头位置最接近的读写任务</li>
</ul>
</li>
<li>扫描&#x2F;电梯（SCAN）<ul>
<li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li>
</ul>
</li>
<li>循环扫描C-SCAN<ul>
<li>只有磁头朝某方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，<strong>返回途中不做任何处理</strong></li>
</ul>
</li>
<li>LOOK<ul>
<li>SCAN 算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li>
</ul>
</li>
<li>C-LOOK<ul>
<li>C-SCAN 算法的升级，只要磁头移动方向上不再有请求，就立即让磁头返回起点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><ul>
<li><p>分类</p>
<p><img src="image-20231209102434412.png" alt="image-20231209102434412.png"></p>
</li>
<li><p>CD和CD-ROM</p>
<ul>
<li>CD和CD-ROM采用类似的技术，但CD-ROM更加耐用且有纠错功能</li>
<li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD或CD-ROM处读取信息</li>
<li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同</li>
</ul>
</li>
<li><p>高清晰光盘</p>
<ul>
<li>通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li>
</ul>
</li>
</ul>
<h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><ul>
<li>介质是柔韧的聚酯薄膜带，外涂磁性材料</li>
<li>顺序读取</li>
</ul>
<h3 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h3><ul>
<li>U盘<ul>
<li>采用了快闪存储器，属于非易失性半导体存储器</li>
<li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li>
</ul>
</li>
<li>固态硬盘<ul>
<li>与 U 盘没有本质区别：容量更大，存储性能更好</li>
</ul>
</li>
</ul>
<h2 id="第十一讲：冗余磁盘阵列"><a href="#第十一讲：冗余磁盘阵列" class="headerlink" title="第十一讲：冗余磁盘阵列"></a>第十一讲：冗余磁盘阵列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>基本思想<ul>
<li>将多个独立操作的磁盘按某种方式组织成磁盘阵列 以增加容量</li>
<li>将数据存储在多个盘体上 通过这些盘并行工作来提高数据传输率</li>
<li>采用数据冗余来进行错误恢复以提高系统可靠性</li>
</ul>
</li>
<li><img src="image-20231214205505393.png" alt="image-20231214205505393.png"></li>
</ul>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p><img src="image-20231214205749592.png" alt="image-20231214205749592.png"></p>
<ul>
<li>数据以条带的形式在可用的磁盘上分布</li>
<li>不采用冗余来改善性能（不是 RAID 家族中的真正成员）</li>
<li>用途：1.高数据传输率 2.高速响应I&#x2F;O请求</li>
</ul>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p><img src="image-20231214210100316.png" alt="image-20231214210100316.png"></p>
<ul>
<li>采用了数据条带</li>
<li>采用简单地备份所有数据的方法来实现冗余</li>
<li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li>
<li>两组硬盘都可以读取，读速度快</li>
<li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li>
</ul>
<h3 id="RAID-2-3"><a href="#RAID-2-3" class="headerlink" title="RAID 2 &amp; 3"></a>RAID 2 &amp; 3</h3><ul>
<li><p>RAID 2</p>
<p><img src="image-20231214210342894.png" alt="image-20231214210342894.png"></p>
<ul>
<li>采用并行存取技术</li>
<li>采用<strong>非常小</strong>的数据条带</li>
<li>所有磁盘都参与每个I&#x2F;O请求的执行</li>
<li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li>
<li>对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li>
</ul>
</li>
<li><p>RAID 3</p>
<p><img src="image-20231214210503149.png" alt="image-20231214210503149.png"></p>
<ul>
<li>与RAID 2 不同点：对所有数据盘上同一位置的数据计算奇偶校验码</li>
</ul>
</li>
</ul>
<h3 id="RAID-4-5"><a href="#RAID-4-5" class="headerlink" title="RAID 4 &amp; 5"></a>RAID 4 &amp; 5</h3><ul>
<li><p>RAID 4</p>
<p><img src="image-20231214220218541.png" alt="image-20231214220218541.png"></p>
<ul>
<li>采用独立存取技术：每个磁盘成员的操作是独立的，各个I&#x2F;O请求能够并行处理</li>
<li>采用相对较大的数据条带</li>
<li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li>
<li>每次写操作都需要修改校验位，I&#x2F;O请求较大时有优势（可用新数据计算）</li>
</ul>
</li>
<li><p>RAID 5</p>
<p><img src="image-20231214220451002.png" alt="image-20231214220451002.png"></p>
<ul>
<li>与RAID 4组织方式相似</li>
<li>在所有磁盘上都分布了奇偶校验条带</li>
</ul>
</li>
</ul>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><img src="image-20231214220620920.png" alt="image-20231214220620920.png"></p>
<ul>
<li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li>
<li>提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才会造成数据丢失</li>
<li>写损失：每次写都要影响两个校验块</li>
</ul>
<h2 id="第十二讲：虚拟存储器"><a href="#第十二讲：虚拟存储器" class="headerlink" title="第十二讲：虚拟存储器"></a>第十二讲：虚拟存储器</h2><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li>分区<ul>
<li>分区方式将主存分为两大区域</li>
<li>系统区：固定的地址范围内，存放操作系统</li>
<li>用户区：存放所有用户程序</li>
<li>简单固定分区：用户区划分成长度不等的固定长的分区，当一个任务调入主存时，分配一个可用的、能容纳它的最小的分区</li>
<li>可变长分区：用户区按每个任务所需要的内存大小进行分配，会导致碎片化</li>
</ul>
</li>
<li>分页<ul>
<li>把主存分成固定长且比较小的存储块，称为页框；每个任务也被划分成固定长的程序块，称为页</li>
<li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li>
<li>逻辑地址：指令中的地址</li>
<li>物理地址：实际主存地址</li>
</ul>
</li>
</ul>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul>
<li><p>基本思想</p>
<ul>
<li>仅将当前需要的的页面调入主存</li>
<li>通过硬件将逻辑地址转换为物理地址</li>
<li>未命中时在主存和硬盘之间交换信息</li>
</ul>
</li>
<li><p>分页式虚拟存储器</p>
<p><img src="image-20231224164127892.png" alt="image-20231224164127892.png"></p>
<ul>
<li>主存储器和虚拟地址空间都被划分为大小相等的页面</li>
<li>页表：页表中包含了所有虚拟页的信息,包括虚拟页的存放位置 、装入位valid、修改位dirty、存取权限位、<strong>物理地址</strong>等等，存储在主存中</li>
<li>地址 &#x3D; 页号 + 页内偏移量</li>
<li>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li>
</ul>
</li>
<li><p>快表</p>
<ul>
<li>页表的使用增加了主存的访问次数，为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li>
<li>主存中的页表相应地称之为“慢表”</li>
</ul>
</li>
<li><p>CPU访存过程</p>
<ul>
<li><img src="image-20231224164538671.png" alt="image-20231224164538671.png"></li>
<li><img src="image-20231224165337226.png" alt="image-20231224165337226.png"></li>
<li><img src="image-20231224165513175.png" alt="image-20231224165513175.png"></li>
</ul>
</li>
<li><p>分段式虚拟存储器</p>
<ul>
<li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li>
<li>虚拟地址：段号 + 段内偏移量</li>
<li>与分页式虚拟存储器相比：分页式简单，但一个数据或一条指令可能会分跨在两个页面；分段式段的分界与程序的自然分界相对应，易于管理，但段大小不固定</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<ul>
<li>将程序和数据分段，段内再进行分页</li>
<li>每个段都有一个页表</li>
<li>虚拟地址 &#x3D; 段号 + 页号 + 页内偏移量</li>
</ul>
</li>
</ul>
<h2 id="第十三讲：指令系统"><a href="#第十三讲：指令系统" class="headerlink" title="第十三讲：指令系统"></a>第十三讲：指令系统</h2><h3 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h3><ul>
<li><p>指令要素</p>
<ul>
<li>操作码：指定将要完成的操作</li>
<li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li>
<li>结果操作数引用：操作可能会产生一个结果</li>
<li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li>
</ul>
</li>
<li><p>操作码</p>
<ul>
<li>指令类型：数据传送、算术运算、逻辑运算、转换、输入&#x2F;输出、系统控制、控制转移</li>
<li>数据传送：指明源和目标操作数的位置、将要传送数据的长度、寻址方式</li>
</ul>
</li>
<li><p>操作数</p>
<ul>
<li>大端法和小端法：大端为高位存在小地址，低位存在大地址，小端与之相反</li>
<li>寻址方式<ul>
<li>立即寻址：操作数实际出现在指令中</li>
<li>直接寻址：地址字段含有操作数的有效地址</li>
<li>间接寻址：地址字段指示一个存储器字地址 , 而此地址出保存有操作数的全长度地址</li>
<li>寄存器寻址：地址字段指示的是寄存器</li>
<li>寄存器间接寻址：地址字段指示的是寄存器，寄存器中存操作数地址</li>
<li>偏移寻址：EA &#x3D; (R) + A，即地址 &#x3D; 偏移量 + 地址，分为三种：相对寻址（R为PC）、基址寄存器寻址(R对应寄存器中为基址，A为偏移量)、变址寻址（A为某主存地址，R中为对于该地址正的偏移量）</li>
<li>栈寻址：方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li>
</ul>
</li>
</ul>
</li>
<li><p>指令设计原则</p>
<ul>
<li>指令尽量短</li>
<li>有足够的操作码位数：要为操作类型不断增加预留</li>
<li>操作码的编码必须有唯一的解释</li>
<li>指令长度是字节的整数倍</li>
<li>合理选择地址字段的个数</li>
<li>指令尽量规整：简化硬件的实现</li>
</ul>
</li>
<li><p>题型：计算指令系统需要多少位</p>
<p><img src="image-20240101163022494.png" alt="image-20240101163022494.png"></p>
<ul>
<li>先算地址多的，多出来没用的操作码n个给地址少的作为操作码前几位</li>
<li>地址少的用多出来的地址位k和n算出可用操作码数（2^k * n），与需要的操作码数量对比，如果足够就结束，不够就要增加一位</li>
<li>所有种类指令都验证完后将位数向上取整变成8的整数倍</li>
</ul>
</li>
</ul>
<h2 id="第十四讲：指令流水线"><a href="#第十四讲：指令流水线" class="headerlink" title="第十四讲：指令流水线"></a>第十四讲：指令流水线</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul>
<li><p>指令周期 ：处理单个指令的过程</p>
<p><img src="image-20231224195348224.png" alt="image-20231224195348224.png"></p>
<p><img src="image-20231224195406263.png" alt="image-20231224195406263.png"></p>
</li>
<li><p>间址周期：把间接地址的读取看成是一个额外的指令子周期</p>
</li>
<li><p>CPU寄存器</p>
<ul>
<li>1个存储地址寄存器MAR</li>
<li>1个存储缓冲寄存器MBR&#x2F; 存储数据寄存器MDR</li>
<li>1个程序计数器PC</li>
<li>1个指令寄存器IR</li>
</ul>
</li>
<li><p>指令周期数据流</p>
<ul>
<li>取指周期<ul>
<li>控制器先发出控制信号告知存储器，PC使用地址总线传输待取指令地址，存储器得到地址</li>
<li>存储器将指令数据传入数据总线，存储缓冲寄存器MBR从数据线上得到指令，再传给IR</li>
<li>控制器告知PC取指完成，使PC中值对应 + 4</li>
</ul>
</li>
<li>间址周期<ul>
<li>MBR第一次取回的是地址，将它传入MAR再进行一次读取</li>
</ul>
</li>
<li>中断周期<ul>
<li>终端前要将所有寄存器状态存入存储器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ul>
<li><p>指令流水线 ：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成</p>
</li>
<li><p>六阶段方法：</p>
<p><img src="image-20231224200754205.png" alt="image-20231224200754205.png"></p>
<ul>
<li>取指令（ Fetch instruction FI ）：读下一条预期的指令到缓冲器</li>
<li>译码指令（ Decode instruction DI ）：确定操作码和操作数指定符</li>
<li>计算操作数（ Calculate operands CO ）：计算每个源操作数的有效地址</li>
<li>取操作数（ Fetch operands FO ）：从存储器取出每个操作数，寄存器中的操作数不需要取</li>
<li>执行指令（ Execute instruction EI ）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li>
<li>写操作数（ Write operand WO ）：将结果存入存储器</li>
<li>问题：不是所有指令都包含6个阶段；不是所有的阶段都能并行完成；若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</li>
<li>条件转移指令会使若干周期无效</li>
</ul>
</li>
<li><p><img src="image-20231224201109097.png" alt="image-20231224201109097.png"></p>
</li>
</ul>
<h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ul>
<li>结构冒险<ul>
<li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源</li>
<li>解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源</li>
</ul>
</li>
<li>数据冒险<ul>
<li>原因：未生成指令所需要的数据</li>
<li>解决方案 1 ：插入 nop 指令</li>
<li>解决方案 2 ：插入 bubble</li>
<li>解决方案 3 ：转发 forwarding &#x2F; 旁路 bypassing：无需等待数据存入对应寄存器，而是将需要的其他指令执行结果直接传送到对应位置</li>
<li>解决方案 4 ：交换指令顺序</li>
</ul>
</li>
<li>控制冒险<ul>
<li>原因：指令的执行顺序被更改（转移、中断、异常、调用&#x2F;返回）</li>
<li>解决：取多条指令、分支预测</li>
</ul>
</li>
</ul>
<h2 id="第十五讲：控制器"><a href="#第十五讲：控制器" class="headerlink" title="第十五讲：控制器"></a>第十五讲：控制器</h2><h3 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h3><p><img src="image-20240101162745149.png" alt="image-20240101162745149.png"></p>
<ul>
<li>用户可见寄存器<ul>
<li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li>
<li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回</li>
<li>通用寄存器：可被程序员指派各种用途</li>
<li>数据寄存器：仅可用于保持数据而不能用于操作数地址的计算</li>
<li>地址寄存器：可以是自身有某些通用性，或是专用于某种具体的寻址方式</li>
<li>条件码寄存器&#x2F;标志寄存器：CPU硬件设置这些条件位作为操作的结果</li>
</ul>
</li>
<li>控制和状态寄存器<ul>
<li>由控制器来控制 CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li>
<li>大多数控制和状态寄存器在大多数机器上是用户不可见的</li>
<li>程序计数器PC（Program counter）：通常在每次取指令之后， PC 的内容即被CPU更改，因此总指向将被执行的下一条指令（用户可见）</li>
<li>指令寄存器IR（Instruction register）：存有最近取来的指令，在其中分析操作码和操作数</li>
<li>存储器地址寄存器MAR（Memory address register）：直接与地址总线相连，存有存储器位置的地址</li>
<li>存储器缓冲寄存器MBR（Memory buffer register）：直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR交换数据</li>
<li>ALU 可对MBR和用户可见寄存器直接存取</li>
</ul>
</li>
<li>程序状态字<ul>
<li>一个或一组包含状态信息的寄存器 包含条件码加上其他状态信息</li>
<li>符号、零、进位、等于、溢出、中断禁止&#x2F;允许、监管</li>
</ul>
</li>
</ul>
<h3 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h3><ul>
<li><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令，每个指令周期又可以看作是由几个更小的子周期组成（取指、间址、执行、中断），每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些步骤称为微操作</p>
</li>
<li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p>
<p><img src="image-20231225192443296.png" alt="image-20231225192443296.png"></p>
<ul>
<li>事件的流动顺序必须是恰当的</li>
<li>必须避免冲突</li>
<li>满足上述条件下 所用的时间单位尽可能少</li>
</ul>
</li>
<li><p>间址周期：如果指令采用间接寻址，则在指令执行前有一个间址周期</p>
<p><img src="image-20231225192951356.png" alt="image-20231225192951356.png"></p>
</li>
<li><p>执行周期：对于不同的操作码，会出现不同的微操作序列</p>
<img src="计组整理.assets/image-20231225193031697.png" alt="image-20231225193031697" style="zoom: 50%;" />

<p><img src="image-20231225193031697.png" alt="image-20231225193031697.png"></p>
</li>
<li><p>中断周期：在完成执行周期时，要确定是否有允许的中断产生，如果有，则出现一个中断周期</p>
</li>
<li><p>指令周期代码：假设一个 2 位的ICC寄存器，明确 CPU 处于指令周期哪个阶段</p>
<p><img src="image-20231225193941116.png" alt="image-20231225193941116.png"></p>
<ul>
<li>00 ：取指</li>
<li>01 ：间址</li>
<li>10 ：执行</li>
<li>11 ：中断</li>
</ul>
</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul>
<li><p>CPU内部总线</p>
<ul>
<li>ALU和寄存器都连接到CPU内部总线上</li>
<li>内部总线和寄存器之间有门和控制信号</li>
</ul>
</li>
<li><p>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</p>
</li>
<li><p>CPU需要完成的微操作：</p>
<ul>
<li>在寄存器之间传送数据</li>
<li>将数据由寄存器传送到外部接口（如系统总线）</li>
<li>将数据由外部接口传送到寄存器</li>
<li>将寄存器作为输入和输出，完成算术和逻辑运算</li>
</ul>
</li>
<li><p>控制器的两个基本任务：定序、执行</p>
</li>
<li><p>控制器的输入：</p>
<ul>
<li>指令寄存器：当前指令的寻址方式和操作码</li>
<li>标志：确定CPU的状态和前一个ALU操作的结果</li>
<li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li>
<li>来自控制总线的控制信号：向控制器提供控制信号（如中断请求）</li>
</ul>
</li>
<li><p>控制器的输出：CPU内的控制信号、到控制总线的控制信号</p>
</li>
<li><p>控制器实现</p>
<ul>
<li>硬布线实现：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，<br>即控制信号</li>
<li>微程序实现：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号</li>
</ul>
</li>
<li><p>硬布线实现</p>
<ul>
<li><p>硬布线控制器是将控制部件做成产生专门固定信号的逻辑电路，产生各种控制信号，因而又称为组合逻辑控制器。微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。</p>
</li>
<li><p>控制器输入：标志和控制总线信号、指令寄存器、时钟</p>
</li>
<li><p>控制器逻辑：为每个输出的控制信号设计一个关于控制器输入的布尔表达式</p>
</li>
</ul>
</li>
<li><p>微程序实现</p>
<ul>
<li><p>基本思路：</p>
<ul>
<li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li>
<li>构造一个<strong>控制字</strong>，每位代表一根控制线，这样每个微操作能用控制字中的不同的 0 和 1 的样式来表示</li>
<li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li>
</ul>
</li>
<li><p>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址</p>
</li>
<li><p>任务：定序和执行</p>
<p><img src="image-20231225205024319.png" alt="image-20231225205024319.png"></p>
</li>
<li><p>微指令编码方式</p>
<ul>
<li><p>直接控制方式：在微指令的控制字段里对不同的微命令各自设置一个数位来表示发出与否（”0&#x2F;1”）</p>
</li>
<li><p>字段直接编译法：对控制字段进行划分，得到多个不同的字段，这些字段表示多个互斥的控制信号，这些微命令在同一时间只有其中的某一个微命令可以生效。</p>
<p><img src="image-20240101165541902.png" alt="image-20240101165541902.png"></p>
</li>
<li><p>字段间接编译法：同样是对控制字段进行划分，但是字段间接编译法在直接编译法以一个字段来表示一条微命令的基础上，辅以另一个字段来解释这个字段。这样的编译方法，可以使得指令的长度进一步减短，但微指令的并行控制能力被削弱了。</p>
<p><img src="image-20240101165705537.png" alt="image-20240101165705537.png"></p>
<p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p>
</li>
<li><p><img src="image-20240101170317517.png" alt="image-20240101170317517.png"></p>
</li>
</ul>
</li>
<li><p>工作流程：</p>
<ul>
<li>为执行一条指令，定序逻辑发出一个读命令给控制存储器</li>
<li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li>
<li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息</li>
<li>定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第十六讲：总线"><a href="#第十六讲：总线" class="headerlink" title="第十六讲：总线"></a>第十六讲：总线</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>类型<ul>
<li>芯片内部总线：连接芯片内部的各个部分</li>
<li>系统总线：连接CPU、存储器、I&#x2F;O控制器和其他功能设备</li>
<li>通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</li>
</ul>
</li>
<li>总线结构<ul>
<li>数据线：在系统组件之间传输数据，数据线的数量决定了一次可以传输的数据的大小</li>
<li>地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向，地址线的数量决定了寻址空间的大小</li>
<li>控制线：控制对数据线和地址线的存取和使用</li>
</ul>
</li>
<li>特点<ul>
<li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</li>
<li>当总线在被使用过程中，其它设备不可以抢占</li>
</ul>
</li>
</ul>
<h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ul>
<li><p>用途</p>
<ul>
<li>专用总线：始终只负责一项功能，或始终分配给特定的计算机组件</li>
<li>复用总线：将同一线路用于多种用途</li>
</ul>
</li>
<li><p>总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备</p>
<ul>
<li>集中式：由仲裁器或总线控制器负责分配总线使用权</li>
<li>分布式：每个设备都包含访问控制逻辑，各设备共同作用，分享总线</li>
</ul>
</li>
<li><p>链式查询</p>
<p><img src="image-20231227191653439.png" alt="image-20231227191653439.png"></p>
<ul>
<li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备</li>
<li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号</li>
<li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</li>
</ul>
</li>
<li><p>计数器查询</p>
<p><img src="image-20231227192026850.png" alt="image-20231227192026850.png"></p>
<ul>
<li>将总线允许线替换为设备ID线，如果总线空闲，总线仲裁器通过设备ID线发送计数</li>
<li>如果当前发送请求的设备ID等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为忙</li>
<li>通过使用不同的初始计数，可以灵活地确定设备优先级（强调优先级从1开始，强调公平性从上次使用总线的下一个设备的ID开始）</li>
</ul>
</li>
<li><p>独立请求</p>
<ul>
<li>每个设备都有自己的总线请求线和总线允许线，当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器，总线仲裁器决定哪个设备可以使用总线</li>
</ul>
</li>
<li><p>自举式</p>
<p><img src="image-20231227194000898.png" alt="image-20231227194000898.png"></p>
<ul>
<li>固定优先级，每个设备在其总线请求线上发送请求</li>
<li>每个设备自行判断自己是否在请求总线的设备中优先级最高</li>
</ul>
</li>
<li><p>时序</p>
<ul>
<li><p>确定每个总线事务的开始和结束时间</p>
</li>
<li><p>同步时序：事件的发生由时钟决定，所有设备共享同一个时钟</p>
</li>
<li><p>异步时序：一个事件的发生取决于前一个事件的发生</p>
</li>
<li><p><img src="image-20231227205709273.png" alt="image-20231227205709273.png"></p>
<p><img src="image-20231227201133777.png" alt="image-20231227201133777.png"></p>
</li>
<li><p>半同步时序：为了减少噪声的影响，在异步计时中使用时钟</p>
</li>
<li><p>分离事务：将一个总线事件分离为两个过程</p>
</li>
</ul>
</li>
<li><p>总线带宽（bus bandwidth）：总线的最大数据传输速率</p>
</li>
<li><p>数据传输速率：考虑地址传输、握手等因素</p>
<ul>
<li><p>同步总线时间：</p>
<ul>
<li>发送指令和地址到内存</li>
<li>内存准备数据时间（时钟周期整数倍，向上取整，例：时钟周期50 ns，230 ns -&gt; 250 ns）</li>
<li>将数据传输到CPU</li>
</ul>
</li>
<li><p>异步总线时间：</p>
<ul>
<li>步骤一握手</li>
<li>max{步骤2、3、4一起的时间，数据准备时间}</li>
<li>步骤5、6、7时间</li>
</ul>
</li>
<li><p>不同数据块大小：</p>
<p><img src="image-20231227212626052.png" alt="image-20231227212626052.png"></p>
<p><img src="image-20231227212641717.png" alt="image-20231227212641717.png"></p>
<p><img src="image-20231227212657044.png" alt="image-20231227212657044.png"></p>
</li>
<li><p>每秒总线事务数：用1s除以<strong>每个</strong>总线事务所需时间</p>
</li>
</ul>
</li>
<li><p>总线传输方式</p>
<ul>
<li>**猝发&#x2F;突发传输（Burst Transfer）：**在一次总线事务中，通过多个时钟周期连续传输一块数据，而不需要额外的地址和控制信号。这种方式可以提高数据传输的效率，因为它减少了每次传输所需的总线控制开销。</li>
<li><strong>DMA传输（Direct Memory Access）：</strong> DMA是一种通过专用的DMA控制器直接在主存储器和I&#x2F;O设备之间传输数据的方式，而无需CPU的直接干预。这提高了数据传输的效率。</li>
<li><strong>同步传输（Synchronous Transfer）：</strong> 在同步传输中，数据在一个统一的时钟信号下传输，根据时钟的边沿进行数据传送。这有助于确保数据的同步性，但要求系统中的各个部件都能保持同步。</li>
<li><strong>异步传输（Asynchronous Transfer）：</strong> 异步传输不依赖于统一的时钟信号，而是使用起始位和停止位来标识数据的开始和结束。异步传输通常用于短距离通信，例如串口通信。</li>
<li><strong>串行传输（Serial Transfer）：</strong> 串行传输是指每个时钟周期传输一个比特。虽然每个时钟周期只传输少量的数据，但串行传输通常具有较高的稳定性和较低的成本。典型：<strong>USB</strong></li>
<li><strong>并行传输（Parallel Transfer）：</strong> 在并行传输中，多个数据位同时在总线上传输。每个时钟周期传输多个比特，这样可以在同一时刻传输更多的数据，提高传输速率。</li>
</ul>
</li>
<li><p>总线层次</p>
<ul>
<li>单总线结构：CPU、存储器和I&#x2F;O模块都连接到一条系统总线</li>
<li>双总线结构：<ul>
<li>方案一：在 CPU 和存储器中间增加一个存储器总线</li>
<li>将系统总线分为存储器总线、 I&#x2F;O 总线 和 IOP (input&#x2F;output processor)</li>
</ul>
</li>
<li>多总线结构：<ul>
<li>方案一：增加一个本地总线（ local bus来连接CPU和cache）</li>
<li>方案二：将系统总线分为存储器总线、I&#x2F;O总线和DMA总线</li>
<li>方案三：增加一个高速I&#x2F;O总线来连接高速设备</li>
</ul>
</li>
</ul>
</li>
<li><p>注：60%的时间在读40%时间写直接用读写的数据传输速度加权；60%的访问为读40%访问为写需要在分母上对消耗的时钟周期加权然后重新计算数据传输速率</p>
<p><img src="image-20240102203024170.png" alt="image-20240102203024170.png"></p>
</li>
</ul>
<h2 id="第十七讲：输入输出（I-O）"><a href="#第十七讲：输入输出（I-O）" class="headerlink" title="第十七讲：输入输出（I&#x2F;O）"></a>第十七讲：输入输出（I&#x2F;O）</h2><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h3><ul>
<li><p>连接情况</p>
<ul>
<li>通过系统总线或中央交换器和存储器连接</li>
<li>通过专用数据线与一个或多个外设连接</li>
</ul>
</li>
<li><p>外部设备接口</p>
<p><img src="image-20231228163308278.png" alt="image-20231228163308278.png"></p>
<ul>
<li>I&#x2F;O模块的接口以控制 、 状态和数据信号的形式出现</li>
<li>与设备相关的控制逻辑控制外设的操作，以响应来自I&#x2F;O模块的命令</li>
<li>缓冲器用于缓存I&#x2F;O模块和外设之间传送的数据</li>
</ul>
</li>
<li><p>I&#x2F;O模块功能</p>
<ul>
<li>处理器通信<ul>
<li>命令译码：I&#x2F;O模块接收来自处理器的命令（I&#x2F;O指令），这些命令一般作为信号发送到控制总线</li>
<li>数据：数据是在处理器（通用寄存器组）和I&#x2F;O模块之间经由数据总线来交换的</li>
<li>状态报告：由于外设速度很慢 , 所以知道I&#x2F;O模块的状态很重要</li>
<li>地址识别：I&#x2F;O模块必须能识别它所控制的每个外设的唯一地址</li>
</ul>
</li>
<li>设备通信：通信内容包含命令、状态信息和数据</li>
<li>数据缓冲：外设的数据传送速度与存储器或处理器不同，有的快有的慢</li>
<li>控制和定时：处理器会非预期的与一个或几个外设进行通信</li>
<li>检错：检错并把差错信息报告给处理器</li>
</ul>
</li>
<li><p>结构</p>
<p><img src="image-20231228165511903.png" alt="image-20231228165511903.png"></p>
</li>
<li><p>I&#x2F;O端口和I&#x2F;O模块区别</p>
<ul>
<li>I&#x2F;O端口是计算机体系结构中的一个机制，用于通过特定地址进行I&#x2F;O访问，而I&#x2F;O模块表示连接到计算机系统的外部设备及其相关的控制电路。 I&#x2F;O模块通常包含一个或多个I&#x2F;O端口，其中每个端口对应于不同的功能或寄存器。</li>
</ul>
</li>
<li><p>外部接口</p>
<ul>
<li>并行接口：多根线连接I&#x2F;O模块和外设，同时传送多位数据</li>
<li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li>
</ul>
</li>
<li><p>编址方式</p>
<ul>
<li><strong>独立编址（Separate Addressing）：</strong> 在独立编址中，内存和I&#x2F;O设备拥有不同的地址空间。系统使用不同的地址范围来访问内存和I&#x2F;O设备，这意味着CPU使用不同的指令或地址范围来读写内存和I&#x2F;O设备。</li>
<li><strong>统一编址（Unified Addressing）：</strong> 在统一编址中，内存和I&#x2F;O设备共享相同的地址空间。系统使用相同的地址范围来访问内存和I&#x2F;O设备，使得CPU可以使用相同的指令和地址范围来读写内存和I&#x2F;O设备。</li>
</ul>
</li>
</ul>
<h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h3><ul>
<li><p>编程式I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</p>
<ul>
<li>当处理器在执行过程中遇到一条与I&#x2F;O操作有关的指令时，它通过发送指令到对应I&#x2F;O模块来执行这条指令</li>
<li>I&#x2F;O模块将执行所要求的动作，然后在I&#x2F;O状态寄存器中设置一些适当的位</li>
<li>I&#x2F;O不会中断处理器 因此处理器需要周期性地检查I&#x2F;O模块的状态 直到发现该操作完成</li>
</ul>
</li>
<li><p>中断驱动式I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令；并且当I&#x2F;O模块完成其工作后，才去中断处理器工作</p>
<p><img src="image-20231228171431496.png" alt="image-20231228171431496.png"></p>
<ul>
<li>处理器发送一个I&#x2F;O命令到模块，然后去处理其它有用的工作</li>
<li>当I&#x2F;O模块准备和处理器交换数据时，它中断处理器以请求服务</li>
<li>处理器执行数据传送，最后恢复它原先的处理工作</li>
<li>响应优先级和处理优先级<ul>
<li>响应优先级：中断被触发时，系统多快能够响应并开始执行相应的中断服务程序</li>
<li>处理优先级：在处理器已经响应中断并开始执行中断服务程序后，不同中断服务程序之间的执行顺序</li>
<li>过程：当中断同时来临时先按照响应优先级顺序响应中断，然后按该顺序处理，准备好当前响应优先级最高的中断所需环境后，比较处理优先级，如果有比当前中断处理优先级高的，插入该中断，完成后再回到原中断。在此过程中新的中断来了正常响应加入队列，但只在每次处理前检查队列的处理优先级</li>
<li>掩码字&#x2F;屏蔽字：该位为1表示可屏蔽对应的中断（自己一定可以屏蔽自己），即当前处理优先级高于该位对应中断的优先级</li>
</ul>
</li>
<li>设备识别方法：多条中断线、软件轮询、菊花链、独立请求</li>
</ul>
</li>
<li><p>直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与主存直接交换数据，而不需要处理器的干涉</p>
<ul>
<li>处理器通过发送以下信息向DMA模块发出命令：读&#x2F;写、I&#x2F;O设备地址、内存中的起始位置、字数，然后处理器继续进行其他工作</li>
<li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出而无需经过处理器</li>
<li>当传输完成时DMA模块向处理器发送一个中断信号</li>
<li><strong>DMA使用总线优先级高于CPU</strong></li>
</ul>
</li>
<li><p>DMA访问方法</p>
<ul>
<li>CPU停止法：控制简单，但影响CPU，没有充分利用内存</li>
<li>周期窃取：充分利用CPU和内存，及时响应I&#x2F;O请求，但每次都要申请总线，且一次只传输一个字</li>
<li>交替分时访问：CPU未停止或等待，DMA不请求总线</li>
</ul>
</li>
<li><p>查询式I&#x2F;O</p>
<ul>
<li>在轮询方式中，CPU定期地检查I&#x2F;O设备是否准备好进行数据传输。这种方式包括以下步骤：<ul>
<li><strong>步骤1：CPU发起请求</strong> CPU向I&#x2F;O设备发送一个请求，询问设备是否准备好进行数据传输。</li>
<li><strong>步骤2：等待设备准备</strong> CPU在一定的时间间隔内不断轮询（检查）设备的状态，看是否已经准备好执行请求。</li>
<li><strong>步骤3：数据传输</strong> 一旦I&#x2F;O设备准备好，CPU开始执行实际的数据传输。</li>
</ul>
</li>
<li>在此方式下，CPU全程参与数据传输，占用率为100%</li>
</ul>
</li>
</ul>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://frosty-xue.github.io/2025/05/08/%E8%AE%A1%E7%BB%84%E6%95%B4%E7%90%86/" data-id="cmaf8dz130003ywtr68jueuft" data-title="计算机组成原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2025/05/05/test/" class="article-date">
  <time class="dt-published" datetime="2025-05-05T12:36:26.000Z" itemprop="datePublished">2025-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2025/05/05/test/">test</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>RPC</p>
<ul>
<li>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</li>
<li>步骤：客户端调用-&gt;请求发送(序列化) -&gt; 服务器接受并处理(反序列化) -&gt; 结果返回(序列化) -&gt; 客户端接收结果(反序列化)</li>
<li>常见的 RPC 框架：gRPC、Thrift、Dubbo</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://frosty-xue.github.io/2025/05/05/test/" data-id="cmaf8dz0w0000ywtr5e9wctdu" data-title="test" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2025/05/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-05-05T12:14:22.281Z" itemprop="datePublished">2025-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2025/05/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://frosty-xue.github.io/2025/05/05/hello-world/" data-id="cmaf8dz100001ywtrbr2dhyqu" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机组成原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2025/05/08/%E8%AE%A1%E7%BB%84%E6%95%B4%E7%90%86/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="2025/05/05/test/">test</a>
          </li>
        
          <li>
            <a href="2025/05/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="js/jquery-3.6.4.min.js"></script>



  
<script src="fancybox/jquery.fancybox.min.js"></script>




<script src="js/script.js"></script>





  </div>
</body>
</html>